/*!
 * @openfl/unsorted - v0.0.0
 * Compiled Sun, 31 May 2020 01:48:35 UTC
 *
 * @openfl/unsorted is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/**
        The ClipboardFormats class defines constants for the names of the standard
        data formats used with the Clipboard class. Flash Player 10 only supports
        TEXT_FORMAT, RICH_TEXT_FORMAT, and HTML_FORMAT.
    **/
var ClipboardFormats;
(function (ClipboardFormats) {
    /**
        HTML data.
    **/
    ClipboardFormats["HTML_FORMAT"] = "air:html";
    /**
        Rich Text Format data.
    **/
    ClipboardFormats["RICH_TEXT_FORMAT"] = "air:rtf";
    /**
        String data.
    **/
    ClipboardFormats["TEXT_FORMAT"] = "air:text";
})(ClipboardFormats || (ClipboardFormats = {}));
var ClipboardFormats$1 = ClipboardFormats;

/**
    The ClipboardTransferMode class defines constants for the modes used as
    values of the `transferMode` parameter of the `Clipboard.getData()`
    method.
    The transfer mode provides a hint about whether to return a reference or a
    copy when accessing an object contained on a clipboard.
**/
var ClipboardTransferMode;
(function (ClipboardTransferMode) {
    /**
        The Clipboard object should only return a copy.
    **/
    ClipboardTransferMode["CLONE_ONLY"] = "cloneOnly";
    /**
        The Clipboard object should return a copy if available and a reference if not.
    **/
    ClipboardTransferMode["CLONE_PREFERRED"] = "clonePreferred";
    /**
        The Clipboard object should only return a reference.
    **/
    ClipboardTransferMode["ORIGINAL_ONLY"] = "originalOnly";
    /**
        The Clipboard object should return a reference if available and a copy if not.
    **/
    ClipboardTransferMode["ORIGINAL_PREFERRED"] = "originalPreferred";
})(ClipboardTransferMode || (ClipboardTransferMode = {}));
var ClipboardTransferMode$1 = ClipboardTransferMode;

/**
    The Clipboard class provides a container for transferring data and objects
    through the clipboard. The operating system clipboard can be accessed
    through the static `generalClipboard` property.
    A Clipboard object can contain the same information in more than one
    format. By supplying information in multiple formats, you increase the
    chances that another application will be able to use that information. Add
    data to a Clipboard object with the `setData()` or `setDataHandler()`
    method.

    The standard formats are:

    * BITMAP_FORMAT: a BitmapData object (AIR only)
    * FILE_LIST_FORMAT: an array of File objects (AIR only)
    * HTML_FORMAT: HTML-formatted string data
    * TEXT_FORMAT: string data
    * RICH_TEXT_FORMAT: a ByteArray containing Rich Text Format data
    * URL_FORMAT: a URL string (AIR only)

    These constants for the names of the standard formats are defined in the
    ClipboardFormats class.

    When a transfer to or from the operating system occurs, the standard
    formats are automatically translated between ActionScript data types and
    the native operating system clipboard types.

    You can use application-defined formats to add ActionScript objects to a
    Clipboard object. If an object is serializable, both a reference and a
    clone of the object can be made available. Object references are valid
    only within the originating application.

    When it is computationally expensive to convert the information to be
    transferred into a particular format, you can supply the name of a
    function that performs the conversion. The is called if and only
    if that format is read by the receiving component or application. Add a
    deferred rendering to a Clipboard object with the
    `setDataHandler()` method. Note that in some cases, the operating system
    calls the before a drop occurs. For example, when you use a
    handler to provide the data for a file dragged from an AIR
    application to the file system, the operating system calls the data
    handler as soon as the drag gesture leaves the AIR
    application - typically resulting in an undesireable pause as the file
    data is downloaded or created.

    **Note for AIR applications:** The clipboard object referenced by the
    event objects dispatched for HTML drag-and-drop and copy-and-paste events
    are not the same type as the AIR Clipboard object. The JavaScript
    clipboard object is described in the AIR developer's guide.

    **Note for Flash Player applications:** In Flash Player 10, a paste
    operation from the clipboard first requires a user event (such as a
    keyboard shortcut for the Paste command or a mouse click on the Paste
    command in a context menu). `Clipboard.getData()` will return the contents
    of the clipboard only if the InteractiveObject has received and is acting
    on a paste event. Calling `Clipboard.getData()` under any other
    circumstances will be unsuccessful. The same restriction applies in AIR
    for content outside the application sandbox.

    On Linux, clipboard data does not persist when an AIR application closes.
**/
class Clipboard {
    constructor() { }
    /**
        Deletes all data representations from this Clipboard object.

        @throws SecurityError Call to generalClipboard.clear() is not
                              permitted in this context. In Flash Player, you
                              can only call this method successfully during
                              the processing of a user event (as in a key
                              press or mouse click). In AIR, this restriction
                              only applies to content outside of the
                              application security sandbox.
    **/
    clear() {
        this.setData(ClipboardFormats$1.TEXT_FORMAT, null);
    }
    /**
        Deletes the data representation for the specified format.

        @param format The data format to remove.
        @throws SecurityError Call to generalClipboard.clearData() is not
                              permitted in this context. In Flash Player, you
                              can only call this method successfully during
                              the processing of a user event (as in a key
                              press or mouse click). In AIR, this restriction
                              only applies to content outside of the
                              application security sandbox.
    **/
    clearData(format) {
        switch (format) {
            case ClipboardFormats$1.HTML_FORMAT:
            case ClipboardFormats$1.RICH_TEXT_FORMAT:
            case ClipboardFormats$1.TEXT_FORMAT:
                this.setData(ClipboardFormats$1.TEXT_FORMAT, null);
                break;
        }
    }
    /**
        Gets the clipboard data if data in the specified format is present.
        Flash Player requires that the `getData()` be called in a `paste`
        event handler. In AIR, this restriction only applies to content
        outside of the application security sandbox.

        When a standard data format is accessed, the data is returned as a new
        object of the corresponding Flash data type.

        When an application-defined format is accessed, the value of the
        `transferMode` parameter determines whether a reference to the
        original object or an anonymous object containing a serialized copy of
        the original object is returned. When an `originalPreferred` or
        `clonePreferred` mode is specified, Flash Player or AIR returns the
        alternate version if the preferred version is not available. When an
        `originalOnly` or `cloneOnly` mode is specified, Flash Player or AIR
        returns `null` if the requested version is not available.

        @param format       The data format to return. The format string can
                            contain one of the standard names defined in the
                            ClipboardFormats class, or an application-defined
                            name.
        @param transferMode Specifies whether to return a reference or
                            serialized copy when an application-defined data
                            format is accessed. The value must be one of the
                            names defined in the ClipboardTransferMode class.
                            This value is ignored for the standard data
                            formats; a copy is always returned.
        @return An object of the type corresponding to the data format.
        @throws Error                 `transferMode` is not one of the names
                                      defined in the ClipboardTransferMode
                                      class.
        @throws IllegalOperationError The Clipboard object requested is no
                                      longer in scope (AIR only).
        @throws SecurityError         Reading from or writing to the clipboard
                                      is not permitted in this context. In
                                      Flash Player, you can only call this
                                      method successfully during the
                                      processing of a `paste` event. In AIR,
                                      this restriction only applies to content
                                      outside of the application security
                                      sandbox.
    **/
    getData(format, transferMode = null) {
        if (transferMode == null) {
            transferMode = ClipboardTransferMode$1.ORIGINAL_PREFERRED;
        }
        switch (format) {
            case ClipboardFormats$1.HTML_FORMAT:
            case ClipboardFormats$1.RICH_TEXT_FORMAT:
            case ClipboardFormats$1.TEXT_FORMAT:
                return this.__text;
            default:
                return null;
        }
    }
    /**
        Checks whether data in the specified format exists in this Clipboard
        object.
        Use the constants in the ClipboardFormats class to reference the
        standard format names.

        @param format The format type to check.
        @return `true`, if data in the specified format is present.
        @throws IllegalOperationError The Clipboard object requested is no
                                      longer in scope.
        @throws SecurityError         Reading from or writing to the clipboard
                                      is not permitted in this context.
    **/
    hasFormat(format) {
        switch (format) {
            case ClipboardFormats$1.HTML_FORMAT:
            case ClipboardFormats$1.RICH_TEXT_FORMAT:
            case ClipboardFormats$1.TEXT_FORMAT:
                return this.__text != null;
            default:
                return false;
        }
    }
    /**
        Adds a representation of the information to be transferred in the
        specified data format.
        In the application sandbox of Adobe AIR, `setData()` can be called
        anytime. In other contexts, `setData()` can only be called in response
        to a user-generated event such as a key press or mouse click.

        Different representations of the same information can be added to the
        clipboard as different formats, which increases the ability of other
        components or applications to make use of the available data. For
        example, an image could be added as bitmap data for use by image
        editing applications, as a URL, and as an encoded PNG file for
        transfer to the native file system.

        The data parameter must be the appropriate data type for the specified
        format:

        | Format | Type | Description |
        | --- | --- | --- |
        | `ClipboardFormats.TEXT_FORMAT` | `String` | string data |
        | `ClipboardFormats.HTML_FORMAT` | `String` | HTML string data |
        | `ClipboardFormats.URL_FORMAT` | `String` | URL string (AIR only) |
        | `ClipboardFormats.RICH_TEXT_FORMAT` | `ByteArray` | Rich Text Format data |
        | `ClipboardFormats.BITMAP_FORMAT` | `BitmapData` | bitmap data (AIR only) |
        | `ClipboardFormats.FILE_LIST_FORMAT` | array of `File` | an array of files (AIR only) |
        | Custom format name | any | object reference and serialized clone |

        Custom format names cannot begin with "air:" or "flash:". To prevent
        name collisions when using custom formats, you may want to use your
        application ID or a namespace name as a prefix to the format, such as
        "com.example.applicationName.dataPacket".

        When transferring within or between applications, the `serializable`
        parameter determines whether both a reference and a copy are
        available, or whether only a reference to an object is available. Set
        `serializable` to `true` to make both the reference and a copy of the
        data object available. Set `serializable` to `false` to make only the
        object reference available. Object references are valid only within
        the current application so setting `serializable` to `false` also
        means that the data in that format is not available to other Flash
        Player or AIR applications. A component can choose to get the
        reference or the copy of the object by setting the appropriate
        clipboard transfer mode when accessing the data for that format.

        **Note:** The standard formats are always converted to native formats
        when data is pasted or dragged outside a supported application, so the
        value of the `serializable` parameter does not affect the availability
        of data in the standard formats to non-Flash-based applications.

        To defer rendering of the data for a format, use the
        `setDataHandler()` method instead. If both the `setData()` and the
        `setDataHandler()` methods are used to add a data representation with
        the same format name, then the handler will never be called.

        **Note:** On Mac OS, when you set the `format` parameter to
        `ClipboardFormats.URL_FORMAT`, the URL is transferred only if it is a
        valid URL. Otherwise, the Clipboard object is emptied (and calling
        `getData()` returns `null`).

        @param format       The format of the data.
        @param data         The information to add.
        @param serializable Specify `true` for objects that can be serialized
                            (and deserialized).
        @return `true` if the data was succesfully set; `false` otherwise. In
                Flash Player, returns `false` when `format` is an unsupported
                member of ClipboardFormats. (Flash Player does not support
                `ClipboardFormats.URL_FORMAT`,
                `ClipboardFormats.FILE_LIST_FORMAT`,
                `ClipboardFormats.FILE_PROMISE_LIST_FORMAT`, or
                `ClipboardFormats.BITMAP_FORMAT`).
        @throws IllegalOperationError The Clipboard object requested is no
                                      longer in scope (which can occur with
                                      clipboards created for drag-and-drop
                                      operations).
        @throws SecurityError         Reading from or writing to the clipboard
                                      is not permitted in this context. In
                                      Flash Player, you can only call this
                                      method successfully during the
                                      processing of a user event (as in a key
                                      press or mouse click). In AIR, this
                                      restriction only applies to content
                                      outside of the application security
                                      sandbox.
        @throws TypeError             `format` or `data` is `null`.
    **/
    setData(format, data, serializable = true) {
        if (this.__textArea == null) {
            this.__textArea = document.createElement("textarea");
            this.__textArea.style.height = "0px";
            this.__textArea.style.left = "-100px";
            this.__textArea.style.opacity = "0";
            this.__textArea.style.position = "fixed";
            this.__textArea.style.top = "-100px";
            this.__textArea.style.width = "0px";
            document.body.appendChild(this.__textArea);
        }
        switch (format) {
            case ClipboardFormats$1.HTML_FORMAT:
            case ClipboardFormats$1.RICH_TEXT_FORMAT:
            case ClipboardFormats$1.TEXT_FORMAT:
                this.__text = data;
                this.__textArea.value = data;
                this.__textArea.focus();
                this.__textArea.select();
                if (document.queryCommandEnabled("copy")) {
                    document.execCommand("copy");
                }
                return true;
            default:
                return false;
        }
    }
    // 	/**
    // 		Adds a reference to a handler that produces the data to be
    // 		transfered.
    // 		Use a handler to defer creation or rendering of the data
    // 		until it is actually accessed.
    // 		The handler must return the appropriate data type for the
    // 		specified format:
    // 		| Format | Return Type |
    // 		| --- | --- |
    // 		| `ClipboardFormats.TEXT_FORMAT` | `String` |
    // 		| `ClipboardFormats.HTML_FORMAT` | `String` |
    // 		| `ClipboardFormats.URL_FORMAT` | `String` (AIR only) |
    // 		| `ClipboardFormats.RICH_TEXT_FORMAT` | `ByteArray` |
    // 		| `ClipboardFormats.BITMAP_FORMAT` | `BitmapData` (AIR only) |
    // 		| `ClipboardFormats.FILE_LIST_FORMAT` | Array of `File` (AIR only) |
    // 		| `ClipboardFormats.FILE_PROMISE_LIST_FORMAT` | Array of `File` (AIR only) |
    // 		| Custom format name | Non-void |
    // 		The handler is called when and only when the data in the
    // 		specified format is read. Note that in some cases, the operating
    // 		system calls the before a drop occurs. For example, when you
    // 		use a handler to provide the data for a file dragged from an
    // 		AIR application to the file system, the operating system calls the
    // 		data handler as soon as the drag gesture leaves the AIR
    // 		application�typically resulting in an undesireable pause as the file
    // 		data is downloaded or created. You can use a URLFilePromise for this
    // 		purpose instead.
    // 		Note that the underlying data can change between the time the handler
    // 		is added and the time the data is read unless your application takes
    // 		steps to protect the data. The behavior that occurs when data on the
    // 		clipboard represented by a handler is read more than once is
    // 		not guaranteed. The clipboard might return the data produced by the
    // 		first call or it might call the again. Do not rely
    // 		on either behavior.
    // 		In the application sandbox of Adobe AIR, `setDataHandler()` can be
    // 		called anytime. In other contexts, `setDataHandler()` can only be
    // 		called in response to a user-generated event such as a key press or
    // 		mouse click.
    // 		To add data directly to this Clipboard object, use the `setData()`
    // 		method instead. If both the `setData()` and the `setDataHandler()`
    // 		methods are called with the same format name, then the handler
    // 		function is never called.
    // 		**Note:** On Mac OS, when you set the `format` parameter to
    // 		`ClipboardFormats.URL_FORMAT`, the URL is transferred only if the
    // 		handler returns a valid URL. Otherwise, the Clipboard object
    // 		is emptied (and calling `getData()` returns `null`).
    // 		@param format       A that returns the data to be
    // 							transferred.
    // 		@param handler      The format of the data.
    // 		@param serializable Specify `true` if the object returned by `handler`
    // 							can be serialized (and deserialized).
    // 		@return `true` if the handler was succesfully set; `false` otherwise.
    // 		@throws IllegalOperationError The Clipboard object requested is no
    // 									  longer in scope (AIR only).
    // 		@throws SecurityError         Reading from or writing to the clipboard
    // 									  is not permitted in this context. In
    // 									  Flash Player, you can only call this
    // 									  method successfully during the
    // 									  processing of a user event (such as a
    // 									  key press or mouse click). In AIR, this
    // 									  restriction only applies to content
    // 									  outside of the application security
    // 									  sandbox.
    // 		@throws TypeError             `format` or `handler` is `null`.
    // 	**/
    // 	public setDataHandler(format: ClipboardFormats, handler: void-> Dynamic, serializable  : boolean = true) : boolean
    // {
    // 	openfl._internal.Lib.notImplemented();
    // 	return false;
    // }
    // Get & Set Methods
    /**
            An array of strings containing the names of the data formats available
            in this Clipboard object.
            String constants for the names of the standard formats are defined in
            the ClipboardFormats class. Other, application-defined, strings may
            also be used as format names to transfer data as an object.
        **/
    get formats() {
        let _formats;
        _formats = [];
        if (this.hasFormat(ClipboardFormats$1.HTML_FORMAT))
            _formats.push(ClipboardFormats$1.HTML_FORMAT);
        if (this.hasFormat(ClipboardFormats$1.RICH_TEXT_FORMAT))
            _formats.push(ClipboardFormats$1.RICH_TEXT_FORMAT);
        if (this.hasFormat(ClipboardFormats$1.TEXT_FORMAT))
            _formats.push(ClipboardFormats$1.TEXT_FORMAT);
        return _formats;
    }
    /**
            The operating system clipboard.
            Any data pasted to the system clipboard is available to other
            applications. This may include insecure remote code running in a web
            browser.

            **Note:** In Flash Player 10 applications, a paste operation from the
            clipboard first requires a user event (such as a keyboard shortcut for
            the Paste command or a mouse click on the Paste command in a context
            menu). `Clipboard.getData()` will return the contents of the clipboard
            only if the InteractiveObject has received and is acting on a paste
            event. Calling `Clipboard.getData()` under any other circumstances
            will be unsuccessful. The same restriction applies in AIR for content
            outside the application sandbox.

            The `generalClipboard` object is created automatically. You cannot
            assign another instance of a Clipboard to this property. Instead, you
            use the `getData()` and `setData()` methods to read and write data to
            the existing object.

            You should always clear the clipboard before writing new data to it to
            ensure that old data in all formats is erased.

            The `generalClipboard` object cannot be passed to the AIR
            NativeDragManager. Create a new Clipboard object for native
            drag-and-drop operations in an AIR application.
        **/
    static get generalClipboard() {
        if (Clipboard.__generalClipboard == null) {
            Clipboard.__generalClipboard = new Clipboard();
        }
        return Clipboard.__generalClipboard;
    }
}

var DisplayObjectType;
(function (DisplayObjectType) {
    DisplayObjectType[DisplayObjectType["BITMAP"] = 0] = "BITMAP";
    DisplayObjectType[DisplayObjectType["DISPLAY_OBJECT"] = 1] = "DISPLAY_OBJECT";
    DisplayObjectType[DisplayObjectType["DISPLAY_OBJECT_CONTAINER"] = 2] = "DISPLAY_OBJECT_CONTAINER";
    DisplayObjectType[DisplayObjectType["DOM_ELEMENT"] = 3] = "DOM_ELEMENT";
    DisplayObjectType[DisplayObjectType["MOVIE_CLIP"] = 4] = "MOVIE_CLIP";
    DisplayObjectType[DisplayObjectType["SHAPE"] = 5] = "SHAPE";
    DisplayObjectType[DisplayObjectType["SIMPLE_BUTTON"] = 6] = "SIMPLE_BUTTON";
    DisplayObjectType[DisplayObjectType["TEXTFIELD"] = 7] = "TEXTFIELD";
    DisplayObjectType[DisplayObjectType["TILEMAP"] = 8] = "TILEMAP";
    DisplayObjectType[DisplayObjectType["VIDEO"] = 9] = "VIDEO";
    DisplayObjectType[DisplayObjectType["CUSTOM"] = 10] = "CUSTOM";
})(DisplayObjectType || (DisplayObjectType = {}));
var DisplayObjectType$1 = DisplayObjectType;

class DisplayObjectRenderData {
    constructor() { }
    dispose() {
        if (this.cacheBitmap != null) {
            this.cacheBitmap.__cleanup();
            this.cacheBitmap = null;
        }
        if (this.cacheBitmapDataTexture != null) {
            this.cacheBitmapDataTexture.dispose();
            this.cacheBitmapDataTexture = null;
        }
        if (this.cacheBitmapData != null) {
            this.cacheBitmapData.dispose();
            this.cacheBitmapData = null;
        }
        if (this.cacheBitmapData2 != null) {
            this.cacheBitmapData2.dispose();
            this.cacheBitmapData2 = null;
        }
        if (this.cacheBitmapData3 != null) {
            this.cacheBitmapData3.dispose();
            this.cacheBitmapData3 = null;
        }
        this.vertexBuffer = null;
        this.framebuffer = null;
        this.framebufferContext = null;
        this.texture = null;
        this.textureContext = null;
        this.canvas = null;
        this.context = null;
        this.style = null;
    }
}

class DisplayObjectIterator {
    constructor() {
        this.entry = null;
        this.current = null;
    }
    // public hasNext(): boolean
    // {
    // 	return (current != null);
    // }
    init(displayObject, childrenOnly) {
        this.entry = displayObject;
        if (this.entry != null) {
            this.current = childrenOnly ? this.entry.__firstChild : this.entry;
        }
        else {
            this.current = null;
        }
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        var _current = this.current;
        if (this.current.__firstChild != null) {
            this.current = this.current.__firstChild;
        }
        else if (this.current.__nextSibling != null) {
            this.current = this.current.__nextSibling;
        }
        else {
            do {
                if (this.current.parent == null || this.current.parent == this.entry) {
                    this.current = null;
                    DisplayObject.__childIterators.release(this);
                    return { value: _current, done: (this.current != null) };
                }
                this.current = this.current.parent;
            } while (this.current.__nextSibling == null);
            this.current = this.current.__nextSibling;
            if (this.current == null) {
                DisplayObject.__childIterators.release(this);
            }
        }
        return { value: _current, done: (this.current != null) };
    }
    skip(current) {
        if (current.__firstChild == null) {
            return;
        }
        if (current.__firstChild == this.current) {
            if (current.__nextSibling != null) {
                this.current = current.__nextSibling;
            }
            else {
                do {
                    if (current.parent == null || current.parent == this.entry) {
                        this.current = null;
                        return;
                    }
                    current = current.parent;
                } while (current.__nextSibling == null);
                this.current = current.__nextSibling;
            }
        }
    }
}

class ObjectPool {
    constructor(create = null, clean = null, size = null) {
        this.__pool = new Map();
        this.activeObjects = 0;
        this.inactiveObjects = 0;
        this.__inactiveObject0 = null;
        this.__inactiveObject1 = null;
        this.__inactiveObjectList = new Array();
        if (create != null) {
            this.create = create;
        }
        if (clean != null) {
            this.clean = clean;
        }
        if (size != null) {
            this.size = size;
        }
    }
    add(object) {
        if (!this.__pool.has(object)) {
            this.__pool.set(object, false);
            this.clean(object);
            this.__addInactive(object);
        }
    }
    clean(object) { }
    clear() {
        this.__pool = new Map();
        this.activeObjects = 0;
        this.inactiveObjects = 0;
        this.__inactiveObject0 = null;
        this.__inactiveObject1 = null;
        this.__inactiveObjectList.length = 0;
    }
    create() {
        return null;
    }
    get() {
        var object = null;
        if (this.inactiveObjects > 0) {
            object = this.__getInactive();
        }
        else if (this.__size == null || this.activeObjects < this.__size) {
            object = this.create();
            if (object != null) {
                this.__pool.set(object, true);
                this.activeObjects++;
            }
        }
        return object;
    }
    release(object) {
        this.activeObjects--;
        if (this.__size == null || this.activeObjects + this.inactiveObjects < this.__size) {
            this.clean(object);
            this.__addInactive(object);
        }
        else {
            this.__pool.delete(object);
        }
    }
    remove(object) {
        if (this.__pool.has(object)) {
            this.__pool.delete(object);
            if (this.__inactiveObject0 == object) {
                this.__inactiveObject0 = null;
                this.inactiveObjects--;
            }
            else if (this.__inactiveObject1 == object) {
                this.__inactiveObject1 = null;
                this.inactiveObjects--;
            }
            else if (this.__inactiveObjectList.indexOf(object) > -1) {
                this.__inactiveObjectList.splice(this.__inactiveObjectList.indexOf(object), 1);
                this.inactiveObjects--;
            }
            else {
                this.activeObjects--;
            }
        }
    }
    __addInactive(object) {
        if (this.__inactiveObject0 == null) {
            this.__inactiveObject0 = object;
        }
        else if (this.__inactiveObject1 == null) {
            this.__inactiveObject1 = object;
        }
        else {
            this.__inactiveObjectList.push(object);
        }
        this.inactiveObjects++;
    }
    __getInactive() {
        var object = null;
        if (this.__inactiveObject0 != null) {
            object = this.__inactiveObject0;
            this.__inactiveObject0 = null;
        }
        else if (this.__inactiveObject1 != null) {
            object = this.__inactiveObject1;
            this.__inactiveObject1 = null;
        }
        else {
            object = this.__inactiveObjectList.pop();
            if (this.__inactiveObjectList.length > 0) {
                this.__inactiveObject0 = this.__inactiveObjectList.pop();
            }
            if (this.__inactiveObjectList.length > 0) {
                this.__inactiveObject1 = this.__inactiveObjectList.pop();
            }
        }
        this.inactiveObjects--;
        this.activeObjects++;
        return object;
    }
    __removeInactive(count) {
        if (count <= 0 || this.inactiveObjects == 0)
            return;
        if (this.__inactiveObject0 != null) {
            this.__pool.delete(this.__inactiveObject0);
            this.__inactiveObject0 = null;
            this.inactiveObjects--;
            count--;
        }
        if (count == 0 || this.inactiveObjects == 0)
            return;
        if (this.__inactiveObject1 != null) {
            this.__pool.delete(this.__inactiveObject1);
            this.__inactiveObject1 = null;
            this.inactiveObjects--;
            count--;
        }
        if (count == 0 || this.inactiveObjects == 0)
            return;
        for (let i = this.__inactiveObjectList.length - 1; i >= 0; i--) {
            this.__pool.delete(this.__inactiveObjectList[i]);
            this.__inactiveObjectList.length--;
            this.inactiveObjects--;
            count--;
            if (count == 0 || this.inactiveObjects == 0)
                return;
        }
    }
    // Get & Set Methods
    get size() {
        return this.__size;
    }
    set size(value) {
        if (value == null) {
            this.__size = null;
        }
        else {
            var current = this.inactiveObjects + this.activeObjects;
            this.__size = value;
            if (current > value) {
                this.__removeInactive(current - value);
            }
            else if (value > current) {
                var object;
                for (let i = 0; i < (value - current); i++) {
                    object = this.create();
                    if (object != null) {
                        this.__pool.set(object, false);
                        this.__inactiveObjectList.push(object);
                        this.inactiveObjects++;
                    }
                    else {
                        break;
                    }
                }
            }
        }
    }
}

let Lib = /** @class */ (() => {
    class Lib {
        static notImplemented() {
            var api = arguments.callee.name;
            if (!Lib.__sentWarnings.has(api)) {
                Lib.__sentWarnings.set(api, true);
                console.warn(api + " is not implemented");
            }
        }
    }
    Lib.__sentWarnings = new Map();
    return Lib;
})();

var openfl$1;
(function (openfl) {
    var display;
    (function (display) {
        /**
         * A class that provides constant values for visual blend mode effects. These
         * constants are used in the following:
         *
         *  *  The `blendMode` property of the
         * openfl.display.DisplayObject class.
         *  *  The `blendMode` parameter of the `draw()`
         * method of the openfl.display.BitmapData class
         *
         */
        let BlendMode;
        (function (BlendMode) {
            /**
             * Adds the values of the constituent colors of the display object to the
             * colors of its background, applying a ceiling of 0xFF. This setting is
             * commonly used for animating a lightening dissolve between two objects.
             *
             * For example, if the display object has a pixel with an RGB value of
             * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
             * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
             * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).
             */
            BlendMode["ADD"] = "add";
            /**
             * Applies the alpha value of each pixel of the display object to the
             * background. This requires the `blendMode` property of the
             * parent display object be set to
             * `openfl.display.BlendMode.LAYER`.
             *
             * Not supported under GPU rendering.
             */
            BlendMode["ALPHA"] = "alpha";
            /**
             * Selects the darker of the constituent colors of the display object and the
             * colors of the background(the colors with the smaller values). This
             * setting is commonly used for superimposing type.
             *
             * For example, if the display object has a pixel with an RGB value of
             * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
             * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
             * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).
             *
             * Not supported under GPU rendering.
             */
            BlendMode["DARKEN"] = "darken";
            /**
             * Compares the constituent colors of the display object with the colors of
             * its background, and subtracts the darker of the values of the two
             * constituent colors from the lighter value. This setting is commonly used
             * for more vibrant colors.
             *
             * For example, if the display object has a pixel with an RGB value of
             * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
             * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
             * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).
             */
            BlendMode["DIFFERENCE"] = "difference";
            /**
             * Erases the background based on the alpha value of the display object. This
             * process requires that the `blendMode` property of the parent
             * display object be set to `openfl.display.BlendMode.LAYER`.
             *
             * Not supported under GPU rendering.
             */
            BlendMode["ERASE"] = "erase";
            /**
             * Adjusts the color of each pixel based on the darkness of the display
             * object. If the display object is lighter than 50% gray, the display object
             * and background colors are screened, which results in a lighter color. If
             * the display object is darker than 50% gray, the colors are multiplied,
             * which results in a darker color. This setting is commonly used for shading
             * effects.
             *
             * Not supported under GPU rendering.
             */
            BlendMode["HARDLIGHT"] = "hardlight";
            /**
             * Inverts the background.
             */
            BlendMode["INVERT"] = "invert";
            /**
             * Forces the creation of a transparency group for the display object. This
             * means that the display object is precomposed in a temporary buffer before
             * it is processed further. The precomposition is done automatically if the
             * display object is precached by means of bitmap caching or if the display
             * object is a display object container that has at least one child object
             * with a `blendMode` setting other than `"normal"`.
             *
             * Not supported under GPU rendering.
             */
            BlendMode["LAYER"] = "layer";
            /**
             * Selects the lighter of the constituent colors of the display object and
             * the colors of the background(the colors with the larger values). This
             * setting is commonly used for superimposing type.
             *
             * For example, if the display object has a pixel with an RGB value of
             * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
             * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
             * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).
             *
             * Not supported under GPU rendering.
             */
            BlendMode["LIGHTEN"] = "lighten";
            /**
             * Multiplies the values of the display object constituent colors by the
             * constituent colors of the background color, and normalizes by dividing by
             * 0xFF, resulting in darker colors. This setting is commonly used for
             * shadows and depth effects.
             *
             * For example, if a constituent color(such as red) of one pixel in the
             * display object and the corresponding color of the pixel in the background
             * both have the value 0x88, the multiplied result is 0x4840. Dividing by
             * 0xFF yields a value of 0x48 for that constituent color, which is a darker
             * shade than the color of the display object or the color of the
             * background.
             */
            BlendMode["MULTIPLY"] = "multiply";
            /**
             * The display object appears in front of the background. Pixel values of the
             * display object override the pixel values of the background. Where the
             * display object is transparent, the background is visible.
             */
            BlendMode["NORMAL"] = "normal";
            /**
             * Adjusts the color of each pixel based on the darkness of the background.
             * If the background is lighter than 50% gray, the display object and
             * background colors are screened, which results in a lighter color. If the
             * background is darker than 50% gray, the colors are multiplied, which
             * results in a darker color. This setting is commonly used for shading
             * effects.
             *
             * Not supported under GPU rendering.
             */
            BlendMode["OVERLAY"] = "overlay";
            /**
             * Multiplies the complement(inverse) of the display object color by the
             * complement of the background color, resulting in a bleaching effect. This
             * setting is commonly used for highlights or to remove black areas of the
             * display object.
             */
            BlendMode["SCREEN"] = "screen";
            /**
                Uses a shader to define the blend between objects.
    
                Setting the blendShader property to a Shader instance automatically sets the
                display object's `blendMode` property to `BlendMode.SHADER`. If the `blendMode`
                property is set to `BlendMode.SHADER` without first setting the `blendShader`
                property, the `blendMode` property is set to `BlendMode.NORMAL` instead. If the
                `blendShader` property is set (which sets the `blendMode` property to
                `BlendMode.SHADER`), then later the value of the `blendMode` property is changed,
                the blend mode can be reset to use the blend shader simply by setting the
                `blendMode` property to `BlendMode.SHADER`. The `blendShader` property does not
                need to be set again except to change the shader that's used to define the blend
                mode.
    
                Not supported under GPU rendering.
            **/
            BlendMode["SHADER"] = "shader";
            /**
             * Subtracts the values of the constituent colors in the display object from
             * the values of the background color, applying a floor of 0. This setting is
             * commonly used for animating a darkening dissolve between two objects.
             *
             * For example, if the display object has a pixel with an RGB value of
             * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
             * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
             * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).
             */
            BlendMode["SUBTRACT"] = "subtract";
        })(BlendMode = display.BlendMode || (display.BlendMode = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$1 || (openfl$1 = {}));
var BlendMode = openfl$1.display.BlendMode;

/**
    The Error class contains information about an error that occurred in a script. In
    developing ActionScript 3.0 applications, when you run your compiled code in the
    debugger version of a Flash runtime, a dialog box displays exceptions of type Error,
    or of a subclass, to help you troubleshoot the code. You create an Error object by
    using the Error constructor function. Typically, you throw a new Error object from
    within a `try` code block that is caught by a `catch` code block.

    You can also create a subclass of the Error class and throw instances of that subclass.
**/
let Error$1 = /** @class */ (() => {
    class Error {
        /**
            Creates a new Error object. If message is specified, its value is assigned to the
            object's Error.message property.
    
            @param	message	A string associated with the Error object; this parameter is optional.
            @param	id	A reference number to associate with the specific error message.
        **/
        constructor(message = "", id = 0) {
            this.message = message;
            this.__errorID = id;
            this.name = "Error";
        }
        // /** @hidden */ @:dox(hide) public static getErrorMessage (index:Int):String;
        /**
            Returns the call stack for an error at the time of the error's construction as a
            string. As shown in the following example, the first line of the return value is
            the string representation of the exception object, followed by the stack trace
            elements:
    
            ```
            TypeError: Error #1009: Cannot access a property or method of a null object reference
                at com.xyz::OrderEntry/retrieveData()[/src/com/xyz/OrderEntry.as:995]
                at com.xyz::OrderEntry/init()[/src/com/xyz/OrderEntry.as:200]
                at com.xyz::OrderEntry()[/src/com/xyz/OrderEntry.as:148]
            ```
    
            The preceding listing shows the value of this method when called in a debugger
            version of Flash Player or code running in the AIR Debug Launcher (ADL). When code
            runs in a release version of Flash Player or AIR, the stack trace is provided
            without the file path and line number information, as in the following example:
    
            ```
            TypeError: Error #1009: Cannot access a property or method of a null object reference
                at com.xyz::OrderEntry/retrieveData()
                at com.xyz::OrderEntry/init()
                at com.xyz::OrderEntry()
            ```
    
            For Flash Player 11.4 and earlier and AIR 3.4 and earlier, stack traces are only
            available when code is running in the debugger version of Flash Player or the AIR
            Debug Launcher (ADL). In non-debugger versions of those runtimes, calling this
            method returns `null`.
    
            @returns	A string representation of the call stack.
        **/
        getStackTrace() {
            return null;
            // return super.stack;
        }
        // /** @hidden */ @:dox(hide) public static throwError (type:Class<Dynamic>, index:UInt, ?p1:Dynamic, ?p2:Dynamic, ?p3:Dynamic, ?p4:Dynamic, ?p5:Dynamic):Dynamic;
        /**
            Returns the string "Error" by default or the value contained in the `Error.message`
            property, if defined.
    
            @returns	The error message.
        **/
        toString() {
            if (this.message != null) {
                return this.message;
            }
            else {
                return Error.DEFAULT_TO_STRING;
            }
        }
        // Get & Set Methods
        /**
            Contains the reference number associated with the specific error message. For a
            custom Error object, this number is the value from the id parameter supplied in the
            constructor.
        **/
        get errorID() {
            return this.__errorID;
        }
    }
    Error.DEFAULT_TO_STRING = "Error";
    return Error;
})();

class TypeError$1 extends Error$1 {
    constructor(message = "") {
        super(message, 0);
        this.name = "TypeError";
    }
}

/**
 * The EventPhase class provides values for the `eventPhase`
 * property of the Event class.
 */
var EventPhase;
(function (EventPhase) {
    /**
        The target phase, which is the second phase of the event flow.
    **/
    EventPhase[EventPhase["AT_TARGET"] = 2] = "AT_TARGET";
    /**
        The bubbling phase, which is the third phase of the event flow.
    **/
    EventPhase[EventPhase["BUBBLING_PHASE"] = 3] = "BUBBLING_PHASE";
    /**
        The capturing phase, which is the first phase of the event flow.
    **/
    EventPhase[EventPhase["CAPTURING_PHASE"] = 1] = "CAPTURING_PHASE";
})(EventPhase || (EventPhase = {}));
var EventPhase$1 = EventPhase;

/**
    The Event class is used as the base class for the creation of Event
    objects, which are passed as parameters to event listeners when an event
    occurs.

    The properties of the Event class carry basic information about an
    event, such as the event's type or whether the event's default behavior can
    be canceled. For many events, such as the events represented by the Event
    class constants, this basic information is sufficient. Other events,
    however, may require more detailed information. Events associated with a
    mouse click, for example, need to include additional information about the
    location of the click event and whether any keys were pressed during the
    click event. You can pass such additional information to event listeners by
    extending the Event class, which is what the MouseEvent class does.
    ActionScript 3.0 API defines several Event subclasses for common events
    that require additional information. Events associated with each of the
    Event subclasses are described in the documentation for each class.

    The methods of the Event class can be used in event listener functions
    to affect the behavior of the event object. Some events have an associated
    default behavior. For example, the `doubleClick` event has an
    associated default behavior that highlights the word under the mouse
    pointer at the time of the event. Your event listener can cancel this
    behavior by calling the `preventDefault()` method. You can also
    make the current event listener the last one to process an event by calling
    the `stopPropagation()` or
    `stopImmediatePropagation()` method.

    Other sources of information include:

    * A useful description about the timing of events, code execution, and
    rendering at runtime in Ted Patrick's blog entry: <a
    [Flash Player Mental Model - The Elastic Racetrack](http://tedpatrick.com/2005/07/19/flash-player-mental-model-the-elastic-racetrack/).
    * A blog entry by Johannes Tacskovics about the timing of frame events,
    such as ENTER_FRAME, EXIT_FRAME: [The MovieClip Lifecycle](http://web.archive.org/web/20110623195412/http://blog.johannest.com:80/2009/06/15/the-movieclip-life-cycle-revisited-from-event-added-to-event-removed_from_stage/).
    * An article by Trevor McCauley about the order of ActionScript
    operations: [Order of Operations in ActionScript](http://web.archive.org/web/20171009141202/http://www.senocular.com:80/flash/tutorials/orderofoperations/).
    * A blog entry by Matt Przybylski on creating custom events:
    [AS3: Custom Events](http://evolve.reintroducing.com/2007/10/23/as3/as3-custom-events/).
**/
let Event = /** @class */ (() => {
    class Event {
        /**
            Creates an Event object to pass as a parameter to event listeners.
    
            @param type       The type of the event, accessible as
                              `Event.type`.
            @param bubbles    Determines whether the Event object participates in the
                              bubbling stage of the event flow. The default value is
                              `false`.
            @param cancelable Determines whether the Event object can be canceled. The
                              default values is `false`.
        **/
        constructor(type, bubbles = false, cancelable = false) {
            this.__type = type;
            this.__bubbles = bubbles;
            this.__cancelable = cancelable;
            this.__eventPhase = EventPhase$1.AT_TARGET;
        }
        /**
            Duplicates an instance of an Event subclass.
    
            Returns a new Event object that is a copy of the original instance of
            the Event object. You do not normally call `clone()`; the
            EventDispatcher class calls it automatically when you redispatch an
            event - that is, when you call `dispatchEvent(event)` from a
            handler that is handling `event`.
    
            The new Event object includes all the properties of the original.
    
            When creating your own custom Event class, you mustthe
            inherited `Event.clone()` method in order for it to duplicate
            the properties of your custom class. If you do not set all the properties
            that you add in your event subclass, those properties will not have the
            correct values when listeners handle the redispatched event.
    
            In this example, `PingEvent` is a subclass of
            `Event` and therefore implements its own version of
            `clone()`.
    
            @return A new Event object that is identical to the original.
        **/
        clone() {
            var event = new Event(this.__type, this.__bubbles, this.__cancelable);
            event.__eventPhase = this.__eventPhase;
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            return event;
        }
        /**
            A utility for implementing the `toString()` method in custom
            ActionScript 3.0 Event classes. Overriding the `toString()` method is
            recommended, but not required.
    
            ```haxe
            class PingEvent extends Event {
                var URL:String;
    
                public constructor() {
                    super();
                }
    
                publictoString():String {
                    return formatToString("PingEvent", "type", "bubbles", "cancelable", "eventPhase", "URL");
                }
            }
            ```
    
            @param className The name of your custom Event class. In the previous
                             example, the `className` parameter is `PingEvent`.
            @return The name of your custom Event class and the String value of
                    your `...arguments` parameter.
        **/
        formatToString(className, ...parameters) {
            var output = `[${className}`;
            var param = null;
            var value = null;
            for (let i = 0; i < parameters.length; i++) {
                param = parameters[i];
                value = this[param];
                if (typeof value === "string") {
                    output += ` ${param}="${value}"`;
                }
                else {
                    output += ` ${param}=${value}`;
                }
            }
            output += "]";
            return output;
        }
        /**
            Checks whether the `preventDefault()` method has been called on
            the event. If the `preventDefault()` method has been called,
            returns `true`; otherwise, returns `false`.
    
            @return If `preventDefault()` has been called, returns
                    `true`; otherwise, returns `false`.
        **/
        isDefaultPrevented() {
            return this.__preventDefault;
        }
        /**
            Cancels an event's default behavior if that behavior can be canceled.
            Many events have associated behaviors that are carried out by default. For example, if a user types a character into a text field, the default behavior is that the character is displayed in the text field. Because the `TextEvent.TEXT_INPUT` event's default behavior can be canceled, you can use the `preventDefault()` method to prevent the character from appearing.
            An example of a behavior that is not cancelable is the default behavior associated with the Event.REMOVED event, which is generated whenever Flash Player is about to remove a display object from the display list. The default behavior (removing the element) cannot be canceled, so the `preventDefault()` method has no effect on this default behavior.
            You can use the `Event.cancelable` property to check whether you can prevent the default behavior associated with a particular event. If the value of `Event.cancelable` is true, then `preventDefault()` can be used to cancel the event; otherwise, `preventDefault()` has no effect.
        **/
        preventDefault() {
            if (this.__cancelable) {
                this.__preventDefault = true;
            }
        }
        /**
            Prevents processing of any event listeners in the current node and any
            subsequent nodes in the event flow. This method takes effect immediately,
            and it affects event listeners in the current node. In contrast, the
            `stopPropagation()` method doesn't take effect until all the
            event listeners in the current node finish processing.
    
            **Note: ** This method does not cancel the behavior associated with
            this event; see `preventDefault()` for that functionality.
    
        **/
        stopImmediatePropagation() {
            this.__isCanceled = true;
            this.__isCanceledNow = true;
        }
        /**
            Prevents processing of any event listeners in nodes subsequent to the
            current node in the event flow. This method does not affect any event
            listeners in the current node(`currentTarget`). In contrast,
            the `stopImmediatePropagation()` method prevents processing of
            event listeners in both the current node and subsequent nodes. Additional
            calls to this method have no effect. This method can be called in any
            phase of the event flow.
    
            **Note: ** This method does not cancel the behavior associated with
            this event; see `preventDefault()` for that functionality.
    
        **/
        stopPropagation() {
            this.__isCanceled = true;
        }
        /**
            Returns a string containing all the properties of the Event object. The
            string is in the following format:
    
            `[Event type=_value_ bubbles=_value_
            cancelable=_value_]`
    
            @return A string containing all the properties of the Event object.
        **/
        toString() {
            return this.formatToString("Event", "type", "bubbles", "cancelable");
        }
        __init() {
            // type = null;
            this.__target = null;
            this.__currentTarget = null;
            this.__bubbles = false;
            this.__cancelable = false;
            this.__eventPhase = EventPhase$1.AT_TARGET;
            this.__isCanceled = false;
            this.__isCanceledNow = false;
            this.__preventDefault = false;
        }
        // Get & Set Methods
        /**
            Indicates whether an event is a bubbling event. If the event can bubble,
            this value is `true`; otherwise it is `false`.
    
            When an event occurs, it moves through the three phases of the event
            flow: the capture phase, which flows from the top of the display list
            hierarchy to the node just before the target node; the target phase, which
            comprises the target node; and the bubbling phase, which flows from the
            node subsequent to the target node back up the display list hierarchy.
    
            Some events, such as the `activate` and `unload`
            events, do not have a bubbling phase. The `bubbles` property
            has a value of `false` for events that do not have a bubbling
            phase.
        **/
        get bubbles() {
            return this.__bubbles;
        }
        /**
            Indicates whether the behavior associated with the event can be prevented.
            If the behavior can be canceled, this value is `true`;
            otherwise it is `false`.
        **/
        get cancelable() {
            return this.__cancelable;
        }
        /**
            The object that is actively processing the Event object with an event
            listener. For example, if a user clicks an OK button, the current target
            could be the node containing that button or one of its ancestors that has
            registered an event listener for that event.
        **/
        get currentTarget() {
            return this.__currentTarget;
        }
        /**
            The current phase in the event flow. This property can contain the
            following numeric values:
    
            * The capture phase(`EventPhase.CAPTURING_PHASE`).
            * The target phase(`EventPhase.AT_TARGET`).
            * The bubbling phase(`EventPhase.BUBBLING_PHASE`).
        **/
        get eventPhase() {
            return this.__eventPhase;
        }
        /**
            The event target. This property contains the target node. For example, if
            a user clicks an OK button, the target node is the display list node
            containing that button.
        **/
        get target() {
            return this.__target;
        }
        /**
            The type of event. The type is case-sensitive.
        **/
        get type() {
            return this.__type;
        }
    }
    /**
        The `ACTIVATE` constant defines the value of the `type` property of an
        `activate` event object.
        **Note:** This event has neither a "capture phase" nor a "bubble
        phase", which means that event listeners must be added directly to any
        potential targets, whether the target is on the display list or not.

        AIR for TV devices never automatically dispatch this event. You can,
        however, dispatch it manually.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any DisplayObject instance with a listener registered for the `activate` event. |
    **/
    Event.ACTIVATE = "activate";
    /**
        The `Event.ADDED` constant defines the value of the `type` property of
        an `added` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The DisplayObject instance being added to the display list. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.ADDED = "added";
    /**
        The `Event.ADDED_TO_STAGE` constant defines the value of the `type`
        property of an `addedToStage` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The DisplayObject instance being added to the on stage display list, either directly or through the addition of a sub tree in which the DisplayObject instance is contained. If the DisplayObject instance is being directly added, the `added` event occurs before this event. |
    **/
    Event.ADDED_TO_STAGE = "addedToStage";
    // /** @hidden */ @:dox(hide) @:require(flash15) public static BROWSER_ZOOM_CHANGE:String;
    /**
        The `Event.CANCEL` constant defines the value of the `type` property
        of a `cancel` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | A reference to the object on which the operation is canceled. |
    **/
    Event.CANCEL = "cancel";
    /**
        The `Event.CHANGE` constant defines the value of the `type` property
        of a `change` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object that has had its value modified. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.CHANGE = "change";
    // /** @hidden */ @:dox(hide) public static CHANNEL_MESSAGE:String;
    // /** @hidden */ @:dox(hide) public static CHANNEL_STATE:String;
    /**
        The `Event.CLEAR` constant defines the value of the `type` property of
        a `clear` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any InteractiveObject instance with a listener registered for the `clear` event. |

        **Note:** TextField objects do _not_ dispatch `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. TextField objects always include Cut,
        Copy, Paste, Clear, and Select All commands in the context menu. You
        cannot remove these commands from the context menu for TextField
        objects. For TextField objects, selecting these commands (or their
        keyboard equivalents) does not generate `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. However, other classes that extend the
        InteractiveObject class, including components built using the Flash
        Text Engine (FTE), will dispatch these events in response to user
        actions such as keyboard shortcuts and context menus.
    **/
    Event.CLEAR = "clear";
    /**
        The `Event.CLOSE` constant defines the value of the `type` property of
        a `close` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object whose connection has been closed. |
    **/
    Event.CLOSE = "close";
    /**
        The `Event.COMPLETE` constant defines the value of the `type` property
        of a `complete` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The network object that has completed loading. |
    **/
    Event.COMPLETE = "complete";
    /**
        The `Event.CONNECT` constant defines the value of the `type` property
        of a `connect` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Socket or XMLSocket object that has established a network connection. |
    **/
    Event.CONNECT = "connect";
    /**
        The `Event.CONTEXT3D_CREATE` constant defines the value of the type property of a
        `context3Dcreate` event object. This event is raised only by Stage3D objects in
        response to either a call to `Stage3D.requestContext3D` or in response to an OS
        triggered reset of the Context3D bound to the Stage3D object. Inspect the
        `Stage3D.context3D` property to get the newly created Context3D object.
    **/
    Event.CONTEXT3D_CREATE = "context3DCreate";
    /**
        Defines the value of the `type` property of a `copy` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any InteractiveObject instance with a listener registered for the `copy` event. |

        **Note:** TextField objects do _not_ dispatch `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. TextField objects always include Cut,
        Copy, Paste, Clear, and Select All commands in the context menu. You
        cannot remove these commands from the context menu for TextField
        objects. For TextField objects, selecting these commands (or their
        keyboard equivalents) does not generate `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. However, other classes that extend the
        InteractiveObject class, including components built using the Flash
        Text Engine (FTE), will dispatch these events in response to user
        actions such as keyboard shortcuts and context menus.
    **/
    Event.COPY = "copy";
    /**
        Defines the value of the `type` property of a `cut` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any InteractiveObject instance with a listener registered for the `cut` event. |

        **Note:** TextField objects do _not_ dispatch `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. TextField objects always include Cut,
        Copy, Paste, Clear, and Select All commands in the context menu. You
        cannot remove these commands from the context menu for TextField
        objects. For TextField objects, selecting these commands (or their
        keyboard equivalents) does not generate `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. However, other classes that extend the
        InteractiveObject class, including components built using the Flash
        Text Engine (FTE), will dispatch these events in response to user
        actions such as keyboard shortcuts and context menus.
    **/
    Event.CUT = "cut";
    /**
        The `Event.DEACTIVATE` constant defines the value of the `type`
        property of a `deactivate` event object.
        **Note:** This event has neither a "capture phase" nor a "bubble
        phase", which means that event listeners must be added directly to any
        potential targets, whether the target is on the display list or not.

        AIR for TV devices never automatically dispatch this event. You can,
        however, dispatch it manually.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any DisplayObject instance with a listener registered for the `deactivate` event. |
    **/
    Event.DEACTIVATE = "deactivate";
    /**
        The `Event.ENTER_FRAME` constant defines the value of the `type`
        property of an `enterFrame` event object.
        **Note:** This event has neither a "capture phase" nor a "bubble
        phase", which means that event listeners must be added directly to any
        potential targets, whether the target is on the display list or not.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any DisplayObject instance with a listener registered for the `enterFrame` event. |
    **/
    Event.ENTER_FRAME = "enterFrame";
    /**
        The `Event.EXIT_FRAME` constant defines the value of the `type`
        property of an `exitFrame` event object.
        **Note:** This event has neither a "capture phase" nor a "bubble
        phase", which means that event listeners must be added directly to any
        potential targets, whether the target is on the display list or not.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any DisplayObject instance with a listener registered for the `enterFrame` event. |
    **/
    Event.EXIT_FRAME = "exitFrame";
    /**
        The `Event.FRAME_CONSTRUCTED` constant defines the value of the `type`
        property of an `frameConstructed` event object.
        **Note:** This event has neither a "capture phase" nor a "bubble
        phase", which means that event listeners must be added directly to any
        potential targets, whether the target is on the display list or not.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any DisplayObject instance with a listener registered for the `frameConstructed` event. |
    **/
    Event.FRAME_CONSTRUCTED = "frameConstructed";
    /**
        The `Event.FRAME_LABEL` constant defines the value of the type property of a
        `frameLabel` event object.

        **Note:** This event has neither a "capture phase" nor a "bubble phase", which
        means that event listeners must be added directly to FrameLabel objects.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The FrameLabel object that is actively processing the Event object with an event listener. |
        | `target` | Any FrameLabel instance with a listener registered for the frameLabel event. |
    **/
    Event.FRAME_LABEL = "frameLabel";
    /**
        The `Event.FULL_SCREEN` constant defines the value of the `type`
        property of a `fullScreen` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Stage object. |
    **/
    Event.FULLSCREEN = "fullScreen";
    /**
        The `Event.ID3` constant defines the value of the `type` property of
        an `id3` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Sound object loading the MP3 for which ID3 data is now available. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.ID3 = "id3";
    /**
        The `Event.INIT` constant defines the value of the `type` property of
        an `init` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The LoaderInfo object associated with the SWF file being loaded. |
    **/
    Event.INIT = "init";
    /**
        The `Event.MOUSE_LEAVE` constant defines the value of the `type`
        property of a `mouseLeave` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Stage object. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.MOUSE_LEAVE = "mouseLeave";
    /**
        The `Event.OPEN` constant defines the value of the `type` property of
        an `open` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The network object that has opened a connection. |
    **/
    Event.OPEN = "open";
    /**
        The `Event.PASTE` constant defines the value of the `type` property of
        a `paste` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any InteractiveObject instance with a listener registered for the `paste` event. |

        **Note:** TextField objects do _not_ dispatch `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. TextField objects always include Cut,
        Copy, Paste, Clear, and Select All commands in the context menu. You
        cannot remove these commands from the context menu for TextField
        objects. For TextField objects, selecting these commands (or their
        keyboard equivalents) does not generate `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. However, other classes that extend the
        InteractiveObject class, including components built using the Flash
        Text Engine (FTE), will dispatch these events in response to user
        actions such as keyboard shortcuts and context menus.
    **/
    Event.PASTE = "paste";
    /**
        The `Event.REMOVED` constant defines the value of the `type` property
        of a `removed` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The DisplayObject instance to be removed from the display list. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.REMOVED = "removed";
    /**
        The `Event.REMOVED_FROM_STAGE` constant defines the value of the
        `type` property of a `removedFromStage` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The DisplayObject instance being removed from the on stage display list, either directly or through the removal of a sub tree in which the DisplayObject instance is contained. If the DisplayObject instance is being directly removed, the `removed` event occurs before this event. |
    **/
    Event.REMOVED_FROM_STAGE = "removedFromStage";
    /**
        The `Event.RENDER` constant defines the value of the `type` property
        of a `render` event object.
        **Note:** This event has neither a "capture phase" nor a "bubble
        phase", which means that event listeners must be added directly to any
        potential targets, whether the target is on the display list or not.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any DisplayObject instance with a listener registered for the `render` event. |
    **/
    Event.RENDER = "render";
    /**
        The `Event.RESIZE` constant defines the value of the `type` property
        of a `resize` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Stage object. |
    **/
    Event.RESIZE = "resize";
    /**
        The `Event.SCROLL` constant defines the value of the `type` property
        of a `scroll` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The TextField object that has been scrolled. The `target` property is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.SCROLL = "scroll";
    /**
        The `Event.SELECT` constant defines the value of the `type` property
        of a `select` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object on which an item has been selected. |
    **/
    Event.SELECT = "select";
    /**
        The `Event.SELECT_ALL` constant defines the value of the `type`
        property of a `selectAll` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | Any InteractiveObject instance with a listener registered for the `selectAll` event. |

        **Note:** TextField objects do _not_ dispatch `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. TextField objects always include Cut,
        Copy, Paste, Clear, and Select All commands in the context menu. You
        cannot remove these commands from the context menu for TextField
        objects. For TextField objects, selecting these commands (or their
        keyboard equivalents) does not generate `clear`, `copy`, `cut`,
        `paste`, or `selectAll` events. However, other classes that extend the
        InteractiveObject class, including components built using the Flash
        Text Engine (FTE), will dispatch these events in response to user
        actions such as keyboard shortcuts and context menus.
    **/
    Event.SELECT_ALL = "selectAll";
    /**
        The `Event.SOUND_COMPLETE` constant defines the value of the `type`
        property of a `soundComplete` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The SoundChannel object in which a sound has finished playing. |
    **/
    Event.SOUND_COMPLETE = "soundComplete";
    /**
        The `Event.TAB_CHILDREN_CHANGE` constant defines the value of the
        `type` property of a `tabChildrenChange` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object whose tabChildren flag has changed. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.TAB_CHILDREN_CHANGE = "tabChildrenChange";
    /**
        The `Event.TAB_ENABLED_CHANGE` constant defines the value of the
        `type` property of a `tabEnabledChange` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The InteractiveObject whose tabEnabled flag has changed. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.TAB_ENABLED_CHANGE = "tabEnabledChange";
    /**
        The `Event.TAB_INDEX_CHANGE` constant defines the value of the `type`
        property of a `tabIndexChange` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object whose tabIndex has changed. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    Event.TAB_INDEX_CHANGE = "tabIndexChange";
    /**
        The `Event.TEXTURE_READY` constant defines the value of the type property of a
        `textureReady` event object. This event is dispatched by Texture and CubeTexture
        objects to signal the completion of an asynchronous upload. Request an asynchronous
        upload by using the `uploadCompressedTextureFromByteArray()` method on Texture or
        CubeTexture. This event neither bubbles nor is cancelable.
    **/
    Event.TEXTURE_READY = "textureReady";
    /**
        The `Event.TEXT_INTERACTION_MODE_CHANGE` constant defines the value of
        the `type` property of a `interaction mode` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The TextField object whose interaction mode property is changed. For example on Android, one can change the interaction mode to SELECTION via context menu. The `target` property is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    // /** @hidden */ @:dox(hide) @:require(flash11) public static TEXT_INTERACTION_MODE_CHANGE:String;
    /**
        The `Event.UNLOAD` constant defines the value of the `type` property
        of an `unload` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The LoaderInfo object associated with the SWF file being unloaded or replaced. |
    **/
    Event.UNLOAD = "unload";
    // /** @hidden */ @:dox(hide) public static VIDEO_FRAME:String;
    // /** @hidden */ @:dox(hide) public static WORKER_STATE:String;
    Event.__pool = new ObjectPool(() => new Event(null), (event) => event.__init());
    return Event;
})();

/**
        The EventDispatcher class is the base class for all classes that dispatch
        events. The EventDispatcher class implements the IEventDispatcher interface
        and is the base class for the DisplayObject class. The EventDispatcher
        class allows any object on the display list to be an event target and as
        such, to use the methods of the IEventDispatcher interface.

        Event targets are an important part of the Flash<sup>®</sup> Player and
        Adobe<sup>®</sup> AIR<sup>®</sup> event model. The event target serves as
        the focal point for how events flow through the display list hierarchy.
        When an event such as a mouse click or a keypress occurs, Flash Player or
        the AIR application dispatches an event object into the event flow from the
        root of the display list. The event object then makes its way through the
        display list until it reaches the event target, at which point it begins
        its return trip through the display list. This round-trip journey to the
        event target is conceptually divided into three phases: the capture phase
        comprises the journey from the root to the last node before the event
        target's node, the target phase comprises only the event target node, and
        the bubbling phase comprises any subsequent nodes encountered on the return
        trip to the root of the display list.

        In general, the easiest way for a user-defined class to gain event
        dispatching capabilities is to extend EventDispatcher. If this is
        impossible(that is, if the class is already extending another class), you
        can instead implement the IEventDispatcher interface, create an
        EventDispatcher member, and write simple hooks to route calls into the
        aggregated EventDispatcher.

        @event activate   [broadcast event] Dispatched when the Flash Player or AIR
                          application gains operating system focus and becomes
                          active. This event is a broadcast event, which means that
                          it is dispatched by all EventDispatcher objects with a
                          listener registered for this event. For more information
                          about broadcast events, see the DisplayObject class.
        @event deactivate [broadcast event] Dispatched when the Flash Player or AIR
                          application operating loses system focus and is becoming
                          inactive. This event is a broadcast event, which means
                          that it is dispatched by all EventDispatcher objects with
                          a listener registered for this event. For more
                          information about broadcast events, see the DisplayObject
                          class.
    **/
class EventDispatcher {
    /**
        Aggregates an instance of the EventDispatcher class.

        The EventDispatcher class is generally used as a base class, which
        means that most developers do not need to use this constructor function.
        However, advanced developers who are implementing the IEventDispatcher
        interface need to use this constructor. If you are unable to extend the
        EventDispatcher class and must instead implement the IEventDispatcher
        interface, use this constructor to aggregate an instance of the
        EventDispatcher class.

        @param target The target object for events dispatched to the
                      EventDispatcher object. This parameter is used when the
                      EventDispatcher instance is aggregated by a class that
                      implements IEventDispatcher; it is necessary so that the
                      containing object can be the target for events. Do not use
                      this parameter in simple cases in which a class extends
                      EventDispatcher.
    **/
    constructor(target = null) {
        if (target != null) {
            this.__targetDispatcher = target;
        }
    }
    /**
        Registers an event listener object with an EventDispatcher object so that
        the listener receives notification of an event. You can register event
        listeners on all nodes in the display list for a specific type of event,
        phase, and priority.

        After you successfully register an event listener, you cannot change
        its priority through additional calls to `addEventListener()`.
        To change a listener's priority, you must first call
        `removeListener()`. Then you can register the listener again
        with the new priority level.

        Keep in mind that after the listener is registered, subsequent calls to
        `addEventListener()` with a different `type` or
        `useCapture` value result in the creation of a separate
        listener registration. For example, if you first register a listener with
        `useCapture` set to `true`, it listens only during
        the capture phase. If you call `addEventListener()` again using
        the same listener object, but with `useCapture` set to
        `false`, you have two separate listeners: one that listens
        during the capture phase and another that listens during the target and
        bubbling phases.

        You cannot register an event listener for only the target phase or the
        bubbling phase. Those phases are coupled during registration because
        bubbling applies only to the ancestors of the target node.

        If you no longer need an event listener, remove it by calling
        `removeEventListener()`, or memory problems could result. Event
        listeners are not automatically removed from memory because the garbage
        collector does not remove the listener as long as the dispatching object
        exists(unless the `useWeakReference` parameter is set to
        `true`).

        Copying an EventDispatcher instance does not copy the event listeners
        attached to it.(If your newly created node needs an event listener, you
        must attach the listener after creating the node.) However, if you move an
        EventDispatcher instance, the event listeners attached to it move along
        with it.

        If the event listener is being registered on a node while an event is
        being processed on this node, the event listener is not triggered during
        the current phase but can be triggered during a later phase in the event
        flow, such as the bubbling phase.

        If an event listener is removed from a node while an event is being
        processed on the node, it is still triggered by the current actions. After
        it is removed, the event listener is never invoked again(unless
        registered again for future processing).

        @param type             The type of event.
        @param useCapture       Determines whether the listener works in the
                                capture phase or the target and bubbling phases.
                                If `useCapture` is set to
                                `true`, the listener processes the
                                event only during the capture phase and not in the
                                target or bubbling phase. If
                                `useCapture` is `false`, the
                                listener processes the event only during the
                                target or bubbling phase. To listen for the event
                                in all three phases, call
                                `addEventListener` twice, once with
                                `useCapture` set to `true`,
                                then again with `useCapture` set to
                                `false`.
        @param priority         The priority level of the event listener. The
                                priority is designated by a signed 32-bit integer.
                                The higher the number, the higher the priority.
                                All listeners with priority _n_ are processed
                                before listeners of priority _n_-1. If two or
                                more listeners share the same priority, they are
                                processed in the order in which they were added.
                                The default priority is 0.
        @param useWeakReference Determines whether the reference to the listener
                                is strong or weak. A strong reference(the
                                default) prevents your listener from being
                                garbage-collected. A weak reference does not.

                                Class-level member functions are not subject to
                                garbage collection, so you can set
                                `useWeakReference` to `true`
                                for class-level member functions without
                                subjecting them to garbage collection. If you set
                                `useWeakReference` to `true`
                                for a listener that is a nested inner function,
                                the will be garbage-collected and no
                                longer persistent. If you create references to the
                                inner function(save it in another variable) then
                                it is not garbage-collected and stays
                                persistent.
        @throws ArgumentError The `listener` specified is not a
                              function.
    **/
    addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false) {
        if (listener == null)
            return;
        if (this.__eventMap == null) {
            this.__eventMap = new Map();
            this.__iterators = new Map();
        }
        if (!this.__eventMap.has(type)) {
            var list = new Array();
            list.push(new Listener(listener, useCapture, priority));
            var iterator = new DispatchIterator(list);
            this.__eventMap.set(type, list);
            this.__iterators.set(type, [iterator]);
        }
        else {
            var list = this.__eventMap.get(type);
            for (let item of list) {
                if (item.match(listener, useCapture))
                    return;
            }
        }
        var iterators = this.__iterators.get(type);
        for (let iterator of iterators) {
            if (iterator.active) {
                iterator.copy();
            }
        }
        this.__addListenerByPriority(list, new Listener(listener, useCapture, priority));
    }
    /**
        Dispatches an event into the event flow. The event target is the
        EventDispatcher object upon which the `dispatchEvent()` method
        is called.

        @param event The Event object that is dispatched into the event flow. If
                     the event is being redispatched, a clone of the event is
                     created automatically. After an event is dispatched, its
                     `target` property cannot be changed, so you must
                     create a new copy of the event for redispatching to work.
        @return A value of `true` if the event was successfully
                dispatched. A value of `false` indicates failure or
                that `preventDefault()` was called on the event.
        @throws Error The event dispatch recursion limit has been reached.
    **/
    dispatchEvent(event) {
        if (this.__targetDispatcher != null) {
            event.__target = this.__targetDispatcher;
        }
        else {
            event.__target = this;
        }
        return this.__dispatchEvent(event);
    }
    /**
        Checks whether the EventDispatcher object has any listeners registered for
        a specific type of event. This allows you to determine where an
        EventDispatcher object has altered handling of an event type in the event
        flow hierarchy. To determine whether a specific event type actually
        triggers an event listener, use `willTrigger()`.

        The difference between `hasEventListener()` and
        `willTrigger()` is that `hasEventListener()`
        examines only the object to which it belongs, whereas
        `willTrigger()` examines the entire event flow for the event
        specified by the `type` parameter.

        When `hasEventListener()` is called from a LoaderInfo
        object, only the listeners that the caller can access are considered.

        @param type The type of event.
        @return A value of `true` if a listener of the specified type
                is registered; `false` otherwise.
    **/
    hasEventListener(type) {
        if (this.__eventMap == null)
            return false;
        return this.__eventMap.has(type);
    }
    /**
        Removes a listener from the EventDispatcher object. If there is no
        matching listener registered with the EventDispatcher object, a call to
        this method has no effect.

        @param type       The type of event.
        @param useCapture Specifies whether the listener was registered for the
                          capture phase or the target and bubbling phases. If the
                          listener was registered for both the capture phase and
                          the target and bubbling phases, two calls to
                          `removeEventListener()` are required to
                          remove both, one call with `useCapture()` set
                          to `true`, and another call with
                          `useCapture()` set to `false`.
    **/
    removeEventListener(type, listener, useCapture = false) {
        if (this.__eventMap == null || listener == null)
            return;
        var list = this.__eventMap.get(type);
        if (list == null)
            return;
        var iterators = this.__iterators.get(type);
        for (let i = 0; i < list.length; i++) {
            if (list[i].match(listener, useCapture)) {
                for (let iterator of iterators) {
                    iterator.remove(list[i], i);
                }
                list.splice(i, 1);
                break;
            }
        }
        if (list.length == 0) {
            this.__eventMap.delete(type);
            this.__iterators.delete(type);
        }
        if (this.__eventMap.size == 0) {
            this.__eventMap = null;
            this.__iterators = null;
        }
    }
    toString() {
        return "[object " + this.constructor.name + "]";
    }
    /**
        Checks whether an event listener is registered with this EventDispatcher
        object or any of its ancestors for the specified event type. This method
        returns `true` if an event listener is triggered during any
        phase of the event flow when an event of the specified type is dispatched
        to this EventDispatcher object or any of its descendants.

        The difference between the `hasEventListener()` and the
        `willTrigger()` methods is that `hasEventListener()`
        examines only the object to which it belongs, whereas the
        `willTrigger()` method examines the entire event flow for the
        event specified by the `type` parameter.

        When `willTrigger()` is called from a LoaderInfo object,
        only the listeners that the caller can access are considered.

        @param type The type of event.
        @return A value of `true` if a listener of the specified type
                will be triggered; `false` otherwise.
    **/
    willTrigger(type) {
        return this.hasEventListener(type);
    }
    __dispatchEvent(event) {
        if (this.__eventMap == null || event == null)
            return true;
        var type = event.type;
        var list = this.__eventMap.get(type);
        if (list == null)
            return true;
        if (event.__target == null) {
            if (this.__targetDispatcher != null) {
                event.__target = this.__targetDispatcher;
            }
            else {
                event.__target = this;
            }
        }
        event.__currentTarget = this;
        var capture = (event.eventPhase == EventPhase$1.CAPTURING_PHASE);
        var iterators = this.__iterators.get(type);
        var iterator = iterators[0];
        if (iterator.active) {
            iterator = new DispatchIterator(list);
            iterators.push(iterator);
        }
        iterator.start();
        for (let listener of iterator) {
            if (listener == null)
                continue;
            if (listener.useCapture == capture) {
                // listener.callback (event.clone ());
                listener.callback(event);
                if (event.__isCanceledNow) {
                    break;
                }
            }
        }
        iterator.stop();
        if (iterator != iterators[0]) {
            let i = iterators.indexOf(iterator);
            if (i > -1)
                iterators.splice(i, 1);
        }
        else {
            iterator.reset(list);
        }
        return !event.isDefaultPrevented();
    }
    /** @hidden */
    __removeAllListeners() {
        this.__eventMap = null;
        this.__iterators = null;
    }
    /** @hidden */
    __addListenerByPriority(list, listener) {
        var numElements = list.length;
        var addAtPosition = numElements;
        for (let i = 0; i < numElements; i++) {
            if (list[i].priority < listener.priority) {
                addAtPosition = i;
                break;
            }
        }
        list.splice(addAtPosition, 0, listener);
    }
}
class DispatchIterator {
    constructor(list) {
        this.active = false;
        this.reset(list);
    }
    copy() {
        if (!this.isCopy) {
            this.list = this.list.slice();
            this.isCopy = true;
        }
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        return { value: this.list[this.index++], done: this.index < this.list.length };
    }
    remove(listener, listIndex) {
        if (this.active) {
            if (!this.isCopy) {
                if (listIndex < this.index) {
                    this.index--;
                }
            }
            else {
                for (let i = this.index; i < this.list.length; i++) {
                    if (this.list[i] == listener) {
                        this.list.splice(i, 1);
                        break;
                    }
                }
            }
        }
    }
    reset(list) {
        this.list = list;
        this.isCopy = false;
        this.index = 0;
    }
    start() {
        this.active = true;
    }
    stop() {
        this.active = false;
    }
}
class Listener {
    constructor(callback, useCapture, priority) {
        this.callback = callback;
        this.useCapture = useCapture;
        this.priority = priority;
    }
    match(callback, useCapture) {
        return (this.callback === callback && this.useCapture == useCapture);
    }
}

/**
    A MouseEvent object is dispatched into the event flow whenever mouse events
    occur. A mouse event is usually generated by a user input device, such as a
    mouse or a trackball, that uses a pointer.

    When nested nodes are involved, mouse events target the deepest possible
    nested node that is visible in the display list. This node is called the
    _target node_. To have a target node's ancestor receive notification
    of a mouse event, use `EventDispatcher.addEventListener()` on
    the ancestor node with the `type` parameter set to the specific
    mouse event you want to detect.
**/
let MouseEvent = /** @class */ (() => {
    class MouseEvent extends Event {
        /**
            Creates an Event object that contains information about mouse events.
            Event objects are passed as parameters to event listeners.
    
            @param type          The type of the event. Possible values are:
                                 `MouseEvent.CLICK`,
                                 `MouseEvent.DOUBLE_CLICK`,
                                 `MouseEvent.MOUSE_DOWN`,
                                 `MouseEvent.MOUSE_MOVE`,
                                 `MouseEvent.MOUSE_OUT`,
                                 `MouseEvent.MOUSE_OVER`,
                                 `MouseEvent.MOUSE_UP`,
                                 `MouseEvent.MIDDLE_CLICK`,
                                 `MouseEvent.MIDDLE_MOUSE_DOWN`,
                                 `MouseEvent.MIDDLE_MOUSE_UP`,
                                 `MouseEvent.RIGHT_CLICK`,
                                 `MouseEvent.RIGHT_MOUSE_DOWN`,
                                 `MouseEvent.RIGHT_MOUSE_UP`,
                                 `MouseEvent.MOUSE_WHEEL`,
                                 `MouseEvent.ROLL_OUT`, and
                                 `MouseEvent.ROLL_OVER`.
            @param bubbles       Determines whether the Event object participates in
                                 the bubbling phase of the event flow.
            @param cancelable    Determines whether the Event object can be canceled.
            @param localX        The horizontal coordinate at which the event occurred
                                 relative to the containing sprite.
            @param localY        The vertical coordinate at which the event occurred
                                 relative to the containing sprite.
            @param relatedObject The complementary InteractiveObject instance that is
                                 affected by the event. For example, when a
                                 `mouseOut` event occurs,
                                 `relatedObject` represents the display
                                 list object to which the pointing device now points.
            @param ctrlKey       On Windows or Linux, indicates whether the Ctrl key
                                 is activated. On Mac, indicates whether either the
                                 Ctrl key or the Command key is activated.
            @param altKey        Indicates whether the Alt key is activated(Windows
                                 or Linux only).
            @param shiftKey      Indicates whether the Shift key is activated.
            @param buttonDown    Indicates whether the primary mouse button is
                                 pressed.
            @param delta         Indicates how many lines should be scrolled for each
                                 unit the user rotates the mouse wheel. A positive
                                 delta value indicates an upward scroll; a negative
                                 value indicates a downward scroll. Typical values are
                                 1 to 3, but faster rotation may produce larger
                                 values. This parameter is used only for the
                                 `MouseEvent.mouseWheel` event.
        **/
        constructor(type, bubbles = true, cancelable = false, localX = 0, localY = 0, relatedObject = null, ctrlKey = false, altKey = false, shiftKey = false, buttonDown = false, delta = 0, commandKey = false, clickCount = 0) {
            super(type, bubbles, cancelable);
            this.shiftKey = shiftKey;
            this.altKey = altKey;
            this.ctrlKey = ctrlKey;
            this.relatedObject = relatedObject;
            this.delta = delta;
            this.localX = localX;
            this.localY = localY;
            this.buttonDown = buttonDown;
            this.commandKey = commandKey;
            this.clickCount = clickCount;
            this.isRelatedObjectInaccessible = false;
            this.stageX = NaN;
            this.stageY = NaN;
        }
        clone() {
            var event = new MouseEvent(this.__type, this.__bubbles, this.__cancelable, this.localX, this.localY, this.relatedObject, this.ctrlKey, this.altKey, this.shiftKey, this.buttonDown, this.delta, this.commandKey, this.clickCount);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("MouseEvent", "type", "bubbles", "cancelable", "localX", "localY", "relatedObject", "ctrlKey", "altKey", "shiftKey", "buttonDown", "delta");
        }
        /**
            Instructs Flash Player or Adobe AIR to render after processing of this
            event completes, if the display list has been modified.
    
        **/
        updateAfterEvent() { }
        static __create(type, button, stageX, stageY, local, target, delta = 0) {
            var event = new MouseEvent(type, true, false, local.x, local.y, null, MouseEvent.__ctrlKey, MouseEvent.__altKey, MouseEvent.__shiftKey, MouseEvent.__buttonDown, delta, MouseEvent.__commandKey);
            event.stageX = stageX;
            event.stageY = stageY;
            event.__target = target;
            return event;
        }
        __init() {
            super.__init();
            this.shiftKey = false;
            this.altKey = false;
            this.ctrlKey = false;
            this.__bubbles = false;
            this.relatedObject = null;
            this.delta = 0;
            this.localX = 0;
            this.localY = 0;
            this.buttonDown = false;
            this.commandKey = false;
            this.clickCount = 0;
            this.isRelatedObjectInaccessible = false;
            this.stageX = NaN;
            this.stageY = NaN;
        }
    }
    /**
        Defines the value of the `type` property of a `click` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | For click events, this value is always `false`. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.CLICK = "click";
    /**
        The `MouseEvent.CONTEXT_MENU` constant defines the value of the `type`
        property of a `contextMenu` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the right mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    // /** @hidden */ @:dox(hide) @:require(flash11_2) public static CONTEXT_MENU:String;
    /**
        Defines the value of the `type` property of a `doubleClick` event
        object. The `doubleClickEnabled` property must be `true` for an object
        to generate the `doubleClick` event.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | For double-click events, this value is always `false`. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.DOUBLE_CLICK = "doubleClick";
    /**
        Defines the value of the `type` property of a `middleClick` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | For middle-click events, this property is always `false`. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MIDDLE_CLICK = "middleClick";
    /**
        Defines the value of the `type` property of a `middleMouseDown` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the middle mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
    /**
        Defines the value of the `type` property of a `middleMouseUp` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the middle mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
    /**
        Defines the value of the `type` property of a `mouseDown` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows and Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MOUSE_DOWN = "mouseDown";
    /**
        Defines the value of the `type` property of a `mouseMove` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MOUSE_MOVE = "mouseMove";
    /**
        Defines the value of the `type` property of a `mouseOut` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `relatedObject` | The display list object to which the pointing device now points. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MOUSE_OUT = "mouseOut";
    /**
        Defines the value of the `type` property of a `mouseOver` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `relatedObject` | The display list object to which the pointing device was pointing. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MOUSE_OVER = "mouseOver";
    /**
        Defines the value of the `type` property of a `mouseUp` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MOUSE_UP = "mouseUp";
    /**
        Defines the value of the `type` property of a `mouseWheel` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `delta` | The number of lines that that each notch on the mouse wheel represents. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.MOUSE_WHEEL = "mouseWheel";
    /**
        Defines the value of the `type` property of a
        `releaseOutside` event object.

        This event has the following properties:
    **/
    MouseEvent.RELEASE_OUTSIDE = "releaseOutside";
    /**
        Defines the value of the `type` property of a `rightClick` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | For right-click events, this property is always `false`. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.RIGHT_CLICK = "rightClick";
    /**
        Defines the value of the `type` property of a `rightMouseDown` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | For right-click events, this property is always `true`. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
    /**
        Defines the value of the `type` property of a `rightMouseUp` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `true` |
        | `buttonDown` | `true` if the right mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; the default behavior cannot be canceled. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `clickCount` | Count of the number of mouse clicks to indicate whether the event is part of a multi-click sequence. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
    /**
        Defines the value of the `type` property of a `rollOut` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `false` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `relatedObject` | The display list object to which the pointing device now points. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.ROLL_OUT = "rollOut";
    /**
        Defines the value of the `type` property of a `rollOver` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows). |
        | `bubbles` | `false` |
        | `buttonDown` | `true` if the primary mouse button is pressed; `false` otherwise. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `relatedObject` | The display list object to which the pointing device was pointing. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the pointing device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    MouseEvent.ROLL_OVER = "rollOver";
    MouseEvent.__pool = new ObjectPool(() => new MouseEvent(null), (event) => event.__init());
    return MouseEvent;
})();

/**
    **BETA**

    RenderEvent is dispatched (optionally) once a listener is added to a
    DisplayObject. When the internal Stage renderer is ready to draw the specified
    object, a RenderEvent will be dispatched.

    Caching a RenderEvent to access at a later time will not work properly. Also,
    since the RenderEvent is more of an internal API, there may be additional
    concerns to order to ensure that all objects and features work as-intended.

    The type of RenderEvent dispatched will match the type of rendering being used.
    This renderer type will match the default Stage render, but also can depend on
    whether an off-screen render (such as DisplayObject `cacheAsBitmap` or BitmapData
    `draw`) is being used.
**/
let RenderEvent = /** @class */ (() => {
    class RenderEvent extends Event {
        /**
            Creates an Event object that contains information about render events.
            Event objects are passed as parameters to event listeners.
    
            @param type        The type of the event. Possible values
                               are: `RenderEvent.CLEAR_DOM`,
                               `RenderEvent.RENDER_CAIRO`,
                               `RenderEvent.RENDER_CANVAS`,
                               `RenderEvent.RENDER_DOM`, and
                               `RenderEvent.RENDER_OPENGL`.
            @param bubbles     Determines whether the Event object participates in the
                               bubbling stage of the event flow.
            @param cancelable  Determines whether the Event object can be canceled.
            @param objectMatrix Sets the concatenated matrix for the display object being rendered.
            @param objectTransform  Sets the concatenated color transform for the display object being
            rendered.
            @param	allowSmoothing	Determines whether the current render should allow smoothing.
        **/
        constructor(type, bubbles = false, cancelable = false, objectMatrix = null, objectColorTransform = null, allowSmoothing = true) {
            super(type, bubbles, cancelable);
            this.objectMatrix = objectMatrix;
            this.objectColorTransform = objectColorTransform;
            this.allowSmoothing = allowSmoothing;
        }
        clone() {
            var event = new RenderEvent(this.__type, this.__bubbles, this.__cancelable, this.objectMatrix.clone(), this.objectColorTransform.__clone(), this.allowSmoothing);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("RenderEvent", "type", "bubbles", "cancelable");
        }
        __init() {
            super.__init();
            this.objectMatrix = null;
            this.objectColorTransform = null;
            this.allowSmoothing = false;
            this.__renderer = null;
        }
        // Get & Set Methods
        /**
            The display object renderer being used for this render.
        **/
        get renderer() {
            return this.__renderer;
        }
    }
    /**
        The `RenderEvent.CLEAR_DOM` constant defines the value of the `type` property
        of an `renderEvent` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true` |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `renderer` | A reference to the active display object renderer. |
        | `target` | The display object that is going to be rendered. |
    **/
    RenderEvent.CLEAR_DOM = "clearDOM";
    /**
        The `RenderEvent.RENDER_CAIRO` constant defines the value of the `type` property
        of an `renderEvent` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true` |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `renderer` | A reference to the active display object renderer. |
        | `target` | The display object that is going to be rendered. |
    **/
    RenderEvent.RENDER_CAIRO = "renderCairo";
    /**
        The `RenderEvent.RENDER_CANVAS` constant defines the value of the `type` property
        of an `renderEvent` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true` |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `renderer` | A reference to the active display object renderer. |
        | `target` | The display object that is going to be rendered. |
    **/
    RenderEvent.RENDER_CANVAS = "renderCanvas";
    /**
        The `RenderEvent.RENDER_DOM` constant defines the value of the `type` property
        of an `renderEvent` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true` |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `renderer` | A reference to the active display object renderer. |
        | `target` | The display object that is going to be rendered. |
    **/
    RenderEvent.RENDER_DOM = "renderDOM";
    /**
        The `RenderEvent.RENDER_OPENGL` constant defines the value of the `type` property
        of an `renderEvent` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true` |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `renderer` | A reference to the active display object renderer. |
        | `target` | The display object that is going to be rendered. |
    **/
    RenderEvent.RENDER_OPENGL = "renderOpenGL";
    RenderEvent.__pool = new ObjectPool(() => new RenderEvent(null), (event) => event.__init());
    return RenderEvent;
})();

/**
    The TouchEvent class lets you handle events on devices that detect user
    contact with the device(such as a finger on a touch screen). When a user
    interacts with a device such as a mobile phone or tablet with a touch
    screen, the user typically touches the screen with his or her fingers or a
    pointing device. You can develop applications that respond to basic touch
    events(such as a single finger tap) with the TouchEvent class. Create
    event listeners using the event types defined in this class. For user
    interaction with multiple points of contact(such as several fingers moving
    across a touch screen at the same time) use the related GestureEvent,
    PressAndTapGestureEvent, and TransformGestureEvent classes. And, use the
    properties and methods of these classes to construct event handlers that
    respond to the user touching the device.

    Use the Multitouch class to determine the current environment's support
    for touch interaction, and to manage the support of touch interaction if
    the current environment supports it.

    **Note:** When objects are nested on the display list, touch events
    target the deepest possible nested object that is visible in the display
    list. This object is called the target node. To have a target node's
    ancestor(an object containing the target node in the display list) receive
    notification of a touch event, use
    `EventDispatcher.addEventListener()` on the ancestor node with
    the type parameter set to the specific touch event you want to detect.
**/
let TouchEvent = /** @class */ (() => {
    class TouchEvent extends Event {
        /**
            Creates an Event object that contains information about touch events.
            Event objects are passed as parameters to event listeners.
    
            @param type                The type of the event. Possible values are:
                                       `TouchEvent.TOUCH_BEGIN`,
                                       `TouchEvent.TOUCH_END`,
                                       `TouchEvent.TOUCH_MOVE`,
                                       `TouchEvent.TOUCH_OUT`,
                                       `TouchEvent.TOUCH_OVER`,
                                       `TouchEvent.TOUCH_ROLL_OUT`,
                                       `TouchEvent.TOUCH_ROLL_OVER`, and
                                       `TouchEvent.TOUCH_TAP`.
            @param bubbles             Determines whether the Event object
                                       participates in the bubbling phase of the event
                                       flow.
            @param cancelable          Determines whether the Event object can be
                                       canceled.
            @param touchPointID        A unique identification number(as an int)
                                       assigned to the touch point.
            @param isPrimaryTouchPoint Indicates whether the first point of contact is
                                       mapped to mouse events.
            @param relatedObject       The complementary InteractiveObject instance
                                       that is affected by the event. For example,
                                       when a `touchOut` event occurs,
                                       `relatedObject` represents the
                                       display list object to which the pointing
                                       device now points.
            @param ctrlKey             On Windows or Linux, indicates whether the Ctrl
                                       key is activated. On Mac, indicates whether
                                       either the Ctrl key or the Command key is
                                       activated.
            @param altKey              Indicates whether the Alt key is activated
                                      (Windows or Linux only).
            @param shiftKey            Indicates whether the Shift key is activated.
        **/
        constructor(type, bubbles = true, cancelable = false, touchPointID = 0, isPrimaryTouchPoint = false, localX = 0, localY = 0, sizeX = 0, sizeY = 0, pressure = 0, relatedObject = null, ctrlKey = false, altKey = false, shiftKey = false, commandKey = false, controlKey = false, timestamp = 0, touchIntent = null, samples = null, isTouchPointCanceled = false) {
            super(type, bubbles, cancelable);
            this.touchPointID = touchPointID;
            this.isPrimaryTouchPoint = isPrimaryTouchPoint;
            this.localX = localX;
            this.localY = localY;
            this.sizeX = sizeX;
            this.sizeY = sizeY;
            this.pressure = pressure;
            this.relatedObject = relatedObject;
            this.ctrlKey = ctrlKey;
            this.altKey = altKey;
            this.shiftKey = shiftKey;
            this.commandKey = commandKey;
            this.controlKey = controlKey;
            this.stageX = NaN;
            this.stageY = NaN;
        }
        clone() {
            var event = new TouchEvent(this.__type, this.__bubbles, this.__cancelable, this.touchPointID, this.isPrimaryTouchPoint, this.localX, this.localY, this.sizeX, this.sizeY, this.pressure, this.relatedObject, this.ctrlKey, this.altKey, this.shiftKey, this.commandKey, this.controlKey);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("TouchEvent", "type", "bubbles", "cancelable", "touchPointID", "isPrimaryTouchPoint", "localX", "localY", "sizeX", "sizeY", "pressure", "relatedObject", "ctrlKey", "altKey", "shiftKey", "commandKey", "controlKey");
        }
        /**
            Instructs Flash Player or Adobe AIR to render after processing of this
            event completes, if the display list has been modified.
    
        **/
        updateAfterEvent() { }
        static __create(type, /*event:lime.ui.TouchEvent,*/ touch /*js.html.Touch*/, stageX, stageY, local, target) {
            var evt = new TouchEvent(type, true, false, 0, true, local.x, local.y, 1, 1, 1);
            evt.stageX = stageX;
            evt.stageY = stageY;
            evt.__target = target;
            return evt;
        }
        __init() {
            super.__init();
            this.touchPointID = 0;
            this.isPrimaryTouchPoint = false;
            this.localX = 0;
            this.localY = 0;
            this.sizeX = 0;
            this.sizeY = 0;
            this.pressure = 0;
            this.relatedObject = null;
            this.ctrlKey = false;
            this.altKey = false;
            this.shiftKey = false;
            this.commandKey = false;
            this.controlKey = false;
            this.stageX = NaN;
            this.stageY = NaN;
        }
    }
    // /** @hidden */ @:dox(hide) public static PROXIMITY_BEGIN:String;
    // /** @hidden */ @:dox(hide) public static PROXIMITY_END:String;
    // /** @hidden */ @:dox(hide) public static PROXIMITY_MOVE:String;
    // /** @hidden */ @:dox(hide) public static PROXIMITY_OUT:String;
    // /** @hidden */ @:dox(hide) public static PROXIMITY_OVER:String;
    // /** @hidden */ @:dox(hide) public static PROXIMITY_ROLL_OUT:String;
    // /** @hidden */ @:dox(hide) public static PROXIMITY_ROLL_OVER:String;
    /**
        Defines the value of the `type` property of a `TOUCH_BEGIN` touch
        event object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_BEGIN = "touchBegin";
    /**
        Defines the value of the `type` property of a `TOUCH_END` touch event
        object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_END = "touchEnd";
    /**
        Defines the value of the `type` property of a `TOUCH_MOVE` touch event
        object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_MOVE = "touchMove";
    /**
        Defines the value of the `type` property of a `TOUCH_OUT` touch event
        object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_OUT = "touchOut";
    /**
        Defines the value of the `type` property of a `TOUCH_OVER` touch event
        object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_OVER = "touchOver";
    /**
        Defines the value of the `type` property of a `TOUCH_ROLL_OUT` touch
        event object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_ROLL_OUT = "touchRollOut";
    /**
        Defines the value of the `type` property of a `TOUCH_ROLL_OVER` touch
        event object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_ROLL_OVER = "touchRollOver";
    /**
        Defines the value of the `type` property of a `TOUCH_TAP` touch event
        object.
        The dispatched TouchEvent object has the following properties:

        | Property | Value |
        | --- | --- |
        | `altKey` | `true` if the Alt key is active (Windows or Linux). |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `commandKey` | `true` on the Mac if the Command key is active; `false` if it is inactive. Always `false` on Windows. |
        | `controlKey` | `true` if the Ctrl or Control key is active; `false` if it is inactive. |
        | `ctrlKey` | `true` on Windows or Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `eventPhase` | The current phase in the event flow. |
        | `isRelatedObjectInaccessible` | `true` if the relatedObject property is set to `null` because of security sandbox rules. |
        | `localX` | The horizontal coordinate at which the event occurred relative to the containing sprite. |
        | `localY` | The vertical coordinate at which the event occurred relative to the containing sprite. |
        | `pressure` | A value between `0.0` and `1.0` indicating force of the contact with the device. If the device does not support detecting the pressure, the value is `1.0`. |
        | `relatedObject` | A reference to a display list object related to the event. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `sizeX` | Width of the contact area. |
        | `sizeY` | Height of the contact area. |
        | `stageX` | The horizontal coordinate at which the event occurred in global stage coordinates. |
        | `stageY` | The vertical coordinate at which the event occurred in global stage coordinates. |
        | `target` | The InteractiveObject instance under the touching device. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `touchPointID` | A unique identification number (as an int) assigned to the touch point. |
    **/
    TouchEvent.TOUCH_TAP = "touchTap";
    TouchEvent.__pool = new ObjectPool(() => new TouchEvent(null), (event) => event.__init());
    return TouchEvent;
})();

/**
    The ColorTransform class lets you adjust the color values in a display
    object. The color adjustment or _color transformation_ can be applied
    to all four channels: red, green, blue, and alpha transparency.

    When a ColorTransform object is applied to a display object, a new value
    for each color channel is calculated like this:


    * New red value = (old red value * `redMultiplier`) +
    `redOffset`
    * New green value = (old green value * `greenMultiplier`) +
    `greenOffset`
    * New blue value = (old blue value * `blueMultiplier`) +
    `blueOffset`
    * New alpha value = (old alpha value * `alphaMultiplier`) +
    `alphaOffset`


    If any of the color channel values is greater than 255 after the
    calculation, it is set to 255. If it is less than 0, it is set to 0.

    You can use ColorTransform objects in the following ways:


    * In the `colorTransform` parameter of the
    `colorTransform()` method of the BitmapData class
    * As the `colorTransform` property of a Transform object
    (which can be used as the `transform` property of a display
    object)


    You must use the `new ColorTransform()` constructor to create
    a ColorTransform object before you can call the methods of the
    ColorTransform object.

    Color transformations do not apply to the background color of a movie
    clip(such as a loaded SWF object). They apply only to graphics and symbols
    that are attached to the movie clip.
**/
let ColorTransform = /** @class */ (() => {
    class ColorTransform {
        /**
            Creates a ColorTransform object for a display object with the specified
            color channel values and alpha values.
    
            @param redMultiplier   The value for the red multiplier, in the range from
                                   0 to 1.
            @param greenMultiplier The value for the green multiplier, in the range
                                   from 0 to 1.
            @param blueMultiplier  The value for the blue multiplier, in the range
                                   from 0 to 1.
            @param alphaMultiplier The value for the alpha transparency multiplier, in
                                   the range from 0 to 1.
            @param redOffset       The offset value for the red color channel, in the
                                   range from -255 to 255.
            @param greenOffset     The offset value for the green color channel, in
                                   the range from -255 to 255.
            @param blueOffset      The offset for the blue color channel value, in the
                                   range from -255 to 255.
            @param alphaOffset     The offset for alpha transparency channel value, in
                                   the range from -255 to 255.
        **/
        constructor(redMultiplier = 1, greenMultiplier = 1, blueMultiplier = 1, alphaMultiplier = 1, redOffset = 0, greenOffset = 0, blueOffset = 0, alphaOffset = 0) {
            this.redMultiplier = redMultiplier;
            this.greenMultiplier = greenMultiplier;
            this.blueMultiplier = blueMultiplier;
            this.alphaMultiplier = alphaMultiplier;
            this.redOffset = redOffset;
            this.greenOffset = greenOffset;
            this.blueOffset = blueOffset;
            this.alphaOffset = alphaOffset;
        }
        /**
            Concatenates the ColorTranform object specified by the `second`
            parameter with the current ColorTransform object and sets the current
            object as the result, which is an additive combination of the two color
            transformations. When you apply the concatenated ColorTransform object,
            the effect is the same as applying the `second` color
            transformation after the _original_ color transformation.
    
            @param second The ColorTransform object to be combined with the current
                          ColorTransform object.
        **/
        concat(second) {
            this.redOffset = second.redOffset * this.redMultiplier + this.redOffset;
            this.greenOffset = second.greenOffset * this.greenMultiplier + this.greenOffset;
            this.blueOffset = second.blueOffset * this.blueMultiplier + this.blueOffset;
            this.alphaOffset = second.alphaOffset * this.alphaMultiplier + this.alphaOffset;
            this.redMultiplier *= second.redMultiplier;
            this.greenMultiplier *= second.greenMultiplier;
            this.blueMultiplier *= second.blueMultiplier;
            this.alphaMultiplier *= second.alphaMultiplier;
        }
        /**
            Formats and returns a string that describes all of the properties of
            the ColorTransform object.
    
            @return A string that lists all of the properties of the
                    ColorTransform object.
        **/
        toString() {
            return `(redMultiplier=${this.redMultiplier}, greenMultiplier=${this.greenMultiplier}, blueMultiplier=${this.blueMultiplier}, alphaMultiplier=${this.alphaMultiplier}, redOffset=${this.redOffset}, greenOffset=${this.greenOffset}, blueOffset=${this.blueOffset}, alphaOffset=${this.alphaOffset})`;
        }
        __clone() {
            return new ColorTransform(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
        }
        __copyFrom(ct) {
            this.redMultiplier = ct.redMultiplier;
            this.greenMultiplier = ct.greenMultiplier;
            this.blueMultiplier = ct.blueMultiplier;
            this.alphaMultiplier = ct.alphaMultiplier;
            this.redOffset = ct.redOffset;
            this.greenOffset = ct.greenOffset;
            this.blueOffset = ct.blueOffset;
            this.alphaOffset = ct.alphaOffset;
        }
        __combine(ct) {
            this.redMultiplier *= ct.redMultiplier;
            this.greenMultiplier *= ct.greenMultiplier;
            this.blueMultiplier *= ct.blueMultiplier;
            this.alphaMultiplier *= ct.alphaMultiplier;
            this.redOffset += ct.redOffset;
            this.greenOffset += ct.greenOffset;
            this.blueOffset += ct.blueOffset;
            this.alphaOffset += ct.alphaOffset;
        }
        __identity() {
            this.redMultiplier = 1;
            this.greenMultiplier = 1;
            this.blueMultiplier = 1;
            this.alphaMultiplier = 1;
            this.redOffset = 0;
            this.greenOffset = 0;
            this.blueOffset = 0;
            this.alphaOffset = 0;
        }
        __invert() {
            this.redMultiplier = this.redMultiplier != 0 ? 1 / this.redMultiplier : 1;
            this.greenMultiplier = this.greenMultiplier != 0 ? 1 / this.greenMultiplier : 1;
            this.blueMultiplier = this.blueMultiplier != 0 ? 1 / this.blueMultiplier : 1;
            this.alphaMultiplier = this.alphaMultiplier != 0 ? 1 / this.alphaMultiplier : 1;
            this.redOffset = -this.redOffset;
            this.greenOffset = -this.greenOffset;
            this.blueOffset = -this.blueOffset;
            this.alphaOffset = -this.alphaOffset;
        }
        __equals(ct, ignoreAlphaMultiplier) {
            return (ct != null
                && this.redMultiplier == ct.redMultiplier
                && this.greenMultiplier == ct.greenMultiplier
                && this.blueMultiplier == ct.blueMultiplier
                && (ignoreAlphaMultiplier || this.alphaMultiplier == ct.alphaMultiplier)
                && this.redOffset == ct.redOffset
                && this.greenOffset == ct.greenOffset
                && this.blueOffset == ct.blueOffset
                && this.alphaOffset == ct.alphaOffset);
        }
        __isDefault(ignoreAlphaMultiplier) {
            if (ignoreAlphaMultiplier) {
                return (this.redMultiplier == 1
                    && this.greenMultiplier == 1
                    && this.blueMultiplier == 1
                    && /*alphaMultiplier == 1 &&*/ this.redOffset == 0
                    && this.greenOffset == 0
                    && this.blueOffset == 0
                    && this.alphaOffset == 0);
            }
            else {
                return (this.redMultiplier == 1 && this.greenMultiplier == 1 && this.blueMultiplier == 1 && this.alphaMultiplier == 1 && this.redOffset == 0 && this.greenOffset == 0
                    && this.blueOffset == 0 && this.alphaOffset == 0);
            }
        }
        __setArrays(colorMultipliers, colorOffsets) {
            colorMultipliers[0] = this.redMultiplier;
            colorMultipliers[1] = this.greenMultiplier;
            colorMultipliers[2] = this.blueMultiplier;
            colorMultipliers[3] = this.alphaMultiplier;
            colorOffsets[0] = this.redOffset;
            colorOffsets[1] = this.greenOffset;
            colorOffsets[2] = this.blueOffset;
            colorOffsets[3] = this.alphaOffset;
        }
        __toLimeColorMatrix() {
            if (ColorTransform.__limeColorMatrix == null) {
                ColorTransform.__limeColorMatrix = new Float32Array(20);
            }
            ColorTransform.__limeColorMatrix[0] = this.redMultiplier;
            ColorTransform.__limeColorMatrix[4] = this.redOffset / 255;
            ColorTransform.__limeColorMatrix[6] = this.greenMultiplier;
            ColorTransform.__limeColorMatrix[9] = this.greenOffset / 255;
            ColorTransform.__limeColorMatrix[12] = this.blueMultiplier;
            ColorTransform.__limeColorMatrix[14] = this.blueOffset / 255;
            ColorTransform.__limeColorMatrix[18] = this.alphaMultiplier;
            ColorTransform.__limeColorMatrix[19] = this.alphaOffset / 255;
            return ColorTransform.__limeColorMatrix;
        }
        // Getters & Setters
        /**
            The RGB color value for a ColorTransform object.
    
            When you set this property, it changes the three color offset values
            (`redOffset`, `greenOffset`, and
            `blueOffset`) accordingly, and it sets the three color
            multiplier values(`redMultiplier`,
            `greenMultiplier`, and `blueMultiplier`) to 0. The
            alpha transparency multiplier and offset values do not change.
    
            When you pass a value for this property, use the format
            0x_RRGGBB_. _RR_, _GG_, and _BB_ each consist of two
            hexadecimal digits that specify the offset of each color component. The 0x
            tells the ActionScript compiler that the number is a hexadecimal
            value.
        **/
        get color() {
            return ((Math.round(this.redOffset) << 16) | (Math.round(this.greenOffset) << 8) | Math.round(this.blueOffset));
        }
        set color(value) {
            this.redOffset = (value >> 16) & 0xFF;
            this.greenOffset = (value >> 8) & 0xFF;
            this.blueOffset = value & 0xFF;
            this.redMultiplier = 0;
            this.greenMultiplier = 0;
            this.blueMultiplier = 0;
        }
    }
    ColorTransform.__pool = new ObjectPool(() => new ColorTransform(), (ct) => ct.__identity());
    return ColorTransform;
})();

/**
    The Point object represents a location in a two-dimensional coordinate
    system, where _x_ represents the horizontal axis and _y_
    represents the vertical axis.

    The following code creates a point at(0,0):

    Methods and properties of the following classes use Point objects:


    * BitmapData
    * DisplayObject
    * DisplayObjectContainer
    * DisplacementMapFilter
    * NativeWindow
    * Matrix
    * Rectangle


    You can use the `new Point()` constructor to create a Point
    object.
**/
let Point = /** @class */ (() => {
    class Point {
        /**
            Creates a new point. If you pass no parameters to this method, a point is
            created at(0,0).
    
            @param x The horizontal coordinate.
            @param y The vertical coordinate.
        **/
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        /**
            Adds the coordinates of another point to the coordinates of this point to
            create a new point.
    
            @param v The point to be added.
            @return The new point.
        **/
        add(v) {
            return new Point(v.x + this.x, v.y + this.y);
        }
        /**
            Creates a copy of this Point object.
    
            @return The new Point object.
        **/
        clone() {
            return new Point(this.x, this.y);
        }
        /**
            Copies all of the point data from the source Point object into the calling Point
            object.
    
            @param	sourcePoint	The Point object from which to copy the data.
        **/
        copyFrom(sourcePoint) {
            this.x = sourcePoint.x;
            this.y = sourcePoint.y;
        }
        /**
            Returns the distance between `pt1` and `pt2`.
    
            @param pt1 The first point.
            @param pt2 The second point.
            @return The distance between the first and second points.
        **/
        static distance(pt1, pt2) {
            var dx = pt1.x - pt2.x;
            var dy = pt1.y - pt2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        /**
            Determines whether two points are equal. Two points are equal if they have
            the same _x_ and _y_ values.
    
            @param toCompare The point to be compared.
            @return A value of `true` if the object is equal to this Point
                    object; `false` if it is not equal.
        **/
        equals(toCompare) {
            return toCompare != null && toCompare.x == this.x && toCompare.y == this.y;
        }
        /**
            Determines a point between two specified points. The parameter
            `f` determines where the new interpolated point is located
            relative to the two end points specified by parameters `pt1`
            and `pt2`. The closer the value of the parameter `f`
            is to `1.0`, the closer the interpolated point is to the first
            point(parameter `pt1`). The closer the value of the parameter
            `f` is to 0, the closer the interpolated point is to the second
            point(parameter `pt2`).
    
            @param pt1 The first point.
            @param pt2 The second point.
            @param f   The level of interpolation between the two points. Indicates
                       where the new point will be, along the line between
                       `pt1` and `pt2`. If `f`=1,
                       `pt1` is returned; if `f`=0,
                       `pt2` is returned.
            @return The new, interpolated point.
        **/
        static interpolate(pt1, pt2, f) {
            return new Point(pt2.x + f * (pt1.x - pt2.x), pt2.y + f * (pt1.y - pt2.y));
        }
        /**
            Scales the line segment between(0,0) and the current point to a set
            length.
    
            @param thickness The scaling value. For example, if the current point is
                            (0,5), and you normalize it to 1, the point returned is
                             at(0,1).
            @return The normalized point.
        **/
        normalize(thickness) {
            if (this.x == 0 && this.y == 0) {
                return;
            }
            else {
                var norm = thickness / Math.sqrt(this.x * this.x + this.y * this.y);
                this.x *= norm;
                this.y *= norm;
            }
        }
        /**
            Offsets the Point object by the specified amount. The value of
            `dx` is added to the original value of _x_ to create the
            new _x_ value. The value of `dy` is added to the original
            value of _y_ to create the new _y_ value.
    
            @param dx The amount by which to offset the horizontal coordinate,
                      _x_.
            @param dy The amount by which to offset the vertical coordinate, _y_.
        **/
        offset(dx, dy) {
            this.x += dx;
            this.y += dy;
        }
        /**
            Converts a pair of polar coordinates to a Cartesian point coordinate.
    
            @param len   The length coordinate of the polar pair.
            @param angle The angle, in radians, of the polar pair.
            @return The Cartesian point.
        **/
        static polar(len, angle) {
            return new Point(len * Math.cos(angle), len * Math.sin(angle));
        }
        /**
            Sets the members of Point to the specified values
    
            @param	xa	the values to set the point to.
            @param	ya
        **/
        setTo(xa, ya) {
            this.x = xa;
            this.y = ya;
        }
        /**
            Subtracts the coordinates of another point from the coordinates of this
            point to create a new point.
    
            @param v The point to be subtracted.
            @return The new point.
        **/
        subtract(v) {
            return new Point(this.x - v.x, this.y - v.y);
        }
        /**
            Returns a string that contains the values of the _x_ and _y_
            coordinates. The string has the form `"(x=_x_,
            y=_y_)"`, so calling the `toString()` method for a
            point at 23,17 would return `"(x=23, y=17)"`.
    
            @return The string representation of the coordinates.
        **/
        toString() {
            return `(x=${this.x}, y=${this.y})`;
        }
        // Getters & Setters
        /**
            The length of the line segment from(0,0) to this point.
        **/
        get length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
    }
    Point.__pool = new ObjectPool(() => new Point(), (p) => p.setTo(0, 0));
    return Point;
})();

/**
    The Matrix class represents a transformation matrix that determines how to
    map points from one coordinate space to another. You can perform various
    graphical transformations on a display object by setting the properties of
    a Matrix object, applying that Matrix object to the `matrix` property of a
    Transform object, and then applying that Transform object as the
    `transform` property of the display object. These transformation functions
    include translation (_x_ and _y_ repositioning), rotation, scaling, and
    skewing.
    Together these types of transformations are known as _affine
    transformations_. Affine transformations preserve the straightness of
    lines while transforming, so that parallel lines stay parallel.

    To apply a transformation matrix to a display object, you create a
    Transform object, set its `matrix` property to the transformation matrix,
    and then set the `transform` property of the display object to the
    Transform object. Matrix objects are also used as parameters of some
    methods, such as the following:

    * The `draw()` method of a BitmapData object
    * The `beginBitmapFill()` method, `beginGradientFill()` method, or
    `lineGradientStyle()` method of a Graphics object

    A transformation matrix object is a 3 x 3 matrix with the following
    contents:

    ![Matrix class properties in matrix notation](/images/matrix_props1.jpg)

    In traditional transformation matrixes, the `u`, `v`, and `w` properties
    provide extra capabilities. The Matrix class can only operate in
    two-dimensional space, so it always assumes that the property values `u`
    and `v` are 0.0, and that the property value `w` is 1.0. The effective
    values of the matrix are as follows:

    ![Matrix class properties in matrix notation showing assumed values for u, v, and w](/images/matrix_props2.jpg)

    You can get and set the values of all six of the other properties in a
    Matrix object: `a`, `b`, `c`, `d`, `tx`, and `ty`.

    The Matrix class supports the four major types of transformations:
    translation, scaling, rotation, and skewing. You can set three of these
    transformations by using specialized methods, as described in the
    following table:

    | Transformation | Method | Matrix values | Display result | Description |
    | --- | --- | --- | --- | --- |
    | Translation (displacement) | `translate(tx, ty)` | ![Matrix notation of translate method parameters](/images/matrix_translate.jpg) | ![Illustration of translate method effects](/images/matrix_translate_image.jpg) | Moves the image `tx` pixels to the right and `ty` pixels down. |
    | Scaling | `scale(sx, sy)` | ![Matrix notation of scale method parameters](/images/matrix_scale.jpg) | ![Illustration of scale method effects](/images/matrix_scale_image.jpg) | Resizes the image, multiplying the location of each pixel by `sx` on the _x_ axis and `sy` on the _y_ axis. |
    | Rotation | `rotate(q)` | ![Matrix notation of rotate method properties](/images/matrix_rotate.jpg) | ![Illustration of rotate method effects](/images/matrix_rotate_image.jpg) | Rotates the image by an angle `q`, which is measured in radians. |
    | Skewing or shearing | None; must set the properties `b` and `c` | ![Matrix notation of skew properties](/images/matrix_skew.jpg) | ![Illustration of skew effects](/images/matrix_skew_image.jpg) | Progressively slides the image in a direction parallel to the _x_ or _y_ axis. The `b` property of the Matrix object represents the tangent of the skew angle along the _y_ axis; the `c` property of the Matrix object represents the tangent of the skew angle along the _x_ axis. |

    Each transformation alters the current matrix properties so that
    you can effectively combine multiple transformations. To do this, you call
    more than one transformation before applying the matrix to its
    display object target (by using the `transform` property of that display
    object).

    Use the `new Matrix()` constructor to create a Matrix object before you
    can call the methods of the Matrix object.
**/
let Matrix = /** @class */ (() => {
    class Matrix {
        /**
            Creates a new Matrix object with the specified parameters. In matrix
            notation, the properties are organized like this:
    
            ![Matrix class properties in matrix notation showing assumed values for u, v, and w](/images/matrix_props2.jpg)
    
            If you do not provide any parameters to the `new Matrix()`
            constructor, it creates an _identity matrix_ with the following
            values:
    
            | `a = 1` | `b = 0` |
            | `c = 0` | `d = 1` |
            | `tx = 0` | `ty = 0` |
    
            In matrix notation, the identity matrix looks like this:
    
            ![Matrix class properties in matrix notation](/images/matrix_identity.jpg)
    
            @param a  The value that affects the positioning of pixels along the
                      _x_ axis when scaling or rotating an image.
            @param b  The value that affects the positioning of pixels along the
                      _y_ axis when rotating or skewing an image.
            @param c  The value that affects the positioning of pixels along the
                      _x_ axis when rotating or skewing an image.
            @param d  The value that affects the positioning of pixels along the
                      _y_ axis when scaling or rotating an image..
            @param tx The distance by which to translate each point along the _x_
                      axis.
            @param ty The distance by which to translate each point along the _y_
                      axis.
        **/
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        }
        /**
            Returns a new Matrix object that is a clone of this matrix, with an exact
            copy of the contained object.
    
            @return A Matrix object.
        **/
        clone() {
            return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
        }
        /**
            Concatenates a matrix with the current matrix, effectively combining the
            geometric effects of the two. In mathematical terms, concatenating two
            matrixes is the same as combining them using matrix multiplication.
    
            For example, if matrix `m1` scales an object by a factor of
            four, and matrix `m2` rotates an object by 1.5707963267949
            radians(`Math.PI/2`), then `m1.concat(m2)`
            transforms `m1` into a matrix that scales an object by a factor
            of four and rotates the object by `Math.PI/2` radians.
    
            This method replaces the source matrix with the concatenated matrix. If
            you want to concatenate two matrixes without altering either of the two
            source matrixes, first copy the source matrix by using the
            `clone()` method, as shown in the Class Examples section.
    
            @param m The matrix to be concatenated to the source matrix.
        **/
        concat(m) {
            var a1 = this.a * m.a + this.b * m.c;
            this.b = this.a * m.b + this.b * m.d;
            this.a = a1;
            var c1 = this.c * m.a + this.d * m.c;
            this.d = this.c * m.b + this.d * m.d;
            this.c = c1;
            var tx1 = this.tx * m.a + this.ty * m.c + m.tx;
            this.ty = this.tx * m.b + this.ty * m.d + m.ty;
            this.tx = tx1;
            // __cleanValues ();
        }
        /**
            Copies a Vector3D object into specific column of the calling Matrix3D object.
    
            @param	column	The column from which to copy the data from.
            @param	vector3D	The Vector3D object from which to copy the data.
        **/
        copyColumnFrom(column, vector3D) {
            if (column > 2) {
                throw "Column " + column + " out of bounds (2)";
            }
            else if (column == 0) {
                this.a = vector3D.x;
                this.b = vector3D.y;
            }
            else if (column == 1) {
                this.c = vector3D.x;
                this.d = vector3D.y;
            }
            else {
                this.tx = vector3D.x;
                this.ty = vector3D.y;
            }
        }
        /**
            Copies specific column of the calling Matrix object into the Vector3D object. The
            `w` element of the Vector3D object will not be changed.
    
            @param	column	The column from which to copy the data from.
            @param	vector3D	The Vector3D object from which to copy the data.
        **/
        copyColumnTo(column, vector3D) {
            if (column > 2) {
                throw "Column " + column + " out of bounds (2)";
            }
            else if (column == 0) {
                vector3D.x = this.a;
                vector3D.y = this.b;
                vector3D.z = 0;
            }
            else if (column == 1) {
                vector3D.x = this.c;
                vector3D.y = this.d;
                vector3D.z = 0;
            }
            else {
                vector3D.x = this.tx;
                vector3D.y = this.ty;
                vector3D.z = 1;
            }
        }
        /**
            Copies all of the matrix data from the source Point object into the calling Matrix
            object.
    
            @param	sourceMatrix	The Matrix object from which to copy the data.
        **/
        copyFrom(sourceMatrix) {
            this.a = sourceMatrix.a;
            this.b = sourceMatrix.b;
            this.c = sourceMatrix.c;
            this.d = sourceMatrix.d;
            this.tx = sourceMatrix.tx;
            this.ty = sourceMatrix.ty;
        }
        /**
            Copies a Vector3D object into specific row of the calling Matrix object.
    
            @param	row	The row from which to copy the data from.
            @param	vector3D	The Vector3D object from which to copy the data.
        **/
        copyRowFrom(row, vector3D) {
            if (row > 2) {
                throw "Row " + row + " out of bounds (2)";
            }
            else if (row == 0) {
                this.a = vector3D.x;
                this.c = vector3D.y;
                this.tx = vector3D.z;
            }
            else if (row == 1) {
                this.b = vector3D.x;
                this.d = vector3D.y;
                this.ty = vector3D.z;
            }
        }
        /**
            Copies specific row of the calling Matrix object into the Vector3D object. The `w`
            element of the Vector3D object will not be changed.
    
            @param	row	The row from which to copy the data from.
            @param	vector3D	The Vector3D object from which to copy the data.
        **/
        copyRowTo(row, vector3D) {
            if (row > 2) {
                throw "Row " + row + " out of bounds (2)";
            }
            else if (row == 0) {
                vector3D.x = this.a;
                vector3D.y = this.c;
                vector3D.z = this.tx;
            }
            else if (row == 1) {
                vector3D.x = this.b;
                vector3D.y = this.d;
                vector3D.z = this.ty;
            }
            else {
                vector3D.setTo(0, 0, 1);
            }
        }
        /**
            Includes parameters for scaling, rotation, and translation. When
            applied to a matrix it sets the matrix's values based on those
            parameters.
            Using the `createBox()` method lets you obtain the same matrix as you
            would if you applied the `identity()`, `rotate()`, `scale()`, and
            `translate()` methods in succession. For example,
            `mat1.createBox(2,2,Math.PI/4, 100, 100)` has the same effect as the
            following:
    
            ```haxe
            import Matrix from "../geom/Matrix";
    
            var mat1 = new Matrix();
            mat1.identity();
            mat1.rotate(Math.PI/4);
            mat1.scale(2,2);
            mat1.translate(10,20);
            ```
    
            @param scaleX   The factor by which to scale horizontally.
            @param scaleY   The factor by which scale vertically.
            @param rotation The amount to rotate, in radians.
            @param tx       The number of pixels to translate (move) to the right
                            along the _x_ axis.
            @param ty       The number of pixels to translate (move) down along
                            the _y_ axis.
        **/
        createBox(scaleX, scaleY, rotation = 0, tx = 0, ty = 0) {
            // identity ();
            // rotate (rotation);
            // scale (scaleX, scaleY);
            // translate (tx, ty);
            if (rotation != 0) {
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                this.a = cos * scaleX;
                this.b = sin * scaleY;
                this.c = -sin * scaleX;
                this.d = cos * scaleY;
            }
            else {
                this.a = scaleX;
                this.b = 0;
                this.c = 0;
                this.d = scaleY;
            }
            this.tx = tx;
            this.ty = ty;
        }
        /**
            Creates the specific style of matrix expected by the
            `beginGradientFill()` and `lineGradientStyle()` methods of the
            Graphics class. Width and height are scaled to a `scaleX`/`scaleY`
            pair and the `tx`/`ty` values are offset by half the width and height.
    
            For example, consider a gradient with the following characteristics:
    
            * `GradientType.LINEAR`
            * Two colors, green and blue, with the ratios array set to `[0, 255]`
            * `SpreadMethod.PAD`
            * `InterpolationMethod.LINEAR_RGB`
    
            The following illustrations show gradients in which the matrix was
            defined using the `createGradientBox()` method with different
            parameter settings:
    
            | `createGradientBox()` settings | Resulting gradient |
            | --- | --- |
            | `width = 25; height = 25; rotation = 0; tx = 0; ty = 0;` | ![resulting linear gradient](/images/createGradientBox-1.jpg) |
            | `width = 25; height = 25; rotation = 0; tx = 25; ty = 0;` | ![resulting linear gradient](/images/createGradientBox-2.jpg) |
            | `width = 50; height = 50; rotation = 0; tx = 0; ty = 0;` | ![resulting linear gradient](/images/createGradientBox-3.jpg) |
            | `width = 50; height = 50; rotation = Math.PI / 4; // 45 degrees tx = 0; ty = 0;` | ![resulting linear gradient](/images/createGradientBox-4.jpg) |
    
            @param width    The width of the gradient box.
            @param height   The height of the gradient box.
            @param rotation The amount to rotate, in radians.
            @param tx       The distance, in pixels, to translate to the right
                            along the _x_ axis. This value is offset by half of
                            the `width` parameter.
            @param ty       The distance, in pixels, to translate down along the
                            _y_ axis. This value is offset by half of the `height`
                            parameter.
        **/
        createGradientBox(width, height, rotation = 0, tx = 0, ty = 0) {
            this.a = width / 1638.4;
            this.d = height / 1638.4;
            // rotation is clockwise
            if (rotation != 0) {
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                this.b = sin * this.d;
                this.c = -sin * this.a;
                this.a *= cos;
                this.d *= cos;
            }
            else {
                this.b = 0;
                this.c = 0;
            }
            this.tx = tx + width / 2;
            this.ty = ty + height / 2;
        }
        /**
            Given a point in the pretransform coordinate space, returns the
            coordinates of that point after the transformation occurs. Unlike the
            standard transformation applied using the `transformPoint()`
            method, the `deltaTransformPoint()` method's transformation
            does not consider the translation parameters `tx` and
            `ty`.
    
            @param point The point for which you want to get the result of the matrix
                         transformation.
            @return The point resulting from applying the matrix transformation.
        **/
        deltaTransformPoint(point) {
            return new Point(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
        }
        /** @hidden */
        equals(matrix) {
            return (matrix != null && this.tx == matrix.tx && this.ty == matrix.ty && this.a == matrix.a && this.b == matrix.b && this.c == matrix.c && this.d == matrix.d);
        }
        /**
            Sets each matrix property to a value that causes a null
            transformation. An object transformed by applying an identity matrix
            will be identical to the original.
            After calling the `identity()` method, the resulting matrix has the
            following properties: `a`=1, `b`=0, `c`=0, `d`=1, `tx`=0, `ty`=0.
    
            In matrix notation, the identity matrix looks like this:
    
            ![Matrix class properties in matrix notation](/images/matrix_identity.jpg)
        **/
        identity() {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.tx = 0;
            this.ty = 0;
        }
        /**
            Performs the opposite transformation of the original matrix. You can apply
            an inverted matrix to an object to undo the transformation performed when
            applying the original matrix.
    
        **/
        invert() {
            var norm = this.a * this.d - this.b * this.c;
            if (norm == 0) {
                this.a = this.b = this.c = this.d = 0;
                this.tx = -this.tx;
                this.ty = -this.ty;
            }
            else {
                norm = 1.0 / norm;
                var a1 = this.d * norm;
                this.d = this.a * norm;
                this.a = a1;
                this.b *= -norm;
                this.c *= -norm;
                var tx1 = -this.a * this.tx - this.c * this.ty;
                this.ty = -this.b * this.tx - this.d * this.ty;
                this.tx = tx1;
            }
            // __cleanValues ();
            return this;
        }
        /**
            Applies a rotation transformation to the Matrix object.
            The `rotate()` method alters the `a`, `b`, `c`, and `d` properties of
            the Matrix object. In matrix notation, this is the same as
            concatenating the current matrix with the following:
    
            ![Matrix notation of scale method parameters](/images/matrix_rotate.jpg)
    
            @param angle The rotation angle in radians.
        **/
        rotate(theta) {
            /**
                Rotate object "after" other transforms
    
                [  a  b   0 ][  ma mb  0 ]
                [  c  d   0 ][  mc md  0 ]
                [  tx ty  1 ][  mtx mty 1 ]
    
                ma = md = cos
                mb = sin
                mc = -sin
                mtx = my = 0
            **/
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            var a1 = this.a * cos - this.b * sin;
            this.b = this.a * sin + this.b * cos;
            this.a = a1;
            var c1 = this.c * cos - this.d * sin;
            this.d = this.c * sin + this.d * cos;
            this.c = c1;
            var tx1 = this.tx * cos - this.ty * sin;
            this.ty = this.tx * sin + this.ty * cos;
            this.tx = tx1;
            // __cleanValues ();
        }
        /**
            Applies a scaling transformation to the matrix. The _x_ axis is
            multiplied by `sx`, and the _y_ axis it is multiplied by `sy`.
            The `scale()` method alters the `a` and `d` properties of the Matrix
            object. In matrix notation, this is the same as concatenating the
            current matrix with the following matrix:
    
            ![Matrix notation of scale method parameters](/images/matrix_scale.jpg)
    
            @param sx A multiplier used to scale the object along the _x_ axis.
            @param sy A multiplier used to scale the object along the _y_ axis.
        **/
        scale(sx, sy) {
            /*
    
                Scale object "after" other transforms
    
                [  a  b   0 ][  sx  0   0 ]
                [  c  d   0 ][  0   sy  0 ]
                [  tx ty  1 ][  0   0   1 ]
            **/
            this.a *= sx;
            this.b *= sy;
            this.c *= sx;
            this.d *= sy;
            this.tx *= sx;
            this.ty *= sy;
            // __cleanValues ();
        }
        setRotation(theta, scale = 1) {
            this.a = Math.cos(theta) * scale;
            this.c = Math.sin(theta) * scale;
            this.b = -this.c;
            this.d = this.a;
            // __cleanValues ();
        }
        /**
            Sets the members of Matrix to the specified values
    
            @param	aa	the values to set the matrix to.
            @param	ba
            @param	ca
            @param	da
            @param	txa
            @param	tya
        **/
        setTo(a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        }
        /** @hidden */
        to3DString(roundPixels = false) {
            if (roundPixels) {
                return `matrix3d(${this.a}, ${this.b}, 0, 0, ${this.c}, ${this.d}, 0, 0, 0, 0, 1, 0, ${Math.round(this.tx)}, ${Math.round(this.ty)}, 0, 1)`;
            }
            else {
                return `matrix3d(${this.a}, ${this.b}, 0, 0, ${this.c}, ${this.d}, 0, 0, 0, 0, 1, 0, ${this.tx}, ${this.ty}, 0, 1)`;
            }
        }
        /**
            Returns a text value listing the properties of the Matrix object.
    
            @return A string containing the values of the properties of the Matrix
                    object: `a`, `b`, `c`,
                    `d`, `tx`, and `ty`.
        **/
        toString() {
            return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;
        }
        /**
            Returns the result of applying the geometric transformation represented by
            the Matrix object to the specified point.
    
            @param point The point for which you want to get the result of the Matrix
                         transformation.
            @return The point resulting from applying the Matrix transformation.
        **/
        transformPoint(pos) {
            return new Point(this.__transformX(pos.x, pos.y), this.__transformY(pos.x, pos.y));
        }
        /**
            Translates the matrix along the _x_ and _y_ axes, as specified
            by the `dx` and `dy` parameters.
    
            @param dx The amount of movement along the _x_ axis to the right, in
                      pixels.
            @param dy The amount of movement down along the _y_ axis, in pixels.
        **/
        translate(dx, dy) {
            this.tx += dx;
            this.ty += dy;
        }
        toArray(transpose = false) {
            if (this.__array == null) {
                this.__array = new Float32Array(9);
            }
            if (transpose) {
                this.__array[0] = this.a;
                this.__array[1] = this.b;
                this.__array[2] = 0;
                this.__array[3] = this.c;
                this.__array[4] = this.d;
                this.__array[5] = 0;
                this.__array[6] = this.tx;
                this.__array[7] = this.ty;
                this.__array[8] = 1;
            }
            else {
                this.__array[0] = this.a;
                this.__array[1] = this.c;
                this.__array[2] = this.tx;
                this.__array[3] = this.b;
                this.__array[4] = this.d;
                this.__array[5] = this.ty;
                this.__array[6] = 0;
                this.__array[7] = 0;
                this.__array[8] = 1;
            }
            return this.__array;
        }
        __cleanValues() {
            this.a = Math.round(this.a * 1000) / 1000;
            this.b = Math.round(this.b * 1000) / 1000;
            this.c = Math.round(this.c * 1000) / 1000;
            this.d = Math.round(this.d * 1000) / 1000;
            this.tx = Math.round(this.tx * 10) / 10;
            this.ty = Math.round(this.ty * 10) / 10;
        }
        __transformInversePoint(point) {
            var norm = this.a * this.d - this.b * this.c;
            if (norm == 0) {
                point.x = -this.tx;
                point.y = -this.ty;
            }
            else {
                var px = (1.0 / norm) * (this.c * (this.ty - point.y) + this.d * (point.x - this.tx));
                point.y = (1.0 / norm) * (this.a * (point.y - this.ty) + this.b * (this.tx - point.x));
                point.x = px;
            }
        }
        __transformInverseX(px, py) {
            var norm = this.a * this.d - this.b * this.c;
            if (norm == 0) {
                return -this.tx;
            }
            else {
                return (1.0 / norm) * (this.c * (this.ty - py) + this.d * (px - this.tx));
            }
        }
        __transformInverseY(px, py) {
            var norm = this.a * this.d - this.b * this.c;
            if (norm == 0) {
                return -this.ty;
            }
            else {
                return (1.0 / norm) * (this.a * (py - this.ty) + this.b * (this.tx - px));
            }
        }
        __transformPoint(point) {
            var px = point.x;
            var py = point.y;
            point.x = this.__transformX(px, py);
            point.y = this.__transformY(px, py);
        }
        __transformX(px, py) {
            return px * this.a + py * this.c + this.tx;
        }
        __transformY(px, py) {
            return px * this.b + py * this.d + this.ty;
        }
        __translateTransformed(px, py) {
            this.tx = this.__transformX(px, py);
            this.ty = this.__transformY(px, py);
            // __cleanValues ();
        }
    }
    Matrix.__identity = new Matrix();
    Matrix.__pool = new ObjectPool(() => new Matrix(), (m) => m.identity());
    return Matrix;
})();

/**
    A Rectangle object is an area defined by its position, as indicated by its
    top-left corner point(_x_, _y_) and by its width and its height.


    The `x`, `y`, `width`, and
    `height` properties of the Rectangle class are independent of
    each other; changing the value of one property has no effect on the others.
    However, the `right` and `bottom` properties are
    integrally related to those four properties. For example, if you change the
    value of the `right` property, the value of the
    `width` property changes; if you change the `bottom`
    property, the value of the `height` property changes.

    The following methods and properties use Rectangle objects:


    * The `applyFilter()`, `colorTransform()`,
    `copyChannel()`, `copyPixels()`, `draw()`,
    `fillRect()`, `generateFilterRect()`,
    `getColorBoundsRect()`, `getPixels()`,
    `merge()`, `paletteMap()`,
    `pixelDisolve()`, `setPixels()`, and
    `threshold()` methods, and the `rect` property of the
    BitmapData class
    * The `getBounds()` and `getRect()` methods, and
    the `scrollRect` and `scale9Grid` properties of the
    DisplayObject class
    * The `getCharBoundaries()` method of the TextField
    class
    * The `pixelBounds` property of the Transform class
    * The `bounds` parameter for the `startDrag()`
    method of the Sprite class
    * The `printArea` parameter of the `addPage()`
    method of the PrintJob class


    You can use the `new Rectangle()` constructor to create a
    Rectangle object.

    **Note:** The Rectangle class does not define a rectangular Shape
    display object. To draw a rectangular Shape object onscreen, use the
    `drawRect()` method of the Graphics class.
**/
let Rectangle = /** @class */ (() => {
    class Rectangle {
        /**
            Creates a new Rectangle object with the top-left corner specified by the
            `x` and `y` parameters and with the specified
            `width` and `height` parameters. If you call this
            function without parameters, a rectangle with `x`,
            `y`, `width`, and `height` properties set
            to 0 is created.
    
            @param x      The _x_ coordinate of the top-left corner of the
                          rectangle.
            @param y      The _y_ coordinate of the top-left corner of the
                          rectangle.
            @param width  The width of the rectangle, in pixels.
            @param height The height of the rectangle, in pixels.
        **/
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        /**
            Returns a new Rectangle object with the same values for the
            `x`, `y`, `width`, and
            `height` properties as the original Rectangle object.
    
            @return A new Rectangle object with the same values for the
                    `x`, `y`, `width`, and
                    `height` properties as the original Rectangle object.
        **/
        clone() {
            return new Rectangle(this.x, this.y, this.width, this.height);
        }
        /**
            Determines whether the specified point is contained within the rectangular
            region defined by this Rectangle object.
    
            @param x The _x_ coordinate(horizontal position) of the point.
            @param y The _y_ coordinate(vertical position) of the point.
            @return A value of `true` if the Rectangle object contains the
                    specified point; otherwise `false`.
        **/
        contains(x, y) {
            return x >= this.x && y >= this.y && x < this.right && y < this.bottom;
        }
        /**
            Determines whether the specified point is contained within the rectangular
            region defined by this Rectangle object. This method is similar to the
            `Rectangle.contains()` method, except that it takes a Point
            object as a parameter.
    
            @param point The point, as represented by its _x_ and _y_
                         coordinates.
            @return A value of `true` if the Rectangle object contains the
                    specified point; otherwise `false`.
        **/
        containsPoint(point) {
            return this.contains(point.x, point.y);
        }
        /**
            Determines whether the Rectangle object specified by the `rect`
            parameter is contained within this Rectangle object. A Rectangle object is
            said to contain another if the second Rectangle object falls entirely
            within the boundaries of the first.
    
            @param rect The Rectangle object being checked.
            @return A value of `true` if the Rectangle object that you
                    specify is contained by this Rectangle object; otherwise
                    `false`.
        **/
        containsRect(rect) {
            if (rect.width <= 0 || rect.height <= 0) {
                return rect.x > this.x && rect.y > this.y && rect.right < this.right && rect.bottom < this.bottom;
            }
            else {
                return rect.x >= this.x && rect.y >= this.y && rect.right <= this.right && rect.bottom <= this.bottom;
            }
        }
        /**
            Copies all of rectangle data from the source Rectangle object into the calling
            Rectangle object.
    
            @param	sourceRect	The Rectangle object from which to copy the data.
        **/
        copyFrom(sourceRect) {
            this.x = sourceRect.x;
            this.y = sourceRect.y;
            this.width = sourceRect.width;
            this.height = sourceRect.height;
        }
        /**
            Determines whether the object specified in the `toCompare`
            parameter is equal to this Rectangle object. This method compares the
            `x`, `y`, `width`, and
            `height` properties of an object against the same properties of
            this Rectangle object.
    
            @param toCompare The rectangle to compare to this Rectangle object.
            @return A value of `true` if the object has exactly the same
                    values for the `x`, `y`, `width`,
                    and `height` properties as this Rectangle object;
                    otherwise `false`.
        **/
        equals(toCompare) {
            if (toCompare == this)
                return true;
            else
                return toCompare != null && this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width && this.height == toCompare.height;
        }
        /**
            Increases the size of the Rectangle object by the specified amounts,
            in pixels. The center point of the Rectangle object stays the same,
            and its size increases to the left and right by the `dx` value, and to
            the top and the bottom by the `dy` value.
    
            @param dx The value to be added to the left and the right of the
                      Rectangle object. The following equation is used to
                      calculate the new width and position of the rectangle:
    
                      ```as3
                      x -= dx;
                      width += 2 * dx;
                      ```
            @param dy The value to be added to the top and the bottom of the
                      Rectangle. The following equation is used to calculate the
                      new height and position of the rectangle:
    
                      ```
                      y -= dy;
                      height += 2 * dy;
                      ```
        **/
        inflate(dx, dy) {
            this.x -= dx;
            this.width += dx * 2;
            this.y -= dy;
            this.height += dy * 2;
        }
        /**
            Increases the size of the Rectangle object. This method is similar to
            the `Rectangle.inflate()` method except it takes a Point object as a
            parameter.
            The following two code examples give the same result:
    
            ```haxe
            var rect1 = new Rectangle(0,0,2,5);
            rect1.inflate(2,2);
            ```
            ```haxe
            var rect1 = new Rectangle(0,0,2,5);
            var pt1 = new Point(2,2);
            rect1.inflatePoint(pt1);
            ```
    
            @param point The `x` property of this Point object is used to increase
                         the horizontal dimension of the Rectangle object. The `y`
                         property is used to increase the vertical dimension of
                         the Rectangle object.
        **/
        inflatePoint(point) {
            this.inflate(point.x, point.y);
        }
        /**
            If the Rectangle object specified in the `toIntersect` parameter
            intersects with this Rectangle object, returns the area of
            intersection as a Rectangle object. If the rectangles do not
            intersect, this method returns an empty Rectangle object with its
            properties set to 0.
    
            ![The resulting intersection rectangle.](/images/rectangle_intersect.jpg)
    
            @param toIntersect The Rectangle object to compare against to see if
                               it intersects with this Rectangle object.
            @return A Rectangle object that equals the area of intersection. If
                    the rectangles do not intersect, this method returns an empty
                    Rectangle object; that is, a rectangle with its `x`, `y`,
                    `width`, and `height` properties set to 0.
        **/
        intersection(toIntersect) {
            var x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
            var x1 = this.right > toIntersect.right ? toIntersect.right : this.right;
            if (x1 <= x0) {
                return new Rectangle();
            }
            var y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
            var y1 = this.bottom > toIntersect.bottom ? toIntersect.bottom : this.bottom;
            if (y1 <= y0) {
                return new Rectangle();
            }
            return new Rectangle(x0, y0, x1 - x0, y1 - y0);
        }
        /**
            Determines whether the object specified in the `toIntersect`
            parameter intersects with this Rectangle object. This method checks the
            `x`, `y`, `width`, and
            `height` properties of the specified Rectangle object to see if
            it intersects with this Rectangle object.
    
            @param toIntersect The Rectangle object to compare against this Rectangle
                               object.
            @return A value of `true` if the specified object intersects
                    with this Rectangle object; otherwise `false`.
        **/
        intersects(toIntersect) {
            var x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
            var x1 = this.right > toIntersect.right ? toIntersect.right : this.right;
            if (x1 <= x0) {
                return false;
            }
            var y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
            var y1 = this.bottom > toIntersect.bottom ? toIntersect.bottom : this.bottom;
            return y1 > y0;
        }
        /**
            Determines whether or not this Rectangle object is empty.
    
            @return A value of `true` if the Rectangle object's width or
                    height is less than or equal to 0; otherwise `false`.
        **/
        isEmpty() {
            return (this.width <= 0 || this.height <= 0);
        }
        /**
            Adjusts the location of the Rectangle object, as determined by its
            top-left corner, by the specified amounts.
    
            @param dx Moves the _x_ value of the Rectangle object by this amount.
            @param dy Moves the _y_ value of the Rectangle object by this amount.
        **/
        offset(dx, dy) {
            this.x += dx;
            this.y += dy;
        }
        /**
            Adjusts the location of the Rectangle object using a Point object as a
            parameter. This method is similar to the `Rectangle.offset()`
            method, except that it takes a Point object as a parameter.
    
            @param point A Point object to use to offset this Rectangle object.
        **/
        offsetPoint(point) {
            this.x += point.x;
            this.y += point.y;
        }
        /**
            Sets all of the Rectangle object's properties to 0. A Rectangle object is
            empty if its width or height is less than or equal to 0.
    
             This method sets the values of the `x`, `y`,
            `width`, and `height` properties to 0.
    
        **/
        setEmpty() {
            this.x = this.y = this.width = this.height = 0;
        }
        /**
            Sets the members of Rectangle to the specified values
    
            @param	xa	the values to set the rectangle to.
            @param	ya
            @param	widtha
            @param	heighta
        **/
        setTo(xa, ya, widtha, heighta) {
            this.x = xa;
            this.y = ya;
            this.width = widtha;
            this.height = heighta;
        }
        toString() {
            return `(x=${this.x}, y=${this.y}, width=${this.width}, height=${this.height})`;
        }
        /**
            Adds two rectangles together to create a new Rectangle object, by
            filling in the horizontal and vertical space between the two
            rectangles.
    
            ![The resulting union rectangle.](/images/rectangle_union.jpg)
    
            **Note:** The `union()` method ignores rectangles with `0` as the
            height or width value, such as: `var rect2:Rectangle = new Rectangle(300,300,50,0);`
    
            @param toUnion A Rectangle object to add to this Rectangle object.
            @return A new Rectangle object that is the union of the two
                    rectangles.
        **/
        union(toUnion) {
            if (this.width == 0 || this.height == 0) {
                return toUnion.clone();
            }
            else if (toUnion.width == 0 || toUnion.height == 0) {
                return this.clone();
            }
            var x0 = this.x > toUnion.x ? toUnion.x : this.x;
            var x1 = this.right < toUnion.right ? toUnion.right : this.right;
            var y0 = this.y > toUnion.y ? toUnion.y : this.y;
            var y1 = this.bottom < toUnion.bottom ? toUnion.bottom : this.bottom;
            return new Rectangle(x0, y0, x1 - x0, y1 - y0);
        }
        __contract(x, y, width, height) {
            if (this.width == 0 && this.height == 0) {
                return;
            }
            var offsetX = 0.0;
            var offsetY = 0.0;
            var offsetRight = 0.0;
            var offsetBottom = 0.0;
            if (this.x < x)
                offsetX = x - this.x;
            if (this.y < y)
                offsetY = y - this.y;
            if (this.right > x + width)
                offsetRight = (x + width) - this.right;
            if (this.bottom > y + height)
                offsetBottom = (y + height) - this.bottom;
            this.x += offsetX;
            this.y += offsetY;
            this.width += offsetRight - offsetX;
            this.height += offsetBottom - offsetY;
        }
        __expand(x, y, width, height) {
            if (this.width == 0 && this.height == 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                return;
            }
            var cacheRight = this.right;
            var cacheBottom = this.bottom;
            if (this.x > x) {
                this.x = x;
                this.width = cacheRight - x;
            }
            if (this.y > y) {
                this.y = y;
                this.height = cacheBottom - y;
            }
            if (cacheRight < x + width)
                this.width = x + width - this.x;
            if (cacheBottom < y + height)
                this.height = y + height - this.y;
        }
        __transform(rect, m) {
            var tx0 = m.a * this.x + m.c * this.y;
            var tx1 = tx0;
            var ty0 = m.b * this.x + m.d * this.y;
            var ty1 = ty0;
            var tx = m.a * (this.x + this.width) + m.c * this.y;
            var ty = m.b * (this.x + this.width) + m.d * this.y;
            if (tx < tx0)
                tx0 = tx;
            if (ty < ty0)
                ty0 = ty;
            if (tx > tx1)
                tx1 = tx;
            if (ty > ty1)
                ty1 = ty;
            tx = m.a * (this.x + this.width) + m.c * (this.y + this.height);
            ty = m.b * (this.x + this.width) + m.d * (this.y + this.height);
            if (tx < tx0)
                tx0 = tx;
            if (ty < ty0)
                ty0 = ty;
            if (tx > tx1)
                tx1 = tx;
            if (ty > ty1)
                ty1 = ty;
            tx = m.a * this.x + m.c * (this.y + this.height);
            ty = m.b * this.x + m.d * (this.y + this.height);
            if (tx < tx0)
                tx0 = tx;
            if (ty < ty0)
                ty0 = ty;
            if (tx > tx1)
                tx1 = tx;
            if (ty > ty1)
                ty1 = ty;
            rect.setTo(tx0 + m.tx, ty0 + m.ty, tx1 - tx0, ty1 - ty0);
        }
        // Getters & Setters
        /**
            The sum of the `y` and `height` properties.
    
            ![A rectangle image showing location and measurement properties.](/images/rectangle.jpg)
        **/
        get bottom() {
            return this.y + this.height;
        }
        set bottom(b) {
            this.height = b - this.y;
        }
        /**
            The location of the Rectangle object's bottom-right corner, determined
            by the values of the `right` and `bottom` properties.
    
            ![A rectangle image showing location and measurement properties.](/images/rectangle.jpg)
        **/
        get bottomRight() {
            return new Point(this.x + this.width, this.y + this.height);
        }
        set bottomRight(p) {
            this.width = p.x - this.x;
            this.height = p.y - this.y;
        }
        /**
            The _x_ coordinate of the top-left corner of the rectangle. Changing
            the `left` property of a Rectangle object has no effect on the `y` and
            `height` properties. However it does affect the `width` property,
            whereas changing the `x` value does _not_ affect the `width` property.
    
            The value of the `left` property is equal to the value of the `x`
            property.
    
            ![A rectangle image showing location and measurement properties.](/images/rectangle.jpg)
        **/
        get left() {
            return this.x;
        }
        set left(l) {
            this.width -= l - this.x;
            this.x = l;
        }
        /**
            The sum of the `x` and `width` properties.
    
            ![A rectangle image showing location and measurement properties.](/images/rectangle.jpg)
        **/
        get right() {
            return this.x + this.width;
        }
        set right(r) {
            this.width = r - this.x;
        }
        /**
            The size of the Rectangle object, expressed as a Point object with the
            values of the `width` and `height` properties.
        **/
        get size() {
            return new Point(this.width, this.height);
        }
        set size(p) {
            this.width = p.x;
            this.height = p.y;
        }
        /**
            The _y_ coordinate of the top-left corner of the rectangle. Changing
            the `top` property of a Rectangle object has no effect on the `x` and
            `width` properties. However it does affect the `height` property,
            whereas changing the `y` value does _not_ affect the `height`
            property.
            The value of the `top` property is equal to the value of the `y`
            property.
    
            ![A rectangle image showing location and measurement properties.](/images/rectangle.jpg)
        **/
        get top() {
            return this.y;
        }
        set top(t) {
            this.height -= t - this.y;
            this.y = t;
        }
        /**
            The location of the Rectangle object's top-left corner, determined by
            the _x_ and _y_ coordinates of the point.
    
            ![A rectangle image showing location and measurement properties.](/images/rectangle.jpg)
        **/
        get topLeft() {
            return new Point(this.x, this.y);
        }
        set topLeft(p) {
            this.x = p.x;
            this.y = p.y;
        }
    }
    Rectangle.__pool = new ObjectPool(() => new Rectangle(), (r) => r.setTo(0, 0, 0, 0));
    return Rectangle;
})();

var openfl$2;
(function (openfl) {
    var geom;
    (function (geom) {
        /**
        The Orientation3D class is an enumeration of constant
        values for representing the orientation style of a Matrix3D object.
        The three types of orientation are Euler angles, axis angle, and quaternion.
        The `decompose` and `recompose` methods of the Matrix3D object take one of these
        enumerated types to identify the rotational components of the Matrix.
    **/
        let Orientation3D;
        (function (Orientation3D) {
            /**
                The axis angle orientation uses a combination of an axis and an angle to determine
                the orientation. A line or vector from the center of a three-dimensional globe to
                the surface is an example of an axis. The axis around which the object is rotated
                is a unit vector that represents any possible direction in the three-dimensional
                space. The angle represents the magnitude of the rotation about the vector. The
                direction determines where a display object is facing and the roll angle
                determines which way is up. You can use Vector3D and the Matrix3D objects to
                determine the various matrix transformations as well as to determine important
                three-dimensional programming values such as the distance to the intersection of
                two objects that can be used to detect simple collision between three-dimensional
                objects.
    
                The Matrix3D `appendRotation()` and Matrix3D `prependRotation()` methods use the
                axis angle orientation.
            **/
            Orientation3D["AXIS_ANGLE"] = "axisAngle";
            /**
                Euler angles, the default orientation for `decompose()` and `recompose()` methods,
                defines the orientation with three separate angles of rotation for each axis.
                Usually, a rotation around the x axis is followed by a rotation around the y axis,
                which is followed by a rotation around the z axis.
    
                Euler angles can sometimes lead to animation errors because of problems such as
                singularities when rotating around the x axis or gimbal lock. For example, since
                with Euler angles each axis is handled independently, gimbal lock can occur during
                the rotation around two or more axes. The axes can become aligned, leading to
                unexpected results.
    
                The axis rotation properties of the display object perform Euler angles rotation.
            **/
            Orientation3D["EULER_ANGLES"] = "eulerAngles";
            /**
                The quaternion orientation uses complex numbers. An orientation in quaternion is
                by the three axes of rotation (x,y,z) and an angle of rotation (w). Quaternion
                guarantees the shortest, most efficient path for the rotation. It also produces a
                smooth, gimbal-lock-free rotation. A gimbal lock can occur when during the
                rotation around two or more axes the axes are aligned, leading to unexpected
                results.
    
                The Matrix3D `interpolate()` method uses quaternion.
            **/
            Orientation3D["QUATERNION"] = "quaternion";
        })(Orientation3D = geom.Orientation3D || (geom.Orientation3D = {}));
    })(geom = openfl.geom || (openfl.geom = {}));
})(openfl$2 || (openfl$2 = {}));
var Orientation3D = openfl$2.geom.Orientation3D;

/**
    The Vector3D class represents a point or a location in the three-dimensional space using
    the Cartesian coordinates x, y, and z. As in a two-dimensional space, the `x` property
    represents the horizontal axis and the `y` property represents the vertical axis. In
    three-dimensional space, the `z` property represents depth. The value of the `x` property increases as the object moves to the right. The value of the `y` property
    increases as the object moves down. The `z` property increases as the object moves
    farther from the point of view. Using perspective projection and scaling, the object is
    seen to be bigger when near and smaller when farther away from the screen. As in a
    right-handed three-dimensional coordinate system, the positive z-axis points away from
    the viewer and the value of the `z` property increases as the object moves away from the
    viewer's eye. The origin point (0,0,0) of the global space is the upper-left corner of
    the stage.

    ![X, Y, Z Axes](/images/xyzAxes.jpg)

    The Vector3D class can also represent a direction, an arrow pointing from the origin of
    the coordinates, such as (0,0,0), to an endpoint; or a floating-point component of an
    RGB (Red, Green, Blue) color model.

    Quaternion notation introduces a fourth element, the `w` property, which provides
    additional orientation information. For example, the `w` property can define an angle
    of rotation of a Vector3D object. The combination of the angle of rotation and the
    coordinates `x`, `y`, and `z` can determine the display object's orientation. Here is
    a representation of Vector3D elements in matrix notation:

    ![Vector3D elements](/images/Vector3Delements.jpg)
**/
class Vector3D {
    /**
        Creates an instance of a Vector3D object. If you do not specify a parameter for
        the constructor, a Vector3D object is created with the elements (0,0,0,0).

        @param	x	The first element, such as the x coordinate.
        @param	y	The second element, such as the y coordinate.
        @param	z	The third element, such as the z coordinate.
        @param	w	An optional element for additional data such as the angle of rotation.
    **/
    constructor(x = 0, y = 0, z = 0, w = 0) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    /**
        Adds the value of the x, y, and z elements of the current Vector3D object to the
        values of the x, y, and z elements of another Vector3D object. The `add()` method
        does not change the current Vector3D object. Instead, it returns a new Vector3D
        object with the new values.

        The result of adding two vectors together is a resultant vector. One way to
        visualize the result is by drawing a vector from the origin or tail of the first
        vector to the end or head of the second vector. The resultant vector is the
        distance between the origin point of the first vector and the end point of the
        second vector.

        ![Resultant Vector3D](/images/resultantVector3D.jpg)

        @param	a	A Vector3D object to be added to the current Vector3D object.
        @returns	A Vector3D object that is the result of adding the current Vector3D
        object to another Vector3D object.
    **/
    add(a) {
        return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z);
    }
    /**
        Returns the angle in radians between two vectors. The returned angle is the
        smallest radian the first Vector3D object rotates until it aligns with the
        second Vector3D object.

        The `angleBetween()` method is a static method. You can use it directly as a method
        of the Vector3D class.

        To convert a degree to a radian, you can use the following formula:

        ```haxe
        radian = Math.PI/180 * degree
        ```

        @param	a	The first Vector3D object.
        @param	b	The second Vector3D object.
        @returns	The angle between two Vector3D objects.

    **/
    static angleBetween(a, b) {
        var la = a.length;
        var lb = b.length;
        var dot = a.dotProduct(b);
        if (la != 0) {
            dot /= la;
        }
        if (lb != 0) {
            dot /= lb;
        }
        return Math.acos(dot);
    }
    /**
        Returns a new Vector3D object that is an exact copy of the current Vector3D object.

        @returns	A new Vector3D object that is a copy of the current Vector3D object.
    **/
    clone() {
        return new Vector3D(this.x, this.y, this.z, this.w);
    }
    /**
        Copies all of vector data from the source Vector3D object into the calling Vector3D
        object.

        @param	sourceVector3D	The Vector3D object from which to copy the data.
    **/
    copyFrom(sourceVector3D) {
        this.x = sourceVector3D.x;
        this.y = sourceVector3D.y;
        this.z = sourceVector3D.z;
    }
    /**
        Returns a new Vector3D object that is perpendicular (at a right angle) to the
        current Vector3D and another Vector3D object. If the returned Vector3D object's
        coordinates are (0,0,0), then the two Vector3D objects are parallel to each other.

        ![Cross Product](/images/crossproduct.jpg)

        You can use the normalized cross product of two vertices of a polygon surface with
        the normalized vector of the camera or eye viewpoint to get a dot product. The
        value of the dot product can identify whether a surface of a three-dimensional
        object is hidden from the viewpoint.

        @param	a	A second Vector3D object.
        @returns	A new Vector3D object that is perpendicular to the current Vector3D
        object and the Vector3D object specified as the parameter.
    **/
    crossProduct(a) {
        return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
    }
    /**
        Decrements the value of the x, y, and z elements of the current Vector3D object by
        the values of the x, y, and z elements of specified Vector3D object. Unlike the
        `Vector3D.subtract()` method, the `decrementBy()` method changes the current
        Vector3D object and does not return a new Vector3D object.

        @param	a	The Vector3D object containing the values to subtract from the current
        Vector3D object.
    **/
    decrementBy(a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
    }
    /**
        Returns the distance between two Vector3D objects. The `distance()` method is a
        static method. You can use it directly as a method of the Vector3D class to get
        the Euclidean distance between two three-dimensional points.

        @param	pt1	A Vector3D object as the first three-dimensional point.
        @param	pt2	A Vector3D object as the second three-dimensional point.
        @returns	The distance between two Vector3D objects.
    **/
    static distance(pt1, pt2) {
        var x = pt2.x - pt1.x;
        var y = pt2.y - pt1.y;
        var z = pt2.z - pt1.z;
        return Math.sqrt(x * x + y * y + z * z);
    }
    /**
        If the current Vector3D object and the one specified as the parameter are unit
        vertices, this method returns the cosine of the angle between the two vertices.
        Unit vertices are vertices that point to the same direction but their length is
        one. They remove the length of the vector as a factor in the result. You can use
        the `normalize()` method to convert a vector to a unit vector.

        The `dotProduct()` method finds the angle between two vertices. It is also used in
        backface culling or lighting calculations. Backface culling is a procedure for
        determining which surfaces are hidden from the viewpoint. You can use the
        normalized vertices from the camera, or eye, viewpoint and the cross product of
        the vertices of a polygon surface to get the dot product. If the dot product is less
        than zero, then the surface is facing the camera or the viewer. If the two unit
        vertices are perpendicular to each other, they are orthogonal and the dot product
        is zero. If the two vertices are parallel to each other, the dot product is one.

        @param	a	The second Vector3D object.
        @returns	A scalar which is the dot product of the current Vector3D object and
        the specified Vector3D object.
    **/
    dotProduct(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    }
    /**
        Determines whether two Vector3D objects are equal by comparing the x, y, and z
        elements of the current Vector3D object with a specified Vector3D object. If the
        values of these elements are the same, the two Vector3D objects are equal. If the
        second optional parameter is set to `true`, all four elements of the Vector3D
        objects, including the `w` property, are compared.

        @param	toCompare	The Vector3D object to be compared with the current Vector3D
        object.
        @param	allFour	An optional parameter that specifies whether the `w` property of
        the Vector3D objects is used in the comparison.
        @returns	A value of `true` if the specified Vector3D object is equal to the current Vector3D object; `false` if it is not equal.
    **/
    equals(toCompare, allFour = false) {
        return this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w);
    }
    /**
        Increments the value of the x, y, and z elements of the current Vector3D object by
        the values of the x, y, and z elements of a specified Vector3D object. Unlike the
        `Vector3D.add()` method, the `incrementBy()` method changes the current Vector3D
        object and does not return a new Vector3D object.

        @param	a	The Vector3D object to be added to the current Vector3D object.
    **/
    incrementBy(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
    }
    /**
        Compares the elements of the current Vector3D object with the elements of a
        specified Vector3D object to determine whether they are nearly equal. The two
        Vector3D objects are nearly equal if the value of all the elements of the two
        vertices are equal, or the result of the comparison is within the tolerance range.
        The difference between two elements must be less than the number specified as the
        tolerance parameter. If the third optional parameter is set to true, all four
        elements of the Vector3D objects, including the w property, are compared.
        Otherwise, only the x, y, and z elements are included in the comparison.

        @param	toCompare	The Vector3D object to be compared with the current Vector3D
        object.
        @param	tolerance	A number determining the tolerance factor. If the difference
        between the values of the Vector3D element specified in the toCompare parameter
        and the current Vector3D element is less than the tolerance number, the two values
        are considered nearly equal.
        @param	allFour	An optional parameter that specifies whether the `w` property of
        the Vector3D objects is used in the comparison.
        @returns	A value of `true` if the specified Vector3D object is nearly equal to the current Vector3D object; `false` if it is not equal.
    **/
    nearEquals(toCompare, tolerance, allFour = false) {
        return Math.abs(this.x - toCompare.x) < tolerance
            && Math.abs(this.y - toCompare.y) < tolerance
            && Math.abs(this.z - toCompare.z) < tolerance
            && (!allFour || Math.abs(this.w - toCompare.w) < tolerance);
    }
    /**
        Sets the current Vector3D object to its inverse. The inverse object is also
        considered the opposite of the original object. The value of the `x`, `y`, and `z`
        properties of the current Vector3D object is changed to -x, -y, and -z.
    **/
    negate() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
    }
    /**
        Converts a Vector3D object to a unit vector by dividing the first three elements
        (x, y, z) by the length of the vector. Unit vertices are vertices that have a
        direction but their `length` is one. They simplify vector calculations by removing `length` as a factor.

        @returns	The length of the current Vector3D object.
    **/
    normalize() {
        var l = length;
        if (l != 0) {
            this.x /= l;
            this.y /= l;
            this.z /= l;
        }
        return l;
    }
    /**
        Divides the value of the `x`, `y`, and `z` properties of the current Vector3D
        object by the value of its `w` property.

        If the current Vector3D object is the result of multiplying a Vector3D object by a
        projection Matrix3D object, the `w` property can hold the transform value. The
        `project()` method then can complete the projection by dividing the elements by the
        `w` property. Use the Matrix3D.rawData property to create a projection Matrix3D
        object.
    **/
    project() {
        this.x /= this.w;
        this.y /= this.w;
        this.z /= this.w;
    }
    /**
        Scales the current Vector3D object by a scalar, a magnitude. The Vector3D object's
        x, y, and z elements are multiplied by the scalar number specified in the
        parameter. For example, if the vector is scaled by ten, the result is a vector
        that is ten times longer. The scalar can also change the direction of the vector.
        Multiplying the vector by a negative number reverses its direction.

        @param	s	A multiplier (scalar) used to scale a Vector3D object.
    **/
    scaleBy(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
    }
    /**
        Sets the members of Vector3D to the specified values

        @param	xa	the values to set the vector to.
        @param	ya
        @param	za
    **/
    setTo(xa, ya, za) {
        this.x = xa;
        this.y = ya;
        this.z = za;
    }
    /**
        Subtracts the value of the x, y, and z elements of the current Vector3D object
        from the values of the x, y, and z elements of another Vector3D object. The
        `subtract()` method does not change the current Vector3D object. Instead, this
        method returns a new Vector3D object with the new values.

        @param	a	The Vector3D object to be subtracted from the current Vector3D object.
        @returns	A new Vector3D object that is the difference between the current
        Vector3D and the specified Vector3D object.
    **/
    subtract(a) {
        return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
    }
    /**
        Returns a string representation of the current Vector3D object. The string contains
        the values of the x, y, and z properties.

        @returns	A string containing the values of the x, y, and z properties.
    **/
    toString() {
        return `Vector3D(${this.x}, ${this.y}, ${this.z})`;
    }
    // Getters & Setters
    /**
        The length, magnitude, of the current Vector3D object from the origin (0,0,0) to
        the object's x, y, and z coordinates. The `w` property is ignored. A unit vector has
        a length or magnitude of one.
    **/
    get length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    /**
        The square of the length of the current Vector3D object, calculated using the `x`,
        `y`, and `z` properties. The `w` property is ignored. Use the `lengthSquared()`
        method whenever possible instead of the slower `Math.sqrt()` method call of the
        `Vector3D.length()` method.
    **/
    get lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    /**
        The x axis defined as a Vector3D object with coordinates (1,0,0).
    **/
    static get X_AXIS() {
        return new Vector3D(1, 0, 0);
    }
    /**
        The y axis defined as a Vector3D object with coordinates (0,1,0).
    **/
    static get Y_AXIS() {
        return new Vector3D(0, 1, 0);
    }
    /**
        The z axis defined as a Vector3D object with coordinates (0,0,1).
    **/
    static get Z_AXIS() {
        return new Vector3D(0, 0, 1);
    }
}

var openfl$3;
(function (openfl) {
    var VectorDescriptor = {
        constructor: { value: null },
        concat: {
            value: function (a)
            {
                return Vector.ofArray(Array.prototype.concat.call(this, a));
            }
        },
        copy: {
            value: function ()
            {
                return Vector.ofArray(this);
            }
        },
        filter: {
            value: function (callback)
            {
                return Vector.ofArray(Array.prototype.filter.call(this, callback));
            }
        },
        get: {
            value: function (index)
            {
                return this[index];
            }
        },
        insertAt: {
            value: function (index, element)
            {
                if (!this.fixed || index < this.length)
                {
                    Array.prototype.splice.call(this, index, 0, element);
                }
            }
        },
        lastIndexOf: {
            value: function (x, from)
            {
                if (from == null)
                {
                    return Array.prototype.lastIndexOf.call(this, x);
                } else
                {
                    return Array.prototype.lastIndexOf.call(this, x, from);
                }
            }
        },
        pop: {
            value: function ()
            {
                if (!this.fixed)
                {
                    return Array.prototype.pop.call(this);
                } else
                {
                    return null;
                }
            }
        },
        push: {
            value: function (x)
            {
                if (!this.fixed)
                {
                    return Array.prototype.push.call(this, x);
                } else
                {
                    return this.length;
                }
            }
        },
        removeAt: {
            value: function (index)
            {
                if (!this.fixed || index < this.length)
                {
                    return Array.prototype.splice.call(this, index, 1)[0];
                }
                return null;
            }
        },
        set: {
            value: function (index, value)
            {
                if (!this.fixed || index < this.length)
                {
                    return this[index] = value;
                } else
                {
                    return value;
                }
            }
        },
        shift: {
            value: function ()
            {
                if (!this.fixed)
                {
                    return Array.prototype.shift.call(this);
                } else
                {
                    return null;
                }
            }
        },
        slice: {
            value: function (startIndex, endIndex)
            {
                if (startIndex == null)
                {
                    startIndex = 0;
                }
                if (endIndex == null)
                {
                    endIndex = 16777215;
                }
                return Vector.ofArray(Array.prototype.slice.call(this, startIndex, endIndex));
            }
        },
        splice: {
            value: function (pos, len)
            {
                return Vector.ofArray(Array.prototype.splice.call(this, pos, len));
            }
        },
        unshift: {
            value: function (x)
            {
                if (!this.fixed)
                {
                    Array.prototype.unshift.call(this, x);
                }
            }
        },
        get_length: {
            value: function ()
            {
                return this.length;
            }
        },
        set_length: {
            value: function (value)
            {
                if (!this.fixed)
                {
                    this.length = value;
                }
                return value;
            }
        }
    };

    var Vector = function (length, fixed, array) {
        if (array == null) array = [];
        if (length != null)
        {
            array.length = length;
        }
        array.fixed = fixed == true;
        return Object.defineProperties(array, VectorDescriptor);
    };

    Vector.ofArray = function (array) {
        if (array == null)
        {
            return null;
        }
        var data = new Vector();
        var i = 0;
        var count = a.length;
        while (i < count)
        {
            data[i] = array[i];
            i++;
        }
        return data;
    };

    Vector.name = "Vector";
    openfl.Vector = Vector;
})(openfl$3 || (openfl$3 = {}));
var Vector = openfl$3.Vector;

/**
    The Matrix3D class represents a transformation matrix that determines the position and
    orientation of a three-dimensional (3D) display object. The matrix can perform
    transformation functions including translation (repositioning along the x, y, and z
    axes), rotation, and scaling (resizing). The Matrix3D class can also perform
    perspective projection, which maps points from the 3D coordinate space to a
    two-dimensional (2D) view.

    A single matrix can combine multiple transformations and apply them at once to a 3D
    display object. For example, a matrix can be applied to 3D coordinates to perform a
    rotation followed by a translation.

    When you explicitly set the `z` property or any of the rotation or scaling properties
    of a display object, a corresponding Matrix3D object is automatically created.

    You can access a 3D display object's Matrix3D object through the `transform.matrix3d`
    property. 2D objects do not have a Matrix3D object.

    The value of the `z` property of a 2D object is zero and the value of its `matrix3D`
    property is `null`.

    **Note:** If the same Matrix3D object is assigned to two different display objects, a
    runtime error is thrown.

    The Matrix3D class uses a 4x4 square matrix: a table of four rows and columns of
    numbers that hold the data for the transformation. The first three rows of the matrix
    hold data for each 3D axis (x,y,z). The translation information is in the last column.
    The orientation and scaling data are in the first three columns. The scaling factors
    are the diagonal numbers in the first three columns. Here is a representation of
    Matrix3D elements:

    ![Matrix3D elements](/images/Matrix3Delements.jpg)

    You don't need to understand matrix mathematics to use the Matrix3D class. It offers
    specific methods that simplify the task of transformation and projection, such as the
    `appendTranslation()`, `appendRotation()`, or `interpolateTo()` methods. You also can
    use the `decompose()` and `recompose()` methods or the `rawData` property to access
    the underlying matrix elements.

    Display objects cache their axis rotation properties to have separate rotation for
    each axis and to manage the different combinations of rotations. When a method of a
    Matrix3D object is called to transform a display object, the rotation cache of the
    object is invalidated.
**/
class Matrix3D {
    constructor(v = null) {
        if (v != null && v.length == 16) {
            this.rawData = v.concat();
        }
        else {
            this.rawData = Vector.ofArray([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);
        }
    }
    /**
        A Vector of 16 Numbers, where every four elements is a column of a 4x4 matrix.

        An exception is thrown if the `rawData` property is set to a matrix that is not
        invertible. The Matrix3D object must be invertible. If a non-invertible matrix is
        needed, create a subclass of the Matrix3D object.
    **/
    append(lhs) {
        var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
    }
    /**
        Appends an incremental rotation to a Matrix3D object. When the Matrix3D object is
        applied to a display object, the matrix performs the rotation after other
        transformations in the Matrix3D object.

        The display object's rotation is defined by an axis, an incremental degree of
        rotation around the axis, and an optional pivot point for the center of the
        object's rotation. The axis can be any general direction. The common axes are the
        `X_AXIS (Vector3D(1,0,0))`, `Y_AXIS (Vector3D(0,1,0))`, and
        `Z_AXIS (Vector3D(0,0,1))`. In aviation terminology, the rotation about the y axis
        is called yaw. The rotation about the x axis is called pitch. The rotation about
        the z axis is called roll.

        The order of transformation matters. A rotation followed by a translation
        transformation produces a different effect than a translation followed by a
        rotation transformation.

        The rotation effect is not absolute. It is relative to the current position and
        orientation. To make an absolute change to the transformation matrix, use the
        `recompose()` method. The `appendRotation()` method is also different from the
        axis rotation property of the display object, such as `rotationX` property. The
        `rotation` property is always performed before any translation, whereas the
        `appendRotation()` method is performed relative to what is already in the matrix.
        To make sure that you get a similar effect as the display object's axis rotation
        property, use the `prependRotation()` method, which performs the rotation before
        other transformations in the matrix.

        When the `appendRotation()` method's transformation is applied to a Matrix3D object
        of a display object, the cached rotation property values of the display object
        are invalidated.

        One way to have a display object rotate around a specific point relative to its
        location is to set the translation of the object to the specified point, rotate
        the object using the `appendRotation()` method, and translate the object back to
        the original position. In the following example, the myObject 3D display object
        makes a y-axis rotation around the coordinate (10,10,0).

        ```haxe
        myObject.z = 1;
        myObject.transform.matrix3D.appendTranslation(10,10,0);
        myObject.transform.matrix3D.appendRotation(1, Vector3D.Y_AXIS);
        myObject.transform.matrix3D.appendTranslation(-10,-10,0);
        ```

        @param	degrees	The degree of the rotation.
        @param	axis	The axis or direction of rotation. The usual axes are the
        `X_AXIS (Vector3D(1,0,0))`, `Y_AXIS (Vector3D(0,1,0))`, and
        `Z_AXIS (Vector3D(0,0,1))`. This vector should have a length of one.
        @param	pivotPoint	A point that determines the center of an object's rotation.
        The default pivot point for an object is its registration point.
    **/
    appendRotation(degrees, axis, pivotPoint = null) {
        var tx, ty, tz;
        tx = ty = tz = 0;
        if (pivotPoint != null) {
            tx = pivotPoint.x;
            ty = pivotPoint.y;
            tz = pivotPoint.z;
        }
        var radian = degrees * Math.PI / 180;
        var cos = Math.cos(radian);
        var sin = Math.sin(radian);
        var x = axis.x;
        var y = axis.y;
        var z = axis.z;
        var x2 = x * x;
        var y2 = y * y;
        var z2 = z * z;
        var ls = x2 + y2 + z2;
        if (ls != 0) {
            var l = Math.sqrt(ls);
            x /= l;
            y /= l;
            z /= l;
            x2 /= ls;
            y2 /= ls;
            z2 /= ls;
        }
        var ccos = 1 - cos;
        var m = new Matrix3D();
        var d = m.rawData;
        d[0] = x2 + (y2 + z2) * cos;
        d[1] = x * y * ccos + z * sin;
        d[2] = x * z * ccos - y * sin;
        d[4] = x * y * ccos - z * sin;
        d[5] = y2 + (x2 + z2) * cos;
        d[6] = y * z * ccos + x * sin;
        d[8] = x * z * ccos + y * sin;
        d[9] = y * z * ccos - x * sin;
        d[10] = z2 + (x2 + y2) * cos;
        d[12] = (tx * (y2 + z2) - x * (ty * y + tz * z)) * ccos + (ty * z - tz * y) * sin;
        d[13] = (ty * (x2 + z2) - y * (tx * x + tz * z)) * ccos + (tz * x - tx * z) * sin;
        d[14] = (tz * (x2 + y2) - z * (tx * x + ty * y)) * ccos + (tx * y - ty * x) * sin;
        this.append(m);
    }
    /**
        Appends an incremental scale change along the x, y, and z axes to a Matrix3D
        object. When the Matrix3D object is applied to a display object, the matrix
        performs the scale changes after other transformations in the Matrix3D object.
        The default scale factor is (1.0, 1.0, 1.0).

        The scale is defined as a set of three incremental changes along the three axes
        (x,y,z). You can multiply each axis with a different number. When the scale
        changes are applied to a display object, the object's size increases or decreases.
        For example, setting the x, y, and z axes to two doubles the size of the object,
        while setting the axes to 0.5 halves the size. To make sure that the scale
        transformation only affects a specific axis, set the other parameters to one. A
        parameter of one means no scale change along the specific axis.

        The `appendScale()` method can be used for resizing as well as for managing
        distortions, such as stretch or contract of a display object, or for zooming in
        and out on a location. Scale transformations are automatically performed during a
        display object's rotation and translation.

        The order of transformation matters. A resizing followed by a translation
        transformation produces a different effect than a translation followed by a
        resizing transformation.

        @param	xScale	A multiplier used to scale the object along the x axis.
        @param	yScale	A multiplier used to scale the object along the y axis.
        @param	zScale	A multiplier used to scale the object along the z axis.
    **/
    appendScale(xScale, yScale, zScale) {
        this.append(new Matrix3D(Vector.ofArray([
            xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, zScale, 0.0, 0.0, 0.0, 0.0, 1.0
        ])));
    }
    /**
        Appends an incremental translation, a repositioning along the x, y, and z axes,
        to a Matrix3D object. When the Matrix3D object is applied to a display object,
        the matrix performs the translation changes after other transformations in the
        Matrix3D object.

        The translation is defined as a set of three incremental changes along the
        three axes (x,y,z). When the transformation is applied to a display object, the
        display object moves from it current location along the x, y, and z axes as
        specified by the parameters. To make sure that the translation only affects a
        specific axis, set the other parameters to zero. A zero parameter means no change
        along the specific axis.

        The translation changes are not absolute. They are relative to the current
        position and orientation of the matrix. To make an absolute change to the
        transformation matrix, use the recompose() method. The order of transformation
        also matters. A translation followed by a rotation transformation produces a
        different effect than a rotation followed by a translation.

        @param	x	An incremental translation along the x axis.
        @param	y	An incremental translation along the y axis.
        @param	z	An incremental translation along the z axis.
    **/
    appendTranslation(x, y, z) {
        this.rawData[12] += x;
        this.rawData[13] += y;
        this.rawData[14] += z;
    }
    /**
        Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.

        @returns	A new Matrix3D object that is an exact copy of the current Matrix3D
        object.
    **/
    clone() {
        return new Matrix3D(this.rawData.copy());
    }
    /**
        Copies a Vector3D object into specific column of the calling Matrix3D object.

        @param	column	The destination column of the copy.
        @param	vector3D	The Vector3D object from which to copy the data.
    **/
    copyColumnFrom(column, vector3D) {
        switch (column) {
            case 0:
                this.rawData[0] = vector3D.x;
                this.rawData[1] = vector3D.y;
                this.rawData[2] = vector3D.z;
                this.rawData[3] = vector3D.w;
                break;
            case 1:
                this.rawData[4] = vector3D.x;
                this.rawData[5] = vector3D.y;
                this.rawData[6] = vector3D.z;
                this.rawData[7] = vector3D.w;
                break;
            case 2:
                this.rawData[8] = vector3D.x;
                this.rawData[9] = vector3D.y;
                this.rawData[10] = vector3D.z;
                this.rawData[11] = vector3D.w;
                break;
            case 3:
                this.rawData[12] = vector3D.x;
                this.rawData[13] = vector3D.y;
                this.rawData[14] = vector3D.z;
                this.rawData[15] = vector3D.w;
                break;
        }
    }
    /**
        Copies specific column of the calling Matrix3D object into the Vector3D object.

        @param	column	The column from which to copy the data.
        @param	vector3D	The destination Vector3D object of the copy.
    **/
    copyColumnTo(column, vector3D) {
        switch (column) {
            case 0:
                vector3D.x = this.rawData[0];
                vector3D.y = this.rawData[1];
                vector3D.z = this.rawData[2];
                vector3D.w = this.rawData[3];
                break;
            case 1:
                vector3D.x = this.rawData[4];
                vector3D.y = this.rawData[5];
                vector3D.z = this.rawData[6];
                vector3D.w = this.rawData[7];
                break;
            case 2:
                vector3D.x = this.rawData[8];
                vector3D.y = this.rawData[9];
                vector3D.z = this.rawData[10];
                vector3D.w = this.rawData[11];
                break;
            case 3:
                vector3D.x = this.rawData[12];
                vector3D.y = this.rawData[13];
                vector3D.z = this.rawData[14];
                vector3D.w = this.rawData[15];
                break;
        }
    }
    /**
        Copies all of the matrix data from the source Matrix3D object into the calling
        Matrix3D object.

        @param	sourceMatrix3D	The Matrix3D object from which to copy the data.
    **/
    copyFrom(other) {
        this.rawData = other.rawData.copy();
    }
    /**
        Copies all of the vector data from the source vector object into the calling
        Matrix3D object. The optional `index` parameter allows you to select any starting
        slot in the vector.

        @param	vector	The vector object from which to copy the data.
        @param	index
        @param	transpose
    **/
    copyRawDataFrom(vector, index = 0, transpose = false) {
        if (transpose) {
            this.transpose();
        }
        var length = vector.length - index;
        for (let i = 0; i < length; i++) {
            this.rawData[i] = vector[i + index];
        }
        if (transpose) {
            this.transpose();
        }
    }
    /**
        Copies all of the matrix data from the calling Matrix3D object into the
        provided vector. The optional index parameter allows you to select any target
        starting slot in the vector.

        @param	vector	The vector object to which to copy the data.
        @param	index
        @param	transpose
    **/
    copyRawDataTo(vector, index = 0, transpose = false) {
        if (transpose) {
            this.transpose();
        }
        for (let i = 0; i < this.rawData.length; i++) {
            vector[i + index] = this.rawData[i];
        }
        if (transpose) {
            this.transpose();
        }
    }
    /**
        Copies a Vector3D object into specific row of the calling Matrix3D object.

        @param	row	The row from which to copy the data to.
        @param	vector3D	The Vector3D object from which to copy the data.
    **/
    copyRowFrom(row, vector3D) {
        switch (row) {
            case 0:
                this.rawData[0] = vector3D.x;
                this.rawData[4] = vector3D.y;
                this.rawData[8] = vector3D.z;
                this.rawData[12] = vector3D.w;
                break;
            case 1:
                this.rawData[1] = vector3D.x;
                this.rawData[5] = vector3D.y;
                this.rawData[9] = vector3D.z;
                this.rawData[13] = vector3D.w;
                break;
            case 2:
                this.rawData[2] = vector3D.x;
                this.rawData[6] = vector3D.y;
                this.rawData[10] = vector3D.z;
                this.rawData[14] = vector3D.w;
                break;
            case 3:
                this.rawData[3] = vector3D.x;
                this.rawData[7] = vector3D.y;
                this.rawData[11] = vector3D.z;
                this.rawData[15] = vector3D.w;
                break;
        }
    }
    /**
        Copies specific row of the calling Matrix3D object into the Vector3D object.

        @param	row	The row from which to copy the data from.
        @param	vector3D	The Vector3D object to copy the data into.
    **/
    copyRowTo(row, vector3D) {
        switch (row) {
            case 0:
                vector3D.x = this.rawData[0];
                vector3D.y = this.rawData[4];
                vector3D.z = this.rawData[8];
                vector3D.w = this.rawData[12];
                break;
            case 1:
                vector3D.x = this.rawData[1];
                vector3D.y = this.rawData[5];
                vector3D.z = this.rawData[9];
                vector3D.w = this.rawData[13];
                break;
            case 2:
                vector3D.x = this.rawData[2];
                vector3D.y = this.rawData[6];
                vector3D.z = this.rawData[10];
                vector3D.w = this.rawData[14];
                break;
            case 3:
                vector3D.x = this.rawData[3];
                vector3D.y = this.rawData[7];
                vector3D.z = this.rawData[11];
                vector3D.w = this.rawData[15];
                break;
        }
    }
    /**
        @param	other
    **/
    copyToMatrix3D(other) {
        other.rawData = this.rawData.copy();
    }
    /**
        Returns the transformation matrix's translation, rotation, and scale settings as
        a Vector of three Vector3D objects. The first Vector3D object holds the
        translation elements. The second Vector3D object holds the rotation elements.
        The third Vector3D object holds the scale elements.

        Some Matrix3D methods, such as the `interpolateTo()` method, automatically
        decompose and recompose the matrix to perform their transformation.

        To modify the matrix's transformation with an absolute parent frame of reference,
        retrieve the settings with the `decompose()` method and make the appropriate
        changes. You can then set the Matrix3D object to the modified transformation
        using the `recompose()` method.

        The `decompose()` method's parameter specifies the orientation style that is
        meant to be used for the transformation. The default orientation is `eulerAngles`,
        which defines the orientation with three separate angles of rotation for each
        axis. The rotations occur consecutively and do not change the axis of each other.
        The display object's axis rotation properties perform Euler Angles orientation
        style transformation. The other orientation style options are `axisAngle` and
        `quaternion`. The Axis Angle orientation uses a combination of an axis and an
        angle to determine the orientation. The axis around which the object is rotated
        is a unit vector that represents a direction. The angle represents the magnitude
        of the rotation about the vector. The direction also determines where a display
        object is facing and the angle determines which way is up. The `appendRotation()`
        and `prependRotation()` methods use the Axis Angle orientation. The `quaternion`
        orientation uses complex numbers and the fourth element of a vector. The three
        axes of rotation (x,y,z) and an angle of rotation (w) represent the orientation.
        The `interpolate()` method uses quaternion.

        @param	orientationStyle	An optional parameter that determines the orientation
        style used for the matrix transformation. The three types of orientation style
        are `eulerAngles` (constant `EULER_ANGLES`), `axisAngle` (constant `AXIS_ANGLE`),
        and `quaternion` (constant `QUATERNION`). For additional information on the
        different orientation style, see the geom.Orientation3D class.
        @returns	A Vector of three Vector3D objects, each holding the translation,
        rotation, and scale settings, respectively.
    **/
    decompose(orientationStyle = Orientation3D.EULER_ANGLES) {
        var vec = new Vector();
        var m = this.clone();
        var mr = m.rawData.copy();
        var pos = new Vector3D(mr[12], mr[13], mr[14]);
        mr[12] = 0;
        mr[13] = 0;
        mr[14] = 0;
        var scale = new Vector3D();
        scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
        scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
        scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
        if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0) {
            scale.z = -scale.z;
        }
        mr[0] /= scale.x;
        mr[1] /= scale.x;
        mr[2] /= scale.x;
        mr[4] /= scale.y;
        mr[5] /= scale.y;
        mr[6] /= scale.y;
        mr[8] /= scale.z;
        mr[9] /= scale.z;
        mr[10] /= scale.z;
        var rot = new Vector3D();
        switch (orientationStyle) {
            case Orientation3D.AXIS_ANGLE:
                rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
                var len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
                if (len != 0) {
                    rot.x = (mr[6] - mr[9]) / len;
                    rot.y = (mr[8] - mr[2]) / len;
                    rot.z = (mr[1] - mr[4]) / len;
                }
                else {
                    rot.x = rot.y = rot.z = 0;
                }
                break;
            case Orientation3D.QUATERNION:
                var tr = mr[0] + mr[5] + mr[10];
                if (tr > 0) {
                    rot.w = Math.sqrt(1 + tr) / 2;
                    rot.x = (mr[6] - mr[9]) / (4 * rot.w);
                    rot.y = (mr[8] - mr[2]) / (4 * rot.w);
                    rot.z = (mr[1] - mr[4]) / (4 * rot.w);
                }
                else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                    rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                    rot.w = (mr[6] - mr[9]) / (4 * rot.x);
                    rot.y = (mr[1] + mr[4]) / (4 * rot.x);
                    rot.z = (mr[8] + mr[2]) / (4 * rot.x);
                }
                else if (mr[5] > mr[10]) {
                    rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                    rot.x = (mr[1] + mr[4]) / (4 * rot.y);
                    rot.w = (mr[8] - mr[2]) / (4 * rot.y);
                    rot.z = (mr[6] + mr[9]) / (4 * rot.y);
                }
                else {
                    rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                    rot.x = (mr[8] + mr[2]) / (4 * rot.z);
                    rot.y = (mr[6] + mr[9]) / (4 * rot.z);
                    rot.w = (mr[1] - mr[4]) / (4 * rot.z);
                }
                break;
            case Orientation3D.EULER_ANGLES:
                rot.y = Math.asin(-mr[2]);
                if (mr[2] != 1 && mr[2] != -1) {
                    rot.x = Math.atan2(mr[6], mr[10]);
                    rot.z = Math.atan2(mr[1], mr[0]);
                }
                else {
                    rot.z = 0;
                    rot.x = Math.atan2(mr[4], mr[5]);
                }
                break;
        }
        vec.push(pos);
        vec.push(rot);
        vec.push(scale);
        return vec;
    }
    /**
        Uses the transformation matrix without its translation elements to transform a
        Vector3D object from one space coordinate to another. The returned Vector3D
        object holds the new coordinates after the rotation and scaling transformations
        have been applied. If the `deltaTransformVector()` method applies a matrix that
        only contains a translation transformation, the returned Vector3D is the same as
        the original Vector3D object.

        You can use the `deltaTransformVector()` method to have a display object in one
        coordinate space respond to the rotation transformation of a second display
        object. The object does not copy the rotation; it only changes its position to
        reflect the changes in the rotation. For example, to use the display.Graphics
        API for drawing a rotating 3D display object, you must map the object's rotating
        coordinates to a 2D point. First, retrieve the object's 3D coordinates after each
        rotation, using the `deltaTransformVector()` method. Next, apply the display
        object's `local3DToGlobal()` method to translate the 3D coordinates to 2D points.
        You can then use the 2D points to draw the rotating 3D object.

        **Note:** This method automatically sets the `w` component of the passed Vector3D
        to 0.0.

        @param	v	A Vector3D object holding the coordinates that are going to be
        transformed.
        @returns	Vector3D	A Vector3D object with the transformed coordinates.
    **/
    deltaTransformVector(v) {
        var x = v.x, y = v.y, z = v.z;
        return new Vector3D((x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8]), (x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9]), (x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10]), (x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11]));
    }
    /**
        Converts the current matrix to an identity or unit matrix. An identity matrix has
        a value of one for the elements on the main diagonal and a value of zero for all
        other elements. The result is a matrix where the rawData value is
        1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1 and the rotation setting is set to
        `Vector3D(0,0,0)`, the position or translation setting is set to `Vector3D(0,0,0)`,
        and the scale is set to `Vector3D(1,1,1)`. Here is a representation of an
        identity matrix.

        ![Identity Matrix](/images/identityMatrix.jpg)

        An object transformed by applying an identity matrix performs no transformation.
        In other words, if a matrix is multiplied by an identity matrix, the result is a
        matrix that is the same as (identical to) the original matrix.
    **/
    identity() {
        this.rawData = Vector.ofArray([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);
    }
    /**
        Interpolates the translation, rotation, and scale transformation of one matrix
        toward those of the target matrix.

        The `interpolate()` method avoids some of the unwanted results that can occur
        when using methods such as the display object's axis rotation properties. The
        `interpolate()` method invalidates the cached value of the rotation property of
        the display object and converts the orientation elements of the display object's
        matrix to a quaternion before interpolation. This method guarantees the shortest,
        most efficient path for the rotation. It also produces a smooth, gimbal-lock-free
        rotation. A gimbal lock can occur when using Euler Angles, where each axis is
        handled independently. During the rotation around two or more axes, the axes can
        become aligned, leading to unexpected results. Quaternion rotation avoids the
        gimbal lock.

        Consecutive calls to the `interpolate()` method can produce the effect of a
        display object starting quickly and then slowly approaching another display
        object. For example, if you set the `thisMat` parameter to the returned Matrix3D
        object, the `toMat` parameter to the target display object's associated Matrix3D
        object, and the `percent` parameter to 0.1, the display object moves ten percent
        toward the target object. On subsequent calls or in subsequent frames, the object
        moves ten percent of the remaining 90 percent, then ten percent of the remaining
        distance, and continues until it reaches the target.

        @param	thisMat	The Matrix3D object that is to be interpolated.
        @param	toMat	The target Matrix3D object.
        @param	percent	A value between 0 and 1 that determines the percent the
        `thisMat` Matrix3D object is interpolated toward the target Matrix3D object.
        @returns	A Matrix3D object with elements that place the values of the matrix
        between the original matrix and the target matrix. When the returned matrix is
        applied to the this display object, the object moves the specified percent closer
        to the target object.
    **/
    static interpolate(thisMat, toMat, percent) {
        var m = new Matrix3D();
        for (let i = 0; i < 16; i++) {
            m.rawData[i] = thisMat.rawData[i] + (toMat.rawData[i] - thisMat.rawData[i]) * percent;
        }
        return m;
    }
    /**
        Interpolates this matrix towards the translation, rotation, and scale
        transformations of the target matrix.

        The `interpolateTo()` method avoids the unwanted results that can occur when
        using methods such as the display object's axis rotation properties. The
        `interpolateTo()` method invalidates the cached value of the rotation property of
        the display object and converts the orientation elements of the display object's
        matrix to a quaternion before interpolation. This method guarantees the shortest,
        most efficient path for the rotation. It also produces a smooth, gimbal-lock-free
        rotation. A gimbal lock can occur when using Euler Angles, where each axis is
        handled independently. During the rotation around two or more axes, the axes can
        become aligned, leading to unexpected results. Quaternion rotation avoids the
        gimbal lock.

        **Note:** In case of interpolation, the scaling value of the matrix will reset and
        the matrix will be normalized.

        Consecutive calls to the `interpolateTo()` method can produce the effect of a
        display object starting quickly and then slowly approaching another display
        object. For example, if the percent parameter is set to 0.1, the display object
        moves ten percent toward the target object specified by the `toMat` parameter.
        On subsequent calls or in subsequent frames, the object moves ten percent of the
        remaining 90 percent, then ten percent of the remaining distance, and continues
        until it reaches the target.

        @param	toMat	The target Matrix3D object.
        @param	percent	A value between 0 and 1 that determines the location of the
        display object relative to the target. The closer the value is to 1.0, the closer
        the display object is to its current position. The closer the value is to 0, the
        closer the display object is to the target.
    **/
    interpolateTo(toMat, percent) {
        for (let i = 0; i < 16; i++) {
            this.rawData[i] = this.rawData[i] + (toMat.rawData[i] - this.rawData[i]) * percent;
        }
    }
    /**
        Inverts the current matrix. An inverted matrix is the same size as the original
        but performs the opposite transformation of the original matrix. For example, if
        the original matrix has an object rotate around the x axis in one direction, the
        inverse of the matrix will have the object rotate around the axis in the opposite
        direction. Applying an inverted matrix to an object undoes the transformation
        performed by the original matrix. If a matrix is multiplied by its inverse
        matrix, the result is an identity matrix.

        An inverse of a matrix can be used to divide one matrix by another. The way to
        divide matrix A by matrix B is to multiply matrix A by the inverse of matrix B.
        The inverse matrix can also be used with a camera space. When the camera moves in
        the world space, the object in the world needs to move in the opposite direction
        to transform from the world view to the camera or view space. For example, if the
        camera moves closer, the objects becomes bigger. In other words, if the camera
        moves down the world z axis, the object moves up world z axis.

        The `invert()` method replaces the current matrix with an inverted matrix. If you
        want to invert a matrix without altering the current matrix, first copy the
        current matrix by using the clone() method and then apply the `invert()` method
        to the copy.

        The Matrix3D object must be invertible.

        @returns	Returns `true` if the matrix was successfully inverted.
    **/
    invert() {
        var d = this.determinant;
        var invertable = Math.abs(d) > 0.00000000001;
        if (invertable) {
            d = 1 / d;
            var m11 = this.rawData[0];
            var m21 = this.rawData[4];
            var m31 = this.rawData[8];
            var m41 = this.rawData[12];
            var m12 = this.rawData[1];
            var m22 = this.rawData[5];
            var m32 = this.rawData[9];
            var m42 = this.rawData[13];
            var m13 = this.rawData[2];
            var m23 = this.rawData[6];
            var m33 = this.rawData[10];
            var m43 = this.rawData[14];
            var m14 = this.rawData[3];
            var m24 = this.rawData[7];
            var m34 = this.rawData[11];
            var m44 = this.rawData[15];
            this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
            this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
            this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
            this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
            this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
            this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
            this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
            this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
            this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
            this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
            this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
            this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
            this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
            this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
            this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
            this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
        }
        return invertable;
    }
    /**
        Rotates the display object so that it faces a specified position. This method
        allows for an in-place modification to the orientation. The forward direction
        vector of the display object (the at Vector3D object) points at the specified
        world-relative position. The display object's up direction is specified with the
        up Vector3D object.

        The `pointAt()` method invalidates the cached rotation property value of the
        display object. The method decomposes the display object's matrix and modifies the
        rotation elements to have the object turn to the specified position. It then
        recomposes (updates) the display object's matrix, which performs the
        transformation. If the object is pointing at a moving target, such as a moving
        object's position, then with each subsequent call, the method has the object
        rotate toward the moving target.

        **Note:** If you use the `Matrix3D.pointAt()` method without setting the
        optional parameters, a target object does not face the specified world-relative
        position by default. You need to set the values for at to the -y-axis (0,-1,0)
        and up to the -z axis (0,0,-1).

        @param	pos	The world-relative position of the target object. World-relative
        defines the object's transformation relative to the world space and coordinates,
        where all objects are positioned.
        @param	at	The object-relative vector that defines where the display object is
        pointing. Object-relative defines the object's transformation relative to the
        object space, the object's own frame of reference and coordinate system. Default
        value is the +y axis (0,1,0).
        @param	up	The object-relative vector that defines "up" for the display object.
        If the object is drawn looking down from above, the +z axis is its "up" vector.
        Object-relative defines the object's transformation relative to the object space,
        the object's own frame of reference and coordinate system. Default value is the
        +z-axis (0,0,1).
    **/
    pointAt(pos, at = null, up = null) {
        /**

            TODO: Need to fix this method

            ```
            trace ("[0.7071067690849304,0,-0.7071067690849304,0,0.5773502588272095,0.5773502588272095,0.5773502588272095,0,0.40824827551841736,-0.8164965510368347,0.40824827551841736,0,0,0,0,1]");

            var matrix3D = new Matrix3D ();
            matrix3D.pointAt (new Vector3D (2, 2, 2, 2), new Vector3D (0, 1, 0, 0), new Vector3D (0, 0, 1, 0));
            ```

            Below is progress toward the solution (I think), the current implementation is broken

            I believe the Flash implementation returns an identity matrix if at and/or up are not normalized

        **/
        // zaxis = normal(Eye - At)
        // xaxis = normal(cross(Up, zaxis))
        // yaxis = cross(zaxis, xaxis)
        // xaxis.x           yaxis.x           zaxis.x          0
        // xaxis.y           yaxis.y           zaxis.y          0
        // xaxis.z           yaxis.z           zaxis.z          0
        // dot(xaxis, eye)   dot(yaxis, eye)   dot(zaxis, eye)  1
        // if (at == null) at = new Vector3D (0, 1, 0);
        // if (up == null) up = new Vector3D (0, 0, 1);
        // eye = position;
        // target = pos;
        // // how to include `at`?
        // zaxis = eye.subtract (target);
        // zaxis.normalize ();
        // // zaxis = zaxis.crossProduct (at);
        // // zaxis.normalize ();
        // xaxis = up.crossProduct (zaxis);
        // xaxis.normalize ();
        // yaxis = zaxis.crossProduct (xaxis);
        // dec = decompose (QUATERNION);
        // rawData[0] = xaxis.x;
        // rawData[1] = xaxis.y;
        // rawData[2] = xaxis.z;
        // rawData[3] = xaxis.dotProduct (eye);
        // rawData[4] = yaxis.x;
        // rawData[5] = yaxis.y;
        // rawData[6] = yaxis.z;
        // rawData[7] = yaxis.dotProduct (eye);
        // rawData[8] = zaxis.x;
        // rawData[9] = zaxis.y;
        // rawData[10] = zaxis.z;
        // rawData[11] = zaxis.dotProduct (eye);
        // rawData[12] = 0;
        // rawData[13] = 0;
        // rawData[14] = 0;
        // rawData[15] = 1.0;
        // dec2 = decompose (QUATERNION);
        // dec[1] = dec2[1];
        // recompose (dec, QUATERNION);
        // rawData[0] = xaxis.x;
        // rawData[4] = xaxis.y;
        // rawData[8] = xaxis.z;
        // rawData[12] = xaxis.dotProduct (eye);
        // rawData[1] = yaxis.x;
        // rawData[5] = yaxis.y;
        // rawData[9] = yaxis.z;
        // rawData[13] = yaxis.dotProduct (eye);
        // rawData[2] = zaxis.x;
        // rawData[6] = zaxis.y;
        // rawData[10] = zaxis.z;
        // rawData[14] = zaxis.dotProduct (eye);
        // rawData[3] = 0;
        // rawData[7] = 0;
        // rawData[11] = 0;
        // rawData[15] = 1.0;
        /** **/
        if (at == null) {
            at = new Vector3D(0, 0, -1);
        }
        if (up == null) {
            up = new Vector3D(0, -1, 0);
        }
        var dir = at.subtract(pos);
        var vup = up.clone();
        var right;
        dir.normalize();
        vup.normalize();
        var dir2 = dir.clone();
        dir2.scaleBy(vup.dotProduct(dir));
        vup = vup.subtract(dir2);
        if (vup.length > 0) {
            vup.normalize();
        }
        else {
            if (dir.x != 0) {
                vup = new Vector3D(-dir.y, dir.x, 0);
            }
            else {
                vup = new Vector3D(1, 0, 0);
            }
        }
        right = vup.crossProduct(dir);
        right.normalize();
        this.rawData[0] = right.x;
        this.rawData[4] = right.y;
        this.rawData[8] = right.z;
        this.rawData[12] = 0.0;
        this.rawData[1] = vup.x;
        this.rawData[5] = vup.y;
        this.rawData[9] = vup.z;
        this.rawData[13] = 0.0;
        this.rawData[2] = dir.x;
        this.rawData[6] = dir.y;
        this.rawData[10] = dir.z;
        this.rawData[14] = 0.0;
        this.rawData[3] = pos.x;
        this.rawData[7] = pos.y;
        this.rawData[11] = pos.z;
        this.rawData[15] = 1.0;
    }
    /**
        Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D
        object. The result combines both matrix transformations.

        Matrix multiplication is different from matrix addition. Matrix multiplication is
        not commutative. In other words, A times B is not equal to B times A. With the
        `prepend()` method, the multiplication happens from the right side, meaning the `rhs`
        Matrix3D object is on the right side of the multiplication operator.

        ```haxe
        thisMatrix = thisMatrix * rhs
        ```

        The modifications made by `prepend()` method are object-space-relative. In other
        words, they are always relative to the object's initial frame of reference.

        The `prepend()` method replaces the current matrix with the prepended matrix. If
        you want to prepend two matrixes without altering the current matrix, first copy
        the current matrix by using the `clone()` method and then apply the `prepend()`
        method to the copy.

        @param	rhs	A right-hand-side of the matrix by which the current Matrix3D is
        multiplied.
    **/
    prepend(rhs) {
        var m111 = rhs.rawData[0], m121 = rhs.rawData[4], m131 = rhs.rawData[8], m141 = rhs.rawData[12], m112 = rhs.rawData[1], m122 = rhs.rawData[5], m132 = rhs.rawData[9], m142 = rhs.rawData[13], m113 = rhs.rawData[2], m123 = rhs.rawData[6], m133 = rhs.rawData[10], m143 = rhs.rawData[14], m114 = rhs.rawData[3], m124 = rhs.rawData[7], m134 = rhs.rawData[11], m144 = rhs.rawData[15], m211 = this.rawData[0], m221 = this.rawData[4], m231 = this.rawData[8], m241 = this.rawData[12], m212 = this.rawData[1], m222 = this.rawData[5], m232 = this.rawData[9], m242 = this.rawData[13], m213 = this.rawData[2], m223 = this.rawData[6], m233 = this.rawData[10], m243 = this.rawData[14], m214 = this.rawData[3], m224 = this.rawData[7], m234 = this.rawData[11], m244 = this.rawData[15];
        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
    }
    /**
        Prepends an incremental rotation to a Matrix3D object. When the Matrix3D object is
        applied to a display object, the matrix performs the rotation before other
        transformations in the Matrix3D object.

        The display object's rotation is defined by an axis, an incremental degree of
        rotation around the axis, and an optional pivot point for the center of the
        object's rotation. The axis can be any general direction. The common axes are the
        `X_AXIS (Vector3D(1,0,0))`, `Y_AXIS (Vector3D(0,1,0))`, and
        `Z_AXIS (Vector3D(0,0,1))`. In aviation terminology, the rotation about the y
        axis is called yaw. The rotation about the x axis is called pitch. The rotation
        about the z axis is called roll.

        The order of transformation matters. A rotation followed by a translation
        transformation produces a different effect than a translation followed by a
        rotation.

        The rotation effect is not absolute. The effect is object-relative, relative to
        the frame of reference of the original position and orientation. To make an
        absolute change to the transformation, use the `recompose()` method.

        When the `prependRotation()` method's transformation is applied to a Matrix3D
        object of a display object, the cached rotation property values of the display
        object are invalidated.

        One way to have a display object rotate around a specific point relative to its
        location is to set the translation of the object to the specified point, rotate
        the object using the `prependRotation()` method, and translate the object back to
        the original position. In the following example, the `myObject` 3D display object
        makes a y-axis rotation around the coordinate (10,10,0).

        ```haxe
        myObject.z = 1;
        myObject.transform.matrix3D.prependTranslation(10,10,0);
        myObject.transform.matrix3D.prependRotation(1, Vector3D.Y_AXIS);
        myObject.transform.matrix3D.prependTranslation(-10,-10,0);
        ```

        @param	degrees	The degree of rotation.
        @param	axis	The axis or direction of rotation. The usual axes are the
        `X_AXIS (Vector3D(1,0,0))`, `Y_AXIS (Vector3D(0,1,0))`, and
        `Z_AXIS (Vector3D(0,0,1))`. This vector should have a length of one.
        @param	pivotPoint	A point that determines the center of rotation. The default
        pivot point for an object is its registration point.
    **/
    prependRotation(degrees, axis, pivotPoint = null) {
        var tx, ty, tz;
        tx = ty = tz = 0;
        if (pivotPoint != null) {
            tx = pivotPoint.x;
            ty = pivotPoint.y;
            tz = pivotPoint.z;
        }
        var radian = degrees * Math.PI / 180;
        var cos = Math.cos(radian);
        var sin = Math.sin(radian);
        var x = axis.x;
        var y = axis.y;
        var z = axis.z;
        var x2 = x * x;
        var y2 = y * y;
        var z2 = z * z;
        var ls = x2 + y2 + z2;
        if (ls != 0) {
            var l = Math.sqrt(ls);
            x /= l;
            y /= l;
            z /= l;
            x2 /= ls;
            y2 /= ls;
            z2 /= ls;
        }
        var ccos = 1 - cos;
        var m = new Matrix3D();
        var d = m.rawData;
        d[0] = x2 + (y2 + z2) * cos;
        d[1] = x * y * ccos + z * sin;
        d[2] = x * z * ccos - y * sin;
        d[4] = x * y * ccos - z * sin;
        d[5] = y2 + (x2 + z2) * cos;
        d[6] = y * z * ccos + x * sin;
        d[8] = x * z * ccos + y * sin;
        d[9] = y * z * ccos - x * sin;
        d[10] = z2 + (x2 + y2) * cos;
        d[12] = (tx * (y2 + z2) - x * (ty * y + tz * z)) * ccos + (ty * z - tz * y) * sin;
        d[13] = (ty * (x2 + z2) - y * (tx * x + tz * z)) * ccos + (tz * x - tx * z) * sin;
        d[14] = (tz * (x2 + y2) - z * (tx * x + ty * y)) * ccos + (tx * y - ty * x) * sin;
        this.prepend(m);
    }
    /**
        Prepends an incremental scale change along the x, y, and z axes to a Matrix3D
        object. When the Matrix3D object is applied to a display object, the matrix
        performs the scale changes before other transformations in the Matrix3D
        object. The changes are object-relative, relative to the frame of reference of
        the original position and orientation. The default scale factor is (1.0, 1.0, 1.0).

        The scale is defined as a set of three incremental changes along the three
        axes (x,y,z). You can multiply each axis with a different number. When the
        scale changes are applied to a display object, the object's size increases or
        decreases. For example, setting the x, y, and z axes to two doubles the size of
        the object, while setting the axes to 0.5 halves the size. To make sure that the
        scale transformation only affects a specific axis, set the other parameters to
        one. A parameter of one means no scale change along the specific axis.

        The `prependScale()` method can be used for resizing as well as for managing
        distortions, such as stretch or contract of a display object. It can also be used
        for zooming in and out on a location. Scale transformations are automatically
        performed during a display object's rotation and translation.

        The order of transformation matters. A resizing followed by a translation
        transformation produces a different effect than a translation followed by a
        resizing transformation.

        @param	xScale	A multiplier used to scale the object along the x axis.
        @param	yScale	A multiplier used to scale the object along the y axis.
        @param	zScale	A multiplier used to scale the object along the z axis.
    **/
    prependScale(xScale, yScale, zScale) {
        this.prepend(new Matrix3D(Vector.ofArray([
            xScale, 0.0, 0.0, 0.0, 0.0, yScale, 0.0, 0.0, 0.0, 0.0, zScale, 0.0, 0.0, 0.0, 0.0, 1.0
        ])));
    }
    /**
        Prepends an incremental translation, a repositioning along the x, y, and z axes,
        to a Matrix3D object. When the Matrix3D object is applied to a display object,
        the matrix performs the translation changes before other transformations in the
        Matrix3D object.

        Translation specifies the distance the display object moves from its current
        location along the x, y, and z axes. The `prependTranslation()` method sets the
        translation as a set of three incremental changes along the three axes (x,y,z).
        To have a translation change only a specific axis, set the other parameters to
        zero. A zero parameter means no change along the specific axis.

        The translation changes are not absolute. The effect is object-relative,
        relative to the frame of reference of the original position and orientation.
        To make an absolute change to the transformation matrix, use the `recompose()`
        method. The order of transformation also matters. A translation followed by a
        rotation transformation produces a different effect than a rotation followed by
        a translation transformation. When prependTranslation() is used, the display
        object continues to move in the direction it is facing, regardless of the other
        transformations. For example, if a display object was facing toward a positive x
        axis, it continues to move in the direction specified by the
        `prependTranslation()` method, regardless of how the object has been rotated. To
        make translation changes occur after other transformations, use the
        `appendTranslation()` method.

        @param	x	An incremental translation along the x axis.
        @param	y	An incremental translation along the y axis.
        @param	z	An incremental translation along the z axis.
    **/
    prependTranslation(x, y, z) {
        var m = new Matrix3D();
        m.position = new Vector3D(x, y, z);
        this.prepend(m);
    }
    /**
        Sets the transformation matrix's translation, rotation, and scale settings. Unlike
        the incremental changes made by the display object's rotation properties or
        Matrix3D object's rotation methods, the changes made by `recompose()` method are
        absolute changes. The `recompose()` method overwrites the matrix's transformation.

        To modify the matrix's transformation with an absolute parent frame of reference,
        retrieve the settings with the decompose() method and make the appropriate
        changes. You can then set the Matrix3D object to the modified transformation
        using the `recompose()` method.

        The `recompose()` method's parameter specifies the orientation style that was
        used for the transformation. The default orientation is eulerAngles, which defines
        the orientation with three separate angles of rotation for each axis. The
        rotations occur consecutively and do not change the axis of each other. The
        display object's axis rotation properties perform Euler Angles orientation style
        transformation. The other orientation style options are axisAngle and quaternion.
        The Axis Angle orientation uses the combination of an axis and an angle to
        determine the orientation. The axis around which the object is rotated is a unit
        vector that represents a direction. The angle represents the magnitude of the
        rotation about the vector. The direction also determines where a display object
        is facing and the angle determines which way is up. The `appendRotation()` and
        `prependRotation()` methods use the Axis Angle orientation. The quaternion
        orientation uses complex numbers and the fourth element of a vector. An
        orientation is represented by the three axes of rotation (x,y,z) and an angle of
        rotation (w). The interpolate() method uses quaternion.

        @param	components	A Vector of three Vector3D objects that replace the Matrix3D
        object's translation, rotation, and scale elements.
        @param	orientationStyle	An optional parameter that determines the orientation
        style used for the matrix transformation. The three types of orientation styles
        are eulerAngles (constant `EULER_ANGLES`), axisAngle (constant `AXIS_ANGLE`), and
        quaternion (constant `QUATERNION`). For additional information on the different
        orientation style, see the geom.Orientation3D class.
        @returns	Returns `false` if any of the Vector3D elements of the components
        Vector do not exist or are `null`.
    **/
    recompose(components, orientationStyle = Orientation3D.EULER_ANGLES) {
        if (components.length < 3 || components[2].x == 0 || components[2].y == 0 || components[2].z == 0) {
            return false;
        }
        this.identity();
        var scale = [];
        scale[0] = scale[1] = scale[2] = components[2].x;
        scale[4] = scale[5] = scale[6] = components[2].y;
        scale[8] = scale[9] = scale[10] = components[2].z;
        switch (orientationStyle) {
            case Orientation3D.EULER_ANGLES:
                var cx = Math.cos(components[1].x);
                var cy = Math.cos(components[1].y);
                var cz = Math.cos(components[1].z);
                var sx = Math.sin(components[1].x);
                var sy = Math.sin(components[1].y);
                var sz = Math.sin(components[1].z);
                this.rawData[0] = cy * cz * scale[0];
                this.rawData[1] = cy * sz * scale[1];
                this.rawData[2] = -sy * scale[2];
                this.rawData[3] = 0;
                this.rawData[4] = (sx * sy * cz - cx * sz) * scale[4];
                this.rawData[5] = (sx * sy * sz + cx * cz) * scale[5];
                this.rawData[6] = sx * cy * scale[6];
                this.rawData[7] = 0;
                this.rawData[8] = (cx * sy * cz + sx * sz) * scale[8];
                this.rawData[9] = (cx * sy * sz - sx * cz) * scale[9];
                this.rawData[10] = cx * cy * scale[10];
                this.rawData[11] = 0;
                this.rawData[12] = components[0].x;
                this.rawData[13] = components[0].y;
                this.rawData[14] = components[0].z;
                this.rawData[15] = 1;
                break;
            default:
                var x = components[1].x;
                var y = components[1].y;
                var z = components[1].z;
                var w = components[1].w;
                if (orientationStyle == Orientation3D.AXIS_ANGLE) {
                    x *= Math.sin(w / 2);
                    y *= Math.sin(w / 2);
                    z *= Math.sin(w / 2);
                    w = Math.cos(w / 2);
                }
                this.rawData[0] = (1 - 2 * y * y - 2 * z * z) * scale[0];
                this.rawData[1] = (2 * x * y + 2 * w * z) * scale[1];
                this.rawData[2] = (2 * x * z - 2 * w * y) * scale[2];
                this.rawData[3] = 0;
                this.rawData[4] = (2 * x * y - 2 * w * z) * scale[4];
                this.rawData[5] = (1 - 2 * x * x - 2 * z * z) * scale[5];
                this.rawData[6] = (2 * y * z + 2 * w * x) * scale[6];
                this.rawData[7] = 0;
                this.rawData[8] = (2 * x * z + 2 * w * y) * scale[8];
                this.rawData[9] = (2 * y * z - 2 * w * x) * scale[9];
                this.rawData[10] = (1 - 2 * x * x - 2 * y * y) * scale[10];
                this.rawData[11] = 0;
                this.rawData[12] = components[0].x;
                this.rawData[13] = components[0].y;
                this.rawData[14] = components[0].z;
                this.rawData[15] = 1;
                break;
        }
        if (components[2].x == 0) {
            this.rawData[0] = 1e-15;
        }
        if (components[2].y == 0) {
            this.rawData[5] = 1e-15;
        }
        if (components[2].z == 0) {
            this.rawData[10] = 1e-15;
        }
        return !(components[2].x == 0 || components[2].y == 0 || components[2].y == 0);
    }
    /**
        Uses the transformation matrix to transform a Vector3D object from one space
        coordinate to another. The returned Vector3D object holds the new coordinates
        after the transformation. All the matrix transformations including translation
        are applied to the Vector3D object.

        If the result of the `transformVector()` method was applied to the position of a
        display object, only the display object's position changes. The display object's
        rotation and scale elements remain the same.

        **Note:** This method automatically sets the w component of the passed Vector3D
        to 1.0.

        @param	v	A Vector3D object holding the coordinates that are going to be
        transformed.
        @returns	A Vector3D object with the transformed coordinates.
    **/
    transformVector(v) {
        var x = v.x;
        var y = v.y;
        var z = v.z;
        return new Vector3D((x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12]), (x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13]), (x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14]), (x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15]));
    }
    /**
        Uses the transformation matrix to transform a Vector of Numbers from one
        coordinate space to another. The `tranformVectors()` method reads every three
        Numbers in the `vin` Vector object as a 3D coordinate (x,y,z) and places a
        transformed 3D coordinate in the `vout` Vector object. All the matrix
        transformations including translation are applied to the `vin` Vector object.
        You can use the `transformVectors()` method to render and transform a 3D object
        as a mesh. A mesh is a collection of vertices that defines the shape of the object.

        @param	vin	A Vector of Floats, where every three Numbers are a 3D coordinate
        (x,y,z) that is going to be transformed.
        @param	vout	A Vector of Floats, where every three Numbers are a 3D
        transformed coordinate (x,y,z).
    **/
    transformVectors(vin, vout) {
        var i = 0;
        var x, y, z;
        while (i + 3 <= vin.length) {
            x = vin[i];
            y = vin[i + 1];
            z = vin[i + 2];
            vout[i] = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
            vout[i + 1] = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
            vout[i + 2] = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
            i += 3;
        }
    }
    /**
        Converts the current Matrix3D object to a matrix where the rows and columns are
        swapped. For example, if the current Matrix3D object's rawData contains the
        following 16 numbers, `1,2,3,4,11,12,13,14,21,22,23,24,31,32,33,34`, the
        `transpose()` method reads every four elements as a row and turns the rows into
        columns. The result is a matrix with the rawData of:
        `1,11,21,31,2,12,22,32,3,13,23,33,4,14,24,34`.

        The `transpose()` method replaces the current matrix with a transposed matrix.
        If you want to transpose a matrix without altering the current matrix, first copy
        the current matrix by using the `clone()` method and then apply the `transpose()`
        method to the copy.

        An orthogonal matrix is a square matrix whose transpose is equal to its inverse.
    **/
    transpose() {
        var oRawData = this.rawData.copy();
        this.rawData[1] = oRawData[4];
        this.rawData[2] = oRawData[8];
        this.rawData[3] = oRawData[12];
        this.rawData[4] = oRawData[1];
        this.rawData[6] = oRawData[9];
        this.rawData[7] = oRawData[13];
        this.rawData[8] = oRawData[2];
        this.rawData[9] = oRawData[6];
        this.rawData[11] = oRawData[14];
        this.rawData[12] = oRawData[3];
        this.rawData[13] = oRawData[7];
        this.rawData[14] = oRawData[11];
    }
    static __getAxisRotation(x, y, z, degrees) {
        var m = new Matrix3D();
        var a1 = new Vector3D(x, y, z);
        var rad = -degrees * (Math.PI / 180);
        var c = Math.cos(rad);
        var s = Math.sin(rad);
        var t = 1.0 - c;
        m.rawData[0] = c + a1.x * a1.x * t;
        m.rawData[5] = c + a1.y * a1.y * t;
        m.rawData[10] = c + a1.z * a1.z * t;
        var tmp1 = a1.x * a1.y * t;
        var tmp2 = a1.z * s;
        m.rawData[4] = tmp1 + tmp2;
        m.rawData[1] = tmp1 - tmp2;
        tmp1 = a1.x * a1.z * t;
        tmp2 = a1.y * s;
        m.rawData[8] = tmp1 - tmp2;
        m.rawData[2] = tmp1 + tmp2;
        tmp1 = a1.y * a1.z * t;
        tmp2 = a1.x * s;
        m.rawData[9] = tmp1 + tmp2;
        m.rawData[6] = tmp1 - tmp2;
        return m;
    }
    // Getters & Setters
    /**
        A Number that determines whether a matrix is invertible.

        A Matrix3D object must be invertible. You can use the `determinant` property to make
        sure that a Matrix3D object is invertible. If determinant is zero, an inverse of
        the matrix does not exist. For example, if an entire row or column of a matrix is
        zero or if two rows or columns are equal, the determinant is zero. Determinant is
        also used to solve a series of equations.

        Only a square matrix, like the Matrix3D class, has a determinant.
    **/
    get determinant() {
        var rawData = this.rawData;
        return 1 * ((rawData[0] * rawData[5] - rawData[4] * rawData[1]) * (rawData[10] * rawData[15] - rawData[14] * rawData[11])
            - (rawData[0] * rawData[9] - rawData[8] * rawData[1]) * (rawData[6] * rawData[15] - rawData[14] * rawData[7])
            + (rawData[0] * rawData[13] - rawData[12] * rawData[1]) * (rawData[6] * rawData[11] - rawData[10] * rawData[7])
            + (rawData[4] * rawData[9] - rawData[8] * rawData[5]) * (rawData[2] * rawData[15] - rawData[14] * rawData[3])
            - (rawData[4] * rawData[13] - rawData[12] * rawData[5]) * (rawData[2] * rawData[11] - rawData[10] * rawData[3])
            + (rawData[8] * rawData[13] - rawData[12] * rawData[9]) * (rawData[2] * rawData[7] - rawData[6] * rawData[3]));
    }
    /**
        A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display
        object within the transformation's frame of reference. The `position` property
        provides immediate access to the translation vector of the display object's
        matrix without needing to decompose and recompose the matrix.

        With the `position` property, you can get and set the translation elements of the
        transformation matrix.
    **/
    get position() {
        return new Vector3D(this.rawData[12], this.rawData[13], this.rawData[14]);
    }
    set position(val) {
        this.rawData[12] = val.x;
        this.rawData[13] = val.y;
        this.rawData[14] = val.z;
    }
}

/**
    The Transform class provides access to color adjustment properties and two-
    or three-dimensional transformation objects that can be applied to a
    display object. During the transformation, the color or the orientation and
    position of a display object is adjusted(offset) from the current values
    or coordinates to new values or coordinates. The Transform class also
    collects data about color and two-dimensional matrix transformations that
    are applied to a display object and all of its parent objects. You can
    access these combined transformations through the
    `concatenatedColorTransform` and `concatenatedMatrix`
    properties.

    To apply color transformations: create a ColorTransform object, set the
    color adjustments using the object's methods and properties, and then
    assign the `colorTransformation` property of the
    `transform` property of the display object to the new
    ColorTransformation object.

    To apply two-dimensional transformations: create a Matrix object, set
    the matrix's two-dimensional transformation, and then assign the
    `transform.matrix` property of the display object to the new
    Matrix object.

    To apply three-dimensional transformations: start with a
    three-dimensional display object. A three-dimensional display object has a
    `z` property value other than zero. You do not need to create
    the Matrix3D object. For all three-dimensional objects, a Matrix3D object
    is created automatically when you assign a `z` value to a
    display object. You can access the display object's Matrix3D object through
    the display object's `transform` property. Using the methods of
    the Matrix3D class, you can add to or modify the existing transformation
    settings. Also, you can create a custom Matrix3D object, set the custom
    Matrix3D object's transformation elements, and then assign the new Matrix3D
    object to the display object using the `transform.matrix`
    property.

    To modify a perspective projection of the stage or root object: use the
    `transform.matrix` property of the root display object to gain
    access to the PerspectiveProjection object. Or, apply different perspective
    projection properties to a display object by setting the perspective
    projection properties of the display object's parent. The child display
    object inherits the new properties. Specifically, create a
    PerspectiveProjection object and set its properties, then assign the
    PerspectiveProjection object to the `perspectiveProjection`
    property of the parent display object's `transform` property.
    The specified projection transformation then applies to all the display
    object's three-dimensional children.

    Since both PerspectiveProjection and Matrix3D objects perform
    perspective transformations, do not assign both to a display object at the
    same time. Use the PerspectiveProjection object for focal length and
    projection center changes. For more control over the perspective
    transformation, create a perspective projection Matrix3D object.
**/
class Transform {
    constructor(displayObject) {
        this.__colorTransform = new ColorTransform();
        this.__concatenatedColorTransform = new ColorTransform();
        this.__pixelBounds = new Rectangle();
        this.__displayObject = displayObject;
        this.__hasMatrix = true;
    }
    /**
        Returns a Matrix3D object, which can transform the space of a
        specified display object in relation to the current display object's
        space. You can use the `getRelativeMatrix3D()` method to move one
        three-dimensional display object relative to another three-dimensional
        display object.

        @param relativeTo The display object relative to which the
                          transformation occurs. To get a Matrix3D object
                          relative to the stage, set the parameter to the
                          `root` or `stage` object. To get the world-relative
                          matrix of the display object, set the parameter to a
                          display object that has a perspective transformation
                          applied to it.
        @return A Matrix3D object that can be used to transform the space from
                the `relativeTo` display object to the current display object
                space.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public getRelativeMatrix3D (relativeTo:DisplayObject):Matrix3D;
    __setTransform(a, b, c, d, tx, ty) {
        if (this.__displayObject != null) {
            var transform = this.__displayObject.__transform;
            if (transform.a == a && transform.b == b && transform.c == c && transform.d == d && transform.tx == tx && transform.ty == ty) {
                return;
            }
            var scaleX = 0.0;
            var scaleY = 0.0;
            if (b == 0) {
                scaleX = a;
            }
            else {
                scaleX = Math.sqrt(a * a + b * b);
            }
            if (c == 0) {
                scaleY = d;
            }
            else {
                scaleY = Math.sqrt(c * c + d * d);
            }
            this.__displayObject.__scaleX = scaleX;
            this.__displayObject.__scaleY = scaleY;
            var rotation = (180 / Math.PI) * Math.atan2(d, c) - 90;
            if (rotation != this.__displayObject.__rotation) {
                this.__displayObject.__rotation = rotation;
                var radians = rotation * (Math.PI / 180);
                this.__displayObject.__rotationSine = Math.sin(radians);
                this.__displayObject.__rotationCosine = Math.cos(radians);
            }
            transform.a = a;
            transform.b = b;
            transform.c = c;
            transform.d = d;
            transform.tx = tx;
            transform.ty = ty;
            this.__displayObject.__setTransformDirty();
            this.__displayObject.__setParentRenderDirty();
        }
    }
    // Get & Set Methods
    /**
        A ColorTransform object containing values that universally adjust the
        colors in the display object.

        @throws TypeError The colorTransform is null when being set
    **/
    get colorTransform() {
        return this.__colorTransform;
    }
    set colorTransform(value) {
        if (!this.__colorTransform.__equals(value, false)) {
            this.__colorTransform.__copyFrom(value);
            if (value != null) {
                this.__displayObject.alpha = value.alphaMultiplier;
            }
            this.__displayObject.__setRenderDirty();
        }
    }
    /**
        A ColorTransform object representing the combined color transformations
        applied to the display object and all of its parent objects, back to the
        root level. If different color transformations have been applied at
        different levels, all of those transformations are concatenated into one
        ColorTransform object for this property.
    **/
    get concatenatedColorTransform() {
        return this.__concatenatedColorTransform;
    }
    /**
        A Matrix object representing the combined transformation matrixes of the
        display object and all of its parent objects, back to the root level. If
        different transformation matrixes have been applied at different levels,
        all of those matrixes are concatenated into one matrix for this property.
        Also, for resizeable SWF content running in the browser, this property
        factors in the difference between stage coordinates and window coordinates
        due to window resizing. Thus, the property converts local coordinates to
        window coordinates, which may not be the same coordinate space as that of
        the Stage.
    **/
    get concatenatedMatrix() {
        if (this.__hasMatrix) {
            return this.__displayObject.__getWorldTransform().clone();
        }
        return null;
    }
    /**
        A Matrix object containing values that alter the scaling, rotation, and
        translation of the display object.

        If the `matrix` property is set to a value (not
        `null`), the `matrix3D` property is
        `null`. And if the `matrix3D` property is set to a
        value(not `null`), the `matrix` property is
        `null`.

        @throws TypeError The matrix is null when being set
    **/
    get matrix() {
        if (this.__hasMatrix) {
            return this.__displayObject.__transform.clone();
        }
        return null;
    }
    set matrix(value) {
        if (value == null) {
            this.__hasMatrix = false;
        }
        else {
            this.__hasMatrix = true;
            this.__hasMatrix3D = false;
            if (this.__displayObject != null) {
                this.__setTransform(value.a, value.b, value.c, value.d, value.tx, value.ty);
            }
        }
    }
    /**
        Provides access to the Matrix3D object of a three-dimensional display
        object. The Matrix3D object represents a transformation matrix that
        determines the display object's position and orientation. A Matrix3D
        object can also perform perspective projection.

        If the `matrix` property is set to a value(not
        `null`), the `matrix3D` property is
        `null`. And if the `matrix3D` property is set to a
        value(not `null`), the `matrix` property is
        `null`.
    **/
    get matrix3D() {
        if (this.__hasMatrix3D) {
            var matrix = this.__displayObject.__transform;
            return new Matrix3D(Vector.ofArray([
                matrix.a, matrix.b, 0.0, 0.0, matrix.c, matrix.d, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, matrix.tx, matrix.ty, 0.0, 1.0
            ]));
        }
        return null;
    }
    set matrix3D(value) {
        if (value == null) {
            this.__hasMatrix3D = false;
        }
        else {
            this.__hasMatrix = false;
            this.__hasMatrix3D = true;
            this.__setTransform(value.rawData[0], value.rawData[1], value.rawData[5], value.rawData[6], value.rawData[12], value.rawData[13]);
        }
    }
    /**
        A Rectangle object that defines the bounding rectangle of the display
        object on the stage.
    **/
    get pixelBounds() {
        return this.__pixelBounds;
    }
}

/**
    The DisplayObject class is the base class for all objects that can be
    placed on the display list. The display list manages all objects displayed
    in openfl. Use the DisplayObjectContainer class to arrange the
    display objects in the display list. DisplayObjectContainer objects can
    have child display objects, while other display objects, such as Shape and
    TextField objects, are "leaf" nodes that have only parents and siblings, no
    children.

    The DisplayObject class supports basic functionality like the _x_
    and _y_ position of an object, as well as more advanced properties of
    the object such as its transformation matrix.

    DisplayObject is an abstract base class; therefore, you cannot call
    DisplayObject directly. Invoking `new DisplayObject()` throws an
    `ArgumentError` exception.

    All display objects inherit from the DisplayObject class.

    The DisplayObject class itself does not include any APIs for rendering
    content onscreen. For that reason, if you want create a custom subclass of
    the DisplayObject class, you will want to extend one of its subclasses that
    do have APIs for rendering content onscreen, such as the Shape, Sprite,
    Bitmap, SimpleButton, TextField, or MovieClip class.

    The DisplayObject class contains several broadcast events. Normally, the
    target of any particular event is a specific DisplayObject instance. For
    example, the target of an `added` event is the specific
    DisplayObject instance that was added to the display list. Having a single
    target restricts the placement of event listeners to that target and in
    some cases the target's ancestors on the display list. With broadcast
    events, however, the target is not a specific DisplayObject instance, but
    rather all DisplayObject instances, including those that are not on the
    display list. This means that you can add a listener to any DisplayObject
    instance to listen for broadcast events. In addition to the broadcast
    events listed in the DisplayObject class's Events table, the DisplayObject
    class also inherits two broadcast events from the EventDispatcher class:
    `activate` and `deactivate`.

    Some properties previously used in the ActionScript 1.0 and 2.0
    MovieClip, TextField, and Button classes(such as `_alpha`,
    `_height`, `_name`, `_width`,
    `_x`, `_y`, and others) have equivalents in the
    ActionScript 3.0 DisplayObject class that are renamed so that they no
    longer begin with the underscore(_) character.

    For more information, see the "Display Programming" chapter of the
    _ActionScript 3.0 Developer's Guide_.

    @event added            Dispatched when a display object is added to the
                            display list. The following methods trigger this
                            event:
                            `DisplayObjectContainer.addChild()`,
                            `DisplayObjectContainer.addChildAt()`.
    @event addedToStage     Dispatched when a display object is added to the on
                            stage display list, either directly or through the
                            addition of a sub tree in which the display object
                            is contained. The following methods trigger this
                            event:
                            `DisplayObjectContainer.addChild()`,
                            `DisplayObjectContainer.addChildAt()`.
    @event enterFrame       [broadcast event] Dispatched when the playhead is
                            entering a new frame. If the playhead is not
                            moving, or if there is only one frame, this event
                            is dispatched continuously in conjunction with the
                            frame rate. This event is a broadcast event, which
                            means that it is dispatched by all display objects
                            with a listener registered for this event.
    @event exitFrame        [broadcast event] Dispatched when the playhead is
                            exiting the current frame. All frame scripts have
                            been run. If the playhead is not moving, or if
                            there is only one frame, this event is dispatched
                            continuously in conjunction with the frame rate.
                            This event is a broadcast event, which means that
                            it is dispatched by all display objects with a
                            listener registered for this event.
    @event frameConstructed [broadcast event] Dispatched after the constructors
                            of frame display objects have run but before frame
                            scripts have run. If the playhead is not moving, or
                            if there is only one frame, this event is
                            dispatched continuously in conjunction with the
                            frame rate. This event is a broadcast event, which
                            means that it is dispatched by all display objects
                            with a listener registered for this event.
    @event removed          Dispatched when a display object is about to be
                            removed from the display list. Two methods of the
                            DisplayObjectContainer class generate this event:
                            `removeChild()` and
                            `removeChildAt()`.

                            The following methods of a
                            DisplayObjectContainer object also generate this
                            event if an object must be removed to make room for
                            the new object: `addChild()`,
                            `addChildAt()`, and
                            `setChildIndex()`.
    @event removedFromStage Dispatched when a display object is about to be
                            removed from the display list, either directly or
                            through the removal of a sub tree in which the
                            display object is contained. Two methods of the
                            DisplayObjectContainer class generate this event:
                            `removeChild()` and
                            `removeChildAt()`.

                            The following methods of a
                            DisplayObjectContainer object also generate this
                            event if an object must be removed to make room for
                            the new object: `addChild()`,
                            `addChildAt()`, and
                            `setChildIndex()`.
    @event render           [broadcast event] Dispatched when the display list
                            is about to be updated and rendered. This event
                            provides the last opportunity for objects listening
                            for this event to make changes before the display
                            list is rendered. You must call the
                            `invalidate()` method of the Stage
                            object each time you want a `render`
                            event to be dispatched. `Render` events
                            are dispatched to an object only if there is mutual
                            trust between it and the object that called
                            `Stage.invalidate()`. This event is a
                            broadcast event, which means that it is dispatched
                            by all display objects with a listener registered
                            for this event.

                            **Note: **This event is not dispatched if the
                            display is not rendering. This is the case when the
                            content is either minimized or obscured.
**/
let DisplayObject = /** @class */ (() => {
    class DisplayObject extends EventDispatcher {
        constructor() {
            super();
            this.__type = DisplayObjectType$1.DISPLAY_OBJECT;
            this.__alpha = 1;
            this.__blendMode = BlendMode.NORMAL;
            this.__cacheAsBitmap = false;
            this.__transform = new Matrix();
            this.__visible = true;
            this.__rotation = 0;
            this.__rotationSine = 0;
            this.__rotationCosine = 1;
            this.__scaleX = 1;
            this.__scaleY = 1;
            this.__worldAlpha = 1;
            this.__worldBlendMode = BlendMode.NORMAL;
            this.__worldTransform = new Matrix();
            this.__worldColorTransform = new ColorTransform();
            this.__renderTransform = new Matrix();
            this.__worldVisible = true;
            this.__transformDirty = true;
            this.__renderData = new DisplayObjectRenderData();
            this.name = "instance" + (++DisplayObject.__instanceCount);
            if (DisplayObject.__initStage != null) {
                this.__stage = DisplayObject.__initStage;
                DisplayObject.__initStage = null;
                this.stage.addChild(this);
            }
        }
        addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false) {
            switch (type) {
                case Event.ACTIVATE:
                case Event.DEACTIVATE:
                case Event.ENTER_FRAME:
                case Event.EXIT_FRAME:
                case Event.FRAME_CONSTRUCTED:
                case Event.RENDER:
                    if (!DisplayObject.__broadcastEvents.has(type)) {
                        DisplayObject.__broadcastEvents.set(type, []);
                    }
                    var dispatchers = DisplayObject.__broadcastEvents.get(type);
                    if (dispatchers.indexOf(this) == -1) {
                        dispatchers.push(this);
                    }
                    break;
                case RenderEvent.CLEAR_DOM:
                case RenderEvent.RENDER_CAIRO:
                case RenderEvent.RENDER_CANVAS:
                case RenderEvent.RENDER_DOM:
                case RenderEvent.RENDER_OPENGL:
                    if (this.__customRenderEvent == null) {
                        this.__customRenderEvent = new RenderEvent(null);
                        this.__customRenderEvent.objectColorTransform = new ColorTransform();
                        this.__customRenderEvent.objectMatrix = new Matrix();
                        this.__customRenderClear = true;
                    }
                    break;
            }
            super.addEventListener(type, listener, useCapture, priority, useWeakReference);
        }
        dispatchEvent(event) {
            if (event instanceof MouseEvent) {
                var mouseEvent = event;
                mouseEvent.stageX = this.__getRenderTransform().__transformX(mouseEvent.localX, mouseEvent.localY);
                mouseEvent.stageY = this.__getRenderTransform().__transformY(mouseEvent.localX, mouseEvent.localY);
            }
            else if (event instanceof TouchEvent) {
                var touchEvent = event;
                touchEvent.stageX = this.__getRenderTransform().__transformX(touchEvent.localX, touchEvent.localY);
                touchEvent.stageY = this.__getRenderTransform().__transformY(touchEvent.localX, touchEvent.localY);
            }
            event.__target = this;
            return this.__dispatchWithCapture(event);
        }
        /**
            Returns a rectangle that defines the area of the display object relative
            to the coordinate system of the `targetCoordinateSpace` object.
            Consider the following code, which shows how the rectangle returned can
            vary depending on the `targetCoordinateSpace` parameter that
            you pass to the method:
    
            **Note:** Use the `localToGlobal()` and
            `globalToLocal()` methods to convert the display object's local
            coordinates to display coordinates, or display coordinates to local
            coordinates, respectively.
    
            The `getBounds()` method is similar to the
            `getRect()` method; however, the Rectangle returned by the
            `getBounds()` method includes any strokes on shapes, whereas
            the Rectangle returned by the `getRect()` method does not. For
            an example, see the description of the `getRect()` method.
    
            @param targetCoordinateSpace The display object that defines the
                                        coordinate system to use.
            @return The rectangle that defines the area of the display object relative
                    to the `targetCoordinateSpace` object's coordinate
                    system.
        **/
        getBounds(targetCoordinateSpace) {
            var matrix = Matrix.__pool.get();
            if (targetCoordinateSpace != null && targetCoordinateSpace != this) {
                matrix.copyFrom(this.__getWorldTransform());
                var targetMatrix = Matrix.__pool.get();
                targetMatrix.copyFrom(targetCoordinateSpace.__getWorldTransform());
                targetMatrix.invert();
                matrix.concat(targetMatrix);
                Matrix.__pool.release(targetMatrix);
            }
            else {
                matrix.identity();
            }
            var bounds = new Rectangle();
            this.__getBounds(bounds, matrix);
            Matrix.__pool.release(matrix);
            return bounds;
        }
        /**
            Returns a rectangle that defines the boundary of the display object, based
            on the coordinate system defined by the `targetCoordinateSpace`
            parameter, excluding any strokes on shapes. The values that the
            `getRect()` method returns are the same or smaller than those
            returned by the `getBounds()` method.
    
            **Note:** Use `localToGlobal()` and
            `globalToLocal()` methods to convert the display object's local
            coordinates to Stage coordinates, or Stage coordinates to local
            coordinates, respectively.
    
            @param targetCoordinateSpace The display object that defines the
                                        coordinate system to use.
            @return The rectangle that defines the area of the display object relative
                    to the `targetCoordinateSpace` object's coordinate
                    system.
        **/
        getRect(targetCoordinateSpace) {
            // should not account for stroke widths, but is that possible?
            return this.getBounds(targetCoordinateSpace);
        }
        /**
            Converts the `point` object from the Stage(global) coordinates
            to the display object's(local) coordinates.
    
            To use this method, first create an instance of the Point class. The
            _x_ and _y_ values that you assign represent global coordinates
            because they relate to the origin(0,0) of the main display area. Then
            pass the Point instance as the parameter to the
            `globalToLocal()` method. The method returns a new Point object
            with _x_ and _y_ values that relate to the origin of the display
            object instead of the origin of the Stage.
    
            @param point An object created with the Point class. The Point object
                        specifies the _x_ and _y_ coordinates as
                        properties.
            @return A Point object with coordinates relative to the display object.
        **/
        globalToLocal(pos) {
            return this.__globalToLocal(pos, new Point());
        }
        // /** @hidden */ @:dox(hide) @:require(flash10) public globalToLocal3D (point:Point):Vector3D;
        /**
            Evaluates the bounding box of the display object to see if it overlaps or
            intersects with the bounding box of the `obj` display object.
    
            @param obj The display object to test against.
            @return `true` if the bounding boxes of the display objects
                    intersect; `false` if not.
        **/
        hitTestObject(obj) {
            if (obj != null && obj.parent != null && parent != null) {
                var currentBounds = this.getBounds(this);
                var targetBounds = obj.getBounds(this);
                return currentBounds.intersects(targetBounds);
            }
            return false;
        }
        /**
            Evaluates the display object to see if it overlaps or intersects with the
            point specified by the `x` and `y` parameters. The
            `x` and `y` parameters specify a point in the
            coordinate space of the Stage, not the display object container that
            contains the display object(unless that display object container is the
            Stage).
    
            @param x         The _x_ coordinate to test against this object.
            @param y         The _y_ coordinate to test against this object.
            @param shapeFlag Whether to check against the actual pixels of the object
                            (`true`) or the bounding box
                            (`false`).
            @return `true` if the display object overlaps or intersects
                    with the specified point; `false` otherwise.
        **/
        hitTestPoint(x, y, shapeFlag = false) {
            if (this.stage != null) {
                return this.__hitTest(x, y, shapeFlag, null, false, this);
            }
            else {
                return false;
            }
        }
        /**
            Calling the `invalidate()` method signals to have the current object
            redrawn the next time the object is eligible to be rendered.
        **/
        invalidate() {
            this.__setRenderDirty();
        }
        /**
            Converts the `point` object from the display object's(local)
            coordinates to the Stage(global) coordinates.
    
            This method allows you to convert any given _x_ and _y_
            coordinates from values that are relative to the origin(0,0) of a
            specific display object(local coordinates) to values that are relative to
            the origin of the Stage(global coordinates).
    
            To use this method, first create an instance of the Point class. The
            _x_ and _y_ values that you assign represent local coordinates
            because they relate to the origin of the display object.
    
            You then pass the Point instance that you created as the parameter to
            the `localToGlobal()` method. The method returns a new Point
            object with _x_ and _y_ values that relate to the origin of the
            Stage instead of the origin of the display object.
    
            @param point The name or identifier of a point created with the Point
                        class, specifying the _x_ and _y_ coordinates as
                        properties.
            @return A Point object with coordinates relative to the Stage.
        **/
        localToGlobal(point) {
            return this.__getRenderTransform().transformPoint(point);
        }
        // /** @hidden */ @:dox(hide) @:require(flash10) public local3DToGlobal (point3d:Vector3D):Point;
        removeEventListener(type, listener, useCapture = false) {
            super.removeEventListener(type, listener, useCapture);
            switch (type) {
                case Event.ACTIVATE:
                case Event.DEACTIVATE:
                case Event.ENTER_FRAME:
                case Event.EXIT_FRAME:
                case Event.FRAME_CONSTRUCTED:
                case Event.RENDER:
                    if (!this.hasEventListener(type)) {
                        if (DisplayObject.__broadcastEvents.has(type)) {
                            var list = DisplayObject.__broadcastEvents.get(type);
                            var index = list.indexOf(this);
                            if (index > -1)
                                list.splice(index, 1);
                        }
                    }
                    break;
                case RenderEvent.CLEAR_DOM:
                case RenderEvent.RENDER_CAIRO:
                case RenderEvent.RENDER_CANVAS:
                case RenderEvent.RENDER_DOM:
                case RenderEvent.RENDER_OPENGL:
                    if (!this.hasEventListener(RenderEvent.CLEAR_DOM)
                        && !this.hasEventListener(RenderEvent.RENDER_CAIRO)
                        && !this.hasEventListener(RenderEvent.RENDER_CANVAS)
                        && !this.hasEventListener(RenderEvent.RENDER_DOM)
                        && !this.hasEventListener(RenderEvent.RENDER_OPENGL)) {
                        this.__customRenderEvent = null;
                    }
                    break;
            }
        }
        __childIterator(childrenOnly = true) {
            var iterator = DisplayObject.__childIterators.get();
            iterator.init(this, childrenOnly);
            return iterator;
        }
        static __calculateAbsoluteTransform(local, parentTransform, target) {
            target.a = local.a * parentTransform.a + local.b * parentTransform.c;
            target.b = local.a * parentTransform.b + local.b * parentTransform.d;
            target.c = local.c * parentTransform.a + local.d * parentTransform.c;
            target.d = local.c * parentTransform.b + local.d * parentTransform.d;
            target.tx = local.tx * parentTransform.a + local.ty * parentTransform.c + parentTransform.tx;
            target.ty = local.tx * parentTransform.b + local.ty * parentTransform.d + parentTransform.ty;
        }
        __cleanup() {
            for (let child of this.__childIterator(false)) {
                child.__renderData.dispose();
                if (child.__graphics != null) {
                    child.__graphics.__cleanup();
                }
                switch (child.__type) {
                    case DisplayObjectType$1.DISPLAY_OBJECT_CONTAINER:
                    case DisplayObjectType$1.MOVIE_CLIP:
                        var displayObjectContainer = child;
                        displayObjectContainer.__cleanupRemovedChildren();
                        break;
                }
            }
        }
        __dispatch(event) {
            if (this.__eventMap != null && this.hasEventListener(event.type)) {
                var result = super.__dispatchEvent(event);
                if (event.__isCanceled) {
                    return true;
                }
                return result;
            }
            return true;
        }
        __dispatchChildren(event) {
            if (this.__type != null) {
                switch (this.__type) {
                    case DisplayObjectType$1.DISPLAY_OBJECT_CONTAINER:
                    case DisplayObjectType$1.MOVIE_CLIP:
                        var displayObjectContainer = this;
                        if (displayObjectContainer.numChildren > 0) {
                            for (let child of this.__childIterator()) {
                                event.__target = child;
                                if (!child.__dispatchWithCapture(event)) {
                                    break;
                                }
                            }
                        }
                }
            }
        }
        __dispatchEvent(event) {
            var parent = event.bubbles ? this.parent : null;
            var result = super.__dispatchEvent(event);
            if (event.__isCanceled) {
                return true;
            }
            if (parent != null && parent != this) {
                event.__eventPhase = EventPhase$1.BUBBLING_PHASE;
                if (event.__target == null) {
                    event.__target = this;
                }
                parent.__dispatchEvent(event);
            }
            return result;
        }
        __dispatchWithCapture(event) {
            if (event.__target == null) {
                event.__target = this;
            }
            if (parent != null) {
                event.__eventPhase = EventPhase$1.CAPTURING_PHASE;
                if (parent == this.stage) {
                    parent.__dispatch(event);
                }
                else {
                    var stack = DisplayObject.__tempStack.get();
                    var parent = parent;
                    var i = 0;
                    while (parent != null) {
                        stack[i] = parent;
                        parent = parent.parent;
                        i++;
                    }
                    for (let j = 0; j < i; j++) {
                        stack[i - j - 1].__dispatch(event);
                    }
                    DisplayObject.__tempStack.release(stack);
                }
            }
            event.__eventPhase = EventPhase$1.AT_TARGET;
            return this.__dispatchEvent(event);
        }
        __getBounds(rect, matrix) {
            if (this.__graphics != null) {
                this.__graphics.__getBounds(rect, matrix);
            }
        }
        __getCursor() {
            return null;
        }
        __getFilterBounds(rect, matrix) {
            this.__getRenderBounds(rect, matrix);
            if (this.__filters != null) {
                var extension = Rectangle.__pool.get();
                for (let filter of this.__filters) {
                    extension.__expand(-filter.__leftExtension, -filter.__topExtension, filter.__leftExtension
                        + filter.__rightExtension, filter.__topExtension
                        + filter.__bottomExtension);
                }
                rect.width += extension.width;
                rect.height += extension.height;
                rect.x += extension.x;
                rect.y += extension.y;
                Rectangle.__pool.release(extension);
            }
        }
        __getInteractive(stack) {
            return false;
        }
        __getLocalBounds() {
            if (this.__localBounds == null) {
                this.__localBounds = new Rectangle();
                this.__localBoundsDirty = true;
            }
            if (this.__localBoundsDirty) {
                this.__localBounds.x = 0;
                this.__localBounds.y = 0;
                this.__localBounds.width = 0;
                this.__localBounds.height = 0;
                this.__getBounds(this.__localBounds, this.__transform);
                this.__localBounds.x -= this.__transform.tx;
                this.__localBounds.y -= this.__transform.ty;
                this.__localBoundsDirty = false;
            }
            return this.__localBounds;
        }
        __getRenderBounds(rect, matrix) {
            if (this.__scrollRect == null) {
                this.__getBounds(rect, matrix);
            }
            else {
                // TODO: Should we have smaller bounds if scrollRect is larger than content?
                var r = Rectangle.__pool.get();
                r.copyFrom(this.__scrollRect);
                r.__transform(r, matrix);
                rect.__expand(r.x, r.y, r.width, r.height);
                Rectangle.__pool.release(r);
            }
        }
        __getRenderTransform() {
            this.__getWorldTransform();
            return this.__renderTransform;
        }
        __getWorldTransform() {
            if (this.__transformDirty) {
                var renderParent = this.__renderParent != null ? this.__renderParent : parent;
                if (this.__isMask && renderParent == null)
                    renderParent = this.__maskTarget;
                if (parent == null || (!parent.__transformDirty && !renderParent.__transformDirty)) {
                    this.__update(true, false);
                }
                else {
                    var list = [];
                    var current = this;
                    while (current != this.stage && current.__transformDirty) {
                        list.push(current);
                        current = current.parent;
                        if (current == null)
                            break;
                    }
                    var i = list.length;
                    while (--i >= 0) {
                        current = list[i];
                        current.__update(true, false);
                    }
                }
            }
            return this.__worldTransform;
        }
        __globalToLocal(global, local) {
            this.__getRenderTransform();
            if (global == local) {
                this.__renderTransform.__transformInversePoint(global);
            }
            else {
                local.x = this.__renderTransform.__transformInverseX(global.x, global.y);
                local.y = this.__renderTransform.__transformInverseY(global.x, global.y);
            }
            return local;
        }
        __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
            var hitTest = false;
            if (this.__graphics != null) {
                if (!hitObject.__visible || this.__isMask || (this.mask != null && !this.mask.__hitTestMask(x, y))) {
                    hitTest = false;
                }
                else if (this.__graphics.__hitTest(x, y, shapeFlag, this.__getRenderTransform())) {
                    if (stack != null && !interactiveOnly) {
                        stack.push(hitObject);
                    }
                    hitTest = true;
                }
            }
            return hitTest;
        }
        __hitTestMask(x, y) {
            return (this.__graphics != null && this.__graphics.__hitTest(x, y, true, this.__getRenderTransform()));
        }
        __readGraphicsData(graphicsData, recurse) {
            if (this.__graphics != null) {
                this.__graphics.__readGraphicsData(graphicsData);
            }
        }
        __setParentRenderDirty() {
            var renderParent = this.__renderParent != null ? this.__renderParent : parent;
            if (renderParent != null && !renderParent.__renderDirty) {
                // TODO: Use separate method? Based on transform, not render change
                renderParent.__localBoundsDirty = true;
                renderParent.__renderDirty = true;
                renderParent.__setParentRenderDirty();
            }
        }
        __setRenderDirty() {
            if (!this.__renderDirty) {
                this.__renderDirty = true;
                this.__setParentRenderDirty();
            }
        }
        __setStageReferences(stage) {
            this.__stage = stage;
            if (this.__firstChild != null) {
                for (let child of this.__childIterator()) {
                    child.__stage = stage;
                    if (child.__type == DisplayObjectType$1.SIMPLE_BUTTON) {
                        var button = child;
                        if (button.__currentState != null) {
                            button.__currentState.__setStageReferences(stage);
                        }
                        if (button.hitTestState != null && button.hitTestState != button.__currentState) {
                            button.hitTestState.__setStageReferences(stage);
                        }
                    }
                }
            }
        }
        __setTransformDirty(force = false) {
            this.__transformDirty = true;
        }
        __stopAllMovieClips() { }
        __update(transformOnly, updateChildren) {
            this.__updateSingle(transformOnly, updateChildren);
        }
        __updateSingle(transformOnly, updateChildren) {
            var renderParent = this.__renderParent != null ? this.__renderParent : parent;
            if (this.__isMask && renderParent == null)
                renderParent = this.__maskTarget;
            this.__renderable = (this.__visible && this.__scaleX != 0 && this.__scaleY != 0 && !this.__isMask && (renderParent == null || !renderParent.__isMask));
            if (this.__transformDirty) {
                if (this.__worldTransform == null) {
                    this.__worldTransform = new Matrix();
                }
                if (this.__renderTransform == null) {
                    this.__renderTransform = new Matrix();
                }
                if (parent != null) {
                    DisplayObject.__calculateAbsoluteTransform(this.__transform, parent.__worldTransform, this.__worldTransform);
                }
                else {
                    this.__worldTransform.copyFrom(this.__transform);
                }
                if (renderParent != null) {
                    DisplayObject.__calculateAbsoluteTransform(this.__transform, renderParent.__renderTransform, this.__renderTransform);
                }
                else {
                    this.__renderTransform.copyFrom(this.__transform);
                }
                if (this.__scrollRect != null) {
                    this.__renderTransform.__translateTransformed(-this.__scrollRect.x, -this.__scrollRect.y);
                }
                this.__transformDirty = false;
            }
            if (!transformOnly) {
                if (DisplayObject.__supportDOM) {
                    this.__renderTransformChanged = !this.__renderTransform.equals(this.__renderTransformCache);
                    if (this.__renderTransformCache == null) {
                        this.__renderTransformCache = this.__renderTransform.clone();
                    }
                    else {
                        this.__renderTransformCache.copyFrom(this.__renderTransform);
                    }
                }
                if (renderParent != null) {
                    if (DisplayObject.__supportDOM) {
                        var worldVisible = (renderParent.__worldVisible && this.__visible);
                        this.__worldVisibleChanged = (this.__worldVisible != worldVisible);
                        this.__worldVisible = worldVisible;
                        var worldAlpha = this.alpha * renderParent.__worldAlpha;
                        this.__worldAlphaChanged = (this.__worldAlpha != worldAlpha);
                        this.__worldAlpha = worldAlpha;
                    }
                    else {
                        this.__worldAlpha = this.alpha * renderParent.__worldAlpha;
                    }
                    if (this.__objectTransform != null) {
                        this.__worldColorTransform.__copyFrom(this.__objectTransform.colorTransform);
                        this.__worldColorTransform.__combine(renderParent.__worldColorTransform);
                    }
                    else {
                        this.__worldColorTransform.__copyFrom(renderParent.__worldColorTransform);
                    }
                    if (this.__blendMode == null || this.__blendMode == BlendMode.NORMAL) {
                        // TODO: Handle multiple blend modes better
                        this.__worldBlendMode = renderParent.__worldBlendMode;
                    }
                    else {
                        this.__worldBlendMode = this.__blendMode;
                    }
                    if (this.__shader == null) {
                        this.__worldShader = renderParent.__shader;
                    }
                    else {
                        this.__worldShader = this.__shader;
                    }
                    if (this.__scale9Grid == null) {
                        this.__worldScale9Grid = renderParent.__scale9Grid;
                    }
                    else {
                        this.__worldScale9Grid = this.__scale9Grid;
                    }
                }
                else {
                    this.__worldAlpha = this.alpha;
                    if (DisplayObject.__supportDOM) {
                        this.__worldVisibleChanged = (this.__worldVisible != this.__visible);
                        this.__worldVisible = this.__visible;
                        this.__worldAlphaChanged = (this.__worldAlpha != this.alpha);
                    }
                    if (this.__objectTransform != null) {
                        this.__worldColorTransform.__copyFrom(this.__objectTransform.colorTransform);
                    }
                    else {
                        this.__worldColorTransform.__identity();
                    }
                    this.__worldBlendMode = this.__blendMode;
                    this.__worldShader = this.__shader;
                    this.__worldScale9Grid = this.__scale9Grid;
                }
            }
            // TODO: Flatten
            if (updateChildren && this.mask != null) {
                this.mask.__update(transformOnly, true);
            }
        }
        // Get & Set Methods
        /**
            Indicates the alpha transparency value of the object specified. Valid
            values are 0 (fully transparent) to 1 (fully opaque). The default value is 1.
            Display objects with `alpha` set to 0 _are_ active, even though they are invisible.
        **/
        get alpha() {
            return this.__alpha;
        }
        set alpha(value) {
            if (value > 1.0)
                value = 1.0;
            if (value < 0.0)
                value = 0.0;
            if (value != this.__alpha && !this.cacheAsBitmap)
                this.__setRenderDirty();
            this.__alpha = value;
        }
        /**
            A value from the BlendMode class that specifies which blend mode to use. A
            bitmap can be drawn internally in two ways. If you have a blend mode
            enabled or an external clipping mask, the bitmap is drawn by adding a
            bitmap-filled square shape to the vector render. If you attempt to set
            this property to an invalid value, Flash runtimes set the value to
            `BlendMode.NORMAL`.
    
            The `blendMode` property affects each pixel of the display
            object. Each pixel is composed of three constituent colors(red, green,
            and blue), and each constituent color has a value between 0x00 and 0xFF.
            Flash Player or Adobe AIR compares each constituent color of one pixel in
            the movie clip with the corresponding color of the pixel in the
            background. For example, if `blendMode` is set to
            `BlendMode.LIGHTEN`, Flash Player or Adobe AIR compares the red
            value of the display object with the red value of the background, and uses
            the lighter of the two as the value for the red component of the displayed
            color.
    
            The following table describes the `blendMode` settings. The
            BlendMode class defines string values you can use. The illustrations in
            the table show `blendMode` values applied to a circular display
            object(2) superimposed on another display object(1).
    
            ![Square Number 1](/images/blendMode-0a.jpg)  ![Circle Number 2](/images/blendMode-0b.jpg)
    
            | BlendMode Constant | Illustration | Description |
            | --- | --- | --- |
            | `BlendMode.NORMAL` | ![blend mode NORMAL](/images/blendMode-1.jpg) | The display object appears in front of the background. Pixel values of the display objectthose of the background. Where the display object is transparent, the background is visible. |
            | `BlendMode.LAYER` | ![blend mode LAYER](/images/blendMode-2.jpg) | Forces the creation of a transparency group for the display object. This means that the display object is pre-composed in a temporary buffer before it is processed further. This is done automatically if the display object is pre-cached using bitmap caching or if the display object is a display object container with at least one child object with a `blendMode` setting other than `BlendMode.NORMAL`. Not supported under GPU rendering. |
            | `BlendMode.MULTIPLY` | ![blend mode MULTIPLY](/images/blendMode-3.jpg) | Multiplies the values of the display object constituent colors by the colors of the background color, and then normalizes by dividing by 0xFF, resulting in darker colors. This setting is commonly used for shadows and depth effects.<br>For example, if a constituent color (such as red) of one pixel in the display object and the corresponding color of the pixel in the background both have the value 0x88, the multiplied result is 0x4840. Dividing by 0xFF yields a value of 0x48 for that constituent color, which is a darker shade than the color of the display object or the color of the background. |
            | `BlendMode.SCREEN` | ![blend mode SCREEN](/images/blendMode-4.jpg) | Multiplies the complement (inverse) of the display object color by the complement of the background color, resulting in a bleaching effect. This setting is commonly used for highlights or to remove black areas of the display object. |
            | `BlendMode.LIGHTEN` | ![blend mode LIGHTEN](/images/blendMode-5.jpg) | Selects the lighter of the constituent colors of the display object and the color of the background (the colors with the larger values). This setting is commonly used for superimposing type.<br>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0xFFF833 (because 0xFF > 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33). Not supported under GPU rendering. |
            | `BlendMode.DARKEN` | ![blend mode DARKEN](/images/blendMode-6.jpg) | Selects the darker of the constituent colors of the display object and the colors of the background (the colors with the smaller values). This setting is commonly used for superimposing type.<br>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0xDDCC00 (because 0xFF > 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33). Not supported under GPU rendering. |
            | `BlendMode.DIFFERENCE` | ![blend mode DIFFERENCE](/images/blendMode-7.jpg) | Compares the constituent colors of the display object with the colors of its background, and subtracts the darker of the values of the two constituent colors from the lighter value. This setting is commonly used for more vibrant colors.<br>For example, if the display object has a pixel with an RGB value of 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the resulting RGB value for the displayed pixel is 0x222C33 (because 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33). |
            | `BlendMode.ADD` | ![blend mode ADD](/images/blendMode-8.jpg) | Adds the values of the constituent colors of the display object to the colors of its background, applying a ceiling of 0xFF. This setting is commonly used for animating a lightening dissolve between two objects.<br>For example, if the display object has a pixel with an RGB value of 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the resulting RGB value for the displayed pixel is 0xFFC833 (because 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33). |
            | `BlendMode.SUBTRACT` | ![blend mode SUBTRACT](/images/blendMode-9.jpg) | Subtracts the values of the constituent colors in the display object from the values of the background color, applying a floor of 0. This setting is commonly used for animating a darkening dissolve between two objects.<br>For example, if the display object has a pixel with an RGB value of 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the resulting RGB value for the displayed pixel is 0x338400 (because 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00). |
            | `BlendMode.INVERT` | ![blend mode INVERT](/images/blendMode-10.jpg) | Inverts the background. |
            | `BlendMode.ALPHA` | ![blend mode ALPHA](/images/blendMode-11.jpg) | Applies the alpha value of each pixel of the display object to the background. This requires the `blendMode` setting of the parent display object to be set to `BlendMode.LAYER`. For example, in the illustration, the parent display object, which is a white background, has `blendMode = BlendMode.LAYER`. Not supported under GPU rendering. |
            | `BlendMode.ERASE` | ![blend mode ERASE](/images/blendMode-12.jpg) | Erases the background based on the alpha value of the display object. This requires the `blendMode` of the parent display object to be set to `BlendMode.LAYER`. For example, in the illustration, the parent display object, which is a white background, has `blendMode = BlendMode.LAYER`. Not supported under GPU rendering. |
            | `BlendMode.OVERLAY` | ![blend mode OVERLAY](/images/blendMode-13.jpg) | Adjusts the color of each pixel based on the darkness of the background. If the background is lighter than 50% gray, the display object and background colors are screened, which results in a lighter color. If the background is darker than 50% gray, the colors are multiplied, which results in a darker color. This setting is commonly used for shading effects. Not supported under GPU rendering. |
            | `BlendMode.HARDLIGHT` | ![blend mode HARDLIGHT](/images/blendMode-14.jpg) | Adjusts the color of each pixel based on the darkness of the display object. If the display object is lighter than 50% gray, the display object and background colors are screened, which results in a lighter color. If the display object is darker than 50% gray, the colors are multiplied, which results in a darker color. This setting is commonly used for shading effects. Not supported under GPU rendering. |
            | `BlendMode.SHADER` | N/A | Adjusts the color using a custom shader routine. The shader that is used is specified as the Shader instance assigned to the blendShader property. Setting the blendShader property of a display object to a Shader instance automatically sets the display object's `blendMode` property to `BlendMode.SHADER`. If the `blendMode` property is set to `BlendMode.SHADER` without first setting the `blendShader` property, the `blendMode` property is set to `BlendMode.NORMAL`. Not supported under GPU rendering. |
        **/
        get blendMode() {
            return this.__blendMode;
        }
        set blendMode(value) {
            if (value == null)
                value = BlendMode.NORMAL;
            if (value != this.__blendMode)
                this.__setRenderDirty();
            this.__blendMode = value;
        }
        /**
            All vector data for a display object that has a cached bitmap is drawn
            to the bitmap instead of the main display. If
            `cacheAsBitmapMatrix` is null or unsupported, the bitmap is
            then copied to the main display as unstretched, unrotated pixels snapped
            to the nearest pixel boundaries. Pixels are mapped 1 to 1 with the parent
            object. If the bounds of the bitmap change, the bitmap is recreated
            instead of being stretched.
    
            If `cacheAsBitmapMatrix` is non-null and supported, the
            object is drawn to the off-screen bitmap using that matrix and the
            stretched and/or rotated results of that rendering are used to draw the
            object to the main display.
    
            No internal bitmap is created unless the `cacheAsBitmap`
            property is set to `true`.
    
            After you set the `cacheAsBitmap` property to
            `true`, the rendering does not change, however the display
            object performs pixel snapping automatically. The animation speed can be
            significantly faster depending on the complexity of the vector content.
    
            The `cacheAsBitmap` property is automatically set to
            `true` whenever you apply a filter to a display object(when
            its `filter` array is not empty), and if a display object has a
            filter applied to it, `cacheAsBitmap` is reported as
            `true` for that display object, even if you set the property to
            `false`. If you clear all filters for a display object, the
            `cacheAsBitmap` setting changes to what it was last set to.
    
            A display object does not use a bitmap even if the
            `cacheAsBitmap` property is set to `true` and
            instead renders from vector data in the following cases:
    
            * The bitmap is too large. In AIR 1.5 and Flash Player 10, the maximum
            size for a bitmap image is 8,191 pixels in width or height, and the total
            number of pixels cannot exceed 16,777,215 pixels.(So, if a bitmap image
            is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9
            and earlier, the limitation is is 2880 pixels in height and 2,880 pixels
            in width.
            *  The bitmap fails to allocate(out of memory error).
    
            The `cacheAsBitmap` property is best used with movie clips
            that have mostly static content and that do not scale and rotate
            frequently. With such movie clips, `cacheAsBitmap` can lead to
            performance increases when the movie clip is translated(when its _x_
            and _y_ position is changed).
        **/
        get cacheAsBitmap() {
            return (this.__filters == null ? this.__cacheAsBitmap : true);
        }
        set cacheAsBitmap(value) {
            if (value != this.__cacheAsBitmap) {
                this.__setRenderDirty();
            }
            this.__cacheAsBitmap = value;
        }
        /**
            If non-null, this Matrix object defines how a display object is rendered when `cacheAsBitmap` is set to
            `true`. The application uses this matrix as a transformation matrix that is applied when rendering the
            bitmap version of the display object.
    
            _AIR profile support:_ This feature is supported on mobile devices, but it is not supported on desktop
            operating systems. It also has limited support on AIR for TV devices. Specifically, on AIR for TV devices,
            supported transformations include scaling and translation, but not rotation and skewing. See AIR Profile
            Support for more information regarding API support across multiple profiles.
    
            With `cacheAsBitmapMatrix` set, the application retains a cached bitmap image across various 2D
            transformations, including translation, rotation, and scaling. If the application uses hardware acceleration,
            the object will be stored in video memory as a texture. This allows the GPU to apply the supported
            transformations to the object. The GPU can perform these transformations faster than the CPU.
    
            To use the hardware acceleration, set Rendering to GPU in the General tab of the iPhone Settings dialog box
            in Flash Professional CS5. Or set the `renderMode` property to gpu in the application descriptor file. Note
            that AIR for TV devices automatically use hardware acceleration if it is available.
    
            For example, the following code sends an untransformed bitmap representation of the display object to the GPU:
    
            ```haxe
            var matrix:Matrix = new Matrix(); // creates an identity matrix
            mySprite.cacheAsBitmapMatrix = matrix;
            mySprite.cacheAsBitmap = true;
            ```
    
            Usually, the identity matrix (`new Matrix()`) suffices. However, you can use another matrix, such as a
            scaled-down matrix, to upload a different bitmap to the GPU. For example, the following example applies a
            `cacheAsBitmapMatrix` matrix that is scaled by 0.5 on the x and y axes. The bitmap object that the GPU uses
            is smaller, however the GPU adjusts its size to match the `transform.matrix` property of the display object:
    
            ```haxe
            var matrix:Matrix = new Matrix(); // creates an identity matrix
            matrix.scale(0.5, 0.5); // scales the matrix
            mySprite.cacheAsBitmapMatrix = matrix;
            mySprite.cacheAsBitmap = true;
            ```
    
            Generally, you should choose to use a matrix that transforms the display object to the size that it will
            appear in the application. For example, if your application displays the bitmap version of the sprite scaled
            down by a half, use a matrix that scales down by a half. If you application will display the sprite larger
            than its current dimensions, use a matrix that scales up by that factor.
    
            **Note:** The `cacheAsBitmapMatrix` property is suitable for 2D transformations. If you need to apply
            transformations in 3D, you may do so by setting a 3D property of the object and manipulating its
            `transform.matrix3D` property. If the application is packaged using GPU mode, this allows the 3D transforms
            to be applied to the object by the GPU. The `cacheAsBitmapMatrix` is ignored for 3D objects.
        **/
        get cacheAsBitmapMatrix() {
            return this.__cacheAsBitmapMatrix;
        }
        set cacheAsBitmapMatrix(value) {
            this.__setRenderDirty();
            this.__cacheAsBitmapMatrix = (value != null ? value.clone() : value);
        }
        /**
            An indexed array that contains each filter object currently associated
            with the display object. The openfl.filters namespace contains several
            classes that define specific filters you can use.
    
            Filters can be applied in Flash Professional at design time, or at run
            time by using ActionScript code. To apply a filter by using ActionScript,
            you must make a temporary copy of the entire `filters` array,
            modify the temporary array, then assign the value of the temporary array
            back to the `filters` array. You cannot directly add a new
            filter object to the `filters` array.
    
            To add a filter by using ActionScript, perform the following steps
            (assume that the target display object is named
            `myDisplayObject`):
    
            1. Create a new filter object by using the constructor method of your
            chosen filter class.
            2. Assign the value of the `myDisplayObject.filters` array
            to a temporary array, such as one named `myFilters`.
            3. Add the new filter object to the `myFilters` temporary
            array.
            4. Assign the value of the temporary array to the
            `myDisplayObject.filters` array.
    
            If the `filters` array is undefined, you do not need to use
            a temporary array. Instead, you can directly assign an array literal that
            contains one or more filter objects that you create. The first example in
            the Examples section adds a drop shadow filter by using code that handles
            both defined and undefined `filters` arrays.
    
            To modify an existing filter object, you must use the technique of
            modifying a copy of the `filters` array:
    
            1. Assign the value of the `filters` array to a temporary
            array, such as one named `myFilters`.
            2. Modify the property by using the temporary array,
            `myFilters`. For example, to set the quality property of the
            first filter in the array, you could use the following code:
            `myFilters[0].quality = 1;`
            3. Assign the value of the temporary array to the `filters`
            array.
    
            At load time, if a display object has an associated filter, it is
            marked to cache itself as a transparent bitmap. From this point forward,
            as long as the display object has a valid filter list, the player caches
            the display object as a bitmap. This source bitmap is used as a source
            image for the filter effects. Each display object usually has two bitmaps:
            one with the original unfiltered source display object and another for the
            final image after filtering. The final image is used when rendering. As
            long as the display object does not change, the final image does not need
            updating.
    
            The openfl.filters namespace includes classes for filters. For example, to
            create a DropShadow filter, you would write:
    
            @throws ArgumentError When `filters` includes a ShaderFilter
                                and the shader output type is not compatible with
                                this operation(the shader must specify a
                                `pixel4` output).
            @throws ArgumentError When `filters` includes a ShaderFilter
                                and the shader doesn't specify any image input or
                                the first input is not an `image4` input.
            @throws ArgumentError When `filters` includes a ShaderFilter
                                and the shader specifies an image input that isn't
                                provided.
            @throws ArgumentError When `filters` includes a ShaderFilter, a
                                ByteArray or Vector.<Number> instance as a shader
                                input, and the `width` and
                                `height` properties aren't specified for
                                the ShaderInput object, or the specified values
                                don't match the amount of data in the input data.
                                See the `ShaderInput.input` property for
                                more information.
        **/
        get filters() {
            if (this.__filters == null) {
                return new Array();
            }
            else {
                return this.__filters.slice();
            }
        }
        set filters(value) {
            if (value != null && value.length > 0) {
                // TODO: Copy incoming array values
                this.__filters = value;
                // __updateFilters = true;
                this.__setRenderDirty();
            }
            else if (this.__filters != null) {
                this.__filters = null;
                // __updateFilters = false;
                this.__setRenderDirty();
            }
        }
        /**
            Indicates the height of the display object, in pixels. The height is
            calculated based on the bounds of the content of the display object. When
            you set the `height` property, the `scaleY` property
            is adjusted accordingly, as shown in the following code:
    
            Except for TextField and Video objects, a display object with no
            content(such as an empty sprite) has a height of 0, even if you try to
            set `height` to a different value.
        **/
        get height() {
            return this.__getLocalBounds().height;
        }
        set height(value) {
            var rect = Rectangle.__pool.get();
            var matrix = Matrix.__pool.get();
            matrix.identity();
            this.__getBounds(rect, matrix);
            if (value != rect.height) {
                this.scaleY = value / rect.height;
            }
            else {
                this.scaleY = 1;
            }
            Rectangle.__pool.release(rect);
            Matrix.__pool.release(matrix);
        }
        /**
            Returns a LoaderInfo object containing information about loading the file
            to which this display object belongs. The `loaderInfo` property
            is defined only for the root display object of a SWF file or for a loaded
            Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
            `loaderInfo` object associated with the SWF file that contains
            a display object named `myDisplayObject`, use
            `myDisplayObject.root.loaderInfo`.
    
            A large SWF file can monitor its download by calling
            `this.root.loaderInfo.addEventListener(Event.COMPLETE,
            func)`.
        **/
        get loaderInfo() {
            if (this.stage != null) {
                return Lib.current.__loaderInfo;
            }
            return null;
        }
        /**
            The calling display object is masked by the specified `mask`
            object. To ensure that masking works when the Stage is scaled, the
            `mask` display object must be in an active part of the display
            list. The `mask` object itself is not drawn. Set
            `mask` to `null` to remove the mask.
    
            To be able to scale a mask object, it must be on the display list. To
            be able to drag a mask Sprite object(by calling its
            `startDrag()` method), it must be on the display list. To call
            the `startDrag()` method for a mask sprite based on a
            `mouseDown` event being dispatched by the sprite, set the
            sprite's `buttonMode` property to `true`.
    
            When display objects are cached by setting the
            `cacheAsBitmap` property to `true` an the
            `cacheAsBitmapMatrix` property to a Matrix object, both the
            mask and the display object being masked must be part of the same cached
            bitmap. Thus, if the display object is cached, then the mask must be a
            child of the display object. If an ancestor of the display object on the
            display list is cached, then the mask must be a child of that ancestor or
            one of its descendents. If more than one ancestor of the masked object is
            cached, then the mask must be a descendent of the cached container closest
            to the masked object in the display list.
    
            **Note:** A single `mask` object cannot be used to mask
            more than one calling display object. When the `mask` is
            assigned to a second display object, it is removed as the mask of the
            first object, and that object's `mask` property becomes
            `null`.
        **/
        get mask() {
            return this.__mask;
        }
        set mask(value) {
            if (value == this.__mask) {
                return;
            }
            if (value != this.__mask) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
                this.__setRenderDirty();
            }
            if (this.__mask != null) {
                this.__mask.__isMask = false;
                this.__mask.__maskTarget = null;
                this.__mask.__setTransformDirty(true);
                this.__mask.__setParentRenderDirty();
                this.__mask.__setRenderDirty();
            }
            if (value != null) {
                if (!value.__isMask) {
                    value.__setParentRenderDirty();
                }
                value.__isMask = true;
                value.__maskTarget = this;
                value.__setTransformDirty(true);
            }
            // TODO: Handle in renderer
            if (this.__renderData.cacheBitmap != null && this.__renderData.cacheBitmap.mask != value) {
                this.__renderData.cacheBitmap.mask = value;
            }
            this.__mask = value;
        }
        /**
            Indicates the x coordinate of the mouse or user input device position, in
            pixels.
    
            **Note**: For a DisplayObject that has been rotated, the returned x
            coordinate will reflect the non-rotated object.
        **/
        get mouseX() {
            var mouseX = (this.stage != null ? this.stage.__mouseX : Lib.current.stage.__mouseX);
            var mouseY = (this.stage != null ? this.stage.__mouseY : Lib.current.stage.__mouseY);
            return this.__getRenderTransform().__transformInverseX(mouseX, mouseY);
        }
        /**
            Indicates the y coordinate of the mouse or user input device position, in
            pixels.
    
            **Note**: For a DisplayObject that has been rotated, the returned y
            coordinate will reflect the non-rotated object.
        **/
        get mouseY() {
            var mouseX = (this.stage != null ? this.stage.__mouseX : Lib.current.stage.__mouseX);
            var mouseY = (this.stage != null ? this.stage.__mouseY : Lib.current.stage.__mouseY);
            return this.__getRenderTransform().__transformInverseY(mouseX, mouseY);
        }
        /**
            Indicates the instance name of the DisplayObject. The object can be
            identified in the child list of its parent display object container by
            calling the `getChildByName()` method of the display object
            container.
    
            @throws IllegalOperationError If you are attempting to set this property
                                        on an object that was placed on the timeline
                                        in the Flash authoring tool.
        **/
        get name() {
            return this.__name;
        }
        set name(value) {
            this.__name = value;
        }
        /**
            Indicates the DisplayObjectContainer object that contains this display
            object. Use the `parent` property to specify a relative path to
            display objects that are above the current display object in the display
            list hierarchy.
    
            You can use `parent` to move up multiple levels in the
            display list as in the following:
    
            ```haxe
            this.parent.parent.alpha = 20;
            ```
    
            @throws SecurityError The parent display object belongs to a security
                                sandbox to which you do not have access. You can
                                avoid this situation by having the parent movie call
                                the `Security.allowDomain()` method.
        **/
        get parent() {
            return this.__parent;
        }
        /**
            For a display object in a loaded SWF file, the `root` property
            is the top-most display object in the portion of the display list's tree
            structure represented by that SWF file. For a Bitmap object representing a
            loaded image file, the `root` property is the Bitmap object
            itself. For the instance of the main class of the first SWF file loaded,
            the `root` property is the display object itself. The
            `root` property of the Stage object is the Stage object itself.
            The `root` property is set to `null` for any display
            object that has not been added to the display list, unless it has been
            added to a display object container that is off the display list but that
            is a child of the top-most display object in a loaded SWF file.
    
            For example, if you create a new Sprite object by calling the
            `Sprite()` constructor method, its `root` property
            is `null` until you add it to the display list(or to a display
            object container that is off the display list but that is a child of the
            top-most display object in a SWF file).
    
            For a loaded SWF file, even though the Loader object used to load the
            file may not be on the display list, the top-most display object in the
            SWF file has its `root` property set to itself. The Loader
            object does not have its `root` property set until it is added
            as a child of a display object for which the `root` property is
            set.
        **/
        get root() {
            if (this.stage != null) {
                return Lib.current;
            }
            return null;
        }
        /**
            Indicates the rotation of the DisplayObject instance, in degrees, from its
            original orientation. Values from 0 to 180 represent clockwise rotation;
            values from 0 to -180 represent counterclockwise rotation. Values outside
            this range are added to or subtracted from 360 to obtain a value within
            the range. For example, the statement `my_video.rotation = 450`
            is the same as ` my_video.rotation = 90`.
        **/
        get rotation() {
            return this.__rotation;
        }
        set rotation(value) {
            if (value != this.__rotation) {
                this.__rotation = value;
                var radians = this.__rotation * (Math.PI / 180);
                this.__rotationSine = Math.sin(radians);
                this.__rotationCosine = Math.cos(radians);
                this.__transform.a = this.__rotationCosine * this.__scaleX;
                this.__transform.b = this.__rotationSine * this.__scaleX;
                this.__transform.c = -this.__rotationSine * this.__scaleY;
                this.__transform.d = this.__rotationCosine * this.__scaleY;
                this.__localBoundsDirty = true;
                this.__setTransformDirty();
                this.__setParentRenderDirty();
            }
        }
        /**
            The current scaling grid that is in effect. If set to `null`,
            the entire display object is scaled normally when any scale transformation
            is applied.
    
            When you define the `scale9Grid` property, the display
            object is divided into a grid with nine regions based on the
            `scale9Grid` rectangle, which defines the center region of the
            grid. The eight other regions of the grid are the following areas:
    
            * The upper-left corner outside of the rectangle
            * The area above the rectangle
            * The upper-right corner outside of the rectangle
            * The area to the left of the rectangle
            * The area to the right of the rectangle
            * The lower-left corner outside of the rectangle
            * The area below the rectangle
            * The lower-right corner outside of the rectangle
    
            You can think of the eight regions outside of the center (defined by
            the rectangle) as being like a picture frame that has special rules
            applied to it when scaled.
    
            **Note:** Content that is not rendered through the `graphics` interface
            of a display object will not be affected by the `scale9Grid` property.
    
            When the `scale9Grid` property is set and a display object
            is scaled, all text and gradients are scaled normally; however, for other
            types of objects the following rules apply:
    
            * Content in the center region is scaled normally.
            * Content in the corners is not scaled.
            * Content in the top and bottom regions is scaled horizontally only.
            * Content in the left and right regions is scaled vertically only.
            * All fills (including bitmaps, video, and gradients) are stretched to
            fit their shapes.
    
            If a display object is rotated, all subsequent scaling is normal(and
            the `scale9Grid` property is ignored).
    
            For example, consider the following display object and a rectangle that
            is applied as the display object's `scale9Grid`:
    
            | | |
            | --- | --- |
            | ![display object image](/images/scale9Grid-a.jpg)<br>The display object. | ![display object scale 9 region](/images/scale9Grid-b.jpg)<br>The red rectangle shows the scale9Grid. |
    
            When the display object is scaled or stretched, the objects within the rectangle scale normally, but the
            objects outside of the rectangle scale according to the `scale9Grid` rules:
    
            | | |
            | --- | --- |
            | Scaled to 75%: | ![display object at 75%](/images/scale9Grid-c.jpg) |
            | Scaled to 50%: | ![display object at 50%](/images/scale9Grid-d.jpg) |
            | Scaled to 25%: | ![display object at 25%](/images/scale9Grid-e.jpg) |
            | Stretched horizontally 150%: | ![display stretched 150%](/images/scale9Grid-f.jpg) |
    
            A common use for setting `scale9Grid` is to set up a display
            object to be used as a component, in which edge regions retain the same
            width when the component is scaled.
    
            @throws ArgumentError If you pass an invalid argument to the method.
        **/
        get scale9Grid() {
            if (this.__scale9Grid == null) {
                return null;
            }
            return this.__scale9Grid.clone();
        }
        set scale9Grid(value) {
            if (value == null && this.__scale9Grid == null)
                return;
            if (value != null && this.__scale9Grid != null && this.__scale9Grid.equals(value))
                return;
            if (value != null) {
                if (this.__scale9Grid == null)
                    this.__scale9Grid = new Rectangle();
                this.__scale9Grid.copyFrom(value);
            }
            else {
                this.__scale9Grid = null;
            }
            this.__setRenderDirty();
        }
        /**
            Indicates the horizontal scale (percentage) of the object as applied from
            the registration point. The default registration point is (0,0). 1.0
            equals 100% scale.
    
            Scaling the local coordinate system changes the `x` and
            `y` property values, which are defined in whole pixels.
        **/
        get scaleX() {
            return this.__scaleX;
        }
        set scaleX(value) {
            if (value != this.__scaleX) {
                this.__scaleX = value;
                if (this.__transform.b == 0) {
                    if (value != this.__transform.a) {
                        this.__localBoundsDirty = true;
                        this.__setTransformDirty();
                        this.__setParentRenderDirty();
                    }
                    this.__transform.a = value;
                }
                else {
                    var a = this.__rotationCosine * value;
                    var b = this.__rotationSine * value;
                    if (this.__transform.a != a || this.__transform.b != b) {
                        this.__localBoundsDirty = true;
                        this.__setTransformDirty();
                        this.__setParentRenderDirty();
                    }
                    this.__transform.a = a;
                    this.__transform.b = b;
                }
            }
        }
        /**
            Indicates the vertical scale (percentage) of an object as applied from the
            registration point of the object. The default registration point is (0,0).
            1.0 is 100% scale.
    
            Scaling the local coordinate system changes the `x` and
            `y` property values, which are defined in whole pixels.
        **/
        get scaleY() {
            return this.__scaleY;
        }
        set scaleY(value) {
            if (value != this.__scaleY) {
                this.__scaleY = value;
                if (this.__transform.c == 0) {
                    if (value != this.__transform.d) {
                        this.__localBoundsDirty = true;
                        this.__setTransformDirty();
                        this.__setParentRenderDirty();
                    }
                    this.__transform.d = value;
                }
                else {
                    var c = -this.__rotationSine * value;
                    var d = this.__rotationCosine * value;
                    if (this.__transform.d != d || this.__transform.c != c) {
                        this.__localBoundsDirty = true;
                        this.__setTransformDirty();
                        this.__setParentRenderDirty();
                    }
                    this.__transform.c = c;
                    this.__transform.d = d;
                }
            }
        }
        /**
            The scroll rectangle bounds of the display object. The display object is
            cropped to the size defined by the rectangle, and it scrolls within the
            rectangle when you change the `x` and `y` properties
            of the `scrollRect` object.
    
            The properties of the `scrollRect` Rectangle object use the
            display object's coordinate space and are scaled just like the overall
            display object. The corner bounds of the cropped window on the scrolling
            display object are the origin of the display object(0,0) and the point
            defined by the width and height of the rectangle. They are not centered
            around the origin, but use the origin to define the upper-left corner of
            the area. A scrolled display object always scrolls in whole pixel
            increments.
    
            You can scroll an object left and right by setting the `x`
            property of the `scrollRect` Rectangle object. You can scroll
            an object up and down by setting the `y` property of the
            `scrollRect` Rectangle object. If the display object is rotated
            90° and you scroll it left and right, the display object actually scrolls
            up and down.
        **/
        get scrollRect() {
            if (this.__scrollRect == null) {
                return null;
            }
            return this.__scrollRect.clone();
        }
        set scrollRect(value) {
            if (value == null && this.__scrollRect == null)
                return;
            if (value != null && this.__scrollRect != null && this.__scrollRect.equals(value))
                return;
            if (value != null) {
                if (this.__scrollRect == null)
                    this.__scrollRect = new Rectangle();
                this.__scrollRect.copyFrom(value);
            }
            else {
                this.__scrollRect = null;
            }
            this.__setTransformDirty();
            this.__setParentRenderDirty();
            if (DisplayObject.__supportDOM) {
                this.__setRenderDirty();
            }
        }
        /**
            **BETA**
    
            Applies a custom Shader object to use when rendering this display object (or its children) when using
            hardware rendering. This occurs as a single-pass render on this object only, if visible. In order to
            apply a post-process effect to multiple display objects at once, enable `cacheAsBitmap` or use the
            `filters` property with a ShaderFilter
        **/
        get shader() {
            return this.__shader;
        }
        set shader(value) {
            this.__shader = value;
            this.__setRenderDirty();
        }
        /**
            The Stage of the display object. A Flash runtime application has only one
            Stage object. For example, you can create and load multiple display
            objects into the display list, and the `stage` property of each
            display object refers to the same Stage object(even if the display object
            belongs to a loaded SWF file).
    
            If a display object is not added to the display list, its
            `stage` property is set to `null`.
        **/
        get stage() {
            return this.__stage;
        }
        /**
            An object with properties pertaining to a display object's matrix, color
            transform, and pixel bounds. The specific properties  -  matrix,
            colorTransform, and three read-only properties
            (`concatenatedMatrix`, `concatenatedColorTransform`,
            and `pixelBounds`)  -  are described in the entry for the
            Transform class.
    
            Each of the transform object's properties is itself an object. This
            concept is important because the only way to set new values for the matrix
            or colorTransform objects is to create a new object and copy that object
            into the transform.matrix or transform.colorTransform property.
    
            For example, to increase the `tx` value of a display
            object's matrix, you must make a copy of the entire matrix object, then
            copy the new object into the matrix property of the transform object:
            ` myMatrix:Matrix =
            myDisplayObject.transform.matrix; myMatrix.tx += 10;
            myDisplayObject.transform.matrix = myMatrix; `
    
            You cannot directly set the `tx` property. The following
            code has no effect on `myDisplayObject`:
            ` myDisplayObject.transform.matrix.tx +=
            10; `
    
            You can also copy an entire transform object and assign it to another
            display object's transform property. For example, the following code
            copies the entire transform object from `myOldDisplayObj` to
            `myNewDisplayObj`:
            `myNewDisplayObj.transform = myOldDisplayObj.transform;`
    
            The resulting display object, `myNewDisplayObj`, now has the
            same values for its matrix, color transform, and pixel bounds as the old
            display object, `myOldDisplayObj`.
    
            Note that AIR for TV devices use hardware acceleration, if it is
            available, for color transforms.
        **/
        get transform() {
            if (this.__objectTransform == null) {
                this.__objectTransform = new Transform(this);
            }
            return this.__objectTransform;
        }
        set transform(value) {
            if (value == null) {
                throw new TypeError$1("Parameter transform must be non-null.");
            }
            if (this.__objectTransform == null) {
                this.__objectTransform = new Transform(this);
            }
            this.__objectTransform.matrix = value.matrix;
            if (!this.__objectTransform.colorTransform.__equals(value.colorTransform, true)
                || (!this.cacheAsBitmap && this.__objectTransform.colorTransform.alphaMultiplier != value.colorTransform.alphaMultiplier)) {
                this.__objectTransform.colorTransform.__copyFrom(value.colorTransform);
                this.__setRenderDirty();
            }
        }
        /**
            Whether or not the display object is visible. Display objects that are not
            visible are disabled. For example, if `visible=false` for an
            InteractiveObject instance, it cannot be clicked.
        **/
        get visible() {
            return this.__visible;
        }
        set visible(value) {
            if (value != this.__visible)
                this.__setRenderDirty();
            this.__visible = value;
        }
        /**
            Indicates the width of the display object, in pixels. The width is
            calculated based on the bounds of the content of the display object. When
            you set the `width` property, the `scaleX` property
            is adjusted accordingly, as shown in the following code:
    
            Except for TextField and Video objects, a display object with no
            content(such as an empty sprite) has a width of 0, even if you try to set
            `width` to a different value.
        **/
        get width() {
            return this.__getLocalBounds().width;
        }
        set width(value) {
            var rect = Rectangle.__pool.get();
            var matrix = Matrix.__pool.get();
            matrix.identity();
            this.__getBounds(rect, matrix);
            if (value != rect.width) {
                this.scaleX = value / rect.width;
            }
            else {
                this.scaleX = 1;
            }
            Rectangle.__pool.release(rect);
            Matrix.__pool.release(matrix);
        }
        /**
            Indicates the _x_ coordinate of the DisplayObject instance relative
            to the local coordinates of the parent DisplayObjectContainer. If the
            object is inside a DisplayObjectContainer that has transformations, it is
            in the local coordinate system of the enclosing DisplayObjectContainer.
            Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
            DisplayObjectContainer's children inherit a coordinate system that is
            rotated 90° counterclockwise. The object's coordinates refer to the
            registration point position.
        **/
        get x() {
            return this.__transform.tx;
        }
        set x(value) {
            if (value != this.__transform.tx) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
            }
            this.__transform.tx = value;
        }
        /**
            Indicates the _y_ coordinate of the DisplayObject instance relative
            to the local coordinates of the parent DisplayObjectContainer. If the
            object is inside a DisplayObjectContainer that has transformations, it is
            in the local coordinate system of the enclosing DisplayObjectContainer.
            Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
            DisplayObjectContainer's children inherit a coordinate system that is
            rotated 90° counterclockwise. The object's coordinates refer to the
            registration point position.
        **/
        get y() {
            return this.__transform.ty;
        }
        set y(value) {
            if (value != this.__transform.ty) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
            }
            this.__transform.ty = value;
        }
    }
    DisplayObject.__broadcastEvents = new Map();
    DisplayObject.__instanceCount = 0;
    DisplayObject.__tempStack = new ObjectPool(() => new Vector(), (stack) => stack.length = 0);
    /**
        Indicates the x-axis rotation of the DisplayObject instance, in degrees, from its original orientation
        relative to the 3D parent container. Values from 0 to 180 represent clockwise rotation; values from 0 to
        -180 represent counterclockwise rotation. Values outside this range are added to or subtracted from 360 to
        obtain a value within the range.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public rotationX:Float;
    /**
        Indicates the y-axis rotation of the DisplayObject instance, in degrees, from its original orientation
        relative to the 3D parent container. Values from 0 to 180 represent clockwise rotation; values from 0 to
        -180 represent counterclockwise rotation. Values outside this range are added to or subtracted from 360 to
        obtain a value within the range.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public rotationY:Float;
    /**
        Indicates the z-axis rotation of the DisplayObject instance, in degrees, from its original orientation
        relative to the 3D parent container. Values from 0 to 180 represent clockwise rotation; values from 0 to
        -180 represent counterclockwise rotation. Values outside this range are added to or subtracted from 360 to
        obtain a value within the range.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public rotationZ:Float;
    /**
        Indicates the depth scale (percentage) of an object as applied from the registration point of the object.
        The default registration point is (0,0). 1.0 is 100% scale.

        Scaling the local coordinate system changes the `x`, `y` and `z` property values, which are defined in whole
        pixels.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public scaleZ:Float;
    DisplayObject.__childIterators = new ObjectPool(() => new DisplayObjectIterator());
    return DisplayObject;
})();

var openfl$4;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The PixelSnapping class is an enumeration of constant values for setting
            the pixel snapping options by using the `pixelSnapping` property
            of a Bitmap object.
        **/
        let PixelSnapping;
        (function (PixelSnapping) {
            /**
                A constant value used in the `pixelSnapping` property of a
                Bitmap object to specify that the bitmap image is always snapped to the
                nearest pixel, independent of any transformation.
            **/
            PixelSnapping["ALWAYS"] = "always";
            /**
                A constant value used in the `pixelSnapping` property of a
                Bitmap object to specify that the bitmap image is snapped to the nearest
                pixel if it is drawn with no rotation or skew and it is drawn at a scale
                factor of 99.9% to 100.1%. If these conditions are satisfied, the image is
                drawn at 100% scale, snapped to the nearest pixel. Internally, this
                setting allows the image to be drawn as fast as possible by using the
                vector renderer.
            **/
            PixelSnapping["AUTO"] = "auto";
            /**
                A constant value used in the `pixelSnapping` property of a
                Bitmap object to specify that no pixel snapping occurs.
            **/
            PixelSnapping["NEVER"] = "never";
        })(PixelSnapping = display.PixelSnapping || (display.PixelSnapping = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$4 || (openfl$4 = {}));
var PixelSnapping = openfl$4.display.PixelSnapping;

/**
    The Bitmap class represents display objects that represent bitmap images.
    These can be images that you load with the `openfl.Assets` or
    `openfl.display.Loader` classes, or they can be images that you
    create with the `Bitmap()` constructor.

    The `Bitmap()` constructor allows you to create a Bitmap
    object that contains a reference to a BitmapData object. After you create a
    Bitmap object, use the `addChild()` or `addChildAt()`
    method of the parent DisplayObjectContainer instance to place the bitmap on
    the display list.

    A Bitmap object can share its BitmapData reference among several Bitmap
    objects, independent of translation or rotation properties. Because you can
    create multiple Bitmap objects that reference the same BitmapData object,
    multiple display objects can use the same complex BitmapData object without
    incurring the memory overhead of a BitmapData object for each display
    object instance.

    A BitmapData object can be drawn to the screen by a Bitmap object in one
    of two ways: by using the default hardware renderer with a single hardware surface,
    or by using the slower software renderer when 3D acceleration is not available.

    If you would prefer to perform a batch rendering command, rather than using a
    single surface for each Bitmap object, you can also draw to the screen using the
    `openfl.display.Tilemap` class.

    **Note:** The Bitmap class is not a subclass of the InteractiveObject
    class, so it cannot dispatch mouse events. However, you can use the
    `addEventListener()` method of the display object container that
    contains the Bitmap object.
**/
class Bitmap extends DisplayObject {
    /**
        Initializes a Bitmap object to refer to the specified BitmapData object.

        @param	bitmapData	The BitmapData object being referenced.
        @param	pixelSnapping	Whether or not the Bitmap object is snapped to the nearest pixel.
        @param	smoothing	Whether or not the bitmap is smoothed when scaled. For example, the following examples
        show the same bitmap scaled by a factor of 3, with `smoothing` set to `false` (left) and `true` (right):

        ![A bitmap without smoothing.](/images/bitmap_smoothing_off.jpg) ![A bitmap with smoothing.](bitmap_smoothing_on.jpg)
    **/
    constructor(bitmapData = null, pixelSnapping = null, smoothing = false) {
        super();
        this.__type = DisplayObjectType$1.BITMAP;
        this.__bitmapData = bitmapData;
        this.pixelSnapping = pixelSnapping;
        this.smoothing = smoothing;
        if (pixelSnapping == null) {
            this.pixelSnapping = PixelSnapping.AUTO;
        }
    }
    __getBounds(rect, matrix) {
        var bounds = Rectangle.__pool.get();
        if (this.__bitmapData != null) {
            bounds.setTo(0, 0, this.__bitmapData.width, this.__bitmapData.height);
        }
        else {
            bounds.setTo(0, 0, 0, 0);
        }
        bounds.__transform(bounds, matrix);
        rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
        Rectangle.__pool.release(bounds);
    }
    __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        if (!hitObject.visible || this.__isMask || this.__bitmapData == null)
            return false;
        if (this.mask != null && !this.mask.__hitTestMask(x, y))
            return false;
        this.__getRenderTransform();
        var px = this.__renderTransform.__transformInverseX(x, y);
        var py = this.__renderTransform.__transformInverseY(x, y);
        if (px > 0 && py > 0 && px <= this.__bitmapData.width && py <= this.__bitmapData.height) {
            if (this.__scrollRect != null && !this.__scrollRect.contains(px, py)) {
                return false;
            }
            if (stack != null && !interactiveOnly) {
                stack.push(hitObject);
            }
            return true;
        }
        return false;
    }
    __hitTestMask(x, y) {
        if (this.__bitmapData == null)
            return false;
        this.__getRenderTransform();
        var px = this.__renderTransform.__transformInverseX(x, y);
        var py = this.__renderTransform.__transformInverseY(x, y);
        if (px > 0 && py > 0 && px <= this.__bitmapData.width && py <= this.__bitmapData.height) {
            return true;
        }
        return false;
    }
    // Get & Set Methods
    /**
        The BitmapData object being referenced.
    **/
    get bitmapData() {
        return this.__bitmapData;
    }
    set bitmapData(value) {
        this.__bitmapData = value;
        this.smoothing = false;
        this.__localBoundsDirty = true;
        this.__setRenderDirty();
        if (this.__filters != null) ;
        this.__imageVersion = -1;
    }
    set height(value) {
        if (this.__bitmapData != null) {
            this.scaleY = value / this.__bitmapData.height; // get_height();
        }
        else {
            this.scaleY = 0;
        }
    }
    set width(value) {
        if (this.__bitmapData != null) {
            this.scaleX = value / this.__bitmapData.width; // get_width();
        }
        else {
            this.scaleX = 0;
        }
    }
}

var openfl$5;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying a texture format.
        **/
        let Context3DTextureFormat;
        (function (Context3DTextureFormat) {
            /**
                16 bit, bgr packed as 5:6:5
            **/
            Context3DTextureFormat["BGR_PACKED"] = "bgrPacked565";
            /**
                32 bit
            **/
            Context3DTextureFormat["BGRA"] = "bgra";
            /**
                16 bit, bgra packed as 4:4:4:4
            **/
            Context3DTextureFormat["BGRA_PACKED"] = "bgraPacked4444";
            /**
                ATF (Adobe Texture Format)
            **/
            Context3DTextureFormat["COMPRESSED"] = "compressed";
            /**
                ATF (Adobe Texture Format), with alpha
            **/
            Context3DTextureFormat["COMPRESSED_ALPHA"] = "compressedAlpha";
            /**
                64 bit, rgba as 16:16:16:16
            **/
            Context3DTextureFormat["RGBA_HALF_FLOAT"] = "rgbaHalfFloat";
        })(Context3DTextureFormat = display3D.Context3DTextureFormat || (display3D.Context3DTextureFormat = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$5 || (openfl$5 = {}));
var Context3DTextureFormat = openfl$5.display3D.Context3DTextureFormat;

class BitmapDataPool {
    constructor(lifetime = 2, context3D = null) {
        this.__lifetime = lifetime;
        this.__context = context3D;
        this.__bitmapData = new Map();
        this.__bitmapDataAge = new Map();
        this.__bitmapDataList = new Array();
    }
    cleanup() {
        for (let bitmapData of this.__bitmapDataList) {
            var age = this.__bitmapDataAge.get(bitmapData);
            if (age >= this.__lifetime) {
                this.__bitmapData[bitmapData.width][bitmapData.height].remove(bitmapData);
                bitmapData.dispose();
                this.__bitmapDataAge.delete(bitmapData);
                var index = this.__bitmapDataList.indexOf(bitmapData);
                if (index > -1)
                    this.__bitmapDataList.splice(index, 1);
            }
            else if (age > -1) {
                this.__bitmapDataAge.set(bitmapData, age + 1);
            }
        }
    }
    get(width, height) {
        // #if openfl_power_of_two
        // width = __powerOfTwo(width);
        // height = __powerOfTwo(height);
        // #end
        var heightMap = this.__bitmapData[width];
        if (heightMap == null) {
            heightMap = this.__bitmapData[width] = new Map();
        }
        var pool = heightMap[height];
        if (pool == null) {
            pool = heightMap[height] = new ObjectPool(this.__createBitmapData.bind(width, height), this.__cleanBitmapData);
        }
        var bitmapData = pool.get();
        if (bitmapData == null)
            return null;
        if (!this.__bitmapDataAge.has(bitmapData)) {
            this.__bitmapDataList.push(bitmapData);
        }
        this.__bitmapDataAge[bitmapData] = -1;
        return bitmapData;
    }
    release(bitmapData) {
        if (this.__bitmapDataAge.has(bitmapData)) {
            this.__bitmapData[bitmapData.width][bitmapData.height].release(bitmapData);
            this.__bitmapDataAge.set(bitmapData, 0);
        }
    }
    __cleanBitmapData(bitmapData) {
        bitmapData.fillRect(bitmapData.rect, 0);
    }
    __createBitmapData(width, height) {
        if (this.__context != null) {
            var texture = this.__context.createRectangleTexture(width, height, Context3DTextureFormat.BGRA, true);
            var bitmapData = BitmapData.fromTexture(texture);
            // bitmapData.setUVRect(__context, 0, 0, width, height);
            return bitmapData;
        }
        else {
            return new BitmapData(width, height, true, 0);
        }
    }
}

// import Context3DRenderer from "../_internal/renderer/context3D/Context3DRenderer";
/**
    The BitmapData class lets you work with the data (pixels) of a Bitmap
    object. You can use the methods of the BitmapData class to create
    arbitrarily sized transparent or opaque bitmap images and manipulate them
    in various ways at runtime. You can also access the BitmapData for a bitmap
    image that you load with the `openfl.Assets` or
    `openfl.display.Loader` classes.

    This class lets you separate bitmap rendering operations from the
    internal display updating routines of OpenFL. By manipulating a
    BitmapData object directly, you can create complex images without incurring
    the per-frame overhead of constantly redrawing the content from vector
    data.

    The methods of the BitmapData class support effects that are not
    available through the filters available to non-bitmap display objects.

    A BitmapData object contains an array of pixel data. This data can
    represent either a fully opaque bitmap or a transparent bitmap that
    contains alpha channel data. Either type of BitmapData object is stored as
    a buffer of 32-bit integers. Each 32-bit integer determines the properties
    of a single pixel in the bitmap.

    Each 32-bit integer is a combination of four 8-bit channel values (from
    0 to 255) that describe the alpha transparency and the red, green, and blue
    (ARGB) values of the pixel. (For ARGB values, the most significant byte
    represents the alpha channel value, followed by red, green, and blue.)

    The four channels (alpha, red, green, and blue) are represented as
    numbers when you use them with the `BitmapData.copyChannel()`
    method or the `DisplacementMapFilter.componentX` and
    `DisplacementMapFilter.componentY` properties, and these numbers
    are represented by the following constants in the BitmapDataChannel
    class:

    * `BitmapDataChannel.ALPHA`
    * `BitmapDataChannel.RED`
    * `BitmapDataChannel.GREEN`
    * `BitmapDataChannel.BLUE`

    You can attach BitmapData objects to a Bitmap object by using the
    `bitmapData` property of the Bitmap object.

    You can use a BitmapData object to fill a Graphics object by using the
    `Graphics.beginBitmapFill()` method.

    You can also use a BitmapData object to perform batch tile rendering
    using the `openfl.display.Tilemap` class.

    In Flash Player 10, the maximum size for a BitmapData object
    is 8,191 pixels in width or height, and the total number of pixels cannot
    exceed 16,777,215 pixels. (So, if a BitmapData object is 8,191 pixels wide,
    it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
    is 2,880 pixels in height and 2,880 in width.
**/
let BitmapData = /** @class */ (() => {
    class BitmapData {
        /**
            Creates a BitmapData object with a specified width and height. If you specify a value for
            the `fillColor` parameter, every pixel in the bitmap is set to that color.
    
            By default, the bitmap is created as transparent, unless you pass the value `false`
            for the transparent parameter. After you create an opaque bitmap, you cannot change it
            to a transparent bitmap. Every pixel in an opaque bitmap uses only 24 bits of color channel
            information. If you define the bitmap as transparent, every pixel uses 32 bits of color
            channel information, including an alpha transparency channel.
    
            @param	width		The width of the bitmap image in pixels.
            @param	height		The height of the bitmap image in pixels.
            @param	transparent		Specifies whether the bitmap image supports per-pixel transparency. The default value is `true`(transparent). To create a fully transparent bitmap, set the value of the `transparent` parameter to `true` and the value of the `fillColor` parameter to 0x00000000(or to 0). Setting the `transparent` property to `false` can result in minor improvements in rendering performance.
            @param	fillColor		A 32-bit ARGB color value that you use to fill the bitmap image area. The default value is 0xFFFFFFFF(solid white).
        **/
        constructor(width, height, transparent = true, fillColor = 0xFFFFFFFF) {
            this.__transparent = transparent;
            width = width == null ? 0 : width;
            height = height == null ? 0 : height;
            width = width < 0 ? 0 : width;
            height = height < 0 ? 0 : height;
            this.__width = width;
            this.__height = height;
            this.__rect = new Rectangle(0, 0, width, height);
            this.__renderData = new DisplayObjectRenderData();
            this.__renderTransform = new Matrix();
            this.__worldAlpha = 1;
            this.__worldTransform = new Matrix();
            this.__worldColorTransform = new ColorTransform();
            this.__renderable = true;
            // __backend = new BitmapDataBackend(this, width, height, transparent, fillColor);
        }
        /**
            Takes a source image and a filter object and generates the filtered image.
    
            This method relies on the behavior of built-in filter objects, which determine the
            destination rectangle that is affected by an input source rectangle.
    
            After a filter is applied, the resulting image can be larger than the input image.
            For example, if you use a BlurFilter class to blur a source rectangle of(50,50,100,100)
            and a destination point of(10,10), the area that changes in the destination image is
            larger than(10,10,60,60) because of the blurring. This happens internally during the
            applyFilter() call.
    
            If the `sourceRect` parameter of the sourceBitmapData parameter is an
            interior region, such as(50,50,100,100) in a 200 x 200 image, the filter uses the source
            pixels outside the `sourceRect` parameter to generate the destination rectangle.
    
            If the BitmapData object and the object specified as the `sourceBitmapData`
            parameter are the same object, the application uses a temporary copy of the object to
            perform the filter. For best performance, avoid this situation.
    
            @param	sourceBitmapData		The input bitmap image to use. The source image can be a different BitmapData object or it can refer to the current BitmapData instance.
            @param	sourceRect		A rectangle that defines the area of the source image to use as input.
            @param	destPoint		The point within the destination image(the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle.
            @param	filter		The filter object that you use to perform the filtering operation.
        **/
        applyFilter(sourceBitmapData, sourceRect, destPoint, filter) {
            if (!this.readable || sourceBitmapData == null || !sourceBitmapData.readable)
                return;
            // __backend.applyFilter(sourceBitmapData, sourceRect, destPoint, filter);
        }
        /**
            Returns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap.
            @return		A new BitmapData object that is identical to the original.
        **/
        clone() {
            // return __backend.clone();
            return null;
        }
        /**
            Adjusts the color values in a specified area of a bitmap image by using a `ColorTransform`
            object. If the rectangle matches the boundaries of the bitmap image, this method transforms the color
            values of the entire image.
            @param	rect		A Rectangle object that defines the area of the image in which the ColorTransform object is applied.
            @param	colorTransform		A ColorTransform object that describes the color transformation values to apply.
        **/
        colorTransform(rect, colorTransform) {
            if (!this.readable)
                return;
            // __backend.colorTransform(rect, colorTransform);
        }
        /**
            Compares two BitmapData objects. If the two BitmapData objects have the same dimensions (width and height), the method returns a new BitmapData object, in which each pixel is the "difference" between the pixels in the two source objects:
    
            - If two pixels are equal, the difference pixel is 0x00000000.
            - If two pixels have different RGB values (ignoring the alpha value), the difference pixel is 0xFFRRGGBB where RR/GG/BB are the individual difference values between red, green, and blue channels. Alpha channel differences are ignored in this case.
            - If only the alpha channel value is different, the pixel value is 0xZZFFFFFF, where ZZ is the difference in the alpha value.
    
            @param	otherBitmapData The BitmapData object to compare with the source BitmapData object.
            @return If the two BitmapData objects have the same dimensions (width and height), the method returns a new BitmapData object that has the difference between the two objects (see the main discussion).If the BitmapData objects are equivalent, the method returns the number 0. If no argument is passed or if the argument is not a BitmapData object, the method returns -1. If either BitmapData object has been disposed of, the method returns -2. If the widths of the BitmapData objects are not equal, the method returns the number -3. If the heights of the BitmapData objects are not equal, the method returns the number -4.
        **/
        compare(otherBitmapData) {
            if (otherBitmapData == this) {
                return 0;
            }
            else if (otherBitmapData == null) {
                return -1;
            }
            else if (this.readable == false || otherBitmapData.readable == false) {
                return -2;
            }
            else if (this.__width != otherBitmapData.width) {
                return -3;
            }
            else if (this.__height != otherBitmapData.height) {
                return -4;
            }
            // return __backend.compare(otherBitmapData);
            return null;
        }
        /**
            Transfers data from one channel of another BitmapData object or the
            current BitmapData object into a channel of the current BitmapData object.
            All of the data in the other channels in the destination BitmapData object
            are preserved.
    
            The source channel value and destination channel value can be one of
            following values:
    
            * `BitmapDataChannel.RED`
            * `BitmapDataChannel.GREEN`
            * `BitmapDataChannel.BLUE`
            * `BitmapDataChannel.ALPHA`
    
    
            @param sourceBitmapData The input bitmap image to use. The source image
                                    can be a different BitmapData object or it can
                                    refer to the current BitmapData object.
            @param sourceRect       The source Rectangle object. To copy only channel
                                    data from a smaller area within the bitmap,
                                    specify a source rectangle that is smaller than
                                    the overall size of the BitmapData object.
            @param destPoint        The destination Point object that represents the
                                    upper-left corner of the rectangular area where
                                    the new channel data is placed. To copy only
                                    channel data from one area to a different area in
                                    the destination image, specify a point other than
                                   (0,0).
            @param sourceChannel    The source channel. Use a value from the
                                    BitmapDataChannel class
                                   (`BitmapDataChannel.RED`,
                                    `BitmapDataChannel.BLUE`,
                                    `BitmapDataChannel.GREEN`,
                                    `BitmapDataChannel.ALPHA`).
            @param destChannel      The destination channel. Use a value from the
                                    BitmapDataChannel class
                                   (`BitmapDataChannel.RED`,
                                    `BitmapDataChannel.BLUE`,
                                    `BitmapDataChannel.GREEN`,
                                    `BitmapDataChannel.ALPHA`).
            @throws TypeError The sourceBitmapData, sourceRect or destPoint are null.
        **/
        copyChannel(sourceBitmapData, sourceRect, destPoint, sourceChannel, destChannel) {
            if (!this.readable)
                return;
            // __backend.copyChannel(sourceBitmapData, sourceRect, destPoint, sourceChannel, destChannel);
        }
        /**
            Provides a fast routine to perform pixel manipulation between images with
            no stretching, rotation, or color effects. This method copies a
            rectangular area of a source image to a rectangular area of the same size
            at the destination point of the destination BitmapData object.
    
            If you include the `alphaBitmap` and `alphaPoint`
            parameters, you can use a secondary image as an alpha source for the
            source image. If the source image has alpha data, both sets of alpha data
            are used to composite pixels from the source image to the destination
            image. The `alphaPoint` parameter is the point in the alpha
            image that corresponds to the upper-left corner of the source rectangle.
            Any pixels outside the intersection of the source image and alpha image
            are not copied to the destination image.
    
            The `mergeAlpha` property controls whether or not the alpha
            channel is used when a transparent image is copied onto another
            transparent image. To copy pixels with the alpha channel data, set the
            `mergeAlpha` property to `true`. By default, the
            `mergeAlpha` property is `false`.
    
            @param sourceBitmapData The input bitmap image from which to copy pixels.
                                    The source image can be a different BitmapData
                                    instance, or it can refer to the current
                                    BitmapData instance.
            @param sourceRect       A rectangle that defines the area of the source
                                    image to use as input.
            @param destPoint        The destination point that represents the
                                    upper-left corner of the rectangular area where
                                    the new pixels are placed.
            @param alphaBitmapData  A secondary, alpha BitmapData object source.
            @param alphaPoint       The point in the alpha BitmapData object source
                                    that corresponds to the upper-left corner of the
                                    `sourceRect` parameter.
            @param mergeAlpha       To use the alpha channel, set the value to
                                    `true`. To copy pixels with no alpha
                                    channel, set the value to `false`.
            @throws TypeError The sourceBitmapData, sourceRect, destPoint are null.
        **/
        copyPixels(sourceBitmapData, sourceRect, destPoint, alphaBitmapData = null, alphaPoint = null, mergeAlpha = false) {
            if (!this.readable || sourceBitmapData == null)
                return;
            // __backend.copyPixels(sourceBitmapData, sourceRect, destPoint, alphaBitmapData, alphaPoint, mergeAlpha);
        }
        // /** @hidden */ @:dox(hide) @:require(flash11_4) public copyPixelsToByteArray (rect:Rectangle, data:ByteArray):Void;
        /**
            Frees memory that is used to store the BitmapData object.
    
            When the `dispose()` method is called on an image, the width
            and height of the image are set to 0. All subsequent calls to methods or
            properties of this BitmapData instance fail, and an exception is thrown.
    
    
            `BitmapData.dispose()` releases the memory occupied by the
            actual bitmap data, immediately(a bitmap can consume up to 64 MB of
            memory). After using `BitmapData.dispose()`, the BitmapData
            object is no longer usable and an exception may be thrown if
            you call functions on the BitmapData object. However,
            `BitmapData.dispose()` does not garbage collect the BitmapData
            object(approximately 128 bytes); the memory occupied by the actual
            BitmapData object is released at the time the BitmapData object is
            collected by the garbage collector.
    
        **/
        dispose() {
            this.__width = 0;
            this.__height = 0;
            this.__rect = null;
            this.__readable = false;
            // __backend.dispose();
        }
        /**
            Frees the backing Lime image buffer, if possible.
    
            When using a software renderer, such as Flash Player or desktop targets
            without OpenGL, the software buffer will be retained so that the BitmapData
            will work properly. When using a hardware renderer, the Lime image
            buffer will be available to garbage collection after a hardware texture
            has been created internally.
    
            `BitmapData.disposeImage()` will immediately change the value of
            the `readable` property to `false`.
        **/
        disposeImage() {
            // __backend.disposeImage();
        }
        /**
            Draws the `source` display object onto the bitmap image, using
            the OpenFL software renderer. You can specify `matrix`,
            `colorTransform`, `blendMode`, and a destination
            `clipRect` parameter to control how the rendering performs.
            Optionally, you can specify whether the bitmap should be smoothed when
            scaled(this works only if the source object is a BitmapData object).
    
            The source display object does not use any of its applied
            transformations for this call. It is treated as it exists in the library
            or file, with no matrix transform, no color transform, and no blend mode.
            To draw a display object(such as a movie clip) by using its own transform
            properties, you can copy its `transform` property object to the
            `transform` property of the Bitmap object that uses the
            BitmapData object.
    
            @param source         The display object or BitmapData object to draw to
                                  the BitmapData object.(The DisplayObject and
                                  BitmapData classes implement the IBitmapDrawable
                                  interface.)
            @param matrix         A Matrix object used to scale, rotate, or translate
                                  the coordinates of the bitmap. If you do not want to
                                  apply a matrix transformation to the image, set this
                                  parameter to an identity matrix, created with the
                                  default `new Matrix()` constructor, or
                                  pass a `null` value.
            @param colorTransform A ColorTransform object that you use to adjust the
                                  color values of the bitmap. If no object is
                                  supplied, the bitmap image's colors are not
                                  transformed. If you must pass this parameter but you
                                  do not want to transform the image, set this
                                  parameter to a ColorTransform object created with
                                  the default `new ColorTransform()`
                                  constructor.
            @param blendMode      A string value, from the openfl.display.BlendMode
                                  class, specifying the blend mode to be applied to
                                  the resulting bitmap.
            @param clipRect       A Rectangle object that defines the area of the
                                  source object to draw. If you do not supply this
                                  value, no clipping occurs and the entire source
                                  object is drawn.
            @param smoothing      A Boolean value that determines whether a BitmapData
                                  object is smoothed when scaled or rotated, due to a
                                  scaling or rotation in the `matrix`
                                  parameter. The `smoothing` parameter only
                                  applies if the `source` parameter is a
                                  BitmapData object. With `smoothing` set
                                  to `false`, the rotated or scaled
                                  BitmapData image can appear pixelated or jagged. For
                                  example, the following two images use the same
                                  BitmapData object for the `source`
                                  parameter, but the `smoothing` parameter
                                  is set to `true` on the left and
                                  `false` on the right:
    
                                  ![Two images: the left one with smoothing and the right one without smoothing.](/images/bitmapData_draw_smoothing.jpg)
    
                                  Drawing a bitmap with `smoothing` set
                                  to `true` takes longer than doing so with
                                  `smoothing` set to
                                  `false`.
            @throws ArgumentError The `source` parameter is not a
                                  BitmapData or DisplayObject object.
            @throws ArgumentError The source is null or not a valid IBitmapDrawable
                                  object.
            @throws SecurityError The `source` object and(in the case of a
                                  Sprite or MovieClip object) all of its child objects
                                  do not come from the same domain as the caller, or
                                  are not in a content that is accessible to the
                                  caller by having called the
                                  `Security.allowDomain()` method. This
                                  restriction does not apply to AIR content in the
                                  application security sandbox.
        **/
        draw(source, matrix = null, colorTransform = null, blendMode = null, clipRect = null, smoothing = false) {
            if (source == null)
                return;
            source.__update(false, true);
            var transform = Matrix.__pool.get();
            transform.copyFrom(source.__renderTransform);
            transform.invert();
            if (matrix != null) {
                transform.concat(matrix);
            }
            // __backend.draw(source, transform, colorTransform, blendMode, clipRect, smoothing);
            Matrix.__pool.release(transform);
        }
        /**
            Draws the `source` display object onto the bitmap image, using the Flash runtime
            vector renderer. You can specify `matrix`, `colorTransform`, `blendMode`, and a
            destination `clipRect` parameter to control how the rendering performs.
            Optionally, you can specify whether the bitmap should be smoothed when scaled
            (this works only if the source object is a BitmapData object).
    
            **Note:** The `drawWithQuality()` method works exactly like the `draw()` method,
            but instead of using the `Stage.quality` property to determine the quality of
            vector rendering, you specify the `quality` parameter to the `drawWithQuality()`
            method.
    
            This method directly corresponds to how objects are drawn with the standard
            vector renderer for objects in the authoring tool interface.
    
            The source display object does not use any of its applied transformations for
            this call. It is treated as it exists in the library or file, with no matrix
            transform, no color transform, and no blend mode. To draw a display object
            (such as a movie clip) by using its own transform properties, you can copy its
            `transform` property object to the `transform` property of the Bitmap object that
            uses the BitmapData object.
    
            This method is supported over RTMP in Flash Player 9.0.115.0 and later and in
            Adobe AIR. You can control access to streams on Flash Media Server in a
            server-side script. For more information, see the `Client.audioSampleAccess` and
            `Client.videoSampleAccess` properties in Server-Side ActionScript Language
            Reference for Adobe Flash Media Server.
    
            If the source object and (in the case of a Sprite or MovieClip object) all of
            its child objects do not come from the same domain as the caller, or are not in
            a content that is accessible to the caller by having called the
            `Security.allowDomain()` method, a call to the `drawWithQuality()` throws a
            SecurityError exception. This restriction does not apply to AIR content in the
            application security sandbox.
    
            There are also restrictions on using a loaded bitmap image as the source. A call
            to the `drawWithQuality()` method is successful if the loaded image comes from the
            same domain as the caller. Also, a cross-domain policy file on the image's server
            can grant permission to the domain of the SWF content calling the
            `drawWithQuality()` method. In this case, you must set the `checkPolicyFile` property
            of a LoaderContext object, and use this object as the `context` parameter when
            calling the `load()` method of the Loader object used to load the image. These
            restrictions do not apply to AIR content in the application security sandbox.
    
            On Windows, the `drawWithQuality()` method cannot capture SWF content embedded in an
            HTML page in an HTMLLoader object in Adobe AIR.
    
            The `drawWithQuality()` method cannot capture PDF content in Adobe AIR. Nor can it
            capture or SWF content embedded in HTML in which the `wmode` attribute is set to
            `"window"` in Adobe AIR.
    
            @param	source	The display object or BitmapData object to draw to the BitmapData
            object. (The DisplayObject and BitmapData classes implement the IBitmapDrawable
            interface.)
            @param	matrix	A Matrix object used to scale, rotate, or translate the coordinates
            of the bitmap. If you do not want to apply a matrix transformation to the image,
            set this parameter to an identity matrix, created with the default `new Matrix()`
            constructor, or pass a `null` value.
            @param	colorTransform	A ColorTransform object that you use to adjust the color
            values of the bitmap. If no object is supplied, the bitmap image's colors are not
            transformed. If you must pass this parameter but you do not want to transform the
            image, set this parameter to a ColorTransform object created with the default
            `new ColorTransform()` constructor.
            @param	blendMode	A string value, from the flash.display.BlendMode class,
            specifying the blend mode to be applied to the resulting bitmap.
            @param	clipRect	A Rectangle object that defines the area of the source object
            to draw. If you do not supply this value, no clipping occurs and the entire source
            object is drawn.
            @param	smoothing	A Boolean value that determines whether a BitmapData object is
            smoothed when scaled or rotated, due to a scaling or rotation in the `matrix`
            parameter. The smoothing parameter only applies if the `source` parameter is a
            BitmapData object. With `smoothing` set to `false`, the rotated or scaled BitmapData
            image can appear pixelated or jagged. For example, the following two images use the
            same BitmapData object for the `source` parameter, but the `smoothing` parameter is
            set to `true` on the left and `false` on the right:
            ![Two images: the left one with smoothing and the right one without smoothing.](/images/bitmapData_draw_smoothing.jpg)
            Drawing a bitmap with `smoothing` set to `true` takes longer than doing so with
            `smoothing` set to `false`.
            @param	quality	Any of one of the StageQuality values. Selects the antialiasing
            quality to be used when drawing vectors graphics.
            @throws	ArgumentError	The source parameter is not a BitmapData or DisplayObject
            object.
            @throws	SecurityError	The source object and (in the case of a Sprite or MovieClip
            object) all of its child objects do not come from the same domain as the caller,
            or are not in a content that is accessible to the caller by having called the
            `Security.allowDomain()` method. This restriction does not apply to AIR content
            in the application security sandbox.
            @throws	ArgumentError	The source is `null` or not a valid IBitmapDrawable object.
        **/
        drawWithQuality(source, matrix = null, colorTransform = null, blendMode = null, clipRect = null, smoothing = false, quality = null) {
            // __backend.drawWithQuality(source, matrix, colorTransform, blendMode, clipRect, smoothing, quality);
        }
        /**
            Compresses this BitmapData object using the selected compressor algorithm and
            returns a new ByteArray object. Optionally, writes the resulting data to the
            specified ByteArray. The `compressor` argument specifies the encoding algorithm,
            and can be PNGEncoderOptions, JPEGEncoderOptions, or JPEGXREncoderOptions.
    
            The following example compresses a BitmapData object using the JPEGEncoderOptions:
    
            ```haxe
            // Compress a BitmapData object as a JPEG file.
            var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
            var byteArray:ByteArray = new ByteArray();
            bitmapData.encode(new Rectangle(0,0,640,480), new openfl.display.JPEGEncoderOptions(), byteArray);
            ```
    
            @param	rect	The area of the BitmapData object to compress.
            @param	compressor	The compressor type to use. Valid values are:
            flash.display.PNGEncoderOptions, flash.display.JPEGEncoderOptions, and
            flash.display.JPEGXREncoderOptions.
            @param	byteArray	The output ByteArray to hold the encoded image.
            @return	A ByteArray containing the encoded image.
        **/
        encode(rect, compressor, byteArray = null) {
            if (!this.readable || rect == null)
                return byteArray = null;
            // return __backend.encode(rect, compressor, byteArray);
        }
        /**
            Fills a rectangular area of pixels with a specified ARGB color.
    
            @param rect  The rectangular area to fill.
            @param color The ARGB color value that fills the area. ARGB colors are
                         often specified in hexadecimal format; for example,
                         0xFF336699.
            @throws TypeError The rect is null.
        **/
        fillRect(rect, color) {
            if (rect == null)
                return;
            // return __backend.fillRect(rect, color);
        }
        /**
            Performs a flood fill operation on an image starting at an(_x_,
            _y_) coordinate and filling with a certain color. The
            `floodFill()` method is similar to the paint bucket tool in
            various paint programs. The color is an ARGB color that contains alpha
            information and color information.
    
            @param x     The _x_ coordinate of the image.
            @param y     The _y_ coordinate of the image.
            @param color The ARGB color to use as a fill.
        **/
        floodFill(x, y, color) {
            if (!this.readable)
                return;
            // return __backend.floodFill(x, y, color);
        }
        /**
            Creates a new BitmapData instance from Base64-encoded data synchronously. This means
            that the BitmapData will be returned immediately (if supported).
    
            HTML5 and Flash do not support creating BitmapData synchronously, so these targets
            always return `null`. Other targets will return `null` if decoding was unsuccessful.
    
            @param	base64	Base64-encoded data
            @param	type	The MIME-type for the encoded data ("image/jpeg", etc)
            @returns	A new BitmapData if successful, or `null` if unsuccessful
        **/
        static fromBase64(base64, type) {
            if (base64 == null)
                return null;
            // return BitmapDataBackend.fromBase64(base64, type);
            return null;
        }
        /**
            Creates a new BitmapData from bytes (a haxe.io.Bytes or openfl.utils.ByteArray)
            synchronously. This means that the BitmapData will be returned immediately (if
            supported).
    
            HTML5 and Flash do not support creating BitmapData synchronously, so these targets
            always return `null`. Other targets will return `null` if decoding was unsuccessful.
    
            The optional `rawAlpha` parameter makes it easier to process images that have alpha
            data stored separately.
    
            @param	bytes	A haxe.io.Bytes or openfl.utils.ByteArray instance
            @param	rawAlpha	An optional byte array with alpha data
            @returns	A new BitmapData if successful, or `null` if unsuccessful
        **/
        static fromBytes(bytes, rawAlpha = null) {
            if (bytes == null)
                return null;
            // return BitmapDataBackend.fromBytes(bytes, rawAlpha);
            return null;
        }
        /**
            Creates a new BitmapData from an HTML5 canvas element immediately.
    
            All targets except from HTML5 targets will return `null`.
    
            @param	canvas	An HTML5 canvas element
            @param	transparent	Whether the new BitmapData object should be considered
            transparent
            @returns	A new BitmapData if successful, or `null` if unsuccessful
        **/
        static fromCanvas(canvas, transparent = true) {
            if (canvas == null)
                return null;
            // return BitmapDataBackend.fromCanvas(canvas, transparent);
            return null;
        }
        /**
            Creates a new BitmapData from a file path synchronously. This means that the
            BitmapData will be returned immediately (if supported).
    
            HTML5 and Flash do not support creating BitmapData synchronously, so these targets
            always return `null`.
    
            In order to load files from a remote web address, use the `loadFromFile` method,
            which supports asynchronous loading.
    
            @param	path	A local file path containing an image
            @returns	A new BitmapData if successful, or `null` if unsuccessful
        **/
        static fromFile(path) {
            if (path == null)
                return null;
            // return BitmapDataBackend.fromFile(path);
            return null;
        }
        /**
            Creates a new BitmapData using an existing Lime Image instance.
    
            @param	image	A Lime Image object
            @param	transparent	Whether the new BitmapData object should be considered
            transparent
            @returns	A new BitmapData if the Image (and associated ImageBuffer) are not
            `null`, otherwise `null` will be returned
        **/
        // public static fromImage(image: Image, transparent: boolean = true): BitmapData
        // {
        // 	if (image == null || image.buffer == null) return null;
        // 	// return BitmapDataBackend.fromImage(image, transparent);
        // 	return null;
        // }
        /**
            **BETA**
    
            Creates a new BitmapData instance from a Stage3D rectangle texture.
    
            This method is not supported by the Flash target.
    
            @param	texture	A Texture or RectangleTexture instance
            @returns	A new BitmapData if successful, or `null` if unsuccessful
        **/
        static fromTexture(texture) {
            if (texture == null)
                return null;
            // return BitmapDataBackend.fromTexture(texture);
            return null;
        }
        /**
            Determines the destination rectangle that the `applyFilter()`
            method call affects, given a BitmapData object, a source rectangle, and a
            filter object.
    
            For example, a blur filter normally affects an area larger than the
            size of the original image. A 100 x 200 pixel image that is being filtered
            by a default BlurFilter instance, where `blurX = blurY = 4`
            generates a destination rectangle of `(-2,-2,104,204)`. The
            `generateFilterRect()` method lets you find out the size of
            this destination rectangle in advance so that you can size the destination
            image appropriately before you perform a filter operation.
    
            Some filters clip their destination rectangle based on the source image
            size. For example, an inner `DropShadow` does not generate a
            larger result than its source image. In this API, the BitmapData object is
            used as the source bounds and not the source `rect`
            parameter.
    
            @param sourceRect A rectangle defining the area of the source image to use
                              as input.
            @param filter     A filter object that you use to calculate the
                              destination rectangle.
            @return A destination rectangle computed by using an image, the
                    `sourceRect` parameter, and a filter.
            @throws TypeError The sourceRect or filter are null.
        **/
        generateFilterRect(sourceRect, filter) {
            // return __backend.generateFilterRect(sourceRect, filter);
            return null;
        }
        /**
            **BETA**
    
            Get the IndexBuffer3D object associated with this BitmapData object
    
            @hidden
            @param	context	A Stage3D context
            @returns	An IndexBuffer3D object for use with rendering
        **/
        // public getIndexBuffer(context: Context3D, scale9Grid: Rectangle = null): IndexBuffer3D
        // {
        // return Context3DBitmapData.getIndexBuffer(this, context, scale9Grid);
        // return null;
        // }
        /**
            **BETA**
    
            Get the VertexBuffer3D object associated with this BitmapData object
    
            @hidden
            @param	context	A Stage3D context
            @returns	A VertexBuffer3D object for use with rendering
        **/
        // public getVertexBuffer(context: Context3D, scale9Grid: Rectangle = null, targetObject: DisplayObject = null): VertexBuffer3D
        // {
        // return Context3DBitmapData.getVertexBuffer(this, context, scale9Grid, targetObject);
        // }
        /**
            Determines a rectangular region that either fully encloses all pixels of a
            specified color within the bitmap image(if the `findColor`
            parameter is set to `true`) or fully encloses all pixels that
            do not include the specified color(if the `findColor`
            parameter is set to `false`).
    
            For example, if you have a source image and you want to determine the
            rectangle of the image that contains a nonzero alpha channel, pass
            `{mask: 0xFF000000, color: 0x00000000}` as parameters. If the
            `findColor` parameter is set to `true`, the entire
            image is searched for the bounds of pixels for which `(value & mask)
            == color`(where `value` is the color value of the
            pixel). If the `findColor` parameter is set to
            `false`, the entire image is searched for the bounds of pixels
            for which `(value & mask) != color`(where `value`
            is the color value of the pixel). To determine white space around an
            image, pass `{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}` to find the
            bounds of nonwhite pixels.
    
            @param mask      A hexadecimal value, specifying the bits of the ARGB
                             color to consider. The color value is combined with this
                             hexadecimal value, by using the `&`(bitwise
                             AND) operator.
            @param color     A hexadecimal value, specifying the ARGB color to match
                            (if `findColor` is set to `true`)
                             or _not_ to match(if `findColor` is set
                             to `false`).
            @param findColor If the value is set to `true`, returns the
                             bounds of a color value in an image. If the value is set
                             to `false`, returns the bounds of where this
                             color doesn't exist in an image.
            @return The region of the image that is the specified color.
        **/
        getColorBoundsRect(mask, color, findColor = true) {
            if (!this.readable)
                return new Rectangle(0, 0, this.__width, this.__height);
            // return __backend.getColorBoundsRect(mask, color, findColor);
            return null;
        }
        /**
            Returns an integer that represents an RGB pixel value from a BitmapData
            object at a specific point(_x_, _y_). The
            `getPixel()` method returns an unmultiplied pixel value. No
            alpha information is returned.
    
            All pixels in a BitmapData object are stored as premultiplied color
            values. A premultiplied image pixel has the red, green, and blue color
            channel values already multiplied by the alpha data. For example, if the
            alpha value is 0, the values for the RGB channels are also 0, independent
            of their unmultiplied values. This loss of data can cause some problems
            when you perform operations. All BitmapData methods take and return
            unmultiplied values. The internal pixel representation is converted from
            premultiplied to unmultiplied before it is returned as a value. During a
            set operation, the pixel value is premultiplied before the raw image pixel
            is set.
    
            @param x The _x_ position of the pixel.
            @param y The _y_ position of the pixel.
            @return A number that represents an RGB pixel value. If the(_x_,
                    _y_) coordinates are outside the bounds of the image, the
                    method returns 0.
        **/
        getPixel(x, y) {
            if (!this.readable)
                return 0;
            // return __backend.getPixel(x, y);
            return 0;
        }
        /**
            Returns an ARGB color value that contains alpha channel data and RGB data.
            This method is similar to the `getPixel()` method, which
            returns an RGB color without alpha channel data.
    
            All pixels in a BitmapData object are stored as premultiplied color
            values. A premultiplied image pixel has the red, green, and blue color
            channel values already multiplied by the alpha data. For example, if the
            alpha value is 0, the values for the RGB channels are also 0, independent
            of their unmultiplied values. This loss of data can cause some problems
            when you perform operations. All BitmapData methods take and return
            unmultiplied values. The internal pixel representation is converted from
            premultiplied to unmultiplied before it is returned as a value. During a
            set operation, the pixel value is premultiplied before the raw image pixel
            is set.
    
            @param x The _x_ position of the pixel.
            @param y The _y_ position of the pixel.
            @return A number representing an ARGB pixel value. If the(_x_,
                    _y_) coordinates are outside the bounds of the image, 0 is
                    returned.
        **/
        getPixel32(x, y) {
            if (!this.readable)
                return 0;
            // return __backend.getPixel32(x, y);
            return 0;
        }
        /**
            Generates a byte array from a rectangular region of pixel data. Writes an
            unsigned integer(a 32-bit unmultiplied pixel value) for each pixel into
            the byte array.
    
            @param rect A rectangular area in the current BitmapData object.
            @return A ByteArray representing the pixels in the given Rectangle.
            @throws TypeError The rect is null.
        **/
        getPixels(rect) {
            if (!this.readable)
                return null;
            if (rect == null)
                rect = this.rect;
            // return __backend.getPixels(rect);
            return null;
        }
        /**
            **BETA**
    
            Get a hardware texture representing this BitmapData instance
    
            @hidden
            @param	context	A Context3D instance
            @returns	A Texture or RectangleTexture instance
        **/
        // public getTexture(context: Context3D): TextureBase
        // {
        // 	if (!this.__isValid) return null;
        // return __backend.getTexture(context);
        // }
        /**
            Generates a vector array from a rectangular region of pixel data. Returns
            a Vector object of unsigned integers(a 32-bit unmultiplied pixel value)
            for the specified rectangle.
            @param rect A rectangular area in the current BitmapData object.
            @return A Vector representing the given Rectangle.
            @throws TypeError The rect is null.
        **/
        getVector(rect) {
            // return __backend.getVector(rect);
            return null;
        }
        /**
            Computes a 256-value binary number histogram of a BitmapData object. This method
            returns a Vector object containing four Vector<number> instances (four Vector
            objects that contain Float objects). The four Vector instances represent the
            red, green, blue and alpha components in order. Each Vector instance contains
            256 values that represent the population count of an individual component value,
            from 0 to 255.
            @param	hRect	The area of the BitmapData object to use.
        **/
        histogram(hRect = null) {
            // return __backend.histogram(hRect);
            return null;
        }
        /**
            Performs pixel-level hit detection between one bitmap image and a point,
            rectangle, or other bitmap image. A hit is defined as an overlap of a point or
            rectangle over an opaque pixel, or two overlapping opaque pixels. No stretching,
            rotation, or other transformation of either object is considered when the hit test
            is performed.
    
            If an image is an opaque image, it is considered a fully opaque rectangle for this
            method. Both images must be transparent images to perform pixel-level hit testing
            that considers transparency. When you are testing two transparent images, the alpha
            threshold parameters control what alpha channel values, from 0 to 255, are
            considered opaque.
    
            @param	firstPoint	A position of the upper-left corner of the BitmapData image
            in an arbitrary coordinate space. The same coordinate space is used in defining
            the secondBitmapPoint parameter.
            @param	firstAlphaThreshold	The smallest alpha channel value that is considered
            opaque for this hit test.
            @param	secondObject	A Rectangle, Point, Bitmap, or BitmapData object.
            @param	secondBitmapDataPoint	A point that defines a pixel location in the
            second BitmapData object. Use this parameter only when the value of `secondObject`
            is a BitmapData object.
            @param	secondAlphaThreshold	The smallest alpha channel value that is
            considered opaque in the second BitmapData object. Use this parameter only when
            the value of `secondObject` is a BitmapData object and both BitmapData objects
            are transparent.
            @return	A value of `true` if a hit occurs; otherwise, `false`.
            @throws	ArgumentError	The `secondObject` parameter is not a Point, Rectangle,
            Bitmap, or BitmapData object.
            @throws	TypeError	The `firstPoint` is `null`.
        **/
        hitTest(firstPoint, firstAlphaThreshold, secondObject, secondBitmapDataPoint = null, secondAlphaThreshold = 1) {
            if (!this.readable)
                return false;
            // return __backend.hitTest(firstPoint, firstAlphaThreshold, secondObject, secondBitmapDataPoint, secondAlphaThreshold);
            return false;
        }
        /**
            Creates a new BitmapData from Base64-encoded data asynchronously. The data
            and (if successful) decoding the data into an image occur in the background.
            Progress, completion and error callbacks will be dispatched in the current
            thread using callbacks attached to a returned Future object.
    
            @param	base64	Base64-encoded data
            @param	type	The MIME-type for the encoded data ("image/jpeg", etc)
            @returns	A Future BitmapData
        **/
        static loadFromBase64(base64, type) {
            // return BitmapDataBackend.loadFromBase64(base64, type);
            return null;
        }
        /**
            Creates a new BitmapData from haxe.io.Bytes or openfl.utils.ByteArray data
            asynchronously. The data and image decoding will occur in the background.
            Progress, completion and error callbacks will be dispatched in the current
            thread using callbacks attached to a returned Future object.
    
            The optional `rawAlpha` parameter makes it easier to process images that have alpha
            data stored separately.
    
            @param	bytes	A haxe.io.Bytes or openfl.utils.ByteArray instance
            @param	rawAlpha	An optional byte array with alpha data
            @returns	A Future BitmapData
        **/
        static loadFromBytes(bytes, rawAlpha = null) {
            // return BitmapDataBackend.loadFromBytes(bytes, rawAlpha);
            return null;
        }
        /**
            Creates a new BitmapData from a file path or web address asynchronously. The file
            load and image decoding will occur in the background.
            Progress, completion and error callbacks will be dispatched in the current
            thread using callbacks attached to a returned Future object.
    
            @param	path	A local file path or web address containing an image
            @returns	A Future BitmapData
        **/
        static loadFromFile(path) {
            // return BitmapDataBackend.loadFromFile(path);
            return null;
        }
        /**
            Locks an image so that any objects that reference the BitmapData object,
            such as Bitmap objects, are not updated when this BitmapData object
            changes. To improve performance, use this method along with the
            `unlock()` method before and after numerous calls to the
            `setPixel()` or `setPixel32()` method.
    
        **/
        lock() { }
        /**
            Performs per-channel blending from a source image to a destination image. For
            each channel and each pixel, a new value is computed based on the channel
            values of the source and destination pixels. For example, in the red channel,
            the new value is computed as follows (where `redSrc` is the red channel value
            for a pixel in the source image and `redDest` is the red channel value at the
            corresponding pixel of the destination image):
    
            ```haxe
            redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256;
            ```
    
            The `redMultiplier`, `greenMultiplier`, `blueMultiplier`, and `alphaMultiplier`
            values are the multipliers used for each color channel. Use a hexadecimal
            value ranging from 0 to 0x100 (256) where 0 specifies the full value from the
            destination is used in the result, 0x100 specifies the full value from the
            source is used, and numbers in between specify a blend is used (such as 0x80
            for 50%).
    
            @param	sourceBitmapData	The input bitmap image to use. The source image can
            be a different BitmapData object, or it can refer to the current BitmapData
            object.
            @param	sourceRect	A rectangle that defines the area of the source image to use
            as input.
            @param	destPoint	The point within the destination image (the current
            BitmapData instance) that corresponds to the upper-left corner of the source
            rectangle.
            @param	redMultiplier	A hexadecimal uint value by which to multiply the red
            channel value.
            @param	greenMultiplier	A hexadecimal uint value by which to multiply the green
            channel value.
            @param	blueMultiplier	A hexadecimal uint value by which to multiply the blue
            channel value.
            @param	alphaMultiplier	A hexadecimal uint value by which to multiply the alpha
            transparency value.
            @throws	TypeError	The `sourceBitmapData`, `sourceRect` or `destPoint` are `null`.
        **/
        merge(sourceBitmapData, sourceRect, destPoint, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier) {
            if (!this.readable || sourceBitmapData == null || !sourceBitmapData.readable || sourceRect == null || destPoint == null)
                return;
            // __backend.merge(sourceBitmapData, sourceRect, destPoint, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier);
        }
        /**
            Fills an image with pixels representing random noise.
    
            @param randomSeed     The random seed number to use. If you keep all other
                                  parameters the same, you can generate different
                                  pseudo-random results by varying the random seed
                                  value. The noise is a mapping function, not
                                  a true random-number generation function, so it
                                  creates the same results each time from the same
                                  random seed.
            @param low            The lowest value to generate for each channel(0 to
                                  255).
            @param high           The highest value to generate for each channel(0 to
                                  255).
            @param channelOptions A number that can be a combination of any of the
                                  four color channel values
                                 (`BitmapDataChannel.RED`,
                                  `BitmapDataChannel.BLUE`,
                                  `BitmapDataChannel.GREEN`, and
                                  `BitmapDataChannel.ALPHA`). You can use
                                  the logical OR operator(`|`) to combine
                                  channel values.
            @param grayScale      A Boolean value. If the value is `true`,
                                  a grayscale image is created by setting all of the
                                  color channels to the same value. The alpha channel
                                  selection is not affected by setting this parameter
                                  to `true`.
        **/
        noise(randomSeed, low = 0, high = 255, channelOptions = 7, grayScale = false) {
            if (!this.readable)
                return;
            // return __backend.noise(randomSeed, low, high, channelOptions, grayScale);
        }
        /**
            Remaps the color channel values in an image that has up to four arrays of
            color palette data, one for each channel.
    
            Flash runtimes use the following steps to generate the resulting image:
    
            1. After the red, green, blue, and alpha values are computed, they are added
            together using standard 32-bit-integer arithmetic.
            2. The red, green, blue, and alpha channel values of each pixel are extracted
            into separate 0 to 255 values. These values are used to look up new color
            values in the appropriate array: `redArray`, `greenArray`, `blueArray`, and
            `alphaArray`. Each of these four arrays should contain 256 values.
            3. After all four of the new channel values are retrieved, they are combined
            into a standard ARGB value that is applied to the pixel.
    
            Cross-channel effects can be supported with this method. Each input array can
            contain full 32-bit values, and no shifting occurs when the values are added
            together. This routine does not support per-channel clamping.
    
            If no array is specified for a channel, the color channel is copied from the
            source image to the destination image.
    
            You can use this method for a variety of effects such as general palette mapping
            (taking one channel and converting it to a false color image). You can also use
            this method for a variety of advanced color manipulation algorithms, such as
            gamma, curves, levels, and quantizing.
    
            @param	sourceBitmapData	The input bitmap image to use. The source image can
            be a different BitmapData object, or it can refer to the current BitmapData
            instance.
            @param	sourceRect	A rectangle that defines the area of the source image to use
            as input.
            @param	destPoint	The point within the destination image (the current BitmapData
            object) that corresponds to the upper-left corner of the source rectangle.
            @param	redArray	If `redArray` is not `null`, `red = redArray[source red value] else red = source rect value`.
            @param	greenArray	If `greenArray` is not `null`, `green = greenArray[source green value] else green = source green value`.
            @param	blueArray	If `blueArray` is not `null, `blue = blueArray[source blue value] else blue = source blue value`.
            @param	alphaArray	If `alphaArray` is not `null, `alpha = alphaArray[source alpha value] else alpha = source alpha value`.
            @throws	TypeError	The `sourceBitmapData`, `sourceRect` or `destPoint` are `null`.
        **/
        paletteMap(sourceBitmapData, sourceRect, destPoint, redArray = null, greenArray = null, blueArray = null, alphaArray = null) {
            // return __backend.paletteMap(sourceBitmapData, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray);
        }
        /**
            Generates a Perlin noise image.
    
            The Perlin noise generation algorithm interpolates and combines
            individual random noise functions(called octaves) into a single function
            that generates more natural-seeming random noise. Like musical octaves,
            each octave is twice the frequency of the one before it. Perlin
            noise has been described as a "fractal sum of noise" because it combines
            multiple sets of noise data with different levels of detail.
    
            You can use Perlin noise functions to simulate natural phenomena and
            landscapes, such as wood grain, clouds, and mountain ranges. In most
            cases, the output of a Perlin noise is not displayed directly but
            is used to enhance other images and give them pseudo-random
            variations.
    
            Simple digital random noise functions often produce images with harsh,
            contrasting points. This kind of harsh contrast is not often found in
            nature. The Perlin noise algorithm blends multiple noise functions that
            operate at different levels of detail. This algorithm results in smaller
            variations among neighboring pixel values.
    
            @param baseX          Frequency to use in the _x_ direction. For
                                  example, to generate a noise that is sized for a 64
                                  x 128 image, pass 64 for the `baseX`
                                  value.
            @param baseY          Frequency to use in the _y_ direction. For
                                  example, to generate a noise that is sized for a 64
                                  x 128 image, pass 128 for the `baseY`
                                  value.
            @param numOctaves     Number of octaves or individual noise functions to
                                  combine to create this noise. Larger numbers of
                                  octaves create images with greater detail. Larger
                                  numbers of octaves also require more processing
                                  time.
            @param randomSeed     The random seed number to use. If you keep all other
                                  parameters the same, you can generate different
                                  pseudo-random results by varying the random seed
                                  value. The Perlin noise is a mapping
                                  function, not a true random-number generation
                                  function, so it creates the same results each time
                                  from the same random seed.
            @param stitch         A Boolean value. If the value is `true`,
                                  the method attempts to smooth the transition edges
                                  of the image to create seamless textures for tiling
                                  as a bitmap fill.
            @param fractalNoise   A Boolean value. If the value is `true`,
                                  the method generates fractal noise; otherwise, it
                                  generates turbulence. An image with turbulence has
                                  visible discontinuities in the gradient that can
                                  make it better approximate sharper visual effects
                                  like flames and ocean waves.
            @param channelOptions A number that can be a combination of any of the
                                  four color channel values
                                 (`BitmapDataChannel.RED`,
                                  `BitmapDataChannel.BLUE`,
                                  `BitmapDataChannel.GREEN`, and
                                  `BitmapDataChannel.ALPHA`). You can use
                                  the logical OR operator(`|`) to combine
                                  channel values.
            @param grayScale      A Boolean value. If the value is `true`,
                                  a grayscale image is created by setting each of the
                                  red, green, and blue color channels to identical
                                  values. The alpha channel value is not affected if
                                  this value is set to `true`.
        **/
        perlinNoise(baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions = 7, grayScale = false, offsets = null) {
            if (!this.readable)
                return;
            // return __backend.perlinNoise(baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets);
        }
        // /** @hidden */ @:dox(hide) public pixelDissolve (sourceBitmapData:BitmapData, sourceRect:Rectangle, destPoint:Point, randomSeed:Int = 0, numPixels:Int = 0, fillColor:UInt = 0):Int;
        /**
            Scrolls an image by a certain(_x_, _y_) pixel amount. Edge
            regions outside the scrolling area are left unchanged.
    
            @param x The amount by which to scroll horizontally.
            @param y The amount by which to scroll vertically.
        **/
        scroll(x, y) {
            if (!this.readable)
                return;
            // return __backend.scroll(x, y);
        }
        /**
            Sets a single pixel of a BitmapData object. The current alpha channel
            value of the image pixel is preserved during this operation. The value of
            the RGB color parameter is treated as an unmultiplied color value.
    
            **Note:** To increase performance, when you use the
            `setPixel()` or `setPixel32()` method repeatedly,
            call the `lock()` method before you call the
            `setPixel()` or `setPixel32()` method, and then call
            the `unlock()` method when you have made all pixel changes.
            This process prevents objects that reference this BitmapData instance from
            updating until you finish making the pixel changes.
    
            @param x     The _x_ position of the pixel whose value changes.
            @param y     The _y_ position of the pixel whose value changes.
            @param color The resulting RGB color for the pixel.
        **/
        setPixel(x, y, color) {
            if (!this.readable)
                return;
            // return __backend.setPixel(x, y, color);
        }
        /**
            Sets the color and alpha transparency values of a single pixel of a
            BitmapData object. This method is similar to the `setPixel()`
            method; the main difference is that the `setPixel32()` method
            takes an ARGB color value that contains alpha channel information.
    
            All pixels in a BitmapData object are stored as premultiplied color
            values. A premultiplied image pixel has the red, green, and blue color
            channel values already multiplied by the alpha data. For example, if the
            alpha value is 0, the values for the RGB channels are also 0, independent
            of their unmultiplied values. This loss of data can cause some problems
            when you perform operations. All BitmapData methods take and return
            unmultiplied values. The internal pixel representation is converted from
            premultiplied to unmultiplied before it is returned as a value. During a
            set operation, the pixel value is premultiplied before the raw image pixel
            is set.
    
            **Note:** To increase performance, when you use the
            `setPixel()` or `setPixel32()` method repeatedly,
            call the `lock()` method before you call the
            `setPixel()` or `setPixel32()` method, and then call
            the `unlock()` method when you have made all pixel changes.
            This process prevents objects that reference this BitmapData instance from
            updating until you finish making the pixel changes.
    
            @param x     The _x_ position of the pixel whose value changes.
            @param y     The _y_ position of the pixel whose value changes.
            @param color The resulting ARGB color for the pixel. If the bitmap is
                         opaque(not transparent), the alpha transparency portion of
                         this color value is ignored.
        **/
        setPixel32(x, y, color) {
            if (!this.readable)
                return;
            // return __backend.setPixel32(x, y, color);
        }
        /**
            Converts a byte array into a rectangular region of pixel data. For each
            pixel, the `ByteArray.readUnsignedInt()` method is called and
            the return value is written into the pixel. If the byte array ends before
            the full rectangle is written, the returns. The data in the byte
            array is expected to be 32-bit ARGB pixel values. No seeking is performed
            on the byte array before or after the pixels are read.
    
            @param rect           Specifies the rectangular region of the BitmapData
                                  object.
            @param inputByteArray A ByteArray object that consists of 32-bit
                                  unmultiplied pixel values to be used in the
                                  rectangular region.
            @throws EOFError  The `inputByteArray` object does not include
                              enough data to fill the area of the `rect`
                              rectangle. The method fills as many pixels as possible
                              before throwing the exception.
            @throws TypeError The rect or inputByteArray are null.
        **/
        setPixels(rect, byteArray) {
            if (!this.readable || rect == null || byteArray == null)
                return;
            var length = (rect.width * rect.height * 4);
            if (byteArray.bytesAvailable < length)
                throw new Error$1("End of file was encountered.", 2030);
            // return __backend.setPixels(rect, byteArray);
        }
        /**
            Converts a Vector into a rectangular region of pixel data. For each pixel,
            a Vector element is read and written into the BitmapData pixel. The data
            in the Vector is expected to be 32-bit ARGB pixel values.
    
            @param rect Specifies the rectangular region of the BitmapData object.
            @throws RangeError The vector array is not large enough to read all the
                               pixel data.
        **/
        setVector(rect, inputVector) {
            if (inputVector == null)
                return;
            // __backend.setVector(rect, inputVector);
        }
        /**
            Tests pixel values in an image against a specified threshold and sets
            pixels that pass the test to new color values. Using the
            `threshold()` method, you can isolate and replace color ranges
            in an image and perform other logical operations on image pixels.
    
            The `threshold()` method's test logic is as follows:
    
             1. If `((pixelValue & mask) operation(threshold & mask))`,
            then set the pixel to `color`;
             2. Otherwise, if `copySource == true`, then set the pixel to
            corresponding pixel value from `sourceBitmap`.
    
            The `operation` parameter specifies the comparison operator
            to use for the threshold test. For example, by using "==" as the
            `operation` parameter, you can isolate a specific color value
            in an image. Or by using `{operation: "<", mask: 0xFF000000,
            threshold: 0x7F000000, color: 0x00000000}`, you can set all
            destination pixels to be fully transparent when the source image pixel's
            alpha is less than 0x7F. You can use this technique for animated
            transitions and other effects.
    
            @param sourceBitmapData The input bitmap image to use. The source image
                                    can be a different BitmapData object or it can
                                    refer to the current BitmapData instance.
            @param sourceRect       A rectangle that defines the area of the source
                                    image to use as input.
            @param destPoint        The point within the destination image(the
                                    current BitmapData instance) that corresponds to
                                    the upper-left corner of the source rectangle.
            @param operation        One of the following comparison operators, passed
                                    as a String: "<", "<=", ">", ">=", "==", "!="
            @param threshold        The value that each pixel is tested against to see
                                    if it meets or exceeds the threshhold.
            @param color            The color value that a pixel is set to if the
                                    threshold test succeeds. The default value is
                                    0x00000000.
            @param mask             The mask to use to isolate a color component.
            @param copySource       If the value is `true`, pixel values
                                    from the source image are copied to the
                                    destination when the threshold test fails. If the
                                    value is `false`, the source image is
                                    not copied when the threshold test fails.
            @return The number of pixels that were changed.
            @throws ArgumentError The operation string is not a valid operation
            @throws TypeError     The sourceBitmapData, sourceRect destPoint or
                                  operation are null.
        **/
        threshold(sourceBitmapData, sourceRect, destPoint, operation, threshold, color = 0x00000000, mask = 0xFFFFFFFF, copySource = false) {
            if (sourceBitmapData == null
                || sourceRect == null
                || destPoint == null
                || sourceRect.x > sourceBitmapData.width
                || sourceRect.y > sourceBitmapData.height
                || destPoint.x > this.__width
                || destPoint.y > this.__height) {
                return 0;
            }
            // return __backend.threshold(sourceBitmapData, sourceRect, destPoint, operation, threshold, color, mask, copySource);
            return 0;
        }
        /**
            Unlocks an image so that any objects that reference the BitmapData object,
            such as Bitmap objects, are updated when this BitmapData object changes.
            To improve performance, use this method along with the `lock()`
            method before and after numerous calls to the `setPixel()` or
            `setPixel32()` method.
    
            @param changeRect The area of the BitmapData object that has changed. If
                              you do not specify a value for this parameter, the
                              entire area of the BitmapData object is considered
                              changed.
        **/
        unlock(changeRect = null) { }
        __getBounds(rect, matrix) {
            var bounds = Rectangle.__pool.get();
            this.rect.__transform(bounds, matrix);
            rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
            Rectangle.__pool.release(bounds);
        }
        __getCanvas(clearData = false) {
            // return __backend.getCanvas(clearData);
            return null;
        }
        __getCanvasContext(clearData = false) {
            // return __backend.getCanvasContext(clearData);
            return null;
        }
        __getElement(clearData = false) {
            // return __backend.getElement(clearData);
            return null;
        }
        __getJSImage() {
            // return __backend.getJSImage();
            return null;
        }
        __getVersion() {
            // return __backend.getVersion();
            return 0;
        }
        __setDirty() {
            // __backend.setDirty();
        }
        __update(transformOnly, updateChildren) { }
        // Get & Set Methods
        /**
            The height of the bitmap image in pixels.
        **/
        get height() {
            return this.__height;
        }
        /**
            Defines whether the bitmap image is readable. Hardware-only bitmap images
            do not support `getPixels`, `setPixels` and other
            BitmapData methods, though they can still be used inside a Bitmap object
            or other display objects that do not need to modify the pixels.
    
            As an exception to the rule, `bitmapData.draw` is supported for
            non-readable bitmap images.
    
            Since non-readable bitmap images do not have a software image buffer, they
            will need to be recreated if the current hardware rendering context is lost.
        **/
        get readable() {
            return this.__readable;
        }
        // #end
        /**
            The rectangle that defines the size and location of the bitmap image. The
            top and left of the rectangle are 0; the width and height are equal to the
            width and height in pixels of the BitmapData object.
        **/
        get rect() {
            return this.__rect;
        }
        /**
            Defines whether the bitmap image supports per-pixel transparency. You can
            set this value only when you construct a BitmapData object by passing in
            `true` for the `transparent` parameter of the
            constructor. Then, after you create a BitmapData object, you can check
            whether it supports per-pixel transparency by determining if the value of
            the `transparent` property is `true`.
        **/
        get transparent() {
            return this.__transparent;
        }
        /**
            The width of the bitmap image in pixels.
        **/
        get width() {
            return this.__width;
        }
    }
    // protected static __hardwareRenderer: Context3DRenderer;
    BitmapData.__pool = new BitmapDataPool();
    BitmapData.__tempVector = new Point();
    return BitmapData;
})();

var openfl$6;
(function (openfl) {
    var display;
    (function (display) {
        /**
         * The BitmapDataChannel class is an enumeration of constant values that
         * indicate which channel to use: red, blue, green, or alpha transparency.
         *
         * When you call some methods, you can use the bitwise OR operator
         * (`|`) to combine BitmapDataChannel constants to indicate
         * multiple color channels.
         *
         * The BitmapDataChannel constants are provided for use as values in the
         * following:
         *
         *
         *  * The `sourceChannel` and `destChannel`
         * parameters of the `openfl.display.BitmapData.copyChannel()`
         * method
         *  * The `channelOptions` parameter of the
         * `openfl.display.BitmapData.noise()` method
         *  * The `openfl.filters.DisplacementMapFilter.componentX` and
         * `openfl.filters.DisplacementMapFilter.componentY` properties
         *
         */
        let BitmapDataChannel;
        (function (BitmapDataChannel) {
            /**
             * The alpha channel.
             */
            BitmapDataChannel[BitmapDataChannel["ALPHA"] = 8] = "ALPHA";
            /**
             * The blue channel.
             */
            BitmapDataChannel[BitmapDataChannel["BLUE"] = 4] = "BLUE";
            /**
             * The green channel.
             */
            BitmapDataChannel[BitmapDataChannel["GREEN"] = 2] = "GREEN";
            /**
             * The red channel.
             */
            BitmapDataChannel[BitmapDataChannel["RED"] = 1] = "RED";
        })(BitmapDataChannel = display.BitmapDataChannel || (display.BitmapDataChannel = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$6 || (openfl$6 = {}));
var BitmapDataChannel = openfl$6.display.BitmapDataChannel;

var openfl$7;
(function (openfl) {
    var display;
    (function (display) {
        /**
         * The CapsStyle class is an enumeration of constant values that specify the
         * caps style to use in drawing lines. The constants are provided for use as
         * values in the `caps` parameter of the
         * `openfl.display.Graphics.lineStyle()` method. You can specify the
         * following three types of caps:
         */
        let CapsStyle;
        (function (CapsStyle) {
            /**
             * Used to specify no caps in the `caps` parameter of the
             * `openfl.display.Graphics.lineStyle()` method.
             */
            CapsStyle["NONE"] = "none";
            /**
             * Used to specify round caps in the `caps` parameter of the
             * `openfl.display.Graphics.lineStyle()` method.
             */
            CapsStyle["ROUND"] = "round";
            /**
             * Used to specify square caps in the `caps` parameter of the
             * `openfl.display.Graphics.lineStyle()` method.
             */
            CapsStyle["SQUARE"] = "square";
        })(CapsStyle = display.CapsStyle || (display.CapsStyle = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$7 || (openfl$7 = {}));
var CapsStyle = openfl$7.display.CapsStyle;

class DisplayObjectLinkedList {
    static __addChild(displayObject, child) {
        if (child == displayObject.__lastChild) {
            return;
        }
        // args:Array<Dynamic> = [child];
        // __validateChildrenInit(displayObject, "__addChild", args);
        if (displayObject.__firstChild == child) {
            displayObject.__firstChild = child.__nextSibling;
        }
        else if (child.__previousSibling != null) {
            child.__previousSibling.__nextSibling = child.__nextSibling;
        }
        if (child.__nextSibling != null) {
            child.__nextSibling.__previousSibling = child.__previousSibling;
        }
        if (displayObject.__firstChild == null) {
            displayObject.__firstChild = child;
        }
        if (displayObject.__lastChild != null) {
            displayObject.__lastChild.__nextSibling = child;
            child.__previousSibling = displayObject.__lastChild;
        }
        displayObject.__lastChild = child;
        child.__nextSibling = null;
    }
    static __insertChildAfter(displayObject, child, before) {
        if (before == child || before.__nextSibling == child) {
            return;
        }
        // args:Array<Dynamic> = [child, before];
        // __validateChildrenInit(displayObject, "__insertChildAfter", args);
        var after = before.__nextSibling;
        if (displayObject.__firstChild == child) {
            displayObject.__firstChild = child.__nextSibling;
        }
        if (displayObject.__lastChild == child) {
            displayObject.__lastChild = child.__previousSibling;
        }
        if (child.__previousSibling != null) {
            child.__previousSibling.__nextSibling = child.__nextSibling;
        }
        if (child.__nextSibling != null) {
            child.__nextSibling.__previousSibling = child.__previousSibling;
        }
        child.__previousSibling = before;
        child.__nextSibling = after;
        if (before != null) {
            before.__nextSibling = child;
        }
        if (after != null) {
            after.__previousSibling = child;
        }
        else {
            displayObject.__lastChild = child;
        }
    }
    static __insertChildBefore(displayObject, child, after) {
        if (after != null && child != after && after.__previousSibling != child) {
            if (after.__previousSibling != null) {
                this.__insertChildAfter(displayObject, child, after.__previousSibling);
            }
            else {
                this.__unshiftChild(displayObject, child);
            }
        }
    }
    static __insertChildAt(displayObject, child, index) {
        if (index == 0) {
            this.__unshiftChild(displayObject, child);
        }
        else {
            // args:Array<Dynamic> = [child, index];
            // __validateChildrenInit(displayObject, "__insertChildAt", args);
            var ref = displayObject.__firstChild;
            var childFound = (ref == child);
            for (let i = 0; i < (index - 1); i++) {
                ref = ref.__nextSibling;
                if (ref == null) {
                    break;
                }
                else if (ref == child) {
                    childFound = true;
                }
            }
            if (childFound && ref.__nextSibling != null) {
                ref = ref.__nextSibling;
            }
            if (ref == child) {
                return;
            }
            this.__insertChildAfter(displayObject, child, ref);
        }
    }
    static __removeChild(displayObject, child) {
        // args:Array<Dynamic> = [child];
        // __validateChildrenInit(displayObject, "__removeChild", args);
        child.__parent = null;
        displayObject.__numChildren--;
        if (displayObject.__firstChild == child) {
            displayObject.__firstChild = child.__nextSibling;
        }
        if (displayObject.__lastChild == child) {
            displayObject.__lastChild = child.__previousSibling;
        }
        if (child.__previousSibling != null) {
            child.__previousSibling.__nextSibling = child.__nextSibling;
        }
        if (child.__nextSibling != null) {
            child.__nextSibling.__previousSibling = child.__previousSibling;
        }
        child.__previousSibling = null;
        child.__nextSibling = null;
    }
    static __reparent(displayObject, child) {
        if (child.parent != displayObject) {
            if (child.parent != null) {
                child.parent.removeChild(child);
            }
            child.__parent = displayObject;
            displayObject.__numChildren++;
        }
    }
    static __swapChildren(displayObject, child1, child2) {
        // args:Array<Dynamic> = [child1, child2];
        // __validateChildrenInit(displayObject, "__swapChildren", args);
        if (child1.__nextSibling == child2 || child2.__nextSibling == child1) {
            var first, second;
            if (child1.__nextSibling == child2) {
                first = child1;
                second = child2;
            }
            else {
                first = child2;
                second = child1;
            }
            var before = first.__previousSibling;
            var after = second.__nextSibling;
            first.__previousSibling = second;
            first.__nextSibling = after;
            second.__previousSibling = before;
            second.__nextSibling = first;
            if (before != null) {
                before.__nextSibling = second;
            }
            if (after != null) {
                after.__previousSibling = first;
            }
        }
        else {
            var prev1 = child1.__previousSibling;
            var next1 = child1.__nextSibling;
            var prev2 = child2.__previousSibling;
            var next2 = child2.__nextSibling;
            child1.__previousSibling = prev2;
            child1.__nextSibling = next2;
            child2.__previousSibling = prev1;
            child2.__nextSibling = next1;
            if (prev1 != null) {
                prev1.__nextSibling = child2;
            }
            if (next1 != null) {
                next1.__previousSibling = child2;
            }
            if (prev2 != null) {
                prev2.__nextSibling = child1;
            }
            if (next2 != null) {
                next2.__previousSibling = child1;
            }
        }
        if (displayObject.__firstChild == child1) {
            displayObject.__firstChild = child2;
        }
        else if (displayObject.__firstChild == child2) {
            displayObject.__firstChild = child1;
        }
        if (displayObject.__lastChild == child1) {
            displayObject.__lastChild = child2;
        }
        else if (displayObject.__lastChild == child2) {
            displayObject.__lastChild = child1;
        }
    }
    static __unshiftChild(displayObject, child) {
        if (displayObject.__firstChild == child) {
            return;
        }
        // args:Array<Dynamic> = [child];
        // __validateChildrenInit(displayObject, "__unshiftChild", args);
        if (child.__previousSibling != null) {
            child.__previousSibling.__nextSibling = child.__nextSibling;
        }
        if (child.__nextSibling != null) {
            child.__nextSibling.__previousSibling = child.__previousSibling;
        }
        if (displayObject.__firstChild != null) {
            displayObject.__firstChild.__previousSibling = child;
        }
        if (child == displayObject.__lastChild) {
            displayObject.__lastChild = child.__previousSibling;
        }
        child.__previousSibling = null;
        child.__nextSibling = displayObject.__firstChild;
        displayObject.__firstChild = child;
        if (child.__nextSibling == null) {
            displayObject.__lastChild = child;
        }
    }
}

class RangeError extends Error$1 {
    constructor(message = "") {
        super(message, 0);
        this.name = "RangeError";
    }
}

/**
    The InteractiveObject class is the abstract base class for all display
    objects with which the user can interact, using the mouse, keyboard, or
    other user input device.

    You cannot instantiate the InteractiveObject class directly. A call to
    the `new InteractiveObject()` constructor throws an
    `ArgumentError` exception.

    The InteractiveObject class itself does not include any APIs for
    rendering content onscreen. To create a custom subclass of the
    InteractiveObject class, extend one of the subclasses that do have APIs for
    rendering content onscreen, such as the Sprite, SimpleButton, TextField, or
    MovieClip classes.

    @event clear                  Dispatched when the user selects 'Clear'(or
                                    'Delete') from the text context menu. This
                                    event is dispatched to the object that
                                    currently has focus. If the object that
                                    currently has focus is a TextField, the
                                    default behavior of this event is to cause
                                    any currently selected text in the text field
                                    to be deleted.
    @event click                  Dispatched when a user presses and releases
                                    the main button of the user's pointing device
                                    over the same InteractiveObject. For a click
                                    event to occur, it must always follow this
                                    series of events in the order of occurrence:
                                    mouseDown event, then mouseUp. The target
                                    object must be identical for both of these
                                    events; otherwise the `click`
                                    event does not occur. Any number of other
                                    mouse events can occur at any time between
                                    the `mouseDown` or
                                    `mouseUp` events; the
                                    `click` event still occurs.
    @event contextMenu            Dispatched when a user gesture triggers the
                                    context menu associated with this interactive
                                    object in an AIR application.
    @event copy                   Dispatched when the user activates the
                                    platform-specific accelerator key combination
                                    for a copy operation or selects 'Copy' from
                                    the text context menu. This event is
                                    dispatched to the object that currently has
                                    focus. If the object that currently has focus
                                    is a TextField, the default behavior of this
                                    event is to cause any currently selected text
                                    in the text field to be copied to the
                                    clipboard.
    @event cut                    Dispatched when the user activates the
                                    platform-specific accelerator key combination
                                    for a cut operation or selects 'Cut' from the
                                    text context menu. This event is dispatched
                                    to the object that currently has focus. If
                                    the object that currently has focus is a
                                    TextField, the default behavior of this event
                                    is to cause any currently selected text in
                                    the text field to be cut to the clipboard.
    @event doubleClick            Dispatched when a user presses and releases
                                    the main button of a pointing device twice in
                                    rapid succession over the same
                                    InteractiveObject when that object's
                                    `doubleClickEnabled` flag is set
                                    to `true`. For a
                                    `doubleClick` event to occur, it
                                    must immediately follow the following series
                                    of events: `mouseDown`,
                                    `mouseUp`, `click`,
                                    `mouseDown`, `mouseUp`.
                                    All of these events must share the same
                                    target as the `doubleClick` event.
                                    The second click, represented by the second
                                    `mouseDown` and
                                    `mouseUp` events, must occur
                                    within a specific period of time after the
                                    `click` event. The allowable
                                    length of this period varies by operating
                                    system and can often be configured by the
                                    user. If the target is a selectable text
                                    field, the word under the pointer is selected
                                    as the default behavior. If the target
                                    InteractiveObject does not have its
                                    `doubleClickEnabled` flag set to
                                    `true` it receives two
                                    `click` events.

                                    The `doubleClickEnabled`
                                    property defaults to `false`.

                                    The double-click text selection behavior
                                    of a TextField object is not related to the
                                    `doubleClick` event. Use
                                    `TextField.doubleClickEnabled` to
                                    control TextField selections.
    @event focusIn                Dispatched _after_ a display object
                                    gains focus. This situation happens when a
                                    user highlights the object with a pointing
                                    device or keyboard navigation. The recipient
                                    of such focus is called the target object of
                                    this event, while the corresponding
                                    InteractiveObject instance that lost focus
                                    because of this change is called the related
                                    object. A reference to the related object is
                                    stored in the receiving object's
                                    `relatedObject` property. The
                                    `shiftKey` property is not used.
                                    This event follows the dispatch of the
                                    previous object's `focusOut`
                                    event.
    @event focusOut               Dispatched _after_ a display object
                                    loses focus. This happens when a user
                                    highlights a different object with a pointing
                                    device or keyboard navigation. The object
                                    that loses focus is called the target object
                                    of this event, while the corresponding
                                    InteractiveObject instance that receives
                                    focus is called the related object. A
                                    reference to the related object is stored in
                                    the target object's
                                    `relatedObject` property. The
                                    `shiftKey` property is not used.
                                    This event precedes the dispatch of the
                                    `focusIn` event by the related
                                    object.
    @event gesturePan             Dispatched when the user moves a point of
                                    contact over the InteractiveObject instance
                                    on a touch-enabled device(such as moving a
                                    finger from left to right over a display
                                    object on a mobile phone or tablet with a
                                    touch screen). Some devices might also
                                    interpret this contact as a
                                    `mouseOver` event and as a
                                    `touchOver` event.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, the
                                    InteractiveObject instance can dispatch a
                                    `mouseOver` event or a
                                    `touchOver` event or a
                                    `gesturePan` event, or all if the
                                    current environment supports it. Choose how
                                    you want to handle the user interaction. Use
                                    the openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseOver` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `gesturePan` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event gesturePressAndTap     Dispatched when the user creates a point of
                                    contact with an InteractiveObject instance,
                                    then taps on a touch-enabled device(such as
                                    placing several fingers over a display object
                                    to open a menu and then taps one finger to
                                    select a menu item on a mobile phone or
                                    tablet with a touch screen). Some devices
                                    might also interpret this contact as a
                                    combination of several mouse events, as well.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, and then provides
                                    a secondary tap, the InteractiveObject
                                    instance can dispatch a
                                    `mouseOver` event and a
                                    `click` event(among others) as
                                    well as the `gesturePressAndTap`
                                    event, or all if the current environment
                                    supports it. Choose how you want to handle
                                    the user interaction. Use the
                                    openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseOver` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `gesturePressAndTap` event, you
                                    can design your event handler to respond to
                                    the specific needs of a touch-enabled
                                    environment and provide users with a richer
                                    touch-enabled experience. You can also handle
                                    both events, separately, to provide a
                                    different response for a touch event than a
                                    mouse event.

                                    When handling the properties of the event
                                    object, note that the `localX` and
                                    `localY` properties are set to the
                                    primary point of contact(the "push"). The
                                    `offsetX` and `offsetY`
                                    properties are the distance to the secondary
                                    point of contact(the "tap").
    @event gestureRotate          Dispatched when the user performs a rotation
                                    gesture at a point of contact with an
                                    InteractiveObject instance(such as touching
                                    two fingers and rotating them over a display
                                    object on a mobile phone or tablet with a
                                    touch screen). Two-finger rotation is a
                                    common rotation gesture, but each device and
                                    operating system can have its own
                                    requirements to indicate rotation. Some
                                    devices might also interpret this contact as
                                    a combination of several mouse events, as
                                    well.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, the
                                    InteractiveObject instance can dispatch a
                                    `mouseOver` event and a
                                    `click` event(among others), in
                                    addition to the `gestureRotate`
                                    event, or all if the current environment
                                    supports it. Choose how you want to handle
                                    the user interaction. Use the
                                    openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseOver` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `gestureRotate` event, you can
                                    design your event handler to respond to the
                                    specific needs of a touch-enabled environment
                                    and provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    When handling the properties of the event
                                    object, note that the `localX` and
                                    `localY` properties are set to the
                                    primary point of contact. The
                                    `offsetX` and `offsetY`
                                    properties are the distance to the point of
                                    contact where the rotation gesture is
                                    complete.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event gestureSwipe           Dispatched when the user performs a swipe
                                    gesture at a point of contact with an
                                    InteractiveObject instance(such as touching
                                    three fingers to a screen and then moving
                                    them in parallel over a display object on a
                                    mobile phone or tablet with a touch screen).
                                    Moving several fingers in parallel is a
                                    common swipe gesture, but each device and
                                    operating system can have its own
                                    requirements for a swipe. Some devices might
                                    also interpret this contact as a combination
                                    of several mouse events, as well.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, and then moves the
                                    fingers together, the InteractiveObject
                                    instance can dispatch a `rollOver`
                                    event and a `rollOut` event(among
                                    others), in addition to the
                                    `gestureSwipe` event, or all if
                                    the current environment supports it. Choose
                                    how you want to handle the user interaction.
                                    If you choose to handle the
                                    `rollOver` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `gestureSwipe` event, you can
                                    design your event handler to respond to the
                                    specific needs of a touch-enabled environment
                                    and provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    When handling the properties of the event
                                    object, note that the `localX` and
                                    `localY` properties are set to the
                                    primary point of contact. The
                                    `offsetX` and `offsetY`
                                    properties are the distance to the point of
                                    contact where the swipe gesture is
                                    complete.

                                    **Note:** While some devices using the
                                    Mac OS operating system can interpret a
                                    four-finger swipe, this API only supports a
                                    three-finger swipe.
    @event gestureTwoFingerTap    Dispatched when the user presses two points
                                    of contact over the same InteractiveObject
                                    instance on a touch-enabled device(such as
                                    presses and releases two fingers over a
                                    display object on a mobile phone or tablet
                                    with a touch screen). Some devices might also
                                    interpret this contact as a
                                    `doubleClick` event.

                                    Specifically, if a user taps two fingers
                                    over an InteractiveObject, the
                                    InteractiveObject instance can dispatch a
                                    `doubleClick` event or a
                                    `gestureTwoFingerTap` event, or
                                    both if the current environment supports it.
                                    Choose how you want to handle the user
                                    interaction. Use the openfl.ui.Multitouch
                                    class to manage touch event handling(enable
                                    touch gesture event handling, simple touch
                                    point event handling, or disable touch events
                                    so only mouse events are dispatched). If you
                                    choose to handle the `doubleClick`
                                    event, then the same event handler will run
                                    on a touch-enabled device and a mouse enabled
                                    device. However, if you choose to handle the
                                    `gestureTwoFingerTap` event, you
                                    can design your event handler to respond to
                                    the specific needs of a touch-enabled
                                    environment and provide users with a richer
                                    touch-enabled experience. You can also handle
                                    both events, separately, to provide a
                                    different response for a touch event than a
                                    mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event gestureZoom            Dispatched when the user performs a zoom
                                    gesture at a point of contact with an
                                    InteractiveObject instance(such as touching
                                    two fingers to a screen and then quickly
                                    spreading the fingers apart over a display
                                    object on a mobile phone or tablet with a
                                    touch screen). Moving fingers apart is a
                                    common zoom gesture, but each device and
                                    operating system can have its own
                                    requirements to indicate zoom. Some devices
                                    might also interpret this contact as a
                                    combination of several mouse events, as well.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, and then moves the
                                    fingers apart, the InteractiveObject instance
                                    can dispatch a `mouseOver` event
                                    and a `click` event(among
                                    others), in addition to the
                                    `gestureZoom` event, or all if the
                                    current environment supports it. Choose how
                                    you want to handle the user interaction. Use
                                    the openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseOver` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `gestureZoom` event, you can
                                    design your event handler to respond to the
                                    specific needs of a touch-enabled environment
                                    and provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    When handling the properties of the event
                                    object, note that the `localX` and
                                    `localY` properties are set to the
                                    primary point of contact. The
                                    `offsetX` and `offsetY`
                                    properties are the distance to the point of
                                    contact where the zoom gesture is
                                    complete.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event imeStartComposition    This event is dispatched to any client app
                                    that supports inline input with an IME
    @event keyDown                Dispatched when the user presses a key.
                                    Mappings between keys and specific characters
                                    vary by device and operating system. This
                                    event type is generated after such a mapping
                                    occurs but before the processing of an input
                                    method editor(IME). IMEs are used to enter
                                    characters, such as Chinese ideographs, that
                                    the standard QWERTY keyboard is ill-equipped
                                    to produce. This event occurs before the
                                    `keyUp` event.

                                    In AIR, canceling this event prevents the
                                    character from being entered into a text
                                    field.
    @event keyFocusChange         Dispatched when the user attempts to change
                                    focus by using keyboard navigation. The
                                    default behavior of this event is to change
                                    the focus and dispatch the corresponding
                                    `focusIn` and
                                    `focusOut` events.

                                    This event is dispatched to the object
                                    that currently has focus. The related object
                                    for this event is the InteractiveObject
                                    instance that receives focus if you do not
                                    prevent the default behavior. You can prevent
                                    the change in focus by calling the
                                    `preventDefault()` method in an
                                    event listener that is properly registered
                                    with the target object. Focus changes and
                                    `focusIn` and
                                    `focusOut` events are dispatched
                                    by default.
    @event keyUp                  Dispatched when the user releases a key.
                                    Mappings between keys and specific characters
                                    vary by device and operating system. This
                                    event type is generated after such a mapping
                                    occurs but before the processing of an input
                                    method editor(IME). IMEs are used to enter
                                    characters, such as Chinese ideographs, that
                                    the standard QWERTY keyboard is ill-equipped
                                    to produce. This event occurs after a
                                    `keyDown` event and has the
                                    following characteristics:
    @event middleClick            Dispatched when a user presses and releases
                                    the middle button of the user's pointing
                                    device over the same InteractiveObject. For a
                                    `middleClick` event to occur, it
                                    must always follow this series of events in
                                    the order of occurrence:
                                    `middleMouseDown` event, then
                                    `middleMouseUp`. The target object
                                    must be identical for both of these events;
                                    otherwise the `middleClick` event
                                    does not occur. Any number of other mouse
                                    events can occur at any time between the
                                    `middleMouseDown` or
                                    `middleMouseUp` events; the
                                    `middleClick` event still occurs.
    @event middleMouseDown        Dispatched when a user presses the middle
                                    pointing device button over an
                                    InteractiveObject instance.
    @event middleMouseUp          Dispatched when a user releases the pointing
                                    device button over an InteractiveObject
                                    instance.
    @event mouseDown              Dispatched when a user presses the pointing
                                    device button over an InteractiveObject
                                    instance. If the target is a SimpleButton
                                    instance, the SimpleButton instance displays
                                    the `downState` display object as
                                    the default behavior. If the target is a
                                    selectable text field, the text field begins
                                    selection as the default behavior.
    @event mouseFocusChange       Dispatched when the user attempts to change
                                    focus by using a pointer device. The default
                                    behavior of this event is to change the focus
                                    and dispatch the corresponding
                                    `focusIn` and
                                    `focusOut` events.

                                    This event is dispatched to the object
                                    that currently has focus. The related object
                                    for this event is the InteractiveObject
                                    instance that receives focus if you do not
                                    prevent the default behavior. You can prevent
                                    the change in focus by calling
                                    `preventDefault()` in an event
                                    listener that is properly registered with the
                                    target object. The `shiftKey`
                                    property is not used. Focus changes and
                                    `focusIn` and
                                    `focusOut` events are dispatched
                                    by default.
    @event mouseMove              Dispatched when a user moves the pointing
                                    device while it is over an InteractiveObject.
                                    If the target is a text field that the user
                                    is selecting, the selection is updated as the
                                    default behavior.
    @event mouseOut               Dispatched when the user moves a pointing
                                    device away from an InteractiveObject
                                    instance. The event target is the object
                                    previously under the pointing device. The
                                    `relatedObject` is the object the
                                    pointing device has moved to. If the target
                                    is a SimpleButton instance, the button
                                    displays the `upState` display
                                    object as the default behavior.

                                    The `mouseOut` event is
                                    dispatched each time the mouse leaves the
                                    area of any child object of the display
                                    object container, even if the mouse remains
                                    over another child object of the display
                                    object container. This is different behavior
                                    than the purpose of the `rollOut`
                                    event, which is to simplify the coding of
                                    rollover behaviors for display object
                                    containers with children. When the mouse
                                    leaves the area of a display object or the
                                    area of any of its children to go to an
                                    object that is not one of its children, the
                                    display object dispatches the
                                    `rollOut` event.The
                                    `rollOut` events are dispatched
                                    consecutively up the parent chain of the
                                    object, starting with the object and ending
                                    with the highest parent that is neither the
                                    root nor an ancestor of the
                                    `relatedObject`.
    @event mouseOver              Dispatched when the user moves a pointing
                                    device over an InteractiveObject instance.
                                    The `relatedObject` is the object
                                    that was previously under the pointing
                                    device. If the target is a SimpleButton
                                    instance, the object displays the
                                    `overState` or
                                    `upState` display object,
                                    depending on whether the mouse button is
                                    down, as the default behavior.

                                    The `mouseOver` event is
                                    dispatched each time the mouse enters the
                                    area of any child object of the display
                                    object container, even if the mouse was
                                    already over another child object of the
                                    display object container. This is different
                                    behavior than the purpose of the
                                    `rollOver` event, which is to
                                    simplify the coding of rollout behaviors for
                                    display object containers with children. When
                                    the mouse enters the area of a display object
                                    or the area of any of its children from an
                                    object that is not one of its children, the
                                    display object dispatches the
                                    `rollOver` event. The
                                    `rollOver` events are dispatched
                                    consecutively down the parent chain of the
                                    object, starting with the highest parent that
                                    is neither the root nor an ancestor of the
                                    `relatedObject` and ending with
                                    the object.
    @event mouseUp                Dispatched when a user releases the pointing
                                    device button over an InteractiveObject
                                    instance. If the target is a SimpleButton
                                    instance, the object displays the
                                    `upState` display object. If the
                                    target is a selectable text field, the text
                                    field ends selection as the default behavior.
    @event mouseWheel             Dispatched when a mouse wheel is spun over an
                                    InteractiveObject instance. If the target is
                                    a text field, the text scrolls as the default
                                    behavior. Only available on Microsoft Windows
                                    operating systems.
    @event nativeDragComplete     Dispatched by the drag initiator
                                    InteractiveObject when the user releases the
                                    drag gesture.

                                    The event's dropAction property indicates
                                    the action set by the drag target object; a
                                    value of "none"
                                    (`DragActions.NONE`) indicates
                                    that the drop was canceled or was not
                                    accepted.

                                    The `nativeDragComplete` event
                                    handler is a convenient place to update the
                                    state of the initiating display object, for
                                    example, by removing an item from a list(on
                                    a drag action of "move"), or by changing the
                                    visual properties.
    @event nativeDragDrop         Dispatched by the target InteractiveObject
                                    when a dragged object is dropped on it and
                                    the drop has been accepted with a call to
                                    DragManager.acceptDragDrop().

                                    Access the dropped data using the event
                                    object `clipboard` property.

                                    The handler for this event should set the
                                    `DragManager.dropAction` property
                                    to provide feedback to the initiator object
                                    about which drag action was taken. If no
                                    value is set, the DragManager will select a
                                    default value from the list of allowed
                                    actions.
    @event nativeDragEnter        Dispatched by an InteractiveObject when a
                                    drag gesture enters its boundary.

                                    Handle either the
                                    `nativeDragEnter` or
                                    `nativeDragOver` events to allow
                                    the display object to become the drop
                                    target.

                                    To determine whether the dispatching
                                    display object can accept the drop, check the
                                    suitability of the data in
                                    `clipboard` property of the event
                                    object, and the allowed drag actions in the
                                    `allowedActions` property.
    @event nativeDragExit         Dispatched by an InteractiveObject when a
                                    drag gesture leaves its boundary.
    @event nativeDragOver         Dispatched by an InteractiveObject
                                    continually while a drag gesture remains
                                    within its boundary.

                                    `nativeDragOver` events are
                                    dispatched whenever the mouse is moved. On
                                    Windows and Mac, they are also dispatched on
                                    a short timer interval even when the mouse
                                    has not moved.

                                    Handle either the
                                    `nativeDragOver` or
                                    `nativeDragEnter` events to allow
                                    the display object to become the drop
                                    target.

                                    To determine whether the dispatching
                                    display object can accept the drop, check the
                                    suitability of the data in
                                    `clipboard` property of the event
                                    object, and the allowed drag actions in the
                                    `allowedActions` property.
    @event nativeDragStart        Dispatched at the beginning of a drag
                                    operation by the InteractiveObject that is
                                    specified as the drag initiator in the
                                    DragManager.doDrag() call.
    @event nativeDragUpdate       Dispatched during a drag operation by the
                                    InteractiveObject that is specified as the
                                    drag initiator in the DragManager.doDrag()
                                    call.

                                    `nativeDragUpdate` events are
                                    not dispatched on Linux.
    @event paste                  Dispatched when the user activates the
                                    platform-specific accelerator key combination
                                    for a paste operation or selects 'Paste' from
                                    the text context menu. This event is
                                    dispatched to the object that currently has
                                    focus. If the object that currently has focus
                                    is a TextField, the default behavior of this
                                    event is to cause the contents of the
                                    clipboard to be pasted into the text field at
                                    the current insertion point replacing any
                                    currently selected text in the text field.
    @event rightClick             Dispatched when a user presses and releases
                                    the right button of the user's pointing
                                    device over the same InteractiveObject. For a
                                    `rightClick` event to occur, it
                                    must always follow this series of events in
                                    the order of occurrence:
                                    `rightMouseDown` event, then
                                    `rightMouseUp`. The target object
                                    must be identical for both of these events;
                                    otherwise the `rightClick` event
                                    does not occur. Any number of other mouse
                                    events can occur at any time between the
                                    `rightMouseDown` or
                                    `rightMouseUp` events; the
                                    `rightClick` event still occurs.
    @event rightMouseDown         Dispatched when a user presses the pointing
                                    device button over an InteractiveObject
                                    instance.
    @event rightMouseUp           Dispatched when a user releases the pointing
                                    device button over an InteractiveObject
                                    instance.
    @event rollOut                Dispatched when the user moves a pointing
                                    device away from an InteractiveObject
                                    instance. The event target is the object
                                    previously under the pointing device or a
                                    parent of that object. The
                                    `relatedObject` is the object that
                                    the pointing device has moved to. The
                                    `rollOut` events are dispatched
                                    consecutively up the parent chain of the
                                    object, starting with the object and ending
                                    with the highest parent that is neither the
                                    root nor an ancestor of the
                                    `relatedObject`.

                                    The purpose of the `rollOut`
                                    event is to simplify the coding of rollover
                                    behaviors for display object containers with
                                    children. When the mouse leaves the area of a
                                    display object or the area of any of its
                                    children to go to an object that is not one
                                    of its children, the display object
                                    dispatches the `rollOut` event.
                                    This is different behavior than that of the
                                    `mouseOut` event, which is
                                    dispatched each time the mouse leaves the
                                    area of any child object of the display
                                    object container, even if the mouse remains
                                    over another child object of the display
                                    object container.
    @event rollOver               Dispatched when the user moves a pointing
                                    device over an InteractiveObject instance.
                                    The event target is the object under the
                                    pointing device or a parent of that object.
                                    The `relatedObject` is the object
                                    that was previously under the pointing
                                    device. The `rollOver` events are
                                    dispatched consecutively down the parent
                                    chain of the object, starting with the
                                    highest parent that is neither the root nor
                                    an ancestor of the `relatedObject`
                                    and ending with the object.

                                    The purpose of the `rollOver`
                                    event is to simplify the coding of rollout
                                    behaviors for display object containers with
                                    children. When the mouse enters the area of a
                                    display object or the area of any of its
                                    children from an object that is not one of
                                    its children, the display object dispatches
                                    the `rollOver` event. This is
                                    different behavior than that of the
                                    `mouseOver` event, which is
                                    dispatched each time the mouse enters the
                                    area of any child object of the display
                                    object container, even if the mouse was
                                    already over another child object of the
                                    display object container.
    @event selectAll              Dispatched when the user activates the
                                    platform-specific accelerator key combination
                                    for a select all operation or selects 'Select
                                    All' from the text context menu. This event
                                    is dispatched to the object that currently
                                    has focus. If the object that currently has
                                    focus is a TextField, the default behavior of
                                    this event is to cause all the contents of
                                    the text field to be selected.
    @event softKeyboardActivate   Dispatched immediately after the soft
                                    keyboard is raised.
    @event softKeyboardActivating Dispatched immediately before the soft
                                    keyboard is raised.
    @event softKeyboardDeactivate Dispatched immediately after the soft
                                    keyboard is lowered.
    @event tabChildrenChange      Dispatched when the value of the object's
                                    `tabChildren` flag changes.
    @event tabEnabledChange       Dispatched when the object's
                                    `tabEnabled` flag changes.
    @event tabIndexChange         Dispatched when the value of the object's
                                    `tabIndex` property changes.
    @event textInput              Dispatched when a user enters one or more
                                    characters of text. Various text input
                                    methods can generate this event, including
                                    standard keyboards, input method editors
                                    (IMEs), voice or speech recognition systems,
                                    and even the act of pasting plain text with
                                    no formatting or style information.
    @event touchBegin             Dispatched when the user first contacts a
                                    touch-enabled device(such as touches a
                                    finger to a mobile phone or tablet with a
                                    touch screen). Some devices might also
                                    interpret this contact as a
                                    `mouseDown` event.

                                    Specifically, if a user touches a finger
                                    to a touch screen, the InteractiveObject
                                    instance can dispatch a
                                    `mouseDown` event or a
                                    `touchBegin` event, or both if the
                                    current environment supports it. Choose how
                                    you want to handle the user interaction. Use
                                    the openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseDown` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `touchBegin` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchEnd               Dispatched when the user removes contact with
                                    a touch-enabled device(such as lifts a
                                    finger off a mobile phone or tablet with a
                                    touch screen). Some devices might also
                                    interpret this contact as a
                                    `mouseUp` event.

                                    Specifically, if a user lifts a finger
                                    from a touch screen, the InteractiveObject
                                    instance can dispatch a `mouseUp`
                                    event or a `touchEnd` event, or
                                    both if the current environment supports it.
                                    Choose how you want to handle the user
                                    interaction. Use the openfl.ui.Multitouch
                                    class to manage touch event handling(enable
                                    touch gesture event handling, simple touch
                                    point event handling, or disable touch events
                                    so only mouse events are dispatched). If you
                                    choose to handle the `mouseUp`
                                    event, then the same event handler will run
                                    on a touch-enabled device and a mouse enabled
                                    device. However, if you choose to handle the
                                    `touchEnd` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchMove              Dispatched when the user moves the point of
                                    contact with a touch-enabled device(such as
                                    drags a finger across a mobile phone or
                                    tablet with a touch screen). Some devices
                                    might also interpret this contact as a
                                    `mouseMove` event.

                                    Specifically, if a user moves a finger
                                    across a touch screen, the InteractiveObject
                                    instance can dispatch a
                                    `mouseMove` event or a
                                    `touchMove` event, or both if the
                                    current environment supports it. Choose how
                                    you want to handle the user interaction. Use
                                    the openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseMove` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `touchMove` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchOut               Dispatched when the user moves the point of
                                    contact away from InteractiveObject instance
                                    on a touch-enabled device(such as drags a
                                    finger from one display object to another on
                                    a mobile phone or tablet with a touch
                                    screen). Some devices might also interpret
                                    this contact as a `mouseOut`
                                    event.

                                    Specifically, if a user moves a finger
                                    across a touch screen, the InteractiveObject
                                    instance can dispatch a `mouseOut`
                                    event or a `touchOut` event, or
                                    both if the current environment supports it.
                                    Choose how you want to handle the user
                                    interaction. Use the openfl.ui.Multitouch
                                    class to manage touch event handling(enable
                                    touch gesture event handling, simple touch
                                    point event handling, or disable touch events
                                    so only mouse events are dispatched). If you
                                    choose to handle the `mouseOut`
                                    event, then the same event handler will run
                                    on a touch-enabled device and a mouse enabled
                                    device. However, if you choose to handle the
                                    `touchOut` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchOver              Dispatched when the user moves the point of
                                    contact over an InteractiveObject instance on
                                    a touch-enabled device(such as drags a
                                    finger from a point outside a display object
                                    to a point over a display object on a mobile
                                    phone or tablet with a touch screen). Some
                                    devices might also interpret this contact as
                                    a `mouseOver` event.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, the
                                    InteractiveObject instance can dispatch a
                                    `mouseOver` event or a
                                    `touchOver` event, or both if the
                                    current environment supports it. Choose how
                                    you want to handle the user interaction. Use
                                    the openfl.ui.Multitouch class to manage touch
                                    event handling(enable touch gesture event
                                    handling, simple touch point event handling,
                                    or disable touch events so only mouse events
                                    are dispatched). If you choose to handle the
                                    `mouseOver` event, then the same
                                    event handler will run on a touch-enabled
                                    device and a mouse enabled device. However,
                                    if you choose to handle the
                                    `touchOver` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchRollOut           Dispatched when the user moves the point of
                                    contact away from an InteractiveObject
                                    instance on a touch-enabled device(such as
                                    drags a finger from over a display object to
                                    a point outside the display object on a
                                    mobile phone or tablet with a touch screen).
                                    Some devices might also interpret this
                                    contact as a `rollOut` event.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, the
                                    InteractiveObject instance can dispatch a
                                    `rollOut` event or a
                                    `touchRollOut` event, or both if
                                    the current environment supports it. Choose
                                    how you want to handle the user interaction.
                                    Use the openfl.ui.Multitouch class to manage
                                    touch event handling(enable touch gesture
                                    event handling, simple touch point event
                                    handling, or disable touch events so only
                                    mouse events are dispatched). If you choose
                                    to handle the `rollOut` event,
                                    then the same event handler will run on a
                                    touch-enabled device and a mouse enabled
                                    device. However, if you choose to handle the
                                    `touchRollOut` event, you can
                                    design your event handler to respond to the
                                    specific needs of a touch-enabled environment
                                    and provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchRollOver          Dispatched when the user moves the point of
                                    contact over an InteractiveObject instance on
                                    a touch-enabled device(such as drags a
                                    finger from a point outside a display object
                                    to a point over a display object on a mobile
                                    phone or tablet with a touch screen). Some
                                    devices might also interpret this contact as
                                    a `rollOver` event.

                                    Specifically, if a user moves a finger
                                    over an InteractiveObject, the
                                    InteractiveObject instance can dispatch a
                                    `rollOver` event or a
                                    `touchRollOver` event, or both if
                                    the current environment supports it. Choose
                                    how you want to handle the user interaction.
                                    Use the openfl.ui.Multitouch class to manage
                                    touch event handling(enable touch gesture
                                    event handling, simple touch point event
                                    handling, or disable touch events so only
                                    mouse events are dispatched). If you choose
                                    to handle the `rollOver` event,
                                    then the same event handler will run on a
                                    touch-enabled device and a mouse enabled
                                    device. However, if you choose to handle the
                                    `touchRollOver` event, you can
                                    design your event handler to respond to the
                                    specific needs of a touch-enabled environment
                                    and provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
    @event touchTap               Dispatched when the user lifts the point of
                                    contact over the same InteractiveObject
                                    instance on which the contact was initiated
                                    on a touch-enabled device(such as presses
                                    and releases a finger from a single point
                                    over a display object on a mobile phone or
                                    tablet with a touch screen). Some devices
                                    might also interpret this contact as a
                                    `click` event.

                                    Specifically, if a user taps a finger over
                                    an InteractiveObject, the InteractiveObject
                                    instance can dispatch a `click`
                                    event or a `touchTap` event, or
                                    both if the current environment supports it.
                                    Choose how you want to handle the user
                                    interaction. Use the openfl.ui.Multitouch
                                    class to manage touch event handling(enable
                                    touch gesture event handling, simple touch
                                    point event handling, or disable touch events
                                    so only mouse events are dispatched). If you
                                    choose to handle the `click`
                                    event, then the same event handler will run
                                    on a touch-enabled device and a mouse enabled
                                    device. However, if you choose to handle the
                                    `touchTap` event, you can design
                                    your event handler to respond to the specific
                                    needs of a touch-enabled environment and
                                    provide users with a richer touch-enabled
                                    experience. You can also handle both events,
                                    separately, to provide a different response
                                    for a touch event than a mouse event.

                                    **Note:** See the Multitouch class for
                                    environment compatibility information.
**/
class InteractiveObject extends DisplayObject {
    /**
        Calling the `new InteractiveObject()` constructor throws an
        `ArgumentError` exception. You can, however, call constructors
        for the following subclasses of InteractiveObject:

        * `new SimpleButton()`
        * `new TextField()`
        * `new Loader()`
        * `new Sprite()`
        * `new MovieClip()`
    **/
    constructor() {
        super();
        this.doubleClickEnabled = false;
        this.mouseEnabled = true;
        this.needsSoftKeyboard = false;
        this.__tabEnabled = null;
        this.__tabIndex = -1;
    }
    /**
        Raises a virtual keyboard.

        Calling this method focuses the InteractiveObject instance and raises
        the soft keyboard, if necessary. The `needsSoftKeyboard` must
        also be `true`. A keyboard is not raised if a hardware keyboard
        is available, or if the client system does not support virtual
        keyboards.

        **Note:** This method is not supported in AIR applications on
        iOS.

        @return A value of `true` means that the soft keyboard request
                was granted; `false` means that the soft keyboard was
                not raised.
    **/
    requestSoftKeyboard() {
        // openfl._internal.Lib.notImplemented();
        return false;
    }
    __allowMouseFocus() {
        return this.tabEnabled;
    }
    __getInteractive(stack) {
        if (stack != null) {
            stack.push(this);
            if (this.parent != null) {
                this.parent.__getInteractive(stack);
            }
        }
        return true;
    }
    // protected __hitTest(x:Float, y:Float, shapeFlag:Bool, stack:Array<DisplayObject>, interactiveOnly:Bool,
    // 		hitObject:DisplayObject):Bool
    // {
    // 	if (!hitObject.visible || __isMask || (interactiveOnly && !mouseEnabled)) return false;
    // 	return inline super.__hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject);
    // }
    __tabTest(stack) {
        if (this.tabEnabled) {
            stack.push(this);
        }
    }
    // Get & Set Methods
    /**
        Specifies whether this object is in the tab order. If this object is
        in the tab order, the value is `true`; otherwise, the value is
        `false`. By default, the value is `false`, except for the following:
        * For a SimpleButton object, the value is `true`.
        * For a TextField object with `type = "input"`, the value is `true`.
        * For a Sprite object or MovieClip object with `buttonMode = true`,
        the value is `true`.
    **/
    get tabEnabled() {
        return this.__tabEnabled == true ? true : false;
    }
    set tabEnabled(value) {
        if (this.__tabEnabled != value) {
            this.__tabEnabled = value;
            this.dispatchEvent(new Event(Event.TAB_ENABLED_CHANGE, true, false));
        }
    }
    /**
        Specifies the tab ordering of objects in a SWF file. The `tabIndex`
        property is -1 by default, meaning no tab index is set for the object.

        If any currently displayed object in the SWF file contains a
        `tabIndex` property, automatic tab ordering is disabled, and the tab
        ordering is calculated from the `tabIndex` properties of objects in
        the SWF file. The custom tab ordering includes only objects that have
        `tabIndex` properties.

        The `tabIndex` property can be a non-negative integer. The objects are
        ordered according to their `tabIndex` properties, in ascending order.
        An object with a `tabIndex` value of 1 precedes an object with a
        `tabIndex` value of 2. Do not use the same `tabIndex` value for
        multiple objects.

        The custom tab ordering that the `tabIndex` property defines is
        _flat_. This means that no attention is paid to the hierarchical
        relationships of objects in the SWF file. All objects in the SWF file
        with `tabIndex` properties are placed in the tab order, and the tab
        order is determined by the order of the `tabIndex` values.

        **Note:** To set the tab order for TLFTextField instances, cast the
        display object child of the TLFTextField as an InteractiveObject, then
        set the `tabIndex` property. For example:

        ```haxe
        cast(tlfInstance.getChildAt(1), InteractiveObject).tabIndex = 3;
        ```

        To reverse the tab order from the default setting for three instances of
        a TLFTextField object (`tlfInstance1`, `tlfInstance2` and
        `tlfInstance3`), use:

        ```haxe
        cast(tlfInstance1.getChildAt(1), InteractiveObject).tabIndex = 3;
        cast(tlfInstance2.getChildAt(1), InteractiveObject).tabIndex = 2;
        cast(tlfInstance3.getChildAt(1), InteractiveObject).tabIndex = 1;
        ```
    **/
    get tabIndex() {
        return this.__tabIndex;
    }
    set tabIndex(value) {
        if (this.__tabIndex != value) {
            if (value < -1)
                throw new RangeError("Parameter tabIndex must be a non-negative number; got " + value);
            this.__tabIndex = value;
            this.dispatchEvent(new Event(Event.TAB_INDEX_CHANGE, true, false));
        }
    }
}

class ArgumentError extends Error$1 {
    constructor(message = "") {
        super(message);
        this.name = "ArgumentError";
    }
}

/**
    The DisplayObjectContainer class is the base class for all objects that can
    serve as display object containers on the display list. The display list
    manages all objects displayed in the Flash runtimes. Use the
    DisplayObjectContainer class to arrange the display objects in the display
    list. Each DisplayObjectContainer object has its own child list for
    organizing the z-order of the objects. The z-order is the front-to-back
    order that determines which object is drawn in front, which is behind, and
    so on.

    DisplayObject is an abstract base class; therefore, you cannot call
    DisplayObject directly. Invoking `new DisplayObject()` throws an
    `ArgumentError` exception.
    The DisplayObjectContainer class is an abstract base class for all objects
    that can contain child objects. It cannot be instantiated directly; calling
    the `new DisplayObjectContainer()` constructor throws an
    `ArgumentError` exception.

    For more information, see the "Display Programming" chapter of the
    _ActionScript 3.0 Developer's Guide_.
**/
class DisplayObjectContainer extends InteractiveObject {
    /**
        Calling the `new DisplayObjectContainer()` constructor throws
        an `ArgumentError` exception. You _can_, however, call
        constructors for the following subclasses of DisplayObjectContainer:

        * `new Loader()`
        * `new Sprite()`
        * `new MovieClip()`

    **/
    constructor() {
        super();
        this.__type = DisplayObjectType$1.DISPLAY_OBJECT_CONTAINER;
        this.mouseChildren = true;
        this.__tabChildren = true;
        this.__numChildren = 0;
        this.__removedChildren = new Vector();
    }
    /**
        Adds a child DisplayObject instance to this DisplayObjectContainer
        instance. The child is added to the front(top) of all other children in
        this DisplayObjectContainer instance.(To add a child to a specific index
        position, use the `addChildAt()` method.)

        If you add a child object that already has a different display object
        container as a parent, the object is removed from the child list of the
        other display object container.

        **Note:** The command `stage.addChild()` can cause
        problems with a published SWF file, including security problems and
        conflicts with other loaded SWF files. There is only one Stage within a
        Flash runtime instance, no matter how many SWF files you load into the
        runtime. So, generally, objects should not be added to the Stage,
        directly, at all. The only object the Stage should contain is the root
        object. Create a DisplayObjectContainer to contain all of the items on the
        display list. Then, if necessary, add that DisplayObjectContainer instance
        to the Stage.

        @param child The DisplayObject instance to add as a child of this
                        DisplayObjectContainer instance.
        @return The DisplayObject instance that you pass in the `child`
                parameter.
        @throws ArgumentError Throws if the child is the same as the parent. Also
                                throws if the caller is a child(or grandchild etc.)
                                of the child being added.
        @event added Dispatched when a display object is added to the display
                        list.
    **/
    addChild(child) {
        if (child == null) {
            var error = new TypeError$1("Error #2007: Parameter child must be non-null.");
            error.__errorID = 2007;
            throw error;
        }
        else if (child.stage == child) {
            var error = new ArgumentError("Error #3783: A Stage object cannot be added as the child of another object.");
            error.__errorID = 3783;
            throw error;
        }
        if (child.parent == this) {
            DisplayObjectLinkedList.__addChild(this, child);
        }
        else {
            DisplayObjectLinkedList.__reparent(this, child);
            DisplayObjectLinkedList.__addChild(this, child);
            var addedToStage = (this.stage != null && child.stage == null);
            if (addedToStage) {
                child.__setStageReferences(this.stage);
            }
            child.__setTransformDirty(true);
            child.__setParentRenderDirty();
            child.__setRenderDirty();
            this.__localBoundsDirty = true;
            this.__setRenderDirty();
            // var event = (<internal.Event><any>Event).__pool.get();
            var event = new Event(Event.ADDED);
            event.__type = Event.ADDED;
            event.__bubbles = true;
            event.__target = child;
            child.__dispatchWithCapture(event);
            // (<internal.Event><any>Event).__pool.release(event);
            if (addedToStage) {
                // event = (<internal.Event><any>Event).__pool.get(Event.ADDED_TO_STAGE);
                event = new Event(Event.ADDED_TO_STAGE);
                child.__dispatchWithCapture(event);
                child.__dispatchChildren(event);
                // (<internal.Event><any>Event).__pool.release(event);
            }
        }
        return child;
    }
    /**
        Adds a child DisplayObject instance to this DisplayObjectContainer
        instance. The child is added at the index position specified. An index of
        0 represents the back(bottom) of the display list for this
        DisplayObjectContainer object.

        For example, the following example shows three display objects, labeled
        a, b, and c, at index positions 0, 2, and 1, respectively:

        ![b over c over a](/images/DisplayObjectContainer_layers.jpg)

        If you add a child object that already has a different display object
        container as a parent, the object is removed from the child list of the
        other display object container.

        @param child The DisplayObject instance to add as a child of this
                        DisplayObjectContainer instance.
        @param index The index position to which the child is added. If you
                        specify a currently occupied index position, the child object
                        that exists at that position and all higher positions are
                        moved up one position in the child list.
        @return The DisplayObject instance that you pass in the `child`
                parameter.
        @throws ArgumentError Throws if the child is the same as the parent. Also
                                throws if the caller is a child(or grandchild etc.)
                                of the child being added.
        @throws RangeError    Throws if the index position does not exist in the
                                child list.
        @event added Dispatched when a display object is added to the display
                        list.
    **/
    addChildAt(child, index) {
        if (index == this.__numChildren) {
            return this.addChild(child);
        }
        if (child == null) {
            var error = new TypeError$1("Error #2007: Parameter child must be non-null.");
            error.__errorID = 2007;
            throw error;
        }
        else if (child.stage == child) {
            var error = new ArgumentError("Error #3783: A Stage object cannot be added as the child of another object.");
            error.__errorID = 3783;
            throw error;
        }
        if (index < 0 || index > this.__numChildren) {
            throw "Invalid index position " + index;
        }
        if (child.parent == this) {
            if (index == 0) {
                if (this.__firstChild != child) {
                    DisplayObjectLinkedList.__unshiftChild(this, child);
                    this.__setRenderDirty();
                }
            }
            else {
                DisplayObjectLinkedList.__swapChildren(this, child, this.getChildAt(index));
                this.__setRenderDirty();
            }
        }
        else {
            DisplayObjectLinkedList.__reparent(this, child);
            DisplayObjectLinkedList.__insertChildAt(this, child, index);
            this.__setRenderDirty();
            var addedToStage = (this.stage != null && child.stage == null);
            if (addedToStage) {
                child.__setStageReferences(this.stage);
            }
            child.__setTransformDirty(true);
            child.__setParentRenderDirty();
            child.__setRenderDirty();
            this.__localBoundsDirty = true;
            this.__setRenderDirty();
            // var event = (<internal.Event><any>Event).__pool.get();
            // (<internal.Event><any>event).__type = Event.ADDED;
            var event = new Event(Event.ADDED);
            event.__bubbles = true;
            event.__target = child;
            child.__dispatchWithCapture(event);
            // (<internal.Event><any>Event).__pool.release(event);
            if (addedToStage) {
                // event = (<internal.Event><any>Event).__pool.get(Event.ADDED_TO_STAGE);
                event = new Event(Event.ADDED_TO_STAGE);
                child.__dispatchWithCapture(event);
                child.__dispatchChildren(event);
                // (<internal.Event><any>Event).__pool.release(event);
            }
        }
        return child;
    }
    /**
        Indicates whether the security restrictions would cause any display
        objects to be omitted from the list returned by calling the
        `DisplayObjectContainer.getObjectsUnderPoint()` method with the
        specified `point` point. By default, content from one domain
        cannot access objects from another domain unless they are permitted to do
        so with a call to the `Security.allowDomain()` method. For more
        information, related to security, see the Flash Player Developer Center
        Topic: [Security](http://www.adobe.com/go/devnet_security_en).

        The `point` parameter is in the coordinate space of the
        Stage, which may differ from the coordinate space of the display object
        container(unless the display object container is the Stage). You can use
        the `globalToLocal()` and the `localToGlobal()`
        methods to convert points between these coordinate spaces.

        @param point The point under which to look.
        @return `true` if the point contains child display objects with
                security restrictions.
    **/
    areInaccessibleObjectsUnderPoint(point) {
        return false;
    }
    /**
        Determines whether the specified display object is a child of the
        DisplayObjectContainer instance or the instance itself. The search
        includes the entire display list including this DisplayObjectContainer
        instance. Grandchildren, great-grandchildren, and so on each return
        `true`.

        @param child The child object to test.
        @return `true` if the `child` object is a child of
                the DisplayObjectContainer or the container itself; otherwise
                `false`.
    **/
    contains(child) {
        while (child != this && child != null) {
            child = child.parent;
        }
        return child == this;
    }
    /**
        Returns the child display object instance that exists at the specified
        index.

        @param index The index position of the child object.
        @return The child display object at the specified index position.
        @throws RangeError    Throws if the index does not exist in the child
                                list.
        @throws SecurityError This child display object belongs to a sandbox to
                                which you do not have access. You can avoid this
                                situation by having the child movie call
                                `Security.allowDomain()`.
    **/
    getChildAt(index) {
        if (index < 0 || index > this.__numChildren - 1) {
            return null;
        }
        var child = this.__firstChild;
        if (child != null) {
            for (let i = 0; i < index; i++) {
                child = child.__nextSibling;
            }
        }
        return child;
    }
    /**
        Returns the child display object that exists with the specified name. If
        more that one child display object has the specified name, the method
        returns the first object in the child list.

        The `getChildAt()` method is faster than the
        `getChildByName()` method. The `getChildAt()` method
        accesses a child from a cached array, whereas the
        `getChildByName()` method has to traverse a linked list to
        access a child.

        @param name The name of the child to return.
        @return The child display object with the specified name.
        @throws SecurityError This child display object belongs to a sandbox to
                                which you do not have access. You can avoid this
                                situation by having the child movie call the
                                `Security.allowDomain()` method.
    **/
    getChildByName(name) {
        var child = this.__firstChild;
        while (child != null) {
            if (child.name == name) {
                return child;
            }
            child = child.__nextSibling;
        }
        return null;
    }
    /**
        Returns the index position of a `child` DisplayObject instance.

        @param child The DisplayObject instance to identify.
        @return The index position of the child display object to identify.
        @throws ArgumentError Throws if the child parameter is not a child of this
                                object.
    **/
    getChildIndex(child) {
        var current = this.__firstChild;
        if (current != null) {
            for (let i = 0; i < this.__numChildren; i++) {
                if (current == child)
                    return i;
                current = current.__nextSibling;
            }
        }
        return -1;
    }
    /**
        Returns an array of objects that lie under the specified point and are
        children(or grandchildren, and so on) of this DisplayObjectContainer
        instance. Any child objects that are inaccessible for security reasons are
        omitted from the returned array. To determine whether this security
        restriction affects the returned array, call the
        `areInaccessibleObjectsUnderPoint()` method.

        The `point` parameter is in the coordinate space of the
        Stage, which may differ from the coordinate space of the display object
        container(unless the display object container is the Stage). You can use
        the `globalToLocal()` and the `localToGlobal()`
        methods to convert points between these coordinate spaces.

        @param point The point under which to look.
        @return An array of objects that lie under the specified point and are
                children(or grandchildren, and so on) of this
                DisplayObjectContainer instance.
    **/
    getObjectsUnderPoint(point) {
        var stack = new Array();
        this.__hitTest(point.x, point.y, false, stack, false, this);
        stack.reverse();
        return stack;
    }
    /**
        Removes the specified `child` DisplayObject instance from the
        child list of the DisplayObjectContainer instance. The `parent`
        property of the removed child is set to `null` , and the object
        is garbage collected if no other references to the child exist. The index
        positions of any display objects above the child in the
        DisplayObjectContainer are decreased by 1.

        The garbage collector reallocates unused memory space. When a variable
        or object is no longer actively referenced or stored somewhere, the
        garbage collector sweeps through and wipes out the memory space it used to
        occupy if no other references to it exist.

        @param child The DisplayObject instance to remove.
        @return The DisplayObject instance that you pass in the `child`
                parameter.
        @throws ArgumentError Throws if the child parameter is not a child of this
                                object.
    **/
    removeChild(child) {
        if (child != null && child.parent == this) {
            child.__setTransformDirty();
            child.__setParentRenderDirty();
            child.__setRenderDirty();
            this.__localBoundsDirty = true;
            this.__setRenderDirty();
            var event = new Event(Event.REMOVED, true);
            child.__dispatchWithCapture(event);
            if (this.stage != null) {
                if (child.stage != null && this.stage.focus == child) {
                    this.stage.focus = null;
                }
                var event = new Event(Event.REMOVED_FROM_STAGE, false, false);
                child.__dispatchWithCapture(event);
                child.__dispatchChildren(event);
                child.__setStageReferences(null);
            }
            DisplayObjectLinkedList.__removeChild(this, child);
            this.__removedChildren.push(child);
            child.__setTransformDirty(true);
            child.__setParentRenderDirty();
        }
        return child;
    }
    /**
        Removes a child DisplayObject from the specified `index`
        position in the child list of the DisplayObjectContainer. The
        `parent` property of the removed child is set to
        `null`, and the object is garbage collected if no other
        references to the child exist. The index positions of any display objects
        above the child in the DisplayObjectContainer are decreased by 1.

        The garbage collector reallocates unused memory space. When a variable
        or object is no longer actively referenced or stored somewhere, the
        garbage collector sweeps through and wipes out the memory space it used to
        occupy if no other references to it exist.

        @param index The child index of the DisplayObject to remove.
        @return The DisplayObject instance that was removed.
        @throws RangeError    Throws if the index does not exist in the child
                                list.
        @throws SecurityError This child display object belongs to a sandbox to
                                which the calling object does not have access. You
                                can avoid this situation by having the child movie
                                call the `Security.allowDomain()` method.
    **/
    removeChildAt(index) {
        if (index >= 0 && index < this.__numChildren) {
            var child = this.__firstChild;
            if (child != null) {
                for (let i = 0; i < this.__numChildren; i++) {
                    if (i == index) {
                        return this.removeChild(child);
                    }
                    child = child.__nextSibling;
                }
            }
        }
        return null;
    }
    /**
        Removes all `child` DisplayObject instances from the child list of the DisplayObjectContainer
        instance. The `parent` property of the removed children is set to `null`, and the objects are
        garbage collected if no other references to the children exist.

        The garbage collector reallocates unused memory space. When a variable or object is no
        longer actively referenced or stored somewhere, the garbage collector sweeps through and
        wipes out the memory space it used to occupy if no other references to it exist.
        @param	beginIndex	The beginning position. A value smaller than 0 throws a `RangeError`.
        @param	endIndex	The ending position. A value smaller than 0 throws a `RangeError`.
    **/
    removeChildren(beginIndex = 0, endIndex = 0x7FFFFFFF) {
        if (endIndex == 0x7FFFFFFF) {
            endIndex = this.__numChildren - 1;
            if (endIndex < 0) {
                return;
            }
        }
        if (beginIndex > this.__numChildren - 1) {
            return;
        }
        else if (endIndex < beginIndex || beginIndex < 0 || endIndex > this.__numChildren) {
            throw new RangeError("The supplied index is out of bounds.");
        }
        var child = this.__firstChild;
        if (child != null) {
            for (let i = 0; i < beginIndex; i++) {
                child = child.__nextSibling;
            }
        }
        var numRemovals = endIndex - beginIndex;
        var next = null;
        while (numRemovals >= 0) {
            next = child.__nextSibling;
            this.removeChild(child);
            child = next;
            numRemovals--;
        }
    }
    resolve(fieldName) {
        var child = this.__firstChild;
        while (child != null) {
            if (child.name == fieldName) {
                return child;
            }
            child = child.__nextSibling;
        }
        return null;
    }
    /**
        Changes the position of an existing child in the display object container.
        This affects the layering of child objects. For example, the following
        example shows three display objects, labeled a, b, and c, at index
        positions 0, 1, and 2, respectively:

        ![c over b over a](/images/DisplayObjectContainerSetChildIndex1.jpg)

        When you use the `setChildIndex()` method and specify an
        index position that is already occupied, the only positions that change
        are those in between the display object's former and new position. All
        others will stay the same. If a child is moved to an index LOWER than its
        current index, all children in between will INCREASE by 1 for their index
        reference. If a child is moved to an index HIGHER than its current index,
        all children in between will DECREASE by 1 for their index reference. For
        example, if the display object container in the previous example is named
        `container`, you can swap the position of the display objects
        labeled a and b by calling the following code:

        ```haxe
        container.setChildIndex(container.getChildAt(1), 0);
        ```

        This code results in the following arrangement of objects:

        ![c over a over b](/images/DisplayObjectContainerSetChildIndex2.jpg)

        @param child The child DisplayObject instance for which you want to change
                        the index number.
        @param index The resulting index number for the `child` display
                        object.
        @throws ArgumentError Throws if the child parameter is not a child of this
                                object.
        @throws RangeError    Throws if the index does not exist in the child
                                list.
    **/
    setChildIndex(child, index) {
        if (index >= 0 && index <= this.__numChildren && this.__numChildren > 1 && child.parent == this) {
            if (index == 0) {
                DisplayObjectLinkedList.__unshiftChild(this, child);
            }
            else if (index >= this.__numChildren - 1) {
                DisplayObjectLinkedList.__addChild(this, child);
            }
            else {
                DisplayObjectLinkedList.__insertChildAt(this, child, index);
            }
            this.__setRenderDirty();
        }
    }
    /**
        Recursively stops the timeline execution of all MovieClips rooted at this object.

        Child display objects belonging to a sandbox to which the excuting code does not
        have access are ignored.

        **Note:** Streaming media playback controlled via a NetStream object will not be
        stopped.
    **/
    stopAllMovieClips() {
        this.__stopAllMovieClips();
    }
    /**
        Swaps the z-order (front-to-back order) of the two specified child
        objects. All other child objects in the display object container remain in
        the same index positions.

        @param child1 The first child object.
        @param child2 The second child object.
        @throws ArgumentError Throws if either child parameter is not a child of
                                this object.
    **/
    swapChildren(child1, child2) {
        if (child1.parent == this && child2.parent == this && child1 != child2) {
            DisplayObjectLinkedList.__swapChildren(this, child1, child2);
            this.__setRenderDirty();
        }
    }
    /**
        Swaps the z-order (front-to-back order) of the child objects at the two
        specified index positions in the child list. All other child objects in
        the display object container remain in the same index positions.

        @param index1 The index position of the first child object.
        @param index2 The index position of the second child object.
        @throws RangeError If either index does not exist in the child list.
    **/
    swapChildrenAt(index1, index2) {
        if (index1 >= 0 && index1 < this.__numChildren && index1 != index2 && index2 >= 0 && index2 < this.__numChildren) {
            var child1 = null, child2 = null;
            var current = this.__firstChild;
            if (current != null) {
                for (let i = 0; i < this.__numChildren; i++) {
                    if (i == index1) {
                        child1 = current;
                    }
                    else if (i == index2) {
                        child2 = current;
                    }
                    current = current.__nextSibling;
                }
            }
            DisplayObjectLinkedList.__swapChildren(this, child1, child2);
            this.__setRenderDirty();
        }
    }
    __cleanupRemovedChildren() {
        for (let orphan of this.__removedChildren) {
            if (orphan.stage == null) {
                orphan.__cleanup();
            }
        }
        this.__removedChildren.length = 0;
    }
    __getBounds(rect, matrix) {
        super.__getBounds(rect, matrix);
        if (this.__numChildren == 0)
            return;
        var childWorldTransform = Matrix.__pool.get();
        var child = this.__firstChild;
        while (child != null) {
            if (child.__scaleX != 0 && child.__scaleY != 0) {
                DisplayObject.__calculateAbsoluteTransform(child.__transform, matrix, childWorldTransform);
                child.__getBounds(rect, childWorldTransform);
            }
            child = child.__nextSibling;
        }
        Matrix.__pool.release(childWorldTransform);
    }
    __getFilterBounds(rect, matrix) {
        super.__getFilterBounds(rect, matrix);
        if (this.__scrollRect != null)
            return;
        if (this.__numChildren == 0)
            return;
        var childWorldTransform = Matrix.__pool.get();
        var child = this.__firstChild;
        while (child != null) {
            if (child.__scaleX != 0 && child.__scaleY != 0 && !child.__isMask) {
                DisplayObject.__calculateAbsoluteTransform(child.__transform, matrix, childWorldTransform);
                child.__getFilterBounds(rect, childWorldTransform);
            }
            child = child.__nextSibling;
        }
        Matrix.__pool.release(childWorldTransform);
    }
    __getRenderBounds(rect, matrix) {
        if (this.__scrollRect != null) {
            super.__getRenderBounds(rect, matrix);
            return;
        }
        else {
            super.__getBounds(rect, matrix);
        }
        if (this.__numChildren == 0)
            return;
        var childWorldTransform = Matrix.__pool.get();
        var child = this.__firstChild;
        while (child != null) {
            if (child.__scaleX != 0 && child.__scaleY != 0 && !child.__isMask) {
                DisplayObject.__calculateAbsoluteTransform(child.__transform, matrix, childWorldTransform);
                child.__getRenderBounds(rect, childWorldTransform);
            }
            child = child.__nextSibling;
        }
        Matrix.__pool.release(childWorldTransform);
    }
    __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        if (!hitObject.visible || this.__isMask || (interactiveOnly && !this.mouseEnabled && !this.mouseChildren))
            return false;
        if (this.mask != null && !this.mask.__hitTestMask(x, y))
            return false;
        if (this.__scrollRect != null) {
            var point = Point.__pool.get();
            point.setTo(x, y);
            this.__getRenderTransform().__transformInversePoint(point);
            if (!this.__scrollRect.containsPoint(point)) {
                Point.__pool.release(point);
                return false;
            }
            Point.__pool.release(point);
        }
        var child = this.__lastChild;
        if (interactiveOnly) {
            if (stack == null || !this.mouseChildren) {
                while (child != null) {
                    if (child.__hitTest(x, y, shapeFlag, null, true, child)) {
                        if (stack != null) {
                            stack.push(hitObject);
                        }
                        return true;
                    }
                    child = child.__previousSibling;
                }
            }
            else if (stack != null) {
                var length = stack.length;
                var interactive = false;
                var hitTest = false;
                while (child != null) {
                    interactive = child.__getInteractive(null);
                    if (interactive || (this.mouseEnabled && !hitTest)) {
                        if (child.__hitTest(x, y, shapeFlag, stack, true, child)) {
                            hitTest = true;
                            if (interactive && stack.length > length) {
                                break;
                            }
                        }
                    }
                    child = child.__previousSibling;
                }
                if (hitTest) {
                    stack.splice(length, 0, hitObject);
                    return true;
                }
            }
        }
        else {
            var hitTest = false;
            while (child != null) {
                if (child.__hitTest(x, y, shapeFlag, stack, false, child)) {
                    hitTest = true;
                    if (stack == null)
                        break;
                }
                child = child.__previousSibling;
            }
            return hitTest;
        }
        return false;
    }
    // protected __hitTest(x:Float, y:Float, shapeFlag:Bool, stack:Array<DisplayObject>, interactiveOnly:Bool,
    // 		hitObject:DisplayObject):Bool
    // {
    // 	if (!hitObject.visible || __isMask || (interactiveOnly && !mouseEnabled && !mouseChildren)) return false;
    // 	if (mask != null && !mask.__hitTestMask(x, y)) return false;
    // 	if (__scrollRect != null)
    // 	{
    // 		var point = Point.__pool.get();
    // 		point.setTo(x, y);
    // 		__getRenderTransform().__transformInversePoint(point);
    // 		if (!__scrollRect.containsPoint(point))
    // 		{
    // 			Point.__pool.release(point);
    // 			return false;
    // 		}
    // 		Point.__pool.release(point);
    // 	}
    // 	if (this.__numChildren > 0)
    // 	{
    // 		var stackRef = (interactiveOnly && !mouseChildren) ? null : stack;
    // 		var hitTest = false;
    // 		var interactive = false;
    // 		var stackLength = -1;
    // 		var children = __childIterator();
    // 		for (child in children)
    // 		{
    // 			if (interactiveOnly && stackRef != null)
    // 			{
    // 				interactive = child.__getInteractive(null);
    // 				if (!interactive && !mouseEnabled && hitTest)
    // 				{
    // 					children.skip(child);
    // 					continue;
    // 				}
    // 				stackLength = stack.length;
    // 			}
    // 			inline super_hitTest(child:DisplayObject, x:Float, y:Float, shapeFlag:Bool, stack:Array<DisplayObject>, interactiveOnly:Bool,
    // 					hitObject:DisplayObject):Bool
    // 			{
    // 				var hitTest = false;
    // 				if (child.__graphics != null)
    // 				{
    // 					if (!hitObject.__visible || child.__isMask || (child.mask != null && !child.mask.__hitTestMask(x, y)))
    // 					{
    // 						hitTest = false;
    // 					}
    // 					else if (child.__graphics.__hitTest(x, y, shapeFlag, child.__getRenderTransform()))
    // 					{
    // 						if (stack != null && !interactiveOnly)
    // 						{
    // 							stack.push(hitObject);
    // 						}
    // 						hitTest = true;
    // 					}
    // 				}
    // 				return hitTest;
    // 			}
    // 			var childHit = switch (child.__type)
    // 			{
    // 				case BITMAP:
    // 					var bitmap:Bitmap = cast child;
    // 					inline bitmap.__hitTest(x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 				case SIMPLE_BUTTON:
    // 					var simpleButton:SimpleButton = cast child;
    // 					inline simpleButton.__hitTest(x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 				case DISPLAY_OBJECT_CONTAINER, MOVIE_CLIP:
    // 					// inline super.__hitTest(x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 					super_hitTest(child, x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 				case TEXTFIELD:
    // 					var textField:TextField = cast child;
    // 					inline textField.__hitTest(x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 				case TILEMAP:
    // 					var tilemap:Tilemap = cast child;
    // 					inline tilemap.__hitTest(x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 				case VIDEO:
    // 					var video:Video = cast child;
    // 					inline video.__hitTest(x, y, shapeFlag, stackRef, interactiveOnly, cast child);
    // 				default: false;
    // 			}
    // 			if (childHit)
    // 			{
    // 				hitTest = true;
    // 				if (stackRef == null || (interactive && stack.length > stackLength))
    // 				{
    // 					break;
    // 				}
    // 			}
    // 		}
    // 		if (hitTest && interactiveOnly && stack != null)
    // 		{
    // 			if (stackLength > -1)
    // 			{
    // 				stack.insert(stackLength, hitObject);
    // 			}
    // 			else
    // 			{
    // 				stack.push(hitObject);
    // 			}
    // 		}
    // 		return hitTest;
    // 	}
    // 	else
    // 	{
    // 		return false;
    // 	}
    // }
    __hitTestMask(x, y) {
        // if (super.__hitTestMask(x, y))
        // {
        // 	return true;
        // }
        if (this.__graphics != null && this.__graphics.__hitTest(x, y, true, this.__getRenderTransform())) {
            return true;
        }
        if (this.__numChildren > 0) {
            for (let child of this.__childIterator()) {
                var hitTest = false;
                switch (child.__type) {
                    case DisplayObjectType$1.BITMAP:
                        var bitmap = child;
                        hitTest = bitmap.__hitTestMask(x, y);
                        break;
                    case DisplayObjectType$1.SIMPLE_BUTTON:
                        var simpleButton = child;
                        hitTest = simpleButton.__hitTestMask(x, y);
                        break;
                    case DisplayObjectType$1.TEXTFIELD:
                        var textField = child;
                        hitTest = textField.__hitTestMask(x, y);
                        break;
                    case DisplayObjectType$1.VIDEO:
                        var video = child;
                        hitTest = video.__hitTestMask(x, y);
                        break;
                    case DisplayObjectType$1.DISPLAY_OBJECT_CONTAINER:
                    case DisplayObjectType$1.MOVIE_CLIP: // inline super.__hitTestMask(x, y) || (child.__graphics != null && child.__graphics.__hitTest(x, y, true, child.__getRenderTransform()));
                        hitTest = (this.__graphics != null && this.__graphics.__hitTest(x, y, true, this.__getRenderTransform()))
                            || (child.__graphics != null && child.__graphics.__hitTest(x, y, true, child.__getRenderTransform()));
                        break;
                    default:
                        hitTest = super.__hitTestMask(x, y);
                }
                if (hitTest) {
                    return true;
                }
            }
        }
        return false;
    }
    __readGraphicsData(graphicsData, recurse) {
        // super.__readGraphicsData(graphicsData, recurse);
        if (this.__graphics != null) {
            this.__graphics.__readGraphicsData(graphicsData);
        }
        if (recurse && this.__numChildren > 0) {
            for (let child of this.__childIterator()) {
                // inline super.__readGraphicsData(graphicsData, recurse);
                if (child.__graphics != null) {
                    child.__graphics.__readGraphicsData(graphicsData);
                }
            }
        }
    }
    __setTransformDirty(force = false) {
        // inline super.__setTransformDirty(force);
        this.__transformDirty = true;
        if (this.__numChildren > 0 && (!this.__childTransformDirty || force)) {
            for (let child of this.__childIterator()) {
                if (child.__type == DisplayObjectType$1.SIMPLE_BUTTON) {
                    var simpleButton = child;
                    simpleButton.__setTransformDirty(force);
                }
                else {
                    // inline super.__setTransformDirty(force);
                    child.__transformDirty = true;
                }
            }
            this.__childTransformDirty = true;
        }
    }
    __stopAllMovieClips() {
        if (this.__numChildren > 0) {
            for (let child of this.__childIterator()) {
                if (child.__type == DisplayObjectType$1.MOVIE_CLIP) {
                    var movieClip = child;
                    movieClip.stop();
                }
            }
        }
    }
    __tabTest(stack) {
        // inline super.__tabTest(stack);
        if (this.__tabEnabled) {
            stack.push(this);
        }
        if (!this.__tabChildren)
            return;
        if (this.__numChildren > 0) {
            var children = this.__childIterator();
            for (let child of children) {
                switch (child.__type) {
                    case DisplayObjectType$1.MOVIE_CLIP:
                        var movieClip = child;
                        if (!movieClip.enabled) {
                            children.skip(movieClip);
                            continue;
                        }
                        else if (movieClip.tabEnabled) {
                            stack.push(movieClip);
                        }
                        if (!movieClip.tabChildren) {
                            children.skip(movieClip);
                            continue;
                        }
                        break;
                    case DisplayObjectType$1.DISPLAY_OBJECT_CONTAINER:
                        var displayObjectContainer = child;
                        if (displayObjectContainer.__tabEnabled) {
                            stack.push(displayObjectContainer);
                        }
                        if (!displayObjectContainer.__tabChildren) {
                            children.skip(displayObjectContainer);
                            continue;
                        }
                        break;
                    case DisplayObjectType$1.SIMPLE_BUTTON:
                    case DisplayObjectType$1.TEXTFIELD:
                        var interactiveObject = child;
                        if (interactiveObject.__tabEnabled) {
                            stack.push(interactiveObject);
                        }
                        break;
                }
            }
        }
    }
    __update(transformOnly, updateChildren) {
        this.__updateSingle(transformOnly, updateChildren);
        if (updateChildren && this.__numChildren > 0) {
            for (let child of this.__childIterator()) {
                var transformDirty = child.__transformDirty;
                // TODO: Flatten masks
                child.__updateSingle(transformOnly, updateChildren);
                switch (child.__type) {
                    case DisplayObjectType$1.SIMPLE_BUTTON:
                        // TODO: Flatten this into the allChildren() call?
                        if (updateChildren) {
                            var button = child;
                            if (button.__currentState != null) {
                                button.__currentState.__update(transformOnly, true);
                            }
                            if (button.hitTestState != null && button.hitTestState != button.__currentState) {
                                button.hitTestState.__update(transformOnly, true);
                            }
                        }
                        break;
                    case DisplayObjectType$1.TEXTFIELD:
                        if (transformDirty) {
                            var textField = child;
                            textField.__renderTransform.__translateTransformed(textField.__offsetX, textField.__offsetY);
                        }
                        break;
                    case DisplayObjectType$1.DISPLAY_OBJECT_CONTAINER:
                    case DisplayObjectType$1.MOVIE_CLIP:
                        // Ensure children are marked as dirty again
                        // as we no longer know if they all are dirty
                        // since at least one has been updated
                        child.__childTransformDirty = false;
                        break;
                }
            }
        }
        this.__childTransformDirty = false;
    }
    // Get & Set Methods
    /**
        Returns the number of children of this object.
    **/
    get numChildren() {
        return this.__numChildren;
    }
    /**
        Determines whether the children of the object are tab enabled. Enables or
        disables tabbing for the children of the object. The default is
        `true`.

        **Note:** Do not use the `tabChildren` property with
        Flex. Instead, use the
        `mx.core.UIComponent.hasFocusableChildren` property.

        @throws IllegalOperationError Calling this property of the Stage object
                                        throws an exception. The Stage object does
                                        not implement this property.
    **/
    get tabChildren() {
        return this.__tabChildren;
    }
    set tabChildren(value) {
        if (this.__tabChildren != value) {
            this.__tabChildren = value;
            this.dispatchEvent(new Event(Event.TAB_CHILDREN_CHANGE, true, false));
        }
    }
}

class DisplayObjectRenderer extends EventDispatcher {
    constructor() {
        super();
        this.__allowSmoothing = true;
        this.__worldAlpha = 1;
    }
    __clear() { }
    __drawBitmapData(bitmapData, source, clipRect) { }
    __enterFrame(displayObject, deltaTime) {
        for (let child of displayObject.__childIterator(false)) {
            switch (child.__type) {
                case DisplayObjectType$1.BITMAP:
                    var bitmap = child;
                    if (bitmap.__bitmapData != null
                        && bitmap.__bitmapData.readable
                        && bitmap.__bitmapData.__getVersion() != bitmap.__imageVersion) {
                        bitmap.__setRenderDirty();
                    }
                    break;
                case DisplayObjectType$1.MOVIE_CLIP:
                    var movieClip = child;
                    if (movieClip.__timeline != null) {
                        movieClip.__timeline.__enterFrame(deltaTime);
                    }
                    break;
                case DisplayObjectType$1.TILEMAP:
                    var tilemap = child;
                    if (tilemap.__group.__dirty) {
                        tilemap.__setRenderDirty();
                    }
                    break;
                case DisplayObjectType$1.VIDEO:
                    var video = child;
                    if (video.__renderable && video.__stream != null) {
                        video.__setRenderDirty();
                    }
                    break;
            }
        }
    }
    __render(object) { }
    __resize(width, height) { }
}

/**
    // TODO: Document GLSL Shaders
    A ShaderData object contains properties representing any parameters and
    inputs for a shader kernel, as well as properties containing any metadata
    specified for the shader.
    These properties are added to the ShaderData object when it is created.
    The properties' names match the names specified in the shader's source
    code. The data type of each property varies according to what aspect of
    the shader the property represents. The properties that represent shader
    parameters are ShaderParameter instances, the properties that represent
    input images are ShaderInput instances, and the properties that represent
    shader metadata are instances of the ActionScript class corresponding to
    their data type (for example, a String instance for textual metadata and a
    uint for uint metadata).

    For example, consider this shader, which is defined with one input image
    (`src`), two parameters (`size` and `radius`), and three metadata values
    (`nameSpace`, `version`, and `description`):

    ```as3
    <languageVersion : 1.0;>

    kernel DoNothing
    <
        namespace: "Adobe::Example";
        vendor: "Adobe examples";
        version: 1;
        description: "A shader that does nothing, but does it well.";
    >
    {
        input image4 src;

        output pixel4 dst;

        parameter float2 size
        <
            description: "The size of the image to which the kernel is applied";
            minValue : number2(0.0, 0.0);
            maxValue : number2(100.0, 100.0);
            defaultValue : number2(50.0, 50.0);
        >;

        parameter float radius
        <
            description: "The radius of the effect";
            minValue: 0.0;
            maxValue: 50.0;
            defaultValue: 25.0;
        >;

        void evaluatePixel()
        {
            float2 one = (radius / radius) ∗ (size / size);
            dst = sampleNearest(src, outCoord());
        }
    }
    ```

    If you create a Shader instance by loading the byte code for this shader,
    the ShaderData instance in its `data` property contains these properties:

    | Property | Data type | Value |
    | --- | --- | --- |
    | name | `String` | "DoNothing" |
    | nameSpace | `String` | "Adobe::Example" |
    | version | `String` | "1" |
    | description | `String` | "A shader that does nothing, but does it well." |
    | src | `ShaderInput` | _[A ShaderInput instance]_ |
    | size | `ShaderParameter` | _[A ShaderParameter instance, with properties for the parameter metadata]_ |
    | radius | `ShaderParameter` | _[A ShaderParameter instance, with properties for the parameter metadata]_ |

    Note that any input image or parameter that is defined in the shader
    source code but not used in the shader's `evaluatePixel()` is
    removed when the shader is compiled to byte code. In that case, there is
    no corresponding ShaderInput or ShaderParameter instance added as a
    property of the ShaderData instance.

    Generally, developer code does not create a ShaderData instance. A
    ShaderData instance containing data, parameters, and inputs for a shader
    is available as the Shader instance's `data` property.
**/
class ShaderData {
    /**
        Creates a ShaderData instance. Generally, developer code does not call
        the ShaderData constructor directly. A ShaderData instance containing
        data, parameters, and inputs for a Shader instance is accessed using
        its `data` property.

        @param byteCode The shader's byte code.
    **/
    constructor(byteArray) { }
}

var openfl$8;
(function (openfl) {
    var display;
    (function (display) {
        /**
            This class defines the constants that represent the possible values for
            the Shader class's `precisionHint` property. Each constant represents one
            of the precision modes for executing shader operations.
            The precision mode selection affects the following shader operations.
            These operations are faster on an Intel processor with the SSE instruction
            set:
    
            * `sin(x)`
            * `cos(x)`
            * `tan(x)`
            * `asin(x)`
            * `acos(x)`
            * `atan(x)`
            * `atan(x, y)`
            * `exp(x)`
            * `exp2(x)`
            * `log(x)`
            * `log2(x)`
            * `pow(x, y)`
            * `reciprocal(x)`
            * `sqrt(x)`
        **/
        let ShaderPrecision;
        (function (ShaderPrecision) {
            /**
                Represents fast precision mode.
                Fast precision mode is designed for maximum performance but does not
                work consistently on different platforms and individual CPU
                configurations. In many cases, this level of precision is sufficient
                to create graphic effects without visible artifacts.
    
                It is usually faster to use fast precision mode than to use lookup
                tables.
            **/
            ShaderPrecision["FAST"] = "fast";
            /**
                Represents full precision mode.
                In full precision mode, the shader computes all math operations to the
                full width of the IEEE 32-bit floating standard. This mode provides
                consistent behavior on all platforms. In this mode, some math
                operations such as trigonometric and exponential functions can be
                slow.
            **/
            ShaderPrecision["FULL"] = "full";
        })(ShaderPrecision = display.ShaderPrecision || (display.ShaderPrecision = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$8 || (openfl$8 = {}));
var ShaderPrecision = openfl$8.display.ShaderPrecision;

/**
    // TODO: Document GLSL Shaders
    A Shader instance represents a Pixel Bender shader kernel in ActionScript.
    To use a shader in your application, you create a Shader instance for it.
    You then use that Shader instance in the appropriate way according to the
    effect you want to create. For example, to use the shader as a filter, you
    assign the Shader instance to the `shader` property of a ShaderFilter
    object.
    A shader defines a that executes on all the pixels in an image,
    one pixel at a time. The result of each call to the is the output
    color at that pixel coordinate in the image. A shader can specify one or
    more input images, which are images whose content can be used in
    determining the output of the function. A shader can also specify one or
    more parameters, which are input values that can be used in calculating
    the output. In a single shader execution, the input and parameter
    values are constant. The only thing that varies is the coordinate of the
    pixel whose color is the result. Shader calls for
    multiple output pixel coordinates execute in parallel to improve shader
    execution performance.

    The shader bytecode can be loaded at run time using a URLLoader instance.
    The following example demonstrates loading a shader bytecode file at run
    time and linking it to a Shader instance.

    ```as3
    var loader:URLLoader = new URLLoader();
    loader.dataFormat = URLLoaderDataFormat.BINARY;
    loader.addEventListener(Event.COMPLETE, onLoadComplete);
    loader.load(new URLRequest("myShader.pbj"));
    var shader:Shader;

    function onLoadComplete(event:Event):void {
        // Create a new shader and set the loaded data as its bytecode
        shader = new Shader();
        shader.byteCode = loader.data;

        // You can also pass the bytecode to the Shader() constructor like this:
        // shader = new Shader(loader.data);

        // do something with the shader
    }
    ```

    You can also embed the shader into the SWF at compile time using the
    `[Embed]` metadata tag. The `[Embed]` metadata tag is only available if
    you use the Flex SDK to compile the SWF. The `[Embed]` tag's `source`
    parameter points to the shader file, and its `mimeType` parameter is
    `"application/octet-stream"`, as in this example:

    ```as3
    [Embed(source="myShader.pbj", mimeType="application/octet-stream)] MyShaderClass:Class;

    // ...

    // create a new shader and set the embedded shader as its bytecode var
    shaderShader = new Shader();
    shader.byteCode = new MyShaderClass();

    // You can also pass the bytecode to the Shader() constructor like this:
    // shader:Shader = new Shader(new MyShaderClass());

    // do something with the shader
    ```

    In either case, you link the raw shader (the `URLLoader.data` property or
    an instance of the `[Embed]` data class) to the Shader instance. As the
    previous examples demonstrate, you can do this in two ways. You can pass
    the shader bytecode as an argument to the `Shader()` constructor.
    Alternatively, you can set it as the Shader instance's `byteCode`
    property.

    Once a Shader instance is created, it can be used in one of several ways:

    * A shader fill: The output of the shader is used as a fill for content
    drawn with the drawing API. Pass the Shader instance as an argument to the
    `Graphics.beginShaderFill()` method.
    * A shader filter: The output of the shader is used as a graphic filter
    applied to a display object. Assign the Shader instance to the `shader`
    property of a ShaderFilter instance.
    * A blend mode: The output of the shader is rendered as the blending
    between two overlapping display objects. Assign the Shader instance to the
    `blendShader` property of the upper of the two display objects.
    * Background shader processing: The shader executes in the background,
    avoiding the possibility of freezing the display, and dispatches an event
    when processing is complete. Assign the Shader instance to the `shader`
    property of a ShaderJob instance.

    Shader fills, filters, and blends are not supported under GPU rendering.

    **Mobile Browser Support:** This feature is not supported in mobile
    browsers.

    _AIR profile support:_ This feature is supported on all desktop operating
    systems, but it is not supported on all mobile devices. It is not
    supported on AIR for TV devices. See <a
    href="http://help.adobe.com/en_US/air/build/WS144092a96ffef7cc16ddeea2126bb46b82f-8000.html">
    AIR Profile Support</a> for more information regarding API support across
    multiple profiles.
**/
class Shader {
    /**
        Creates a new Shader instance.

        @param code The raw shader bytecode to link to the Shader.
    **/
    constructor(code = null) {
        this.byteCode = code;
        this.precisionHint = ShaderPrecision.FULL;
        // __backend = new ShaderBackend(this);
        this.__glSourceDirty = true;
        // numPasses = 1;
        this.__data = new ShaderData(code);
    }
    __init(context3D = null) {
        // __backend.init(context3D);
    }
    __update() {
        // __backend.update();
    }
    // Get & Set Methods
    /**
        Provides access to parameters, input images, and metadata for the
        Shader instance. ShaderParameter objects representing parameters for
        the shader, ShaderInput objects representing the input images for the
        shader, and other values representing the shader's metadata are
        dynamically added as properties of the `data` property object when the
        Shader instance is created. Those properties can be used to introspect
        the shader and to set parameter and input values.
        For information about accessing and manipulating the dynamic
        properties of the `data` object, see the ShaderData class description.
    **/
    get data() {
        if (this.__glSourceDirty || this.__data == null) {
            this.__init();
        }
        return this.__data;
    }
    set data(value) {
        this.__data = value;
    }
    /**
        Get or set the fragment source used when compiling with GLSL.

        This property is not available on the Flash target.
    **/
    get glFragmentSource() {
        return this.__glFragmentSource;
    }
    set glFragmentSource(value) {
        if (value != this.__glFragmentSource) {
            this.__glSourceDirty = true;
        }
        this.__glFragmentSource = value;
    }
    /**
        The compiled GLProgram if available.

        This property is not available on the Flash target.
    **/
    get glProgram() {
        return this.__glProgram;
    }
    /**
        Get or set the vertex source used when compiling with GLSL.

        This property is not available on the Flash target.
    **/
    get glVertexSource() {
        return this.__glVertexSource;
    }
    set glVertexSource(value) {
        if (value != this.__glVertexSource) {
            this.__glSourceDirty = true;
        }
        this.__glVertexSource = value;
    }
}

class DisplayObjectShader extends Shader {
    constructor(code = null) {
        super(code);
        this.glVertexHeader = `
		attribute float openfl_Alpha;
		attribute vec4 openfl_ColorMultiplier;
		attribute vec4 openfl_ColorOffset;
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;

		varying float openfl_Alphav;
		varying vec4 openfl_ColorMultiplierv;
		varying vec4 openfl_ColorOffsetv;
		varying vec2 openfl_TextureCoordv;

		uniform mat4 openfl_Matrix;
		uniform bool openfl_HasColorTransform;
		uniform vec2 openfl_TextureSize;
	`;
        this.glVertexBody = `
		openfl_Alphav = openfl_Alpha;
		openfl_TextureCoordv = openfl_TextureCoord;

		if (openfl_HasColorTransform)
		{

			openfl_ColorMultiplierv = openfl_ColorMultiplier;
			openfl_ColorOffsetv = openfl_ColorOffset / 255.0;

		}

		gl_Position = openfl_Matrix * openfl_Position;
	`;
        this.glVertexSource = `
		#pragma header

		void main(void)
		{
			#pragma body
		}
	`;
        this.glFragmentHeader = `
		varying float openfl_Alphav;
		varying vec4 openfl_ColorMultiplierv;
		varying vec4 openfl_ColorOffsetv;
		varying vec2 openfl_TextureCoordv;

		uniform bool openfl_HasColorTransform;
		uniform sampler2D openfl_Texture;
		uniform vec2 openfl_TextureSize;
	`;
        this.glFragmentBody = `
		vec4 color = texture2D(openfl_Texture, openfl_TextureCoordv);

		if (color.a == 0.0)
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		}
		else if (openfl_HasColorTransform)
		{
			color = vec4(color.rgb / color.a, color.a);

			vec4 colorMultiplier = vec4(openfl_ColorMultiplierv.rgb, 1.0);
			color = clamp((color * colorMultiplier) + openfl_ColorOffsetv, 0.0, 1.0);

			if (color.a > 0.0)
			{
				gl_FragColor = vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);
			}
			else
			{
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			}
		}
		else
		{
			gl_FragColor = color * openfl_Alphav;
		}
	`;
        this.glFragmentSource = `
		#pragma header

		void main(void)
		{
			#pragma body
		}
	`;
    }
}

class DOMElement extends DisplayObject {
    constructor(element) {
        super();
        this.__element = element;
        this.__type = DisplayObjectType$1.DOM_ELEMENT;
    }
}

class TextFormatRange {
    constructor(format, start, end) {
        this.format = format;
        this.start = start;
        this.end = end;
    }
}

let HTMLParser = /** @class */ (() => {
    class HTMLParser {
        static parse(value, textFormat, textFormatRanges) {
            value = value.replace(this.__regexBreakTag, "\n");
            value = value.replace(this.__regexEntities[0], "\"");
            value = value.replace(this.__regexEntities[1], "'");
            value = value.replace(this.__regexEntities[2], "&");
            value = value.replace(this.__regexEntities[5], " ");
            // crude solution
            var segments = value.split("<");
            if (segments.length == 1) {
                value = value.replace(this.__regexHTMLTag, "");
                if (textFormatRanges.length > 1) {
                    textFormatRanges.splice(1, textFormatRanges.length - 1);
                }
                value = value.replace(this.__regexEntities[3], "<");
                value = value.replace(this.__regexEntities[4], ">");
                var range = textFormatRanges[0];
                range.format = textFormat;
                range.start = 0;
                range.end = value.length;
                return value;
            }
            else {
                textFormatRanges.splice(0, textFormatRanges.length);
                value = "";
                var segment;
                for (let i = 0; i < segments.length; i++) {
                    segment = segments[i];
                    segment = segment.replace(this.__regexEntities[3], "<");
                    segment = segment.replace(this.__regexEntities[4], ">");
                    segments[i] = segment;
                }
                var formatStack = [textFormat.clone()];
                var tagStack = [];
                var sub;
                var noLineBreak = false;
                for (let segment of segments) {
                    if (segment == "")
                        continue;
                    var isClosingTag = segment.substr(0, 1) == "/";
                    var tagEndIndex = segment.indexOf(">");
                    var start = tagEndIndex + 1;
                    var spaceIndex = segment.indexOf(" ");
                    var tagName = segment.substring(isClosingTag ? 1 : 0, spaceIndex > -1
                        && spaceIndex < tagEndIndex ? spaceIndex : tagEndIndex);
                    var format;
                    if (isClosingTag) {
                        if (tagStack.length == 0 || tagName.toLowerCase() != tagStack[tagStack.length - 1].toLowerCase()) {
                            console.info("Invalid HTML, unexpected closing tag ignored: " + tagName);
                            continue;
                        }
                        tagStack.pop();
                        formatStack.pop();
                        format = formatStack[formatStack.length - 1].clone();
                        if (tagName.toLowerCase() == "p" && textFormatRanges.length > 0) {
                            value += "\n";
                            noLineBreak = true;
                            textFormatRanges[textFormatRanges.length - 1].end++;
                        }
                        if (start < segment.length) {
                            sub = segment.substr(start);
                            textFormatRanges.push(new TextFormatRange(format, value.length, value.length + sub.length));
                            value += sub;
                            noLineBreak = false;
                        }
                    }
                    else {
                        format = formatStack[formatStack.length - 1].clone();
                        var result = null;
                        if (tagEndIndex > -1) {
                            switch (tagName.toLowerCase()) {
                                case "a":
                                    result = this.__getAttributeMatch(this.__regexHref, segment);
                                    if (result != null) {
                                        format.url = result;
                                    }
                                    break;
                                case "p":
                                    if (textFormatRanges.length > 0 && !noLineBreak) {
                                        value += "\n";
                                    }
                                    result = this.__getAttributeMatch(this.__regexAlign, segment);
                                    if (result != null) {
                                        format.align = result.toLowerCase();
                                    }
                                    break;
                                case "font":
                                    result = this.__getAttributeMatch(this.__regexFace, segment);
                                    if (result != null) {
                                        format.font = result;
                                    }
                                    result = this.__getAttributeMatch(this.__regexColor, segment);
                                    if (result != null) {
                                        format.color = Math.round(parseFloat(("0x" + result)));
                                    }
                                    result = this.__getAttributeMatch(this.__regexSize, segment);
                                    if (result != null) {
                                        var firstChar = result.charCodeAt(0);
                                        if (firstChar == "+".charCodeAt(0) || firstChar == "-".charCodeAt(0)) {
                                            var parentFormat = (formatStack.length >= 2) ? formatStack[formatStack.length - 2] : textFormat;
                                            format.size = parentFormat.size + Math.round(parseFloat((result)));
                                        }
                                        else {
                                            format.size = Math.round(parseFloat(result));
                                        }
                                    }
                                    break;
                                case "b":
                                    format.bold = true;
                                    break;
                                case "u":
                                    format.underline = true;
                                    break;
                                case "i":
                                case "em":
                                    format.italic = true;
                                    break;
                                case "textformat":
                                    result = this.__getAttributeMatch(this.__regexBlockIndent, segment);
                                    if (result != null) {
                                        format.blockIndent = Math.round(parseFloat(result));
                                    }
                                    result = this.__getAttributeMatch(this.__regexIndent, segment);
                                    if (result != null) {
                                        format.indent = Math.round(parseFloat(result));
                                    }
                                    result = this.__getAttributeMatch(this.__regexLeading, segment);
                                    if (result != null) {
                                        format.leading = Math.round(parseFloat(result));
                                    }
                                    result = this.__getAttributeMatch(this.__regexLeftMargin, segment);
                                    if (result != null) {
                                        format.leftMargin = Math.round(parseFloat(result));
                                    }
                                    result = this.__getAttributeMatch(this.__regexRightMargin, segment);
                                    if (result != null) {
                                        format.rightMargin = Math.round(parseFloat(result));
                                    }
                                    result = this.__getAttributeMatch(this.__regexTabStops, segment);
                                    if (result != null) {
                                        var values = result.split(" ");
                                        var tabStops = [];
                                        for (let stop of values) {
                                            tabStops.push(Math.round(parseFloat(stop)));
                                        }
                                        format.tabStops = tabStops;
                                    }
                                    break;
                            }
                            formatStack.push(format);
                            tagStack.push(tagName);
                            if (start < segment.length) {
                                sub = segment.substring(start);
                                textFormatRanges.push(new TextFormatRange(format, value.length, value.length + sub.length));
                                value += sub;
                                noLineBreak = false;
                            }
                        }
                        else {
                            textFormatRanges.push(new TextFormatRange(format, value.length, value.length + segment.length));
                            value += segment;
                            noLineBreak = false;
                        }
                    }
                }
                if (textFormatRanges.length == 0) {
                    textFormatRanges.push(new TextFormatRange(formatStack[0], 0, 0));
                }
            }
            return value;
        }
        static __getAttributeMatch(regex, segment) {
            var result = regex.exec(segment);
            if (result != null) {
                return result[2] != null ? result[2] : result[3];
            }
            return null;
        }
    }
    HTMLParser.__regexAlign = /align\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexBreakTag = /<br\s*\/?>/gi;
    HTMLParser.__regexBlockIndent = /blockindent\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexColor = /color\s?=\s?("#([^"]+)"|'#([^']+)')/i;
    HTMLParser.__regexEntities = [/&quot;/g, /&apos;/g, /&amp;/g, /&lt;/g, /&gt;/g, /&nbsp;/g];
    HTMLParser.__regexFace = /face\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexHTMLTag = /<.*?>/g;
    HTMLParser.__regexHref = /href\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexIndent = / indent\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexLeading = /leading\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexLeftMargin = /leftmargin\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexRightMargin = /rightmargin\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexSize = /size\s?=\s?("([^"]+)"|'([^']+)')/i;
    HTMLParser.__regexTabStops = /tabstops\s?=\s?("([^"]+)"|'([^']+)')/i;
    return HTMLParser;
})();

/**
    `Promise` is an implementation of Futures and Promises, with the exception that
    in addition to "success" and "failure" states (represented as "complete" and "error"),
    Lime `Future` introduces "progress" feedback as well to increase the value of
    `Future` values.

    While `Future` is meant to be read-only, `Promise` can be used to set the state of a future
    for receipients of it's `Future` object. For example:

    ```haxe
    function examplePromise ():Future<string> {

        var promise = new Promise<string> ();

        var progress = 0, total = 10;
        var timer = new Timer (100);
        timer.run = () {

            promise.progress (progress, total);
            progress++;

            if (progress == total) {

                promise.complete ("Done!");
                timer.stop ();

            }

        };

        return promise.future;

    }

    var future = examplePromise ();
    future.onComplete (function (message) { trace (message); });
    future.onProgress (function (loaded, total) { trace ("Progress: " + loaded + ", " + total); });
    ```
**/
class Promise {
    /**
        Create a new `Promise` instance
    **/
    constructor() {
        this.__future = new Future();
    }
    /**
        Resolves this `Promise` with a completion state
        @param	data	The completion value
        @return	The current `Promise`
    **/
    complete(data) {
        var future = this.__future;
        if (!future.__isError) {
            future.__isComplete = true;
            future.__value = data;
            if (future.__completeListeners != null) {
                for (let i = 0; i < future.__completeListeners.length; i++) {
                    future.__completeListeners[i](data);
                }
                future.__completeListeners = null;
            }
        }
        return this;
    }
    /**
        Resolves this `Promise` with the complete, error and/or progress state
        of another `Future`
        @param	future	The `Future` to use to resolve this `Promise`
        @return	The current `Promise`
    **/
    completeWith(future) {
        this.__future.onComplete(this.complete);
        this.__future.onError(this.error);
        this.__future.onProgress(this.progress);
        return this;
    }
    /**
        Resolves this `Promise` with an error state
        @param	msg	The error value
        @return	The current `Promise`
    **/
    error(msg) {
        var future = this.__future;
        if (!future.__isComplete) {
            future.__isError = true;
            future.__error = msg;
            if (future.__errorListeners != null) {
                for (let i = 0; i < future.__errorListeners.length; i++) {
                    future.__errorListeners[i](msg);
                }
                future.__errorListeners = null;
            }
        }
        return this;
    }
    /**
        Sends progress updates to the related `Future`
        @param	progress	A progress value
        @param	total	A total value. This should be equal or greater to the `progress` value
        @return	The current `Promise`
    **/
    progress(progress, total) {
        var future = this.__future;
        if (!future.__isError && !future.__isComplete) {
            if (future.__progressListeners != null) {
                for (let i = 0; i < future.__progressListeners.length; i++) {
                    future.__progressListeners[i](progress, total);
                }
            }
        }
        return this;
    }
    // Get & Set Methods
    /**
        The `Future` associated with this `Promise`.

        All subsequent calls to set an error, completion or progress state
        will update the status and notify listeners to this `Future`
    **/
    get future() {
        return this.__future;
    }
    /**
        Whether the `Promise` (and related `Future`) has finished with a completion state.
        This will be `false` if the `Promise` has not been resolved with a completion or error state.
    **/
    get isComplete() {
        return this.__future.isComplete;
    }
    /**
        Whether the `Promise` (and related `Future`) has finished with an error state.
        This will be `false` if the `Promise` has not been resolved with a completion or error state.
    **/
    get isError() {
        return this.__future.isError;
    }
}

/**
    `Future` is an implementation of Futures and Promises, with the exception that
    in addition to "success" and "failure" states (represented as "complete" and "error"),
    Lime `Future` introduces "progress" feedback as well to increase the value of
    `Future` values.

    ```haxe
    var future = Image.loadFromFile ("image.png");
    future.onComplete (function (image) { trace ("Image loaded"); });
    future.onProgress (function (loaded, total) { trace ("Loading: " + loaded + ", " + total); });
    future.onError (function (error) { trace (error); });

    Image.loadFromFile ("image.png").then (function (image) {

        return Future.withValue (image.width);

    }).onComplete (function (width) { trace (width); })
    ```

    `Future` values can be chained together for asynchronous processing of values.

    If an error occurs earlier in the chain, the error is propagated to all `onError` callbacks.

    `Future` will call `onComplete` callbacks, even if completion occurred before registering the
    callback. This resolves race conditions, so even functions that return immediately can return
    values using `Future`.

    `Future` values are meant to be immutable, if you wish to update a `Future`, you should create one
    using a `Promise`, and use the `Promise` interface to influence the error, complete or progress state
    of a `Future`.
**/
class Future {
    /**
        Create a new `Future` instance
        @param	work	(Optional) A to execute
        @param	async	(Optional) If a is specified, whether to execute it asynchronously where supported
    **/
    constructor(work = null, async = false) {
        if (work != null) {
            // if (async)
            // {
            // 	var promise = new Promise<T>();
            // 	promise.future = this;
            // 	FutureWork.queue({promise: promise, work: work});
            // }
            // else
            // {
            try {
                this.__value = work();
                this.__isComplete = true;
            }
            catch (e) {
                this.__error = e;
                this.__isError = true;
            }
            // }
        }
    }
    /**
        Create a new `Future` instance based on complete and (optionally) error and/or progress `Event` instances
    **/
    // public static ofEvents<T>(onComplete:Event<T->Void>, onError:Event<Dynamic->Void> = null, onProgress:Event<Int->Int->Void> = null):Future<T>
    // {
    // 	var promise = new Promise<T>();
    // 	onComplete.add(function(data) promise.complete(data), true);
    // 	if (onError != null) onError.add(function(error) promise.error(error), true);
    // 	if (onProgress != null) onProgress.add(function(progress, total) promise.progress(progress, total), true);
    // 	return promise.future;
    // }
    /**
        Register a listener for when the `Future` completes.

        If the `Future` has already completed, this is called immediately with the result
        @param	listener	A callback method to receive the result value
        @return	The current `Future`
    **/
    onComplete(listener) {
        if (listener != null) {
            if (this.__isComplete) {
                listener(this.__value);
            }
            else if (!this.__isError) {
                if (this.__completeListeners == null) {
                    this.__completeListeners = new Array();
                }
                this.__completeListeners.push(listener);
            }
        }
        return this;
    }
    /**
        Register a listener for when the `Future` ends with an error state.

        If the `Future` has already ended with an error, this is called immediately with the error value
        @param	listener	A callback method to receive the error value
        @return	The current `Future`
    **/
    onError(listener) {
        if (listener != null) {
            if (this.__isError) {
                listener(this.__error);
            }
            else if (!this.__isComplete) {
                if (this.__errorListeners == null) {
                    this.__errorListeners = new Array();
                }
                this.__errorListeners.push(listener);
            }
        }
        return this;
    }
    /**
        Register a listener for when the `Future` updates progress.

        If the `Future` is already completed, this will not be called.
        @param	listener	A callback method to receive the progress value
        @return	The current `Future`
    **/
    onProgress(listener) {
        if (listener != null) {
            if (this.__progressListeners == null) {
                this.__progressListeners = new Array();
            }
            this.__progressListeners.push(listener);
        }
        return this;
    }
    /**
        Attempts to block on an asynchronous `Future`, returning when it is completed.
        @param	waitTime	(Optional) A timeout before this call will stop blocking
        @return	This current `Future`
    **/
    ready(waitTime = -1) {
        if (this.__isComplete || this.__isError) {
            return this;
        }
        else {
            console.warn("Cannot block thread in JavaScript");
            return this;
        }
    }
    /**
        Attempts to block on an asynchronous `Future`, returning the completion value when it is finished.
        @param	waitTime	(Optional) A timeout before this call will stop blocking
        @return	The completion value, or `null` if the request timed out or blocking is not possible
    **/
    result(waitTime = -1) {
        this.ready(waitTime);
        if (this.__isComplete) {
            return this.__value;
        }
        else {
            return null;
        }
    }
    /**
        Chains two `Future` instances together, passing the result from the first
        as input for creating/returning a new `Future` instance of a new or the same type
    **/
    then(next) {
        if (this.__isComplete) {
            return next(this.value);
        }
        else if (this.__isError) {
            var future = new Future();
            future.__isError = true;
            future.__error = this.__error;
            return future;
        }
        else {
            var promise = new Promise();
            this.onError(promise.error);
            this.onProgress(promise.progress);
            this.onComplete(function (val) {
                var future = next(val);
                future.onError(promise.error);
                future.onComplete(promise.complete);
            });
            return promise.future;
        }
    }
    /**
        Creates a `Future` instance which has finished with an error value
        @param	error	The error value to set
        @return	A new `Future` instance
    **/
    static withError(error) {
        var future = new Future();
        future.__isError = true;
        future.__error = error;
        return future;
    }
    /**
        Creates a `Future` instance which has finished with a completion value
        @param	error	The completion value to set
        @return	A new `Future` instance
    **/
    static withValue(value) {
        var future = new Future();
        future.__isComplete = true;
        future.__value = value;
        return future;
    }
    // Get & Set Methods
    /**
        If the `Future` has finished with an error state, the `error` value
    **/
    get error() {
        return this.__error;
    }
    /**
        Whether the `Future` finished with a completion state
    **/
    get isComplete() {
        return this.__isComplete;
    }
    /**
        Whether the `Future` finished with an error state
    **/
    get isError() {
        return this.__isError;
    }
    /**
        If the `Future` has finished with a completion state, the completion `value`
    **/
    get value() {
        return this.__value;
    }
}

/**
    The Font class is used to manage embedded fonts in SWF files. Embedded
    fonts are represented as a subclass of the Font class. The Font class is
    currently useful only to find out information about embedded fonts; you
    cannot alter a font by using this class. You cannot use the Font class to
    load external fonts, or to create an instance of a Font object by itself.
    Use the Font class as an abstract base class.
**/
let Font = /** @class */ (() => {
    class Font {
        constructor(name = null) {
            this.fontName = name;
        }
        /**
            Specifies whether to provide a list of the currently available embedded
            fonts.
    
            @param enumerateDeviceFonts Indicates whether you want to limit the list
                                        to only the currently available embedded
                                        fonts. If this is set to `true`
                                        then a list of all fonts, both device fonts
                                        and embedded fonts, is returned. If this is
                                        set to `false` then only a list of
                                        embedded fonts is returned.
            @return A list of available fonts as an array of Font objects.
        **/
        static enumerateFonts(enumerateDeviceFonts = false) {
            return Font.__registeredFonts;
        }
        /**
            Creates a new Font from bytes (a haxe.io.Bytes or openfl.utils.ByteArray)
            synchronously. This means that the Font will be returned immediately (if
            supported).
    
            @param	bytes	A haxe.io.Bytes or openfl.utils.ByteArray instance
            @returns	A new Font if successful, or `null` if unsuccessful
        **/
        static fromBytes(bytes) {
            var font = new Font();
            return font;
        }
        /**
            Creates a new Font from a file path synchronously. This means that the
            Font will be returned immediately (if supported).
    
            @param	path	A local file path containing a font
            @returns	A new Font if successful, or `null` if unsuccessful
        **/
        static fromFile(path) {
            var font = new Font();
            return font;
        }
        /**
            Specifies whether a provided string can be displayed using the
            currently assigned font.
    
            @param str The string to test against the current font.
            @return A value of `true` if the specified string can be fully
                    displayed using this font.
        **/
        // /** @hidden */ @:dox(hide) public hasGlyphs (str:String):Bool;
        /**
            Creates a new Font from haxe.io.Bytes or openfl.utils.ByteArray data
            asynchronously. The font decoding will occur in the background.
            Progress, completion and error callbacks will be dispatched in the current
            thread using callbacks attached to a returned Future object.
    
            @param	bytes	A haxe.io.Bytes or openfl.utils.ByteArray instance
            @returns	A Future Font
        **/
        static loadFromBytes(bytes) {
            return Future.withError("Cannot load font from bytes");
        }
        /**
            Creates a new Font from a file path or web address asynchronously. The file
            load and font decoding will occur in the background.
            Progress, completion and error callbacks will be dispatched in the current
            thread using callbacks attached to a returned Future object.
    
            @param	path	A local file path or web address containing a font
            @returns	A Future Font
        **/
        static loadFromFile(path) {
            return Future.withError("Cannot load font from file");
        }
        /**
            Creates a new Font from a font name asynchronously. This feature should work
            for embedded CSS fonts on the HTML5 target, but is not implemented for
            registered OS fonts on native targets currently. The file
            load and font decoding will occur in the background.
            Progress, completion and error callbacks will be dispatched in the current
            thread using callbacks attached to a returned Future object.
    
            @param	path	A font name
            @returns	A Future Font
        **/
        static loadFromName(path) {
            var font = new Font();
            return font.__loadFromName(path);
        }
        /**
            Registers a font in the global font list.
    
        **/
        static registerFont(font) {
            var instance = null;
            {
                instance = font;
            }
            if (instance != null) {
                /*if (Reflect.hasField (font, "resourceName")) {
    
                    instance.fontName = __ofResource (Reflect.field (font, "resourceName"));
    
                }*/
                Font.__registeredFonts.push(instance);
                Font.__fontByName[instance.fontName] = instance;
            }
        }
        __initialize() {
            return this.__initialized;
        }
        __loadFromName(name) {
            var promise = new Promise();
            // this.name = name;
            this.fontName = name;
            var userAgent = navigator.userAgent.toLowerCase();
            var isSafari = (userAgent.indexOf(" safari/") >= 0 && userAgent.indexOf(" chrome/") < 0);
            var isUIWebView = userAgent.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Version)/i).length > 0;
            if (!isSafari && !isUIWebView && document["fonts"] && document["fonts"].load) {
                document["fonts"].load("1em '" + name + "'").then(function (_) {
                    promise.complete(this);
                }, () => {
                    console.warn("Could not load web font \"" + name + "\"");
                    promise.complete(this);
                });
            }
            else {
                var node1 = Font.__measureFontNode("'" + name + "', sans-serif");
                var node2 = Font.__measureFontNode("'" + name + "', serif");
                var width1 = node1.offsetWidth;
                var width2 = node2.offsetWidth;
                var interval = -1;
                var timeout = 3000;
                var intervalLength = 50;
                var intervalCount = 0;
                var loaded, timeExpired;
                var checkFont = () => {
                    intervalCount++;
                    loaded = (node1.offsetWidth != width1 || node2.offsetWidth != width2);
                    timeExpired = (intervalCount * intervalLength >= timeout);
                    if (loaded || timeExpired) {
                        window.clearInterval(interval);
                        node1.parentNode.removeChild(node1);
                        node2.parentNode.removeChild(node2);
                        node1 = null;
                        node2 = null;
                        if (timeExpired) {
                            console.warn("Could not load web font \"" + name + "\"");
                        }
                        promise.complete(this);
                    }
                };
                interval = window.setInterval(checkFont, intervalLength);
            }
            return promise.future;
        }
        static __measureFontNode(fontFamily) {
            var node = document.createElement("span");
            node.setAttribute("aria-hidden", "true");
            var text = document.createTextNode("BESbswy");
            node.appendChild(text);
            var style = node.style;
            style.display = "block";
            style.position = "absolute";
            style.top = "-9999px";
            style.left = "-9999px";
            style.fontSize = "300px";
            style.width = "auto";
            style.height = "auto";
            style.lineHeight = "normal";
            style.margin = "0";
            style.padding = "0";
            style.fontVariant = "normal";
            style.whiteSpace = "nowrap";
            style.fontFamily = fontFamily;
            document.body.appendChild(node);
            return node;
        }
    }
    Font.__fontByName = new Map();
    Font.__registeredFonts = new Array();
    return Font;
})();

/**
        The GridFitType class defines values for grid fitting in the TextField
        class.
    **/
var GridFitType;
(function (GridFitType) {
    /**
        Doesn't set grid fitting. Horizontal and vertical lines in the glyphs
        are not forced to the pixel grid. This constant is used in setting the
        `gridFitType` property of the TextField class. This is often a good
        setting for animation or for large font sizes. Use the syntax
        `GridFitType.NONE`.
    **/
    GridFitType["NONE"] = "none";
    /**
        Fits strong horizontal and vertical lines to the pixel grid. This
        constant is used in setting the `gridFitType` property of the
        TextField class. This setting only works for left-justified text
        fields and acts like the `GridFitType.SUBPIXEL` constant in static
        text. This setting generally provides the best readability for
        left-aligned text. Use the syntax `GridFitType.PIXEL`.
    **/
    GridFitType["PIXEL"] = "pixel";
    /**
        Fits strong horizontal and vertical lines to the sub-pixel grid on LCD
        monitors. (Red, green, and blue are actual pixels on an LCD screen.)
        This is often a good setting for right-aligned or center-aligned
        dynamic text, and it is sometimes a useful tradeoff for animation vs.
        text quality. This constant is used in setting the `gridFitType`
        property of the TextField class. Use the syntax
        `GridFitType.SUBPIXEL`.
    **/
    GridFitType["SUBPIXEL"] = "subpixel";
})(GridFitType || (GridFitType = {}));
var GridFitType$1 = GridFitType;

/**
    The TextFieldAutoSize class is an enumeration of constant values used in
    setting the `autoSize` property of the TextField class.
**/
var TextFieldAutoSize;
(function (TextFieldAutoSize) {
    /**
        Specifies that the text is to be treated as center-justified text. Any
        resizing of a single line of a text field is equally distributed to both
        the right and left sides.
    **/
    TextFieldAutoSize["CENTER"] = "center";
    /**
        Specifies that the text is to be treated as left-justified text, meaning
        that the left side of the text field remains fixed and any resizing of a
        single line is on the right side.
    **/
    TextFieldAutoSize["LEFT"] = "left";
    /**
        Specifies that no resizing is to occur.
    **/
    TextFieldAutoSize["NONE"] = "none";
    /**
        Specifies that the text is to be treated as right-justified text, meaning
        that the right side of the text field remains fixed and any resizing of a
        single line is on the left side.
    **/
    TextFieldAutoSize["RIGHT"] = "right";
})(TextFieldAutoSize || (TextFieldAutoSize = {}));
var TextFieldAutoSize$1 = TextFieldAutoSize;

/**
    The TextFieldType class is an enumeration of constant values used in
    setting the `type` property of the TextField class.
**/
var TextFieldType;
(function (TextFieldType) {
    /**
        Used to specify a `dynamic` TextField.
    **/
    TextFieldType["DYNAMIC"] = "dynamic";
    /**
        Used to specify an `input` TextField.
    **/
    TextFieldType["INPUT"] = "input";
})(TextFieldType || (TextFieldType = {}));
var TextFieldType$1 = TextFieldType;

/**
    The TextFormatAlign class provides values for text alignment in the
    TextFormat class.
**/
var TextFormatAlign;
(function (TextFormatAlign) {
    /**
        Constant; centers the text in the text field. Use the syntax
        `TextFormatAlign.CENTER`.
    **/
    TextFormatAlign["CENTER"] = "center";
    /**
        Constant; aligns text to the end edge of a line. Same as right for left-to-right
        languages and same as left for right-to-left languages.

        The `END` constant may only be used with the StageText class.
    **/
    TextFormatAlign["END"] = "end";
    /**
        Constant; justifies text within the text field. Use the syntax
        `TextFormatAlign.JUSTIFY`.
    **/
    TextFormatAlign["JUSTIFY"] = "justify";
    /**
        Constant; aligns text to the left within the text field. Use the syntax
        `TextFormatAlign.LEFT`.
    **/
    TextFormatAlign["LEFT"] = "left";
    /**
        Constant; aligns text to the right within the text field. Use the syntax
        `TextFormatAlign.RIGHT`.
    **/
    TextFormatAlign["RIGHT"] = "right";
    /**
        Constant; aligns text to the start edge of a line. Same as left for left-to-right
        languages and same as right for right-to-left languages.

        The `START` constant may only be used with the StageText class.
    **/
    TextFormatAlign["START"] = "start";
})(TextFormatAlign || (TextFormatAlign = {}));
var TextFormatAlign$1 = TextFormatAlign;

// TODO: Need to measure all characters (including whitespace) but include a value for non-whitespace characters separately (for sake of alignment and wrapping)
class TextLayoutGroup {
    constructor(format, startIndex, endIndex) {
        this.format = format;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }
    getAdvance(index) {
        return this.positions[index];
    }
}

let TextEngine = /** @class */ (() => {
    class TextEngine {
        constructor(textField) {
            this.textField = textField;
            this.width = 100;
            this.height = 100;
            this.text = "";
            this.bounds = new Rectangle(0, 0, 0, 0);
            this.textBounds = new Rectangle(0, 0, 0, 0);
            this.type = TextFieldType$1.DYNAMIC;
            this.autoSize = TextFieldAutoSize$1.NONE;
            this.embedFonts = false;
            this.selectable = true;
            this.borderColor = 0x000000;
            this.border = false;
            this.backgroundColor = 0xffffff;
            this.background = false;
            this.gridFitType = GridFitType$1.PIXEL;
            this.maxChars = 0;
            this.multiline = false;
            this.__numLines = 1;
            this.sharpness = 0;
            this.scrollH = 0;
            this.scrollV = 1;
            this.wordWrap = false;
            this.lineAscents = new Vector();
            this.lineBreaks = new Vector();
            this.lineDescents = new Vector();
            this.lineLeadings = new Vector();
            this.lineHeights = new Vector();
            this.lineWidths = new Vector();
            this.layoutGroups = new Vector();
            this.textFormatRanges = new Vector();
            if (TextEngine.__context == null) {
                TextEngine.__context = document.createElement("canvas").getContext("2d");
            }
        }
        createRestrictRegexp(restrict) {
            var declinedRange = /\^(.-.|.)/gu;
            var declined = "";
            var result = declinedRange.exec(restrict);
            if (result != null) {
                restrict = restrict.replace(declinedRange, "");
                for (let i = 0; i < result.length; i++) {
                    declined += result[i];
                }
            }
            var testRegexpParts = [];
            if (restrict.length > 0) {
                testRegexpParts.push(`[^${restrict}]`);
            }
            if (declined.length > 0) {
                testRegexpParts.push(`[${declined}]`);
            }
            return new RegExp(`(${testRegexpParts.join(' | ')})`, "g");
        }
        static findFont(name) {
            return Font.__fontByName.get(name);
        }
        static findFontVariant(format) {
            var fontName = format.font;
            var bold = format.bold;
            var italic = format.italic;
            if (fontName == null)
                fontName = "_serif";
            var fontNamePrefix = fontName.replace(" Normal", "").replace(" Regular", "");
            if (bold && italic && Font.__fontByName.has(fontNamePrefix + " Bold Italic")) {
                return this.findFont(fontNamePrefix + " Bold Italic");
            }
            else if (bold && Font.__fontByName.has(fontNamePrefix + " Bold")) {
                return this.findFont(fontNamePrefix + " Bold");
            }
            else if (italic && Font.__fontByName.has(fontNamePrefix + " Italic")) {
                return this.findFont(fontNamePrefix + " Italic");
            }
            return this.findFont(fontName);
        }
        getBounds() {
            var padding = this.border ? 1 : 0;
            this.bounds.width = this.width + padding;
            this.bounds.height = this.height + padding;
            var x = this.width, y = this.width;
            for (let group of this.layoutGroups) {
                if (group.offsetX < x)
                    x = group.offsetX;
                if (group.offsetY < y)
                    y = group.offsetY;
            }
            if (x >= this.width)
                x = TextEngine.GUTTER;
            if (y >= this.height)
                y = TextEngine.GUTTER;
            var textHeight = textHeight * 1.185; // measurement isn't always accurate, add padding
            this.textBounds.setTo(Math.max(x - TextEngine.GUTTER, 0), Math.max(y - TextEngine.GUTTER, 0), Math.min(this.textWidth + TextEngine.GUTTER * 2, this.bounds.width + TextEngine.GUTTER * 2), Math.min(textHeight + TextEngine.GUTTER * 2, this.bounds.height + TextEngine.GUTTER * 2));
        }
        static getFormatHeight(format) {
            var ascent, descent, leading;
            this.__context.font = this.getFont(format);
            var font = this.getFontInstance(format);
            if (format.__ascent != null) {
                ascent = format.size * format.__ascent;
                descent = format.size * format.__descent;
            }
            else if (font != null && font.unitsPerEM != 0) {
                ascent = (font.ascender / font.unitsPerEM) * format.size;
                descent = Math.abs((font.descender / font.unitsPerEM) * format.size);
            }
            else {
                ascent = format.size;
                descent = format.size * 0.185;
            }
            leading = format.leading;
            return ascent + descent + leading;
        }
        static getFont(format) {
            var fontName = format.font;
            var bold = format.bold;
            var italic = format.italic;
            if (fontName == null)
                fontName = "_serif";
            var fontNamePrefix = fontName.replace(" Normal", "").replace(" Regular", "");
            if (bold && italic && Font.__fontByName.has(fontNamePrefix + " Bold Italic")) {
                fontName = fontNamePrefix + " Bold Italic";
                bold = false;
                italic = false;
            }
            else if (bold && Font.__fontByName.has(fontNamePrefix + " Bold")) {
                fontName = fontNamePrefix + " Bold";
                bold = false;
            }
            else if (italic && Font.__fontByName.has(fontNamePrefix + " Italic")) {
                fontName = fontNamePrefix + " Italic";
                italic = false;
            }
            else {
                // Prevent "extra" bold and italic fonts
                if (bold && (fontName.indexOf(" Bold ") > -1 || fontName.endsWith(" Bold"))) {
                    bold = false;
                }
                if (italic && (fontName.indexOf(" Italic ") > -1 || fontName.endsWith(" Italic"))) {
                    italic = false;
                }
            }
            var font = italic ? "italic " : "normal ";
            font += "normal ";
            font += bold ? "bold " : "normal ";
            font += format.size + "px";
            font += "/" + (format.leading + format.size + 3) + "px ";
            switch (fontName) {
                case "_sans":
                    font += "sans-serif";
                    break;
                case "_serif":
                    font += "serif";
                    break;
                case "_typewriter":
                    font += "monospace";
                    break;
                default:
                    font += "'" + fontName.replace(/^[\s'"]+(.*)[\s'"]+$/, '$1') + "'";
                    break;
            }
            return font;
        }
        static getFontInstance(format) {
            return this.findFontVariant(format);
        }
        getLine(index) {
            if (index < 0 || index > this.lineBreaks.length + 1) {
                return null;
            }
            if (this.lineBreaks.length == 0) {
                return this.text;
            }
            else {
                return this.text.substring(index > 0 ? this.lineBreaks[index - 1] : 0, this.lineBreaks[index]);
            }
        }
        getLineBreakIndex(startIndex = 0) {
            var cr = this.text.indexOf("\n", startIndex);
            var lf = this.text.indexOf("\r", startIndex);
            if (cr == -1)
                return lf;
            if (lf == -1)
                return cr;
            return cr < lf ? cr : lf;
        }
        getLineMeasurements() {
            this.lineAscents.length = 0;
            this.lineDescents.length = 0;
            this.lineLeadings.length = 0;
            this.lineHeights.length = 0;
            this.lineWidths.length = 0;
            var currentLineAscent = 0.0;
            var currentLineDescent = 0.0;
            var currentLineLeading = null;
            var currentLineHeight = 0.0;
            var currentLineWidth = 0.0;
            var currentTextHeight = 0.0;
            this.textWidth = 0;
            this.textHeight = 0;
            this.__numLines = 1;
            this.__maxScrollH = 0;
            for (let group of this.layoutGroups) {
                while (group.lineIndex > this.numLines - 1) {
                    this.lineAscents.push(currentLineAscent);
                    this.lineDescents.push(currentLineDescent);
                    this.lineLeadings.push(currentLineLeading != null ? currentLineLeading : 0);
                    this.lineHeights.push(currentLineHeight);
                    this.lineWidths.push(currentLineWidth);
                    currentLineAscent = 0;
                    currentLineDescent = 0;
                    currentLineLeading = null;
                    currentLineHeight = 0;
                    currentLineWidth = 0;
                    this.__numLines++;
                }
                currentLineAscent = Math.max(currentLineAscent, group.ascent);
                currentLineDescent = Math.max(currentLineDescent, group.descent);
                if (currentLineLeading == null) {
                    currentLineLeading = group.leading;
                }
                else {
                    currentLineLeading = Math.max(currentLineLeading, group.leading);
                }
                currentLineHeight = Math.max(currentLineHeight, group.height);
                currentLineWidth = Math.max(currentLineWidth, group.offsetX - TextEngine.GUTTER + group.width);
                // TODO: confirm whether textWidth ignores margins, indents, etc or not
                // currently they are not ignored, and setTextAlignment() happens to work due to this (gut feeling is that it does ignore them)
                if (currentLineWidth > this.textWidth) {
                    this.textWidth = currentLineWidth;
                }
                currentTextHeight = group.offsetY - TextEngine.GUTTER + group.ascent + group.descent;
                if (currentTextHeight > this.textHeight) {
                    this.textHeight = currentTextHeight;
                }
            }
            if (this.textHeight == 0 && this.textField != null && this.textField.type == TextFieldType$1.INPUT) {
                var currentFormat = this.textField.__textFormat;
                var ascent, descent, leading;
                var font = TextEngine.getFontInstance(currentFormat);
                if (currentFormat.__ascent != null) {
                    ascent = currentFormat.size * currentFormat.__ascent;
                    descent = currentFormat.size * currentFormat.__descent;
                }
                else if (font != null && font.unitsPerEM != 0) {
                    ascent = (font.ascender / font.unitsPerEM) * currentFormat.size;
                    descent = Math.abs((font.descender / font.unitsPerEM) * currentFormat.size);
                }
                else {
                    ascent = currentFormat.size;
                    descent = currentFormat.size * 0.185;
                }
                leading = currentFormat.leading;
                currentLineAscent = ascent;
                currentLineDescent = descent;
                currentLineLeading = leading;
                // TODO : numbereger line heights/text heights
                currentTextHeight = ascent + descent;
                this.textHeight = currentTextHeight;
            }
            this.lineAscents.push(currentLineAscent);
            this.lineDescents.push(currentLineDescent);
            this.lineLeadings.push(currentLineLeading != null ? currentLineLeading : 0);
            this.lineHeights.push(currentLineHeight);
            this.lineWidths.push(currentLineWidth);
            if (this.numLines == 1) {
                if (currentLineLeading > 0) {
                    this.textHeight += currentLineLeading;
                }
            }
            if (this.layoutGroups.length > 0) {
                var group = this.layoutGroups[this.layoutGroups.length - 1];
                if (group != null && group.startIndex == group.endIndex) {
                    this.textHeight -= currentLineHeight;
                }
            }
            if (this.autoSize != TextFieldAutoSize$1.NONE) {
                switch (this.autoSize) {
                    case TextFieldAutoSize$1.LEFT:
                    case TextFieldAutoSize$1.RIGHT:
                    case TextFieldAutoSize$1.CENTER:
                        if (!this.wordWrap /*&& (width < textWidth + GUTTER * 2)*/) {
                            this.width = this.textWidth + TextEngine.GUTTER * 2;
                        }
                        this.height = this.textHeight + TextEngine.GUTTER * 2;
                        // bottomScrollV = numLines;
                        break;
                }
            }
            // TODO: see if margins and stuff affect this
            if (this.textWidth > this.width - TextEngine.GUTTER * 2) {
                this.__maxScrollH = Math.floor(this.textWidth - this.width + TextEngine.GUTTER * 2);
            }
            else {
                this.__maxScrollH = 0;
            }
            if (this.scrollH > this.maxScrollH)
                this.scrollH = this.maxScrollH;
            this.updateScrollV();
        }
        getLayoutGroups() {
            this.layoutGroups.length = 0;
            if (this.text == null || this.text == "")
                return;
            let rangeIndex = -1;
            let formatRange = null;
            let font = null;
            let currentFormat = TextField.__defaultTextFormat.clone();
            // line metrics
            let leading = 0; // TODO: is maxLeading needed, just like with ascent? In case multiple formats in the same line have different leading values
            let ascent = 0.0, maxAscent = 0.0;
            let descent = 0.0;
            // paragraph metrics
            let align = null;
            align = TextFormatAlign$1.LEFT;
            let blockIndent = 0;
            let indent = 0;
            let leftMargin = 0;
            let rightMargin = 0;
            let firstLineOfParagraph = true;
            let layoutGroup = null, positions = null;
            let widthValue = 0.0, heightValue = 0, maxHeightValue = 0;
            let previousSpaceIndex = -2; // -1 equals not found, -2 saves extra comparison in `breakIndex == previousSpaceIndex`
            let previousBreakIndex = -1;
            let spaceIndex = this.text.indexOf(" ");
            let breakIndex = this.getLineBreakIndex();
            let offsetX = 0.0;
            let offsetY = 0.0;
            let textIndex = 0;
            let lineIndex = 0;
            var getPositions = (text, startIndex, endIndex) => {
                // TODO: optimize
                var positions = [];
                var letterSpacing = 0.0;
                if (formatRange.format.letterSpacing != null) {
                    letterSpacing = formatRange.format.letterSpacing;
                }
                if (this.__useIntAdvances == null) {
                    this.__useIntAdvances = /Trident\/7.0/.test(navigator.userAgent); // IE
                }
                if (this.__useIntAdvances) {
                    // slower, but more accurate if browser returns Int measurements
                    var previousWidth = 0.0;
                    var width;
                    for (let i = startIndex; i < endIndex; i++) {
                        width = TextEngine.__context.measureText(text.substring(startIndex, i + 1)).width;
                        // if (i > 0) width += letterSpacing;
                        positions.push(width - previousWidth);
                        previousWidth = width;
                    }
                }
                else {
                    for (let i = startIndex; i < endIndex; i++) {
                        var advance;
                        if (i < this.text.length - 1) {
                            // Advance can be less for certain letter combinations, e.g. 'Yo' vs. 'Do'
                            var nextWidth = TextEngine.__context.measureText(text.charAt(i + 1)).width;
                            var twoWidths = TextEngine.__context.measureText(text.substr(i, 2)).width;
                            advance = twoWidths - nextWidth;
                        }
                        else {
                            advance = TextEngine.__context.measureText(text.charAt(i)).width;
                        }
                        // if (i > 0) advance += letterSpacing;
                        positions.push(advance);
                    }
                }
                return positions;
            };
            var getPositionsWidth = (positions) => {
                var width = 0.0;
                for (let position of positions) {
                    width += position;
                }
                return width;
            };
            var getBaseX = () => {
                // TODO: swap margins in RTL
                return TextEngine.GUTTER + leftMargin + blockIndent + (firstLineOfParagraph ? indent : 0);
            };
            var getWrapWidth = () => {
                // TODO: swap margins in RTL
                return this.width - TextEngine.GUTTER - rightMargin - getBaseX();
            };
            var nextLayoutGroup = (startIndex, endIndex) => {
                if (layoutGroup == null || layoutGroup.startIndex != layoutGroup.endIndex) {
                    layoutGroup = new TextLayoutGroup(formatRange.format, startIndex, endIndex);
                    this.layoutGroups.push(layoutGroup);
                }
                else {
                    layoutGroup.format = formatRange.format;
                    layoutGroup.startIndex = startIndex;
                    layoutGroup.endIndex = endIndex;
                }
            };
            var setLineMetrics = () => {
                if (currentFormat.__ascent != null) {
                    ascent = currentFormat.size * currentFormat.__ascent;
                    descent = currentFormat.size * currentFormat.__descent;
                }
                else if (font != null && font.unitsPerEM != 0) {
                    ascent = (font.ascender / font.unitsPerEM) * currentFormat.size;
                    descent = Math.abs((font.descender / font.unitsPerEM) * currentFormat.size);
                }
                else {
                    ascent = currentFormat.size;
                    descent = currentFormat.size * 0.185;
                }
                leading = currentFormat.leading;
                heightValue = Math.ceil(ascent + descent + leading);
                if (heightValue > maxHeightValue) {
                    maxHeightValue = heightValue;
                }
                if (ascent > maxAscent) {
                    maxAscent = ascent;
                }
            };
            var setParagraphMetrics = () => {
                firstLineOfParagraph = true;
                align = currentFormat.align != null ? currentFormat.align : TextFormatAlign$1.LEFT;
                blockIndent = currentFormat.blockIndent != null ? currentFormat.blockIndent : 0;
                if (currentFormat.bullet != null) ;
                indent = currentFormat.indent != null ? currentFormat.indent : 0;
                leftMargin = currentFormat.leftMargin != null ? currentFormat.leftMargin : 0;
                rightMargin = currentFormat.rightMargin != null ? currentFormat.rightMargin : 0;
                if (currentFormat.tabStops != null) ;
            };
            var nextFormatRange = () => {
                if (rangeIndex < this.textFormatRanges.length - 1) {
                    rangeIndex++;
                    formatRange = this.textFormatRanges[rangeIndex];
                    currentFormat.__merge(formatRange.format);
                    TextEngine.__context.font = TextEngine.getFont(currentFormat);
                    font = TextEngine.getFontInstance(currentFormat);
                    return true;
                }
                return false;
            };
            var setFormattedPositions = (startIndex, endIndex) => {
                // sets the positions of the text from start to end, including format changes if there are any
                if (startIndex >= endIndex) {
                    positions = [];
                    widthValue = 0;
                }
                else if (endIndex <= formatRange.end) {
                    positions = getPositions(this.text, startIndex, endIndex);
                    widthValue = getPositionsWidth(positions);
                }
                else {
                    var tempIndex = startIndex;
                    var tempRangeEnd = formatRange.end;
                    var countRanges = 0;
                    positions = [];
                    widthValue = 0;
                    while (true) {
                        if (tempIndex != tempRangeEnd) {
                            var tempPositions = getPositions(this.text, tempIndex, tempRangeEnd);
                            positions = positions.concat(tempPositions);
                        }
                        if (tempRangeEnd != endIndex) {
                            if (!nextFormatRange()) {
                                console.warn("You found a bug in OpenFL's text code! Please save a copy of your project and contact Joshua Granick (@singmajesty) so we can fix this.");
                                break;
                            }
                            tempIndex = tempRangeEnd;
                            tempRangeEnd = endIndex < formatRange.end ? endIndex : formatRange.end;
                            countRanges++;
                        }
                        else {
                            widthValue = getPositionsWidth(positions);
                            break;
                        }
                    }
                    rangeIndex -= countRanges + 1;
                    nextFormatRange(); // get back to the formatRange and font
                }
            };
            var placeFormattedText = (endIndex) => {
                if (endIndex <= formatRange.end) {
                    // don't worry about placing multiple formats if a space or break happens first
                    positions = getPositions(this.text, textIndex, endIndex);
                    widthValue = getPositionsWidth(positions);
                    nextLayoutGroup(textIndex, endIndex);
                    layoutGroup.positions = positions;
                    layoutGroup.offsetX = offsetX + getBaseX();
                    layoutGroup.ascent = ascent;
                    layoutGroup.descent = descent;
                    layoutGroup.leading = leading;
                    layoutGroup.lineIndex = lineIndex;
                    layoutGroup.offsetY = offsetY + TextEngine.GUTTER;
                    layoutGroup.width = widthValue;
                    layoutGroup.height = heightValue;
                    offsetX += widthValue;
                    if (endIndex == formatRange.end) {
                        layoutGroup = null;
                        nextFormatRange();
                        setLineMetrics();
                    }
                }
                else {
                    // fill in all text from start to end, including any format changes
                    while (true) {
                        var tempRangeEnd = endIndex < formatRange.end ? endIndex : formatRange.end;
                        if (textIndex != tempRangeEnd) {
                            positions = getPositions(this.text, textIndex, tempRangeEnd);
                            widthValue = getPositionsWidth(positions);
                            nextLayoutGroup(textIndex, tempRangeEnd);
                            layoutGroup.positions = positions;
                            layoutGroup.offsetX = offsetX + getBaseX();
                            layoutGroup.ascent = ascent;
                            layoutGroup.descent = descent;
                            layoutGroup.leading = leading;
                            layoutGroup.lineIndex = lineIndex;
                            layoutGroup.offsetY = offsetY + TextEngine.GUTTER;
                            layoutGroup.width = widthValue;
                            layoutGroup.height = heightValue;
                            offsetX += widthValue;
                            textIndex = tempRangeEnd;
                        }
                        if (tempRangeEnd == formatRange.end)
                            layoutGroup = null;
                        if (tempRangeEnd == endIndex)
                            break;
                        if (!nextFormatRange()) {
                            console.warn("You found a bug in OpenFL's text code! Please save a copy of your project and contact Joshua Granick (@singmajesty) so we can fix this.");
                            break;
                        }
                        setLineMetrics();
                    }
                }
                textIndex = endIndex;
            };
            var alignBaseline = () => {
                // aligns the baselines of all characters in a single line
                setLineMetrics();
                var i = this.layoutGroups.length;
                while (--i > -1) {
                    var lg = this.layoutGroups[i];
                    if (lg.lineIndex < lineIndex)
                        break;
                    if (lg.lineIndex > lineIndex)
                        continue;
                    lg.ascent = maxAscent;
                    lg.height = maxHeightValue;
                }
                offsetY += maxHeightValue;
                maxAscent = 0.0;
                maxHeightValue = 0;
                ++lineIndex;
                offsetX = 0;
                firstLineOfParagraph = false; // TODO: need to thoroughly test this
            };
            var breakLongWords = (endIndex) => {
                // breaks up words that are too long to fit in a single line
                var remainingPositions = positions;
                var i, bufferCount, placeIndex, positionWidth;
                var currentPosition;
                var tempWidth = getPositionsWidth(remainingPositions);
                while (remainingPositions.length > 0 && offsetX + tempWidth > getWrapWidth()) {
                    i = bufferCount = 0;
                    positionWidth = 0.0;
                    while (offsetX + positionWidth < getWrapWidth()) {
                        currentPosition = remainingPositions[i];
                        if (currentPosition == 0.0) {
                            // skip Unicode character buffer positions
                            i++;
                            bufferCount++;
                        }
                        else {
                            positionWidth += currentPosition;
                            i++;
                        }
                    }
                    // if there's no room to put even a single character, automatically wrap the next character
                    if (i == bufferCount) {
                        i = bufferCount + 1;
                    }
                    else {
                        // remove characters until the text fits one line
                        // because of combining letters potentially being broken up now, we have to redo the formatted positions each time
                        // TODO: this may not work exactly with Unicode buffer characters...
                        // TODO: maybe assume no combining letters, then compare result to i+1 and i-1 results?
                        while (i > 1 && offsetX + positionWidth > getWrapWidth()) {
                            i--;
                            if (i - bufferCount > 0) {
                                setFormattedPositions(textIndex, textIndex + i - bufferCount);
                                positionWidth = widthValue;
                            }
                            else {
                                // TODO: does this run anymore?
                                i = 1;
                                bufferCount = 0;
                                setFormattedPositions(textIndex, textIndex + 1);
                                positionWidth = 0; // breaks out of the loops
                            }
                        }
                    }
                    placeIndex = textIndex + i - bufferCount;
                    placeFormattedText(placeIndex);
                    alignBaseline();
                    setFormattedPositions(placeIndex, endIndex);
                    remainingPositions = positions;
                    tempWidth = widthValue;
                }
                // positions only contains the final unbroken line at the end
            };
            var placeText = (endIndex) => {
                if (this.width >= TextEngine.GUTTER * 2 && this.wordWrap) {
                    breakLongWords(endIndex);
                }
                placeFormattedText(endIndex);
            };
            nextFormatRange();
            setParagraphMetrics();
            setLineMetrics();
            var wrap;
            var maxLoops = this.text.length + 1;
            // Do an extra iteration to ensure a LayoutGroup is created in case the last line is empty (trailing line break).
            while (textIndex < maxLoops) {
                if ((breakIndex > -1) && (spaceIndex == -1 || breakIndex < spaceIndex)) {
                    // if a line break is the next thing that needs to be dealt with
                    // TODO: when is this condition ever false?
                    if (textIndex <= breakIndex) {
                        setFormattedPositions(textIndex, breakIndex);
                        placeText(breakIndex);
                        layoutGroup = null;
                    }
                    else if (layoutGroup != null && layoutGroup.startIndex != layoutGroup.endIndex) {
                        // Trim the last space from the line width, for correct TextFormatAlign.RIGHT alignment
                        if (layoutGroup.endIndex == spaceIndex) {
                            layoutGroup.width -= layoutGroup.getAdvance(layoutGroup.positions.length - 1);
                        }
                        layoutGroup = null;
                    }
                    alignBaseline();
                    // TODO: is this necessary or already handled by placeText above?
                    // TODO: what happens if the \n is formatted differently from the previous and next text?
                    if (formatRange.end == breakIndex || formatRange.end == breakIndex + 1) {
                        nextFormatRange();
                        setLineMetrics();
                    }
                    textIndex = breakIndex + 1;
                    previousBreakIndex = breakIndex;
                    breakIndex = this.getLineBreakIndex(textIndex);
                    setParagraphMetrics();
                }
                else if (spaceIndex > -1) {
                    // if a space is the next thing that needs to be dealt with
                    if (layoutGroup != null && layoutGroup.startIndex != layoutGroup.endIndex) {
                        layoutGroup = null;
                    }
                    wrap = false;
                    while (true) {
                        if (textIndex >= this.text.length)
                            break;
                        var endIndex = -1;
                        if (spaceIndex == -1) {
                            endIndex = breakIndex;
                        }
                        else {
                            endIndex = spaceIndex + 1;
                            if (breakIndex > -1 && breakIndex < endIndex) {
                                endIndex = breakIndex;
                            }
                        }
                        if (endIndex == -1) {
                            endIndex = this.text.length;
                        }
                        setFormattedPositions(textIndex, endIndex);
                        if (align == TextFormatAlign$1.JUSTIFY) {
                            if (positions.length > 0 && textIndex == previousSpaceIndex) {
                                // Trim left space of this word
                                textIndex++;
                                var spaceWidth = positions.shift();
                                widthValue -= spaceWidth;
                                offsetX += spaceWidth;
                            }
                            if (positions.length > 0 && endIndex == spaceIndex + 1) {
                                // Trim right space of this word
                                endIndex--;
                                var spaceWidth = positions.pop();
                                widthValue -= spaceWidth;
                            }
                        }
                        if (this.wordWrap) {
                            if (offsetX + widthValue > getWrapWidth()) {
                                wrap = true;
                                if (positions.length > 0 && endIndex == spaceIndex + 1) {
                                    // if last letter is a space, avoid word wrap if possible
                                    // TODO: Handle multiple spaces
                                    var lastPosition = positions[positions.length - 1];
                                    var spaceWidth = lastPosition;
                                    if (offsetX + widthValue - spaceWidth <= getWrapWidth()) {
                                        wrap = false;
                                    }
                                }
                            }
                        }
                        if (wrap) {
                            if (align != TextFormatAlign$1.JUSTIFY && (layoutGroup != null || this.layoutGroups.length > 0)) {
                                var previous = layoutGroup;
                                if (previous == null) {
                                    previous = this.layoutGroups[this.layoutGroups.length - 1];
                                }
                                // For correct selection rectangles and alignment, trim the trailing space of the previous line:
                                previous.width -= previous.getAdvance(previous.positions.length - 1);
                                previous.endIndex--;
                            }
                            var i = this.layoutGroups.length - 1;
                            var offsetCount = 0;
                            while (true) {
                                layoutGroup = this.layoutGroups[i];
                                if (i > 0 && layoutGroup.startIndex > previousSpaceIndex) {
                                    offsetCount++;
                                }
                                else {
                                    break;
                                }
                                i--;
                            }
                            if (textIndex == previousSpaceIndex + 1) {
                                alignBaseline();
                            }
                            offsetX = 0;
                            if (offsetCount > 0) {
                                var bumpX = this.layoutGroups[this.layoutGroups.length - offsetCount].offsetX;
                                for (let i = (this.layoutGroups.length - offsetCount); i < this.layoutGroups.length; i++) {
                                    layoutGroup = this.layoutGroups[i];
                                    layoutGroup.offsetX -= bumpX;
                                    layoutGroup.offsetY = offsetY + TextEngine.GUTTER;
                                    layoutGroup.lineIndex = lineIndex;
                                    offsetX += layoutGroup.width;
                                }
                            }
                            placeText(endIndex);
                            wrap = false;
                        }
                        else {
                            if (layoutGroup != null && textIndex == spaceIndex) {
                                // TODO: does this case ever happen?
                                if (align != TextFormatAlign$1.JUSTIFY) {
                                    layoutGroup.endIndex = spaceIndex;
                                    layoutGroup.positions = layoutGroup.positions.concat(positions);
                                    layoutGroup.width += widthValue;
                                }
                                offsetX += widthValue;
                                textIndex = endIndex;
                            }
                            else if (layoutGroup == null || align == TextFormatAlign$1.JUSTIFY) {
                                placeText(endIndex);
                            }
                            else {
                                var tempRangeEnd = endIndex < formatRange.end ? endIndex : formatRange.end;
                                if (tempRangeEnd < endIndex) {
                                    positions = getPositions(this.text, textIndex, tempRangeEnd);
                                    widthValue = getPositionsWidth(positions);
                                }
                                layoutGroup.endIndex = tempRangeEnd;
                                layoutGroup.positions = layoutGroup.positions.concat(positions);
                                layoutGroup.width += widthValue;
                                offsetX += widthValue;
                                if (tempRangeEnd == formatRange.end) {
                                    layoutGroup = null;
                                    nextFormatRange();
                                    setLineMetrics();
                                    textIndex = tempRangeEnd;
                                    if (tempRangeEnd != endIndex) {
                                        placeFormattedText(endIndex);
                                    }
                                }
                                // If next char is newline, process it immediately and prevent useless extra layout groups
                                // TODO: is this needed?
                                if (breakIndex == endIndex)
                                    endIndex++;
                                textIndex = endIndex;
                                if (endIndex == this.text.length)
                                    alignBaseline();
                            }
                        }
                        var nextSpaceIndex = this.text.indexOf(" ", textIndex);
                        // Check if we can continue wrapping this line until the next line-break or end-of-String.
                        // When `previousSpaceIndex == breakIndex`, the loop has finished growing layoutGroup.endIndex until the end of this line.
                        if (breakIndex == previousSpaceIndex) {
                            layoutGroup.endIndex = breakIndex;
                            if (breakIndex - layoutGroup.startIndex - layoutGroup.positions.length < 0) {
                                // Newline has no size
                                layoutGroup.positions.push(0.0);
                            }
                            textIndex = breakIndex + 1;
                        }
                        previousSpaceIndex = spaceIndex;
                        spaceIndex = nextSpaceIndex;
                        if ((breakIndex > -1 && breakIndex <= textIndex && (spaceIndex > breakIndex || spaceIndex == -1))
                            || textIndex > this.text.length) {
                            break;
                        }
                    }
                }
                else {
                    if (textIndex < this.text.length) {
                        // if there are no line breaks or spaces to deal with next, place all remaining text
                        setFormattedPositions(textIndex, this.text.length);
                        placeText(this.text.length);
                        alignBaseline();
                    }
                    textIndex++;
                }
            }
            // if final char is a line break, create an empty layoutGroup for it
            if (previousBreakIndex == textIndex - 2 && previousBreakIndex > -1) {
                nextLayoutGroup(textIndex, textIndex);
                layoutGroup.positions = [];
                layoutGroup.ascent = ascent;
                layoutGroup.descent = descent;
                layoutGroup.leading = leading;
                layoutGroup.lineIndex = lineIndex - 1;
                layoutGroup.offsetX = getBaseX(); // TODO: double check it doesn't default to GUTTER or something
                layoutGroup.offsetY = offsetY + TextEngine.GUTTER;
                layoutGroup.width = 0;
                layoutGroup.height = heightValue;
            }
            // 		#if openfl_trace_text_layout_groups
            // for (lg in layoutGroups)
            // {
            // 	Log.info('LG ${lg.positions.length - (lg.endIndex - lg.startIndex)},line:${lg.lineIndex},w:${lg.width},h:${lg.height},x:${Std.int(lg.offsetX)},y:${Std.int(lg.offsetY)},"${text.substring(lg.startIndex, lg.endIndex)}",${lg.startIndex},${lg.endIndex}');
            // }
            // 		#end
        }
        restrictText(value) {
            if (value == null) {
                return value;
            }
            if (this.__restrictRegexp != null) {
                value = value.split(this.__restrictRegexp).join("");
            }
            // if (maxChars > 0 && value.length > maxChars) {
            // 	value = value.substr (0, maxChars);
            // }
            return value;
        }
        setTextAlignment() {
            var lineIndex = -1;
            var offsetX = 0.0;
            var totalWidth = this.width - TextEngine.GUTTER * 2; // TODO: do margins and stuff affect this at all?
            var group, lineLength;
            var lineMeasurementsDirty = false;
            for (let i = 0; i < this.layoutGroups.length; i++) {
                group = this.layoutGroups[i];
                if (group.lineIndex != lineIndex) {
                    lineIndex = group.lineIndex;
                    totalWidth = this.width - TextEngine.GUTTER * 2 - group.format.rightMargin;
                    switch (group.format.align) {
                        case TextFormatAlign$1.CENTER:
                            if (this.lineWidths[lineIndex] < totalWidth) {
                                offsetX = Math.round((totalWidth - this.lineWidths[lineIndex]) / 2);
                            }
                            else {
                                offsetX = 0;
                            }
                        case TextFormatAlign$1.RIGHT:
                            if (this.lineWidths[lineIndex] < totalWidth) {
                                offsetX = Math.round(totalWidth - this.lineWidths[lineIndex]);
                            }
                            else {
                                offsetX = 0;
                            }
                        case TextFormatAlign$1.JUSTIFY:
                            if (this.lineWidths[lineIndex] < totalWidth) {
                                lineLength = 1;
                                for (let j = (i + 1); i < this.layoutGroups.length; i++) {
                                    if (this.layoutGroups[j].lineIndex == lineIndex) {
                                        if (j == 0 || this.text.charCodeAt(this.layoutGroups[j].startIndex - 1) == " ".charCodeAt(0)) {
                                            lineLength++;
                                        }
                                    }
                                    else {
                                        break;
                                    }
                                }
                                if (lineLength > 1) {
                                    group = this.layoutGroups[i + lineLength - 1];
                                    var endChar = this.text.charCodeAt(group.endIndex);
                                    if (group.endIndex < this.text.length && endChar != "\n".charCodeAt(0) && endChar != "\r".charCodeAt(0)) {
                                        offsetX = (totalWidth - this.lineWidths[lineIndex]) / (lineLength - 1);
                                        lineMeasurementsDirty = true;
                                        var j = 1;
                                        do {
                                            // if (text.charCodeAt (this.layoutGroups[j].startIndex - 1) != " ".code) {
                                            // 	layoutGroups[i + j].offsetX += (offsetX * (j-1));
                                            // 	j++;
                                            // }
                                            this.layoutGroups[i + j].offsetX += (offsetX * j);
                                        } while (++j < lineLength);
                                    }
                                }
                            }
                            offsetX = 0;
                        default:
                            offsetX = 0;
                    }
                }
                if (offsetX > 0) {
                    group.offsetX += offsetX;
                }
            }
            if (lineMeasurementsDirty) {
                // TODO: Better way to fix justify textWidth?
                this.getLineMeasurements();
            }
        }
        trimText(value) {
            if (value == null) {
                return value;
            }
            if (this.maxChars > 0 && value.length > this.maxChars) {
                value = value.substr(0, this.maxChars);
            }
            return value;
        }
        update() {
            if (this.text == null /*|| text == ""*/ || this.textFormatRanges.length == 0) {
                this.lineAscents.length = 0;
                this.lineBreaks.length = 0;
                this.lineDescents.length = 0;
                this.lineLeadings.length = 0;
                this.lineHeights.length = 0;
                this.lineWidths.length = 0;
                this.layoutGroups.length = 0;
                this.textWidth = 0;
                this.textHeight = 0;
                this.__numLines = 1;
                this.__maxScrollH = 0;
                // maxScrollV = 1;
                // bottomScrollV = 1;
                this.updateScrollV();
            }
            else {
                this.getLayoutGroups();
                this.getLineMeasurements();
                this.setTextAlignment();
            }
            this.getBounds();
        }
        updateScrollV() {
            if (this.numLines == 1 || this.lineHeights == null) {
                this.__maxScrollV = 1;
            }
            else {
                var i = this.numLines - 1, tempHeight = 0.0;
                var j = i;
                while (i >= 0) {
                    if (tempHeight + this.lineHeights[i] <= Math.ceil(this.height - TextEngine.GUTTER * 2)) {
                        tempHeight += this.lineHeights[i];
                        i--;
                    }
                    else {
                        break;
                    }
                }
                if (i == j) {
                    i = this.numLines; // maxScrollV defaults to numLines if the height - 4 is less than the line's height
                    // TODO: check if it's based on the first or last line's height
                }
                else {
                    i += 2;
                }
                if (i < 1) {
                    this.__maxScrollV = 1;
                }
                else {
                    this.__maxScrollV = i;
                }
            }
            if (this.numLines == 1 || this.lineHeights == null) {
                this.__bottomScrollV = 1;
            }
            else {
                var tempHeight = 0.0;
                var ret = this.__scrollV;
                while (ret <= this.lineHeights.length) {
                    if (tempHeight + this.lineHeights[ret - 1] <= Math.ceil(this.height - TextEngine.GUTTER)) {
                        tempHeight += this.lineHeights[ret - 1];
                    }
                    else {
                        break;
                    }
                    ret++;
                }
                this.__bottomScrollV = ret - 1;
            }
        }
        // Get & Set Methods
        get bottomScrollV() {
            return this.__bottomScrollV;
        }
        get maxScrollH() {
            return this.__maxScrollH;
        }
        get maxScrollV() {
            return this.__maxScrollV;
        }
        get numLines() {
            return this.__numLines;
        }
        get restrict() {
            return this.__restrict;
        }
        set restrict(value) {
            if (this.__restrict == value) {
                return;
            }
            this.__restrict = value;
            if (this.__restrict == null || this.__restrict.length == 0) {
                this.__restrictRegexp = null;
            }
            else {
                this.__restrictRegexp = this.createRestrictRegexp(value);
            }
        }
        get scrollV() {
            if (this.__numLines == 1 || this.lineHeights == null)
                return 1;
            var max = this.__maxScrollV;
            if (this.__scrollV > max)
                return max;
            return this.__scrollV;
        }
        set scrollV(value) {
            if (value < 1)
                value = 1;
            this.__scrollV = value;
            // TODO: Cheaper way to update bottomScrollV?
            this.updateScrollV();
        }
        get text() {
            return this.__text;
        }
        set text(value) {
            this.__text = value;
        }
    }
    TextEngine.UTF8_TAB = 9;
    TextEngine.UTF8_ENDLINE = 10;
    TextEngine.UTF8_SPACE = 32;
    TextEngine.UTF8_HYPHEN = 0x2D;
    TextEngine.GUTTER = 2;
    TextEngine.__defaultFonts = new Map();
    return TextEngine;
})();

var DrawCommandType;
(function (DrawCommandType) {
    DrawCommandType[DrawCommandType["BEGIN_BITMAP_FILL"] = 0] = "BEGIN_BITMAP_FILL";
    DrawCommandType[DrawCommandType["BEGIN_FILL"] = 1] = "BEGIN_FILL";
    DrawCommandType[DrawCommandType["BEGIN_GRADIENT_FILL"] = 2] = "BEGIN_GRADIENT_FILL";
    DrawCommandType[DrawCommandType["BEGIN_SHADER_FILL"] = 3] = "BEGIN_SHADER_FILL";
    DrawCommandType[DrawCommandType["CUBIC_CURVE_TO"] = 4] = "CUBIC_CURVE_TO";
    DrawCommandType[DrawCommandType["CURVE_TO"] = 5] = "CURVE_TO";
    DrawCommandType[DrawCommandType["DRAW_CIRCLE"] = 6] = "DRAW_CIRCLE";
    DrawCommandType[DrawCommandType["DRAW_ELLIPSE"] = 7] = "DRAW_ELLIPSE";
    DrawCommandType[DrawCommandType["DRAW_QUADS"] = 8] = "DRAW_QUADS";
    DrawCommandType[DrawCommandType["DRAW_RECT"] = 9] = "DRAW_RECT";
    DrawCommandType[DrawCommandType["DRAW_ROUND_RECT"] = 10] = "DRAW_ROUND_RECT";
    DrawCommandType[DrawCommandType["DRAW_TILES"] = 11] = "DRAW_TILES";
    DrawCommandType[DrawCommandType["DRAW_TRIANGLES"] = 12] = "DRAW_TRIANGLES";
    DrawCommandType[DrawCommandType["END_FILL"] = 13] = "END_FILL";
    DrawCommandType[DrawCommandType["LINE_BITMAP_STYLE"] = 14] = "LINE_BITMAP_STYLE";
    DrawCommandType[DrawCommandType["LINE_GRADIENT_STYLE"] = 15] = "LINE_GRADIENT_STYLE";
    DrawCommandType[DrawCommandType["LINE_STYLE"] = 16] = "LINE_STYLE";
    DrawCommandType[DrawCommandType["LINE_TO"] = 17] = "LINE_TO";
    DrawCommandType[DrawCommandType["MOVE_TO"] = 18] = "MOVE_TO";
    DrawCommandType[DrawCommandType["OVERRIDE_BLEND_MODE"] = 19] = "OVERRIDE_BLEND_MODE";
    DrawCommandType[DrawCommandType["OVERRIDE_MATRIX"] = 20] = "OVERRIDE_MATRIX";
    DrawCommandType[DrawCommandType["WINDING_EVEN_ODD"] = 21] = "WINDING_EVEN_ODD";
    DrawCommandType[DrawCommandType["WINDING_NON_ZERO"] = 22] = "WINDING_NON_ZERO";
    DrawCommandType[DrawCommandType["UNKNOWN"] = 23] = "UNKNOWN";
})(DrawCommandType || (DrawCommandType = {}));
var DrawCommandType$1 = DrawCommandType;

class DrawCommandReader {
    constructor(buffer) {
        this.buffer = buffer;
        this.bPos = this.iPos = this.fPos = this.oPos = this.ffPos = this.iiPos = this.tsPos = 0;
        this.prev = DrawCommandType$1.UNKNOWN;
    }
    advance() {
        switch (this.prev) {
            case DrawCommandType$1.BEGIN_BITMAP_FILL:
                this.oPos += 2; // bitmap, matrix
                this.bPos += 2; // repeat, smooth
                break;
            case DrawCommandType$1.BEGIN_FILL:
                this.iPos += 1; // color
                this.fPos += 1; // alpha
                break;
            case DrawCommandType$1.BEGIN_GRADIENT_FILL:
                this.oPos += 4; // type, matrix, spreadMethod, interpolationMethod
                this.iiPos += 2; // colors, ratios
                this.ffPos += 1; // alphas
                this.fPos += 1; // focalPointRatio
                break;
            case DrawCommandType$1.BEGIN_SHADER_FILL:
                this.oPos += 1; // shaderBuffer
                break;
            case DrawCommandType$1.CUBIC_CURVE_TO:
                this.fPos += 6; // controlX1, controlY1, controlX2, controlY2, anchorX, anchorY
                break;
            case DrawCommandType$1.CURVE_TO:
                this.fPos += 4; // controlX, controlY, anchorX, anchorY
                break;
            case DrawCommandType$1.DRAW_CIRCLE:
                this.fPos += 3; // x, y, radius
                break;
            case DrawCommandType$1.DRAW_ELLIPSE:
                this.fPos += 4; // x, y, width, height
                break;
            case DrawCommandType$1.DRAW_QUADS:
                this.oPos += 3; // rects, indices, transforms
                break;
            case DrawCommandType$1.DRAW_RECT:
                this.fPos += 4; // x, y, width, height
                break;
            case DrawCommandType$1.DRAW_ROUND_RECT:
                this.fPos += 5; // x, y, width, height, ellipseWidth
                this.oPos += 1; // ellipseHeight
                break;
            case DrawCommandType$1.DRAW_TRIANGLES:
                this.oPos += 4; // vertices, indices, uvtData, culling
                break;
            case DrawCommandType$1.END_FILL:
                break;
            // no parameters
            case DrawCommandType$1.LINE_BITMAP_STYLE:
                this.oPos += 2; // bitmap, matrix
                this.bPos += 2; // repeat, smooth
                break;
            case DrawCommandType$1.LINE_GRADIENT_STYLE:
                this.oPos += 4; // type, matrix, spreadMethod, interpolationMethod
                this.iiPos += 2; // colors, ratios
                this.ffPos += 1; // alphas
                this.fPos += 1; // focalPointRatio
                break;
            case DrawCommandType$1.LINE_STYLE:
                this.oPos += 4; // thickness, scaleMode, caps, joints
                this.iPos += 1; // color
                this.fPos += 2; // alpha, miterLimit
                this.bPos += 1; // pixelHinting
                break;
            case DrawCommandType$1.LINE_TO:
                this.fPos += 2; // x, y
                break;
            case DrawCommandType$1.MOVE_TO:
                this.fPos += 2; // x, y
                break;
            case DrawCommandType$1.OVERRIDE_BLEND_MODE:
                this.oPos += 1; // blendMode
                break;
            case DrawCommandType$1.OVERRIDE_MATRIX:
                this.oPos += 1; // matrix
                break;
            case DrawCommandType$1.WINDING_EVEN_ODD:
            case DrawCommandType$1.WINDING_NON_ZERO:
        }
    }
    bool(index) {
        return this.buffer.b[this.bPos + index];
    }
    destroy() {
        this.buffer = null;
        this.reset();
    }
    fArr(index) {
        return this.buffer.ff[this.ffPos + index];
    }
    float(index) {
        return this.buffer.f[this.fPos + index];
    }
    iArr(index) {
        return this.buffer.ii[this.iiPos + index];
    }
    int(index) {
        return this.buffer.i[this.iPos + index];
    }
    obj(index) {
        return this.buffer.o[this.oPos + index];
    }
    readBeginBitmapFill() {
        this.advance();
        this.prev = DrawCommandType$1.BEGIN_BITMAP_FILL;
        return new BeginBitmapFillView(this);
    }
    readBeginFill() {
        this.advance();
        this.prev = DrawCommandType$1.BEGIN_FILL;
        return new BeginFillView(this);
    }
    readBeginGradientFill() {
        this.advance();
        this.prev = DrawCommandType$1.BEGIN_GRADIENT_FILL;
        return new BeginGradientFillView(this);
    }
    readBeginShaderFill() {
        this.advance();
        this.prev = DrawCommandType$1.BEGIN_SHADER_FILL;
        return new BeginShaderFillView(this);
    }
    readCubicCurveTo() {
        this.advance();
        this.prev = DrawCommandType$1.CUBIC_CURVE_TO;
        return new CubicCurveToView(this);
    }
    readCurveTo() {
        this.advance();
        this.prev = DrawCommandType$1.CURVE_TO;
        return new CurveToView(this);
    }
    readDrawCircle() {
        this.advance();
        this.prev = DrawCommandType$1.DRAW_CIRCLE;
        return new DrawCircleView(this);
    }
    readDrawEllipse() {
        this.advance();
        this.prev = DrawCommandType$1.DRAW_ELLIPSE;
        return new DrawEllipseView(this);
    }
    readDrawQuads() {
        this.advance();
        this.prev = DrawCommandType$1.DRAW_QUADS;
        return new DrawQuadsView(this);
    }
    readDrawRect() {
        this.advance();
        this.prev = DrawCommandType$1.DRAW_RECT;
        return new DrawRectView(this);
    }
    readDrawRoundRect() {
        this.advance();
        this.prev = DrawCommandType$1.DRAW_ROUND_RECT;
        return new DrawRoundRectView(this);
    }
    readDrawTriangles() {
        this.advance();
        this.prev = DrawCommandType$1.DRAW_TRIANGLES;
        return new DrawTrianglesView(this);
    }
    readEndFill() {
        this.advance();
        this.prev = DrawCommandType$1.END_FILL;
        return new EndFillView(this);
    }
    readLineBitmapStyle() {
        this.advance();
        this.prev = DrawCommandType$1.LINE_BITMAP_STYLE;
        return new LineBitmapStyleView(this);
    }
    readLineGradientStyle() {
        this.advance();
        this.prev = DrawCommandType$1.LINE_GRADIENT_STYLE;
        return new LineGradientStyleView(this);
    }
    readLineStyle() {
        this.advance();
        this.prev = DrawCommandType$1.LINE_STYLE;
        return new LineStyleView(this);
    }
    readLineTo() {
        this.advance();
        this.prev = DrawCommandType$1.LINE_TO;
        return new LineToView(this);
    }
    readMoveTo() {
        this.advance();
        this.prev = DrawCommandType$1.MOVE_TO;
        return new MoveToView(this);
    }
    readOverrideBlendMode() {
        this.advance();
        this.prev = DrawCommandType$1.OVERRIDE_BLEND_MODE;
        return new OverrideBlendModeView(this);
    }
    readOverrideMatrix() {
        this.advance();
        this.prev = DrawCommandType$1.OVERRIDE_MATRIX;
        return new OverrideMatrixView(this);
    }
    readWindingEvenOdd() {
        this.advance();
        this.prev = DrawCommandType$1.WINDING_EVEN_ODD;
        return new WindingEvenOddView(this);
    }
    readWindingNonZero() {
        this.advance();
        this.prev = DrawCommandType$1.WINDING_NON_ZERO;
        return new WindingNonZeroView(this);
    }
    reset() {
        this.bPos = this.iPos = this.fPos = this.oPos = this.ffPos = this.iiPos = this.tsPos = 0;
    }
    skip(type) {
        this.advance();
        this.prev = type;
    }
}
class BeginBitmapFillView {
    constructor(d) {
        this.bitmap = d.obj(0);
        this.matrix = d.obj(1);
        this.repeat = d.bool(0);
        this.smooth = d.bool(1);
    }
}
class BeginFillView {
    constructor(d) {
        this.color = d.int(0);
        this.alpha = d.float(0);
    }
}
class BeginGradientFillView {
    constructor(d) {
        this.type = d.obj(0);
        this.colors = d.iArr(0);
        this.alphas = d.fArr(0);
        this.ratios = d.iArr(1);
        this.matrix = d.obj(1);
        this.spreadMethod = d.obj(2);
        this.interpolationMethod = d.obj(3);
        this.focalPointRatio = d.float(0);
    }
}
class BeginShaderFillView {
    constructor(d) {
        this.shaderBuffer = d.obj(0);
    }
}
class CubicCurveToView {
    constructor(d) {
        this.controlX1 = d.float(0);
        this.controlY1 = d.float(1);
        this.controlX2 = d.float(2);
        this.controlY2 = d.float(3);
        this.anchorX = d.float(4);
        this.anchorY = d.float(5);
    }
}
class CurveToView {
    constructor(d) {
        this.controlX = d.float(0);
        this.controlY = d.float(1);
        this.anchorX = d.float(2);
        this.anchorY = d.float(3);
    }
}
class DrawCircleView {
    constructor(d) {
        this.x = d.float(0);
        this.y = d.float(1);
        this.radius = d.float(2);
    }
}
class DrawEllipseView {
    constructor(d) {
        this.x = d.float(0);
        this.y = d.float(1);
        this.width = d.float(2);
        this.height = d.float(3);
    }
}
class DrawQuadsView {
    constructor(d) {
        this.rects = d.obj(0);
        this.indices = d.obj(1);
        this.transforms = d.obj(2);
    }
}
class DrawRectView {
    constructor(d) {
        this.x = d.float(0);
        this.y = d.float(1);
        this.width = d.float(2);
        this.height = d.float(3);
    }
}
class DrawRoundRectView {
    constructor(d) {
        this.x = d.float(0);
        this.y = d.float(1);
        this.width = d.float(2);
        this.height = d.float(3);
        this.ellipseWidth = d.float(4);
        this.ellipseHeight = d.obj(0);
    }
}
class DrawTrianglesView {
    constructor(d) {
        this.vertices = d.obj(0);
        this.indices = d.obj(1);
        this.uvtData = d.obj(2);
        this.culling = d.obj(3);
    }
}
class EndFillView {
    constructor(d) {
    }
}
class LineBitmapStyleView {
    constructor(d) {
        this.bitmap = d.obj(0);
        this.matrix = d.obj(1);
        this.repeat = d.bool(0);
        this.smooth = d.bool(1);
    }
}
class LineGradientStyleView {
    constructor(d) {
        this.type = d.obj(0);
        this.colors = d.iArr(0);
        this.alphas = d.fArr(0);
        this.ratios = d.iArr(1);
        this.matrix = d.obj(1);
        this.spreadMethod = d.obj(2);
        this.interpolationMethod = d.obj(3);
        this.focalPointRatio = d.float(0);
    }
}
class LineStyleView {
    constructor(d) {
        this.thickness = d.obj(0);
        this.color = d.int(0);
        this.alpha = d.float(0);
        this.pixelHinting = d.bool(0);
        this.scaleMode = d.obj(1);
        this.caps = d.obj(2);
        this.joints = d.obj(3);
        this.miterLimit = d.float(1);
    }
}
class LineToView {
    constructor(d) {
        this.x = d.float(0);
        this.y = d.float(1);
    }
}
class MoveToView {
    constructor(d) {
        this.x = d.float(0);
        this.y = d.float(1);
    }
}
class OverrideBlendModeView {
    constructor(d) {
        this.blendMode = d.obj(0);
    }
}
class OverrideMatrixView {
    constructor(d) {
        this.matrix = d.obj(0);
    }
}
class WindingEvenOddView {
    constructor(d) {
    }
}
class WindingNonZeroView {
    constructor(d) {
    }
}

let DrawCommandBuffer = /** @class */ (() => {
    class DrawCommandBuffer {
        constructor() {
            if (DrawCommandBuffer.empty == null) {
                this.types = [];
                this.b = [];
                this.i = [];
                this.f = [];
                this.o = [];
                this.ff = [];
                this.ii = [];
                this.copyOnWrite = true;
            }
            else {
                this.clear();
            }
        }
        append(other) {
            if (length == 0) {
                this.types = other.types;
                this.b = other.b;
                this.i = other.i;
                this.f = other.f;
                this.o = other.o;
                this.ff = other.ff;
                this.ii = other.ii;
                this.copyOnWrite = other.copyOnWrite = true;
                return other;
            }
            var data = new DrawCommandReader(other);
            for (let type of other.types) {
                switch (type) {
                    case DrawCommandType$1.BEGIN_BITMAP_FILL:
                        var c = data.readBeginBitmapFill();
                        this.beginBitmapFill(c.bitmap, c.matrix, c.repeat, c.smooth);
                        break;
                    case DrawCommandType$1.BEGIN_FILL:
                        var c2 = data.readBeginFill();
                        this.beginFill(c2.color, c2.alpha);
                        break;
                    case DrawCommandType$1.BEGIN_GRADIENT_FILL:
                        var c3 = data.readBeginGradientFill();
                        this.beginGradientFill(c3.type, c3.colors, c3.alphas, c3.ratios, c3.matrix, c3.spreadMethod, c3.interpolationMethod, c3.focalPointRatio);
                        break;
                    case DrawCommandType$1.BEGIN_SHADER_FILL:
                        var c4 = data.readBeginShaderFill();
                        this.beginShaderFill(c4.shaderBuffer);
                        break;
                    case DrawCommandType$1.CUBIC_CURVE_TO:
                        var c5 = data.readCubicCurveTo();
                        this.cubicCurveTo(c5.controlX1, c5.controlY1, c5.controlX2, c5.controlY2, c5.anchorX, c5.anchorY);
                        break;
                    case DrawCommandType$1.CURVE_TO:
                        var c6 = data.readCurveTo();
                        this.curveTo(c6.controlX, c6.controlY, c6.anchorX, c6.anchorY);
                        break;
                    case DrawCommandType$1.DRAW_CIRCLE:
                        var c7 = data.readDrawCircle();
                        this.drawCircle(c7.x, c7.y, c7.radius);
                        break;
                    case DrawCommandType$1.DRAW_ELLIPSE:
                        var c8 = data.readDrawEllipse();
                        this.drawEllipse(c8.x, c8.y, c8.width, c8.height);
                        break;
                    case DrawCommandType$1.DRAW_QUADS:
                        var c9 = data.readDrawQuads();
                        this.drawQuads(c9.rects, c9.indices, c9.transforms);
                        break;
                    case DrawCommandType$1.DRAW_RECT:
                        var c10 = data.readDrawRect();
                        this.drawRect(c10.x, c10.y, c10.width, c10.height);
                        break;
                    case DrawCommandType$1.DRAW_ROUND_RECT:
                        var c11 = data.readDrawRoundRect();
                        this.drawRoundRect(c11.x, c11.y, c11.width, c11.height, c11.ellipseWidth, c11.ellipseHeight);
                        break;
                    case DrawCommandType$1.DRAW_TRIANGLES:
                        var c12 = data.readDrawTriangles();
                        this.drawTriangles(c12.vertices, c12.indices, c12.uvtData, c12.culling);
                        break;
                    case DrawCommandType$1.END_FILL:
                        var c13 = data.readEndFill();
                        this.endFill();
                        break;
                    case DrawCommandType$1.LINE_BITMAP_STYLE:
                        var c14 = data.readLineBitmapStyle();
                        this.lineBitmapStyle(c14.bitmap, c14.matrix, c14.repeat, c14.smooth);
                        break;
                    case DrawCommandType$1.LINE_GRADIENT_STYLE:
                        var c15 = data.readLineGradientStyle();
                        this.lineGradientStyle(c15.type, c15.colors, c15.alphas, c15.ratios, c15.matrix, c15.spreadMethod, c15.interpolationMethod, c15.focalPointRatio);
                        break;
                    case DrawCommandType$1.LINE_STYLE:
                        var c16 = data.readLineStyle();
                        this.lineStyle(c16.thickness, c16.color, c16.alpha, c16.pixelHinting, c16.scaleMode, c16.caps, c16.joints, c16.miterLimit);
                        break;
                    case DrawCommandType$1.LINE_TO:
                        var c17 = data.readLineTo();
                        this.lineTo(c17.x, c17.y);
                        break;
                    case DrawCommandType$1.MOVE_TO:
                        var c18 = data.readMoveTo();
                        this.moveTo(c18.x, c18.y);
                        break;
                    case DrawCommandType$1.OVERRIDE_MATRIX:
                        var c19 = data.readOverrideMatrix();
                        this.overrideMatrix(c19.matrix);
                        break;
                    case DrawCommandType$1.WINDING_EVEN_ODD:
                        var c20 = data.readWindingEvenOdd();
                        this.windingEvenOdd();
                        break;
                    case DrawCommandType$1.WINDING_NON_ZERO:
                        var c21 = data.readWindingNonZero();
                        this.windingNonZero();
                        break;
                }
            }
            data.destroy();
            return other;
        }
        beginBitmapFill(bitmap, matrix, repeat, smooth) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.BEGIN_BITMAP_FILL);
            this.o.push(bitmap);
            this.o.push(matrix);
            this.b.push(repeat);
            this.b.push(smooth);
        }
        beginFill(color, alpha) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.BEGIN_FILL);
            this.i.push(color);
            this.f.push(alpha);
        }
        beginGradientFill(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.BEGIN_GRADIENT_FILL);
            this.o.push(type);
            this.ii.push(colors);
            this.ff.push(alphas);
            this.ii.push(ratios);
            this.o.push(matrix);
            this.o.push(spreadMethod);
            this.o.push(interpolationMethod);
            this.f.push(focalPointRatio);
        }
        beginShaderFill(shaderBuffer) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.BEGIN_SHADER_FILL);
            this.o.push(shaderBuffer);
        }
        clear() {
            var empty = DrawCommandBuffer.empty;
            this.types = empty.types;
            this.b = empty.b;
            this.i = empty.i;
            this.f = empty.f;
            this.o = empty.o;
            this.ff = empty.ff;
            this.ii = empty.ii;
            this.copyOnWrite = true;
        }
        copy() {
            var copy = new DrawCommandBuffer();
            copy.append(this);
            return copy;
        }
        cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.CUBIC_CURVE_TO);
            this.f.push(controlX1);
            this.f.push(controlY1);
            this.f.push(controlX2);
            this.f.push(controlY2);
            this.f.push(anchorX);
            this.f.push(anchorY);
        }
        curveTo(controlX, controlY, anchorX, anchorY) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.CURVE_TO);
            this.f.push(controlX);
            this.f.push(controlY);
            this.f.push(anchorX);
            this.f.push(anchorY);
        }
        destroy() {
            this.clear();
            this.types = null;
            this.b = null;
            this.i = null;
            this.f = null;
            this.o = null;
            this.ff = null;
            this.ii = null;
        }
        drawCircle(x, y, radius) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.DRAW_CIRCLE);
            this.f.push(x);
            this.f.push(y);
            this.f.push(radius);
        }
        drawEllipse(x, y, width, height) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.DRAW_ELLIPSE);
            this.f.push(x);
            this.f.push(y);
            this.f.push(width);
            this.f.push(height);
        }
        drawQuads(rects, indices, transforms) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.DRAW_QUADS);
            this.o.push(rects);
            this.o.push(indices);
            this.o.push(transforms);
        }
        drawRect(x, y, width, height) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.DRAW_RECT);
            this.f.push(x);
            this.f.push(y);
            this.f.push(width);
            this.f.push(height);
        }
        drawRoundRect(x, y, width, height, ellipseWidth, ellipseHeight) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.DRAW_ROUND_RECT);
            this.f.push(x);
            this.f.push(y);
            this.f.push(width);
            this.f.push(height);
            this.f.push(ellipseWidth);
            this.o.push(ellipseHeight);
        }
        drawTriangles(vertices, indices, uvtData, culling) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.DRAW_TRIANGLES);
            this.o.push(vertices);
            this.o.push(indices);
            this.o.push(uvtData);
            this.o.push(culling);
        }
        endFill() {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.END_FILL);
        }
        lineBitmapStyle(bitmap, matrix, repeat, smooth) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.LINE_BITMAP_STYLE);
            this.o.push(bitmap);
            this.o.push(matrix);
            this.b.push(repeat);
            this.b.push(smooth);
        }
        lineGradientStyle(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.LINE_GRADIENT_STYLE);
            this.o.push(type);
            this.ii.push(colors);
            this.ff.push(alphas);
            this.ii.push(ratios);
            this.o.push(matrix);
            this.o.push(spreadMethod);
            this.o.push(interpolationMethod);
            this.f.push(focalPointRatio);
        }
        lineStyle(thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.LINE_STYLE);
            this.o.push(thickness);
            this.i.push(color);
            this.f.push(alpha);
            this.b.push(pixelHinting);
            this.o.push(scaleMode);
            this.o.push(caps);
            this.o.push(joints);
            this.f.push(miterLimit);
        }
        lineTo(x, y) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.LINE_TO);
            this.f.push(x);
            this.f.push(y);
        }
        moveTo(x, y) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.MOVE_TO);
            this.f.push(x);
            this.f.push(y);
        }
        prepareWrite() {
            if (this.copyOnWrite) {
                this.types = this.types.slice();
                this.b = this.b.slice();
                this.i = this.i.slice();
                this.f = this.f.slice();
                this.o = this.o.slice();
                this.ff = this.ff.slice();
                this.ii = this.ii.slice();
                this.copyOnWrite = false;
            }
        }
        overrideBlendMode(blendMode) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.OVERRIDE_BLEND_MODE);
            this.o.push(blendMode);
        }
        overrideMatrix(matrix) {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.OVERRIDE_MATRIX);
            this.o.push(matrix);
        }
        windingEvenOdd() {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.WINDING_EVEN_ODD);
        }
        windingNonZero() {
            this.prepareWrite();
            this.types.push(DrawCommandType$1.WINDING_NON_ZERO);
        }
        // Get & Set Methods
        get length() {
            return this.types.length;
        }
    }
    DrawCommandBuffer.empty = new DrawCommandBuffer();
    return DrawCommandBuffer;
})();

var openfl$9;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The GradientType class provides values for the `type` parameter
            in the `beginGradientFill()` and
            `lineGradientStyle()` methods of the openfl.display.Graphics
            class.
        **/
        let GradientType;
        (function (GradientType) {
            /**
                Value used to specify a linear gradient fill.
            **/
            GradientType["LINEAR"] = "linear";
            /**
                Value used to specify a radial gradient fill.
            **/
            GradientType["RADIAL"] = "radial";
        })(GradientType = display.GradientType || (display.GradientType = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$9 || (openfl$9 = {}));
var GradientType = openfl$9.display.GradientType;

var openfl$a;
(function (openfl) {
    var display;
    (function (display) {
        /**
            Defines codes for culling algorithms that determine which triangles not to
            render when drawing triangle paths.
    
            The terms `POSITIVE` and `NEGATIVE` refer to the
            sign of a triangle's normal along the z-axis. The normal is a 3D vector
            that is perpendicular to the surface of the triangle.
    
            A triangle whose vertices 0, 1, and 2 are arranged in a clockwise order
            has a positive normal value. That is, its normal points in a positive
            z-axis direction, away from the current view point. When the
            `TriangleCulling.POSITIVE` algorithm is used, triangles with
            positive normals are not rendered. Another term for this is backface
            culling.
    
            A triangle whose vertices are arranged in a counter-clockwise order has
            a negative normal value. That is, its normal points in a negative z-axis
            direction, toward the current view point. When the
            `TriangleCulling.NEGATIVE` algorithm is used, triangles with
            negative normals will not be rendered.
        **/
        let TriangleCulling;
        (function (TriangleCulling) {
            /**
                Specifies culling of all triangles facing toward the current view point.
            **/
            TriangleCulling["NEGATIVE"] = "negative";
            /**
                Specifies no culling. All triangles in the path are rendered.
            **/
            TriangleCulling["NONE"] = "none";
            /**
                Specifies culling of all triangles facing away from the current view
                point. This is also known as backface culling.
            **/
            TriangleCulling["POSITIVE"] = "positive";
        })(TriangleCulling = display.TriangleCulling || (display.TriangleCulling = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$a || (openfl$a = {}));
var TriangleCulling = openfl$a.display.TriangleCulling;

var openfl$b;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for sampler filter mode.
        **/
        let Context3DTextureFilter;
        (function (Context3DTextureFilter) {
            /**
                Use anisotropic filter with radio 16 when upsampling textures
            **/
            Context3DTextureFilter["ANISOTROPIC16X"] = "anisotropic16x";
            /**
                Use anisotropic filter with radio 2 when upsampling textures
            **/
            Context3DTextureFilter["ANISOTROPIC2X"] = "anisotropic2x";
            /**
                Use anisotropic filter with radio 4 when upsampling textures
            **/
            Context3DTextureFilter["ANISOTROPIC4X"] = "anisotropic4x";
            /**
                Use anisotropic filter with radio 8 when upsampling textures
            **/
            Context3DTextureFilter["ANISOTROPIC8X"] = "anisotropic8x";
            /**
                Use linear interpolation when upsampling textures (gives a smooth, blurry look).
            **/
            Context3DTextureFilter["LINEAR"] = "linear";
            /**
                Use nearest neighbor sampling when upsampling textures (gives a pixelated,
                sharp mosaic look).
            **/
            Context3DTextureFilter["NEAREST"] = "nearest";
        })(Context3DTextureFilter = display3D.Context3DTextureFilter || (display3D.Context3DTextureFilter = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$b || (openfl$b = {}));
var Context3DTextureFilter = openfl$b.display3D.Context3DTextureFilter;

var openfl$c;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for sampler wrap mode
        **/
        let Context3DWrapMode;
        (function (Context3DWrapMode) {
            /**
                Clamp texture coordinates outside the 0..1 range.
    
                The is x = max(min(x,0),1)
            **/
            Context3DWrapMode["CLAMP"] = "clamp";
            /**
                Clamp in U axis but Repeat in V axis.
            **/
            Context3DWrapMode["CLAMP_U_REPEAT_V"] = "clamp_u_repeat_v";
            /**
                Repeat (tile) texture coordinates outside the 0..1 range.
    
                The is x = x<0?1.0-frac(abs(x)):frac(x)
            **/
            Context3DWrapMode["REPEAT"] = "repeat";
            /**
                Repeat in U axis but Clamp in V axis.
            **/
            Context3DWrapMode["REPEAT_U_CLAMP_V"] = "repeat_u_clamp_v";
        })(Context3DWrapMode = display3D.Context3DWrapMode || (display3D.Context3DWrapMode = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$c || (openfl$c = {}));
var Context3DWrapMode = openfl$c.display3D.Context3DWrapMode;

// import openfl._internal.backend.lime_standalone.ImageCanvasUtil;
var CanvasWindingRule;
(function (CanvasWindingRule) {
    CanvasWindingRule["NONZERO"] = "nonzero";
    CanvasWindingRule["EVENODD"] = "evenodd";
})(CanvasWindingRule || (CanvasWindingRule = {}));
let CanvasGraphics = /** @class */ (() => {
    class CanvasGraphics {
        static closePath(strokeBefore = false) {
            if (this.context.strokeStyle == null) {
                return;
            }
            if (!strokeBefore) {
                this.context.closePath();
            }
            this.context.stroke();
            if (strokeBefore) {
                this.context.closePath();
            }
            this.context.beginPath();
        }
        static createBitmapFill(bitmap, bitmapRepeat, smooth) {
            this.setSmoothing(smooth);
            return this.context.createPattern(bitmap.__getElement(), bitmapRepeat ? "repeat" : "no-repeat");
        }
        static createGradientPattern(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
            var gradientFill = null, point = null, point2 = null, releaseMatrix = false;
            if (matrix == null) {
                matrix = Matrix.__pool.get();
                releaseMatrix = true;
            }
            switch (type) {
                case GradientType.RADIAL:
                    point = Point.__pool.get();
                    point.setTo(1638.4, 0);
                    matrix.__transformPoint(point);
                    gradientFill = this.context.createRadialGradient(matrix.tx, matrix.ty, 0, matrix.tx, matrix.ty, Math.abs((point.x - matrix.tx) / 2));
                    break;
                case GradientType.LINEAR:
                    point = Point.__pool.get();
                    point.setTo(-819.2, 0);
                    matrix.__transformPoint(point);
                    point2 = Point.__pool.get();
                    point2.setTo(819.2, 0);
                    matrix.__transformPoint(point2);
                    gradientFill = this.context.createLinearGradient(point.x, point.y, point2.x, point2.y);
                    break;
            }
            var rgb, alpha, r, g, b, ratio;
            for (let i = 0; i < colors.length; i++) {
                rgb = colors[i];
                alpha = alphas[i];
                r = (rgb & 0xFF0000) >>> 16;
                g = (rgb & 0x00FF00) >>> 8;
                b = (rgb & 0x0000FF);
                ratio = ratios[i] / 0xFF;
                if (ratio < 0)
                    ratio = 0;
                if (ratio > 1)
                    ratio = 1;
                gradientFill.addColorStop(ratio, "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")");
            }
            if (point != null)
                Point.__pool.release(point);
            if (point2 != null)
                Point.__pool.release(point2);
            if (releaseMatrix)
                Matrix.__pool.release(matrix);
            return gradientFill;
        }
        static createTempPatternCanvas(bitmap, repeat, width, height) {
            // TODO: Don't create extra canvas elements like this
            var canvas = document.createElement("canvas");
            var context = canvas.getContext("2d");
            canvas.width = width;
            canvas.height = height;
            context.fillStyle = context.createPattern(bitmap.__getElement(), repeat ? "repeat" : "no-repeat");
            context.beginPath();
            context.moveTo(0, 0);
            context.lineTo(0, height);
            context.lineTo(width, height);
            context.lineTo(width, 0);
            context.lineTo(0, 0);
            context.closePath();
            if (!this.hitTesting)
                context.fill(this.windingRule);
            return canvas;
        }
        static drawRoundRect(x, y, width, height, ellipseWidth, ellipseHeight) {
            if (ellipseHeight == null)
                ellipseHeight = ellipseWidth;
            ellipseWidth *= 0.5;
            ellipseHeight *= 0.5;
            if (ellipseWidth > width / 2)
                ellipseWidth = width / 2;
            if (ellipseHeight > height / 2)
                ellipseHeight = height / 2;
            var xe = x + width, ye = y + height, cx1 = -ellipseWidth + (ellipseWidth * this.SIN45), cx2 = -ellipseWidth + (ellipseWidth * this.TAN22), cy1 = -ellipseHeight + (ellipseHeight * this.SIN45), cy2 = -ellipseHeight + (ellipseHeight * this.TAN22);
            var context = this.context;
            context.moveTo(xe, ye - ellipseHeight);
            context.quadraticCurveTo(xe, ye + cy2, xe + cx1, ye + cy1);
            context.quadraticCurveTo(xe + cx2, ye, xe - ellipseWidth, ye);
            context.lineTo(x + ellipseWidth, ye);
            context.quadraticCurveTo(x - cx2, ye, x - cx1, ye + cy1);
            context.quadraticCurveTo(x, ye + cy2, x, ye - ellipseHeight);
            context.lineTo(x, y + ellipseHeight);
            context.quadraticCurveTo(x, y - cy2, x - cx1, y - cy1);
            context.quadraticCurveTo(x - cx2, y, x + ellipseWidth, y);
            context.lineTo(xe - ellipseWidth, y);
            context.quadraticCurveTo(xe + cx2, y, xe + cx1, y - cy1);
            context.quadraticCurveTo(xe, y - cy2, xe, y + ellipseHeight);
            context.lineTo(xe, ye - ellipseHeight);
        }
        static endFill() {
            this.context.beginPath();
            this.playCommands(this.fillCommands, false);
            this.fillCommands.clear();
        }
        static endStroke() {
            this.context.beginPath();
            this.playCommands(this.strokeCommands, true);
            this.context.closePath();
            this.strokeCommands.clear();
        }
        static hitTest(graphics, x, y) {
            this.bounds = graphics.__bounds;
            CanvasGraphics.graphics = graphics;
            if (graphics.__commands.length == 0 || this.bounds == null || this.bounds.width <= 0 || this.bounds.height <= 0) {
                return false;
            }
            else {
                this.hitTesting = true;
                var transform = graphics.__renderTransform;
                var px = transform.__transformX(x, y);
                var py = transform.__transformY(x, y);
                x = px;
                y = py;
                x -= transform.__transformX(this.bounds.x, this.bounds.y);
                y -= transform.__transformY(this.bounds.x, this.bounds.y);
                var cacheCanvas = graphics.__renderData.canvas;
                var cacheContext = graphics.__renderData.context;
                graphics.__renderData.canvas = this.hitTestCanvas;
                graphics.__renderData.context = this.hitTestContext;
                this.context = graphics.__renderData.context;
                this.context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
                this.fillCommands.clear();
                this.strokeCommands.clear();
                this.hasFill = false;
                this.hasStroke = false;
                this.bitmapFill = null;
                this.bitmapRepeat = false;
                this.windingRule = CanvasWindingRule.EVENODD;
                var data = new DrawCommandReader(graphics.__commands);
                for (let type of graphics.__commands.types) {
                    switch (type) {
                        case DrawCommandType$1.CUBIC_CURVE_TO:
                            var c = data.readCubicCurveTo();
                            this.fillCommands.cubicCurveTo(c.controlX1, c.controlY1, c.controlX2, c.controlY2, c.anchorX, c.anchorY);
                            this.strokeCommands.cubicCurveTo(c.controlX1, c.controlY1, c.controlX2, c.controlY2, c.anchorX, c.anchorY);
                            break;
                        case DrawCommandType$1.CURVE_TO:
                            var c2 = data.readCurveTo();
                            this.fillCommands.curveTo(c2.controlX, c2.controlY, c2.anchorX, c2.anchorY);
                            this.strokeCommands.curveTo(c2.controlX, c2.controlY, c2.anchorX, c2.anchorY);
                            break;
                        case DrawCommandType$1.LINE_TO:
                            var c3 = data.readLineTo();
                            this.fillCommands.lineTo(c3.x, c3.y);
                            this.strokeCommands.lineTo(c3.x, c3.y);
                            break;
                        case DrawCommandType$1.MOVE_TO:
                            var c4 = data.readMoveTo();
                            this.fillCommands.moveTo(c4.x, c4.y);
                            this.strokeCommands.moveTo(c4.x, c4.y);
                            break;
                        case DrawCommandType$1.LINE_GRADIENT_STYLE:
                            var c5 = data.readLineGradientStyle();
                            this.strokeCommands.lineGradientStyle(c5.type, c5.colors, c5.alphas, c5.ratios, c5.matrix, c5.spreadMethod, c5.interpolationMethod, c5.focalPointRatio);
                            break;
                        case DrawCommandType$1.LINE_BITMAP_STYLE:
                            var c6 = data.readLineBitmapStyle();
                            this.strokeCommands.lineBitmapStyle(c6.bitmap, c6.matrix, c6.repeat, c6.smooth);
                            break;
                        case DrawCommandType$1.LINE_STYLE:
                            var c7 = data.readLineStyle();
                            this.strokeCommands.lineStyle(c7.thickness, c7.color, 1, c7.pixelHinting, c7.scaleMode, c7.caps, c7.joints, c7.miterLimit);
                            break;
                        case DrawCommandType$1.END_FILL:
                            data.readEndFill();
                            this.endFill();
                            if (this.hasFill && this.context.isPointInPath(x, y, this.windingRule)) {
                                data.destroy();
                                graphics.__renderData.canvas = cacheCanvas;
                                graphics.__renderData.context = cacheContext;
                                return true;
                            }
                            this.endStroke();
                            if (this.hasStroke && this.context.isPointInStroke(x, y)) {
                                data.destroy();
                                graphics.__renderData.canvas = cacheCanvas;
                                graphics.__renderData.context = cacheContext;
                                return true;
                            }
                            this.hasFill = false;
                            this.bitmapFill = null;
                            break;
                        case DrawCommandType$1.BEGIN_BITMAP_FILL:
                        case DrawCommandType$1.BEGIN_FILL:
                        case DrawCommandType$1.BEGIN_GRADIENT_FILL:
                        case DrawCommandType$1.BEGIN_SHADER_FILL:
                            this.endFill();
                            if (this.hasFill && this.context.isPointInPath(x, y, this.windingRule)) {
                                data.destroy();
                                graphics.__renderData.canvas = cacheCanvas;
                                graphics.__renderData.context = cacheContext;
                                return true;
                            }
                            this.endStroke();
                            if (this.hasStroke && this.context.isPointInStroke(x, y)) {
                                data.destroy();
                                graphics.__renderData.canvas = cacheCanvas;
                                graphics.__renderData.context = cacheContext;
                                return true;
                            }
                            if (type == DrawCommandType$1.BEGIN_BITMAP_FILL) {
                                var c8 = data.readBeginBitmapFill();
                                this.fillCommands.beginBitmapFill(c8.bitmap, c8.matrix, c8.repeat, c8.smooth);
                                this.strokeCommands.beginBitmapFill(c8.bitmap, c8.matrix, c8.repeat, c8.smooth);
                            }
                            else if (type == DrawCommandType$1.BEGIN_GRADIENT_FILL) {
                                var c9 = data.readBeginGradientFill();
                                this.fillCommands.beginGradientFill(c9.type, c9.colors, c9.alphas, c9.ratios, c9.matrix, c9.spreadMethod, c9.interpolationMethod, c9.focalPointRatio);
                                this.strokeCommands.beginGradientFill(c9.type, c9.colors, c9.alphas, c9.ratios, c9.matrix, c9.spreadMethod, c9.interpolationMethod, c9.focalPointRatio);
                            }
                            else if (type == DrawCommandType$1.BEGIN_SHADER_FILL) {
                                var c10 = data.readBeginShaderFill();
                                this.fillCommands.beginShaderFill(c10.shaderBuffer);
                                this.strokeCommands.beginShaderFill(c10.shaderBuffer);
                            }
                            else {
                                var c11 = data.readBeginFill();
                                this.fillCommands.beginFill(c11.color, 1);
                                this.strokeCommands.beginFill(c11.color, 1);
                            }
                            break;
                        case DrawCommandType$1.DRAW_CIRCLE:
                            var c12 = data.readDrawCircle();
                            this.fillCommands.drawCircle(c12.x, c12.y, c12.radius);
                            this.strokeCommands.drawCircle(c12.x, c12.y, c12.radius);
                            break;
                        case DrawCommandType$1.DRAW_ELLIPSE:
                            var c13 = data.readDrawEllipse();
                            this.fillCommands.drawEllipse(c13.x, c13.y, c13.width, c13.height);
                            this.strokeCommands.drawEllipse(c13.x, c13.y, c13.width, c13.height);
                            break;
                        case DrawCommandType$1.DRAW_RECT:
                            var c14 = data.readDrawRect();
                            this.fillCommands.drawRect(c14.x, c14.y, c14.width, c14.height);
                            this.strokeCommands.drawRect(c14.x, c14.y, c14.width, c14.height);
                            break;
                        case DrawCommandType$1.DRAW_ROUND_RECT:
                            var c15 = data.readDrawRoundRect();
                            this.fillCommands.drawRoundRect(c15.x, c15.y, c15.width, c15.height, c15.ellipseWidth, c15.ellipseHeight);
                            this.strokeCommands.drawRoundRect(c15.x, c15.y, c15.width, c15.height, c15.ellipseWidth, c15.ellipseHeight);
                            break;
                        case DrawCommandType$1.WINDING_EVEN_ODD:
                            this.windingRule = CanvasWindingRule.EVENODD;
                            break;
                        case DrawCommandType$1.WINDING_NON_ZERO:
                            this.windingRule = CanvasWindingRule.NONZERO;
                            break;
                        default:
                            data.skip(type);
                    }
                }
                var hitTest = false;
                if (this.fillCommands.length > 0) {
                    this.endFill();
                }
                if (this.hasFill && this.context.isPointInPath(x, y, this.windingRule)) {
                    hitTest = true;
                }
                if (this.strokeCommands.length > 0) {
                    this.endStroke();
                }
                if (this.hasStroke && this.context.isPointInStroke(x, y)) {
                    hitTest = true;
                }
                data.destroy();
                graphics.__renderData.canvas = cacheCanvas;
                graphics.__renderData.context = cacheContext;
                return hitTest;
            }
        }
        static isCCW(x1, y1, x2, y2, x3, y3) {
            return ((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)) < 0;
        }
        static normalizeUVT(uvt, skipT = false) {
            var max = Number.NEGATIVE_INFINITY;
            var tmp = Number.NEGATIVE_INFINITY;
            var len = uvt.length;
            for (let t = 1; t < len + 1; t++) {
                if (skipT && t % 3 == 0) {
                    continue;
                }
                tmp = uvt[t - 1];
                if (max < tmp) {
                    max = tmp;
                }
            }
            if (!skipT) {
                return { max: max, uvt: uvt };
            }
            var result = new Vector();
            for (let t = 1; t < len + 1; t++) {
                if (skipT && t % 3 == 0) {
                    continue;
                }
                result.push(uvt[t - 1]);
            }
            return { max: max, uvt: result };
        }
        static playCommands(commands, stroke = false) {
            this.bounds = this.graphics.__bounds;
            var offsetX = this.bounds.x;
            var offsetY = this.bounds.y;
            var positionX = 0.0;
            var positionY = 0.0;
            var closeGap = false;
            var startX = 0.0;
            var startY = 0.0;
            var setStart = false;
            this.windingRule = CanvasWindingRule.EVENODD;
            this.setSmoothing(true);
            var hasPath = false;
            var data = new DrawCommandReader(commands);
            var x, y, width, height, kappa = .5522848, ox, oy, xe, ye, xm, ym, r, g, b;
            var optimizationUsed, canOptimizeMatrix, st, sr, sb, sl, stl = null, sbr = null;
            for (let type of commands.types) {
                switch (type) {
                    case DrawCommandType$1.CUBIC_CURVE_TO:
                        var c = data.readCubicCurveTo();
                        hasPath = true;
                        this.context.bezierCurveTo(c.controlX1
                            - offsetX, c.controlY1
                            - offsetY, c.controlX2
                            - offsetX, c.controlY2
                            - offsetY, c.anchorX
                            - offsetX, c.anchorY
                            - offsetY);
                        break;
                    case DrawCommandType$1.CURVE_TO:
                        var c2 = data.readCurveTo();
                        hasPath = true;
                        this.context.quadraticCurveTo(c2.controlX - offsetX, c2.controlY - offsetY, c2.anchorX - offsetX, c2.anchorY - offsetY);
                        break;
                    case DrawCommandType$1.DRAW_CIRCLE:
                        var c3 = data.readDrawCircle();
                        hasPath = true;
                        this.context.moveTo(c3.x - offsetX + c3.radius, c3.y - offsetY);
                        this.context.arc(c3.x - offsetX, c3.y - offsetY, c3.radius, 0, Math.PI * 2, true);
                        break;
                    case DrawCommandType$1.DRAW_ELLIPSE:
                        var c4 = data.readDrawEllipse();
                        hasPath = true;
                        x = c4.x;
                        y = c4.y;
                        width = c4.width;
                        height = c4.height;
                        x -= offsetX;
                        y -= offsetY;
                        ox = (width / 2) * kappa; // control point offset horizontal
                        oy = (height / 2) * kappa; // control point offset vertical
                        xe = x + width; // x-end
                        ye = y + height; // y-end
                        xm = x + width / 2; // x-middle
                        ym = y + height / 2; // y-middle
                        this.context.moveTo(x, ym);
                        this.context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                        this.context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                        this.context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                        this.context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                        break;
                    case DrawCommandType$1.DRAW_ROUND_RECT:
                        var c5 = data.readDrawRoundRect();
                        hasPath = true;
                        this.drawRoundRect(c5.x - offsetX, c5.y - offsetY, c5.width, c5.height, c5.ellipseWidth, c5.ellipseHeight);
                        break;
                    case DrawCommandType$1.LINE_TO:
                        var c6 = data.readLineTo();
                        hasPath = true;
                        this.context.lineTo(c6.x - offsetX, c6.y - offsetY);
                        positionX = c6.x;
                        positionY = c6.y;
                        if (positionX == startX && positionY == startY) {
                            closeGap = true;
                        }
                        break;
                    case DrawCommandType$1.MOVE_TO:
                        var c7 = data.readMoveTo();
                        this.context.moveTo(c7.x - offsetX, c7.y - offsetY);
                        positionX = c7.x;
                        positionY = c7.y;
                        if (setStart && c7.x != startX && c7.y != startY) {
                            closeGap = true;
                        }
                        startX = c7.x;
                        startY = c7.y;
                        setStart = true;
                        break;
                    case DrawCommandType$1.LINE_STYLE:
                        var c8 = data.readLineStyle();
                        if (stroke && this.hasStroke) {
                            this.closePath(true);
                        }
                        this.context.moveTo(positionX - offsetX, positionY - offsetY);
                        if (c8.thickness == null) {
                            this.hasStroke = false;
                        }
                        else {
                            this.context.lineWidth = (c8.thickness > 0 ? c8.thickness : 1);
                            this.context.lineJoin = (c8.joints == null ? "round" : String(c8.joints).toLowerCase());
                            switch (c8.caps) {
                                case null:
                                    this.context.lineCap = "round";
                                    break;
                                case CapsStyle.NONE:
                                    this.context.lineCap = "butt";
                                    break;
                                default:
                                    this.context.lineCap = c8.caps.toLowerCase();
                            }
                            this.context.miterLimit = c8.miterLimit;
                            if (c8.alpha == 1) {
                                this.context.strokeStyle = "#" + (c8.color & 0x00FFFFFF).toString(16);
                            }
                            else {
                                r = (c8.color & 0xFF0000) >>> 16;
                                g = (c8.color & 0x00FF00) >>> 8;
                                b = (c8.color & 0x0000FF);
                                this.context.strokeStyle = "rgba(" + r + ", " + g + ", " + b + ", " + c8.alpha + ")";
                            }
                            this.setSmoothing(true);
                            this.hasStroke = true;
                        }
                        break;
                    case DrawCommandType$1.LINE_GRADIENT_STYLE:
                        var c9 = data.readLineGradientStyle();
                        if (stroke && this.hasStroke) {
                            this.closePath();
                        }
                        this.context.moveTo(positionX - offsetX, positionY - offsetY);
                        this.context.strokeStyle = this.createGradientPattern(c9.type, c9.colors, c9.alphas, c9.ratios, c9.matrix, c9.spreadMethod, c9.interpolationMethod, c9.focalPointRatio);
                        this.setSmoothing(true);
                        this.hasStroke = true;
                        break;
                    case DrawCommandType$1.LINE_BITMAP_STYLE:
                        var c10 = data.readLineBitmapStyle();
                        if (stroke && this.hasStroke) {
                            this.closePath();
                        }
                        this.context.moveTo(positionX - offsetX, positionY - offsetY);
                        this.context.strokeStyle = this.createBitmapFill(c10.bitmap, c10.repeat, c10.smooth);
                        this.hasStroke = true;
                        break;
                    case DrawCommandType$1.BEGIN_BITMAP_FILL:
                        var c11 = data.readBeginBitmapFill();
                        this.bitmapFill = c11.bitmap;
                        this.context.fillStyle = this.createBitmapFill(c11.bitmap, c11.repeat, c11.smooth);
                        this.hasFill = true;
                        if (c11.matrix != null) {
                            this.pendingMatrix = c11.matrix;
                            this.inversePendingMatrix = c11.matrix.clone();
                            this.inversePendingMatrix.invert();
                        }
                        else {
                            this.pendingMatrix = null;
                            this.inversePendingMatrix = null;
                        }
                        break;
                    case DrawCommandType$1.BEGIN_FILL:
                        var c12 = data.readBeginFill();
                        if (c12.alpha < 0.005) {
                            this.hasFill = false;
                        }
                        else {
                            if (c12.alpha == 1) {
                                this.context.fillStyle = "#" + (c12.color & 0xFFFFFF).toString(16);
                            }
                            else {
                                r = (c12.color & 0xFF0000) >>> 16;
                                g = (c12.color & 0x00FF00) >>> 8;
                                b = (c12.color & 0x0000FF);
                                this.context.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + c12.alpha + ")";
                            }
                            this.bitmapFill = null;
                            this.setSmoothing(true);
                            this.hasFill = true;
                        }
                        break;
                    case DrawCommandType$1.BEGIN_GRADIENT_FILL:
                        var c13 = data.readBeginGradientFill();
                        this.context.fillStyle = this.createGradientPattern(c13.type, c13.colors, c13.alphas, c13.ratios, c13.matrix, c13.spreadMethod, c13.interpolationMethod, c13.focalPointRatio);
                        this.bitmapFill = null;
                        this.setSmoothing(true);
                        this.hasFill = true;
                        break;
                    case DrawCommandType$1.BEGIN_SHADER_FILL:
                        var c14 = data.readBeginShaderFill();
                        var shaderBuffer = c14.shaderBuffer;
                        if (shaderBuffer.inputCount > 0) {
                            this.bitmapFill = shaderBuffer.inputs[0];
                            this.context.fillStyle = this.createBitmapFill(this.bitmapFill, shaderBuffer.inputWrap[0] != Context3DWrapMode.CLAMP, shaderBuffer.inputFilter[0] != Context3DTextureFilter.NEAREST);
                            this.hasFill = true;
                            this.pendingMatrix = null;
                            this.inversePendingMatrix = null;
                        }
                        break;
                    case DrawCommandType$1.DRAW_QUADS:
                        var c15 = data.readDrawQuads();
                        var rects = c15.rects;
                        var indices = c15.indices;
                        var transforms = c15.transforms;
                        var hasIndices = (indices != null);
                        var transformABCD = false, transformXY = false;
                        var length = hasIndices ? indices.length : Math.floor(rects.length / 4);
                        if (length == 0)
                            return;
                        if (transforms != null) {
                            if (transforms.length >= length * 6) {
                                transformABCD = true;
                                transformXY = true;
                            }
                            else if (transforms.length >= length * 4) {
                                transformABCD = true;
                            }
                            else if (transforms.length >= length * 2) {
                                transformXY = true;
                            }
                        }
                        var tileRect = Rectangle.__pool.get();
                        var tileTransform = Matrix.__pool.get();
                        var transform = this.graphics.__renderTransform;
                        var ri, ti;
                        this.context.save(); // TODO: Restore transform without save/restore
                        for (let i = 0; i < length; i++) {
                            ri = (hasIndices ? (indices[i] * 4) : i * 4);
                            if (ri < 0)
                                continue;
                            tileRect.setTo(rects[ri], rects[ri + 1], rects[ri + 2], rects[ri + 3]);
                            if (tileRect.width <= 0 || tileRect.height <= 0) {
                                continue;
                            }
                            if (transformABCD && transformXY) {
                                ti = i * 6;
                                tileTransform.setTo(transforms[ti], transforms[ti + 1], transforms[ti + 2], transforms[ti + 3], transforms[ti + 4], transforms[ti + 5]);
                            }
                            else if (transformABCD) {
                                ti = i * 4;
                                tileTransform.setTo(transforms[ti], transforms[ti + 1], transforms[ti + 2], transforms[ti + 3], tileRect.x, tileRect.y);
                            }
                            else if (transformXY) {
                                ti = i * 2;
                                tileTransform.tx = transforms[ti];
                                tileTransform.ty = transforms[ti + 1];
                            }
                            else {
                                tileTransform.tx = tileRect.x;
                                tileTransform.ty = tileRect.y;
                            }
                            tileTransform.tx += positionX - offsetX;
                            tileTransform.ty += positionY - offsetY;
                            tileTransform.concat(transform);
                            // if (roundPixels) {
                            // 	tileTransform.tx = Math.round (tileTransform.tx);
                            // 	tileTransform.ty = Math.round (tileTransform.ty);
                            // }
                            this.context.setTransform(tileTransform.a, tileTransform.b, tileTransform.c, tileTransform.d, tileTransform.tx, tileTransform.ty);
                            if (this.bitmapFill != null) {
                                this.context.drawImage(this.bitmapFill.__getElement(), tileRect.x, tileRect.y, tileRect.width, tileRect.height, 0, 0, tileRect.width, tileRect.height);
                            }
                            else {
                                this.context.fillRect(0, 0, tileRect.width, tileRect.height);
                            }
                        }
                        Rectangle.__pool.release(tileRect);
                        Matrix.__pool.release(tileTransform);
                        this.context.restore();
                        break;
                    case DrawCommandType$1.DRAW_TRIANGLES:
                        var c16 = data.readDrawTriangles();
                        var v = c16.vertices;
                        var ind = c16.indices;
                        var uvt = c16.uvtData;
                        var pattern = null;
                        var colorFill = this.bitmapFill == null;
                        if (colorFill && uvt != null) {
                            break;
                        }
                        if (!colorFill) {
                            // TODO move this to Graphics?
                            if (uvt == null) {
                                uvt = new Vector();
                                for (let i = 0; i < v.length / 2; i++) {
                                    uvt.push(v[i * 2] - offsetX / this.bitmapFill.width);
                                    uvt.push(v[i * 2 + 1] - offsetY / this.bitmapFill.height);
                                }
                            }
                            var skipT = uvt.length != v.length;
                            var normalizedUVT = this.normalizeUVT(uvt, skipT);
                            var maxUVT = normalizedUVT.max;
                            uvt = normalizedUVT.uvt;
                            if (maxUVT > 1) {
                                pattern = this.createTempPatternCanvas(this.bitmapFill, this.bitmapRepeat, Math.floor(this.bounds.width), Math.floor(this.bounds.height));
                            }
                            else {
                                pattern = this.createTempPatternCanvas(this.bitmapFill, this.bitmapRepeat, this.bitmapFill.width, this.bitmapFill.height);
                            }
                        }
                        var i = 0;
                        var l = ind.length;
                        var a_, b_, c_;
                        var iax, iay, ibx, iby, icx, icy;
                        var x1, y1, x2, y2, x3, y3;
                        var uvx1, uvy1, uvx2, uvy2, uvx3, uvy3;
                        var denom;
                        var t1, t2, t3, t4;
                        var dx, dy;
                        while (i < l) {
                            a_ = i;
                            b_ = i + 1;
                            c_ = i + 2;
                            iax = ind[a_] * 2;
                            iay = ind[a_] * 2 + 1;
                            ibx = ind[b_] * 2;
                            iby = ind[b_] * 2 + 1;
                            icx = ind[c_] * 2;
                            icy = ind[c_] * 2 + 1;
                            x1 = v[iax] - offsetX;
                            y1 = v[iay] - offsetY;
                            x2 = v[ibx] - offsetX;
                            y2 = v[iby] - offsetY;
                            x3 = v[icx] - offsetX;
                            y3 = v[icy] - offsetY;
                            switch (c16.culling) {
                                case TriangleCulling.POSITIVE:
                                    if (!this.isCCW(x1, y1, x2, y2, x3, y3)) {
                                        i += 3;
                                        continue;
                                    }
                                    break;
                                case TriangleCulling.NEGATIVE:
                                    if (this.isCCW(x1, y1, x2, y2, x3, y3)) {
                                        i += 3;
                                        continue;
                                    }
                                    break;
                            }
                            if (colorFill) {
                                this.context.beginPath();
                                this.context.moveTo(x1, y1);
                                this.context.lineTo(x2, y2);
                                this.context.lineTo(x3, y3);
                                this.context.closePath();
                                if (!this.hitTesting)
                                    this.context.fill(this.windingRule);
                                i += 3;
                                continue;
                            }
                            uvx1 = uvt[iax] * pattern.width;
                            uvx2 = uvt[ibx] * pattern.width;
                            uvx3 = uvt[icx] * pattern.width;
                            uvy1 = uvt[iay] * pattern.height;
                            uvy2 = uvt[iby] * pattern.height;
                            uvy3 = uvt[icy] * pattern.height;
                            denom = uvx1 * (uvy3 - uvy2) - uvx2 * uvy3 + uvx3 * uvy2 + (uvx2 - uvx3) * uvy1;
                            if (denom == 0) {
                                i += 3;
                                this.context.restore();
                                continue;
                            }
                            this.context.save();
                            this.context.beginPath();
                            this.context.moveTo(x1, y1);
                            this.context.lineTo(x2, y2);
                            this.context.lineTo(x3, y3);
                            this.context.closePath();
                            this.context.clip();
                            t1 = -(uvy1 * (x3 - x2) - uvy2 * x3 + uvy3 * x2 + (uvy2 - uvy3) * x1) / denom;
                            t2 = (uvy2 * y3 + uvy1 * (y2 - y3) - uvy3 * y2 + (uvy3 - uvy2) * y1) / denom;
                            t3 = (uvx1 * (x3 - x2) - uvx2 * x3 + uvx3 * x2 + (uvx2 - uvx3) * x1) / denom;
                            t4 = -(uvx2 * y3 + uvx1 * (y2 - y3) - uvx3 * y2 + (uvx3 - uvx2) * y1) / denom;
                            dx = (uvx1 * (uvy3 * x2 - uvy2 * x3) + uvy1 * (uvx2 * x3 - uvx3 * x2) + (uvx3 * uvy2 - uvx2 * uvy3) * x1) / denom;
                            dy = (uvx1 * (uvy3 * y2 - uvy2 * y3) + uvy1 * (uvx2 * y3 - uvx3 * y2) + (uvx3 * uvy2 - uvx2 * uvy3) * y1) / denom;
                            this.context.transform(t1, t2, t3, t4, dx, dy);
                            this.context.drawImage(pattern, 0, 0, pattern.width, pattern.height);
                            this.context.restore();
                            i += 3;
                        }
                    case DrawCommandType$1.DRAW_RECT:
                        var c17 = data.readDrawRect();
                        optimizationUsed = false;
                        if (this.bitmapFill != null && !this.hitTesting) {
                            st = 0;
                            sr = 0;
                            sb = 0;
                            sl = 0;
                            canOptimizeMatrix = true;
                            if (this.pendingMatrix != null) {
                                if (this.pendingMatrix.b != 0 || this.pendingMatrix.c != 0) {
                                    canOptimizeMatrix = false;
                                }
                                else {
                                    if (stl == null)
                                        stl = Point.__pool.get();
                                    if (sbr == null)
                                        sbr = Point.__pool.get();
                                    stl.setTo(c17.x, c17.y);
                                    this.inversePendingMatrix.__transformPoint(stl);
                                    sbr.setTo(c17.x + c17.width, c17.y + c17.height);
                                    this.inversePendingMatrix.__transformPoint(sbr);
                                    st = stl.y;
                                    sl = stl.x;
                                    sb = sbr.y;
                                    sr = sbr.x;
                                }
                            }
                            else {
                                st = c17.y;
                                sl = c17.x;
                                sb = c17.y + c17.height;
                                sr = c17.x + c17.width;
                            }
                            if (canOptimizeMatrix && st >= 0 && sl >= 0 && sr <= this.bitmapFill.width && sb <= this.bitmapFill.height) {
                                optimizationUsed = true;
                                if (!this.hitTesting)
                                    this.context.drawImage(this.bitmapFill.__getElement(), sl, st, sr - sl, sb - st, c17.x - offsetX, c17.y - offsetY, c17.width, c17.height);
                            }
                        }
                        if (!optimizationUsed) {
                            hasPath = true;
                            this.context.rect(c17.x - offsetX, c17.y - offsetY, c17.width, c17.height);
                        }
                        break;
                    case DrawCommandType$1.WINDING_EVEN_ODD:
                        this.windingRule = CanvasWindingRule.EVENODD;
                        break;
                    case DrawCommandType$1.WINDING_NON_ZERO:
                        this.windingRule = CanvasWindingRule.NONZERO;
                    default:
                        data.skip(type);
                }
            }
            if (stl != null)
                Point.__pool.release(stl);
            if (sbr != null)
                Point.__pool.release(sbr);
            data.destroy();
            if (hasPath) {
                if (stroke && this.hasStroke) {
                    if (this.hasFill && closeGap) {
                        this.context.lineTo(startX - offsetX, startY - offsetY);
                        this.closePath(false);
                    }
                    else if (closeGap && positionX == startX && positionY == startY) {
                        this.closePath(false);
                    }
                    if (!this.hitTesting)
                        this.context.stroke();
                }
                if (!stroke) {
                    if (this.hasFill || this.bitmapFill != null) {
                        this.context.translate(-this.bounds.x, -this.bounds.y);
                        if (this.pendingMatrix != null) {
                            this.context.transform(this.pendingMatrix.a, this.pendingMatrix.b, this.pendingMatrix.c, this.pendingMatrix.d, this.pendingMatrix.tx, this.pendingMatrix.ty);
                            if (!this.hitTesting)
                                this.context.fill(this.windingRule);
                            this.context.transform(this.inversePendingMatrix.a, this.inversePendingMatrix.b, this.inversePendingMatrix.c, this.inversePendingMatrix.d, this.inversePendingMatrix.tx, this.inversePendingMatrix.ty);
                        }
                        else {
                            if (!this.hitTesting)
                                this.context.fill(this.windingRule);
                        }
                        this.context.translate(this.bounds.x, this.bounds.y);
                        this.context.closePath();
                    }
                }
            }
        }
        static render(graphics, renderer) {
            graphics.__update(renderer.__worldTransform);
            if (graphics.__softwareDirty) {
                this.hitTesting = false;
                CanvasGraphics.graphics = graphics;
                CanvasGraphics.allowSmoothing = renderer.__allowSmoothing;
                CanvasGraphics.worldAlpha = renderer.__getAlpha(graphics.__owner.__worldAlpha);
                this.bounds = graphics.__bounds;
                var width = graphics.__width;
                var height = graphics.__height;
                if (!graphics.__visible || graphics.__commands.length == 0 || this.bounds == null || width < 1 || height < 1) {
                    graphics.__renderData.canvas = null;
                    graphics.__renderData.context = null;
                    graphics.__bitmap = null;
                }
                else {
                    if (graphics.__renderData.canvas == null) {
                        graphics.__renderData.canvas = document.createElement("canvas");
                        graphics.__renderData.context = graphics.__renderData.canvas.getContext("2d");
                    }
                    this.context = graphics.__renderData.context;
                    var transform = graphics.__renderTransform;
                    var canvas = graphics.__renderData.canvas;
                    var scale = renderer.pixelRatio;
                    var scaledWidth = Math.floor(width * scale);
                    var scaledHeight = Math.floor(height * scale);
                    renderer.__setBlendModeContext(this.context, BlendMode.NORMAL);
                    if (renderer.__domRenderer != null) {
                        if (canvas.width == scaledWidth && canvas.height == scaledHeight) {
                            this.context.clearRect(0, 0, scaledWidth, scaledHeight);
                        }
                        else {
                            canvas.width = scaledWidth;
                            canvas.height = scaledHeight;
                            canvas.style.width = width + "px";
                            canvas.style.height = height + "px";
                        }
                        var transform = graphics.__renderTransform;
                        this.context.setTransform(transform.a * scale, transform.b * scale, transform.c * scale, transform.d * scale, transform.tx * scale, transform.ty * scale);
                    }
                    else {
                        if (canvas.width == scaledWidth && canvas.height == scaledHeight) {
                            this.context.closePath();
                            this.context.setTransform(1, 0, 0, 1, 0, 0);
                            this.context.clearRect(0, 0, scaledWidth, scaledHeight);
                        }
                        else {
                            canvas.width = width;
                            canvas.height = height;
                        }
                        this.context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
                    }
                    this.fillCommands.clear();
                    this.strokeCommands.clear();
                    this.hasFill = false;
                    this.hasStroke = false;
                    this.bitmapFill = null;
                    this.bitmapRepeat = false;
                    var hasLineStyle = false;
                    var initStrokeX = 0.0;
                    var initStrokeY = 0.0;
                    this.windingRule = CanvasWindingRule.EVENODD;
                    var data = new DrawCommandReader(graphics.__commands);
                    for (let type of graphics.__commands.types) {
                        switch (type) {
                            case DrawCommandType$1.CUBIC_CURVE_TO:
                                var c = data.readCubicCurveTo();
                                this.fillCommands.cubicCurveTo(c.controlX1, c.controlY1, c.controlX2, c.controlY2, c.anchorX, c.anchorY);
                                if (hasLineStyle) {
                                    this.strokeCommands.cubicCurveTo(c.controlX1, c.controlY1, c.controlX2, c.controlY2, c.anchorX, c.anchorY);
                                }
                                else {
                                    initStrokeX = c.anchorX;
                                    initStrokeY = c.anchorY;
                                }
                                break;
                            case DrawCommandType$1.CURVE_TO:
                                var c2 = data.readCurveTo();
                                this.fillCommands.curveTo(c2.controlX, c2.controlY, c2.anchorX, c2.anchorY);
                                if (hasLineStyle) {
                                    this.strokeCommands.curveTo(c2.controlX, c2.controlY, c2.anchorX, c2.anchorY);
                                }
                                else {
                                    initStrokeX = c2.anchorX;
                                    initStrokeY = c2.anchorY;
                                }
                                break;
                            case DrawCommandType$1.LINE_TO:
                                var c3 = data.readLineTo();
                                this.fillCommands.lineTo(c3.x, c3.y);
                                if (hasLineStyle) {
                                    this.strokeCommands.lineTo(c3.x, c3.y);
                                }
                                else {
                                    initStrokeX = c3.x;
                                    initStrokeY = c3.y;
                                }
                                break;
                            case DrawCommandType$1.MOVE_TO:
                                var c4 = data.readMoveTo();
                                this.fillCommands.moveTo(c4.x, c4.y);
                                if (hasLineStyle) {
                                    this.strokeCommands.moveTo(c4.x, c4.y);
                                }
                                else {
                                    initStrokeX = c4.x;
                                    initStrokeY = c4.y;
                                }
                                break;
                            case DrawCommandType$1.END_FILL:
                                data.readEndFill();
                                this.endFill();
                                this.endStroke();
                                this.hasFill = false;
                                hasLineStyle = false;
                                this.bitmapFill = null;
                                initStrokeX = 0;
                                initStrokeY = 0;
                                break;
                            case DrawCommandType$1.LINE_GRADIENT_STYLE:
                                var c5 = data.readLineGradientStyle();
                                if (!hasLineStyle && (initStrokeX != 0 || initStrokeY != 0)) {
                                    this.strokeCommands.moveTo(initStrokeX, initStrokeY);
                                    initStrokeX = 0;
                                    initStrokeY = 0;
                                }
                                hasLineStyle = true;
                                this.strokeCommands.lineGradientStyle(c5.type, c5.colors, c5.alphas, c5.ratios, c5.matrix, c5.spreadMethod, c5.interpolationMethod, c5.focalPointRatio);
                                break;
                            case DrawCommandType$1.LINE_BITMAP_STYLE:
                                var c6 = data.readLineBitmapStyle();
                                if (!hasLineStyle && (initStrokeX != 0 || initStrokeY != 0)) {
                                    this.strokeCommands.moveTo(initStrokeX, initStrokeY);
                                    initStrokeX = 0;
                                    initStrokeY = 0;
                                }
                                hasLineStyle = true;
                                this.strokeCommands.lineBitmapStyle(c6.bitmap, c6.matrix, c6.repeat, c6.smooth);
                                break;
                            case DrawCommandType$1.LINE_STYLE:
                                var c7 = data.readLineStyle();
                                if (!hasLineStyle && c7.thickness != null) {
                                    if (initStrokeX != 0 || initStrokeY != 0) {
                                        this.strokeCommands.moveTo(initStrokeX, initStrokeY);
                                        initStrokeX = 0;
                                        initStrokeY = 0;
                                    }
                                }
                                hasLineStyle = c7.thickness != null;
                                this.strokeCommands.lineStyle(c7.thickness, c7.color, c7.alpha, c7.pixelHinting, c7.scaleMode, c7.caps, c7.joints, c7.miterLimit);
                                break;
                            case DrawCommandType$1.BEGIN_BITMAP_FILL:
                            case DrawCommandType$1.BEGIN_FILL:
                            case DrawCommandType$1.BEGIN_GRADIENT_FILL:
                            case DrawCommandType$1.BEGIN_SHADER_FILL:
                                this.endFill();
                                this.endStroke();
                                if (type == DrawCommandType$1.BEGIN_BITMAP_FILL) {
                                    var c8 = data.readBeginBitmapFill();
                                    this.fillCommands.beginBitmapFill(c8.bitmap, c8.matrix, c8.repeat, c8.smooth);
                                    this.strokeCommands.beginBitmapFill(c8.bitmap, c8.matrix, c8.repeat, c8.smooth);
                                }
                                else if (type == DrawCommandType$1.BEGIN_GRADIENT_FILL) {
                                    var c9 = data.readBeginGradientFill();
                                    this.fillCommands.beginGradientFill(c9.type, c9.colors, c9.alphas, c9.ratios, c9.matrix, c9.spreadMethod, c9.interpolationMethod, c9.focalPointRatio);
                                    this.strokeCommands.beginGradientFill(c9.type, c9.colors, c9.alphas, c9.ratios, c9.matrix, c9.spreadMethod, c9.interpolationMethod, c9.focalPointRatio);
                                }
                                else if (type == DrawCommandType$1.BEGIN_SHADER_FILL) {
                                    var c10 = data.readBeginShaderFill();
                                    this.fillCommands.beginShaderFill(c10.shaderBuffer);
                                    this.strokeCommands.beginShaderFill(c10.shaderBuffer);
                                }
                                else {
                                    var c11 = data.readBeginFill();
                                    this.fillCommands.beginFill(c11.color, c11.alpha);
                                    this.strokeCommands.beginFill(c11.color, c11.alpha);
                                }
                                break;
                            case DrawCommandType$1.DRAW_CIRCLE:
                                var c12 = data.readDrawCircle();
                                this.fillCommands.drawCircle(c12.x, c12.y, c12.radius);
                                if (hasLineStyle) {
                                    this.strokeCommands.drawCircle(c12.x, c12.y, c12.radius);
                                }
                                break;
                            case DrawCommandType$1.DRAW_ELLIPSE:
                                var c13 = data.readDrawEllipse();
                                this.fillCommands.drawEllipse(c13.x, c13.y, c13.width, c13.height);
                                if (hasLineStyle) {
                                    this.strokeCommands.drawEllipse(c13.x, c13.y, c13.width, c13.height);
                                }
                                break;
                            case DrawCommandType$1.DRAW_RECT:
                                var c14 = data.readDrawRect();
                                this.fillCommands.drawRect(c14.x, c14.y, c14.width, c14.height);
                                if (hasLineStyle) {
                                    this.strokeCommands.drawRect(c14.x, c14.y, c14.width, c14.height);
                                }
                                break;
                            case DrawCommandType$1.DRAW_ROUND_RECT:
                                var c15 = data.readDrawRoundRect();
                                this.fillCommands.drawRoundRect(c15.x, c15.y, c15.width, c15.height, c15.ellipseWidth, c15.ellipseHeight);
                                if (hasLineStyle) {
                                    this.strokeCommands.drawRoundRect(c15.x, c15.y, c15.width, c15.height, c15.ellipseWidth, c15.ellipseHeight);
                                }
                                break;
                            case DrawCommandType$1.DRAW_QUADS:
                                var c16 = data.readDrawQuads();
                                this.fillCommands.drawQuads(c16.rects, c16.indices, c16.transforms);
                                break;
                            case DrawCommandType$1.DRAW_TRIANGLES:
                                var c17 = data.readDrawTriangles();
                                this.fillCommands.drawTriangles(c17.vertices, c17.indices, c17.uvtData, c17.culling);
                                break;
                            case DrawCommandType$1.OVERRIDE_BLEND_MODE:
                                var c18 = data.readOverrideBlendMode();
                                renderer.__setBlendModeContext(this.context, c18.blendMode);
                                break;
                            case DrawCommandType$1.WINDING_EVEN_ODD:
                                data.readWindingEvenOdd();
                                this.fillCommands.windingEvenOdd();
                                this.windingRule = CanvasWindingRule.EVENODD;
                                break;
                            case DrawCommandType$1.WINDING_NON_ZERO:
                                data.readWindingNonZero();
                                this.fillCommands.windingNonZero();
                                this.windingRule = CanvasWindingRule.NONZERO;
                                break;
                            default:
                                data.skip(type);
                        }
                    }
                    if (this.fillCommands.length > 0) {
                        this.endFill();
                    }
                    if (this.strokeCommands.length > 0) {
                        this.endStroke();
                    }
                    data.destroy();
                    graphics.__bitmap = BitmapData.fromCanvas(graphics.__renderData.canvas);
                }
                graphics.__softwareDirty = false;
                graphics.__dirty = false;
            }
        }
        static renderMask(graphics, renderer) {
            // TODO: Move to normal render method, browsers appear to support more than
            // one path in clipping now
            if (graphics.__commands.length != 0) {
                this.context = renderer.context;
                this.context.beginPath();
                var positionX = 0.0;
                var positionY = 0.0;
                var offsetX = 0;
                var offsetY = 0;
                var data = new DrawCommandReader(graphics.__commands);
                var x, y, width, height, kappa = .5522848, ox, oy, xe, ye, xm, ym;
                for (let type of graphics.__commands.types) {
                    switch (type) {
                        case DrawCommandType$1.CUBIC_CURVE_TO:
                            var c = data.readCubicCurveTo();
                            this.context.bezierCurveTo(c.controlX1
                                - offsetX, c.controlY1
                                - offsetY, c.controlX2
                                - offsetX, c.controlY2
                                - offsetY, c.anchorX
                                - offsetX, c.anchorY
                                - offsetY);
                            positionX = c.anchorX;
                            positionY = c.anchorY;
                            break;
                        case DrawCommandType$1.CURVE_TO:
                            var c2 = data.readCurveTo();
                            this.context.quadraticCurveTo(c2.controlX - offsetX, c2.controlY - offsetY, c2.anchorX - offsetX, c2.anchorY - offsetY);
                            positionX = c2.anchorX;
                            positionY = c2.anchorY;
                            break;
                        case DrawCommandType$1.DRAW_CIRCLE:
                            var c3 = data.readDrawCircle();
                            this.context.arc(c3.x - offsetX, c3.y - offsetY, c3.radius, 0, Math.PI * 2, true);
                            break;
                        case DrawCommandType$1.DRAW_ELLIPSE:
                            var c4 = data.readDrawEllipse();
                            x = c4.x;
                            y = c4.y;
                            width = c4.width;
                            height = c4.height;
                            x -= offsetX;
                            y -= offsetY;
                            ox = (width / 2) * kappa; // control point offset horizontal
                            oy = (height / 2) * kappa; // control point offset vertical
                            xe = x + width; // x-end
                            ye = y + height; // y-end
                            xm = x + width / 2; // x-middle
                            ym = y + height / 2; // y-middle
                            // closePath (false);
                            // beginPath ();
                            this.context.moveTo(x, ym);
                            this.context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                            this.context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                            this.context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                            this.context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                            // closePath (false);
                            break;
                        case DrawCommandType$1.DRAW_RECT:
                            var c5 = data.readDrawRect();
                            // context.beginPath();
                            this.context.rect(c5.x - offsetX, c5.y - offsetY, c5.width, c5.height);
                            // context.closePath();
                            break;
                        case DrawCommandType$1.DRAW_ROUND_RECT:
                            var c6 = data.readDrawRoundRect();
                            this.drawRoundRect(c6.x - offsetX, c6.y - offsetY, c6.width, c6.height, c6.ellipseWidth, c6.ellipseHeight);
                            break;
                        case DrawCommandType$1.LINE_TO:
                            var c7 = data.readLineTo();
                            this.context.lineTo(c7.x - offsetX, c7.y - offsetY);
                            positionX = c7.x;
                            positionY = c7.y;
                            break;
                        case DrawCommandType$1.MOVE_TO:
                            var c8 = data.readMoveTo();
                            this.context.moveTo(c8.x - offsetX, c8.y - offsetY);
                            positionX = c8.x;
                            positionY = c8.y;
                            break;
                        default:
                            data.skip(type);
                    }
                }
                this.context.closePath();
                data.destroy();
            }
        }
        static setSmoothing(smooth) {
            if (!this.allowSmoothing) {
                smooth = false;
            }
            if (this.context.imageSmoothingEnabled != smooth) {
                this.context.imageSmoothingEnabled = smooth;
            }
        }
    }
    CanvasGraphics.SIN45 = 0.70710678118654752440084436210485;
    CanvasGraphics.TAN22 = 0.4142135623730950488016887242097;
    CanvasGraphics.fillCommands = new DrawCommandBuffer();
    CanvasGraphics.strokeCommands = new DrawCommandBuffer();
    CanvasGraphics.hitTestCanvas = document.createElement("canvas");
    CanvasGraphics.hitTestContext = CanvasGraphics.hitTestCanvas.getContext("2d");
    return CanvasGraphics;
})();

var GraphicsDataType;
(function (GraphicsDataType) {
    GraphicsDataType[GraphicsDataType["STROKE"] = 0] = "STROKE";
    GraphicsDataType[GraphicsDataType["SOLID"] = 1] = "SOLID";
    GraphicsDataType[GraphicsDataType["GRADIENT"] = 2] = "GRADIENT";
    GraphicsDataType[GraphicsDataType["PATH"] = 3] = "PATH";
    GraphicsDataType[GraphicsDataType["BITMAP"] = 4] = "BITMAP";
    GraphicsDataType[GraphicsDataType["END"] = 5] = "END";
    GraphicsDataType[GraphicsDataType["QUAD_PATH"] = 6] = "QUAD_PATH";
    GraphicsDataType[GraphicsDataType["TRIANGLE_PATH"] = 7] = "TRIANGLE_PATH";
    GraphicsDataType[GraphicsDataType["SHADER"] = 8] = "SHADER";
})(GraphicsDataType || (GraphicsDataType = {}));
var GraphicsDataType$1 = GraphicsDataType;

var GraphicsFillType;
(function (GraphicsFillType) {
    GraphicsFillType[GraphicsFillType["SOLID_FILL"] = 0] = "SOLID_FILL";
    GraphicsFillType[GraphicsFillType["GRADIENT_FILL"] = 1] = "GRADIENT_FILL";
    GraphicsFillType[GraphicsFillType["BITMAP_FILL"] = 2] = "BITMAP_FILL";
    GraphicsFillType[GraphicsFillType["END_FILL"] = 3] = "END_FILL";
    GraphicsFillType[GraphicsFillType["SHADER_FILL"] = 4] = "SHADER_FILL";
})(GraphicsFillType || (GraphicsFillType = {}));
var GraphicsFillType$1 = GraphicsFillType;

class ShaderBuffer {
    constructor() {
        this.inputRefs = [];
        this.inputFilter = [];
        this.inputMipFilter = [];
        this.inputs = [];
        this.inputWrap = [];
        // overrideNames = [];
        // overrideValues = [];
        this.overrideIntNames = [];
        this.overrideIntValues = [];
        this.overrideFloatNames = [];
        this.overrideFloatValues = [];
        this.overrideBoolNames = [];
        this.overrideBoolValues = [];
        this.paramLengths = [];
        this.paramPositions = [];
        this.paramRefs_Bool = [];
        this.paramRefs_Float = [];
        this.paramRefs_Int = [];
        this.paramTypes = [];
    }
    addBoolOverride(name, values) {
        this.overrideBoolNames[this.overrideBoolCount] = name;
        this.overrideBoolValues[this.overrideBoolCount] = values;
        this.overrideBoolCount++;
    }
    addFloatOverride(name, values) {
        this.overrideFloatNames[this.overrideFloatCount] = name;
        this.overrideFloatValues[this.overrideFloatCount] = values;
        this.overrideFloatCount++;
    }
    addIntOverride(name, values) {
        this.overrideIntNames[this.overrideIntCount] = name;
        this.overrideIntValues[this.overrideIntCount] = values;
        this.overrideIntCount++;
    }
    clearOverride() {
        // overrideCount = 0;
        this.overrideIntCount = 0;
        this.overrideFloatCount = 0;
        this.overrideBoolCount = 0;
    }
    update(shader) {
        this.inputCount = 0;
        // overrideCount = 0;
        this.overrideIntCount = 0;
        this.overrideFloatCount = 0;
        this.overrideBoolCount = 0;
        this.paramBoolCount = 0;
        this.paramCount = 0;
        this.paramDataLength = 0;
        this.paramFloatCount = 0;
        this.paramIntCount = 0;
        this.shader = null;
        if (shader == null)
            return;
        shader.__init();
        this.inputCount = shader.__inputBitmapData.length;
        var input;
        for (let i = 0; i < this.inputCount; i++) {
            input = shader.__inputBitmapData[i];
            this.inputs[i] = input.input;
            this.inputFilter[i] = input.filter;
            this.inputMipFilter[i] = input.mipFilter;
            this.inputRefs[i] = input;
            this.inputWrap[i] = input.wrap;
        }
        var boolCount = shader.__paramBool.length;
        var floatCount = shader.__paramFloat.length;
        var intCount = shader.__paramInt.length;
        this.paramCount = boolCount + floatCount + intCount;
        this.paramBoolCount = boolCount;
        this.paramFloatCount = floatCount;
        this.paramIntCount = intCount;
        var length = 0, p = 0;
        var param;
        for (let i = 0; i < boolCount; i++) {
            param = shader.__paramBool[i];
            this.paramPositions[p] = this.paramDataLength;
            length = (param.value != null ? param.value.length : 0);
            this.paramLengths[p] = length;
            this.paramDataLength += length;
            this.paramTypes[p] = 0;
            this.paramRefs_Bool[i] = param;
            p++;
        }
        var param;
        for (let i = 0; i < floatCount; i++) {
            param = shader.__paramFloat[i];
            this.paramPositions[p] = this.paramDataLength;
            length = (param.value != null ? param.value.length : 0);
            this.paramLengths[p] = length;
            this.paramDataLength += length;
            this.paramTypes[p] = 1;
            this.paramRefs_Float[i] = param;
            p++;
        }
        var param;
        for (let i = 0; i < intCount; i++) {
            param = shader.__paramInt[i];
            this.paramPositions[p] = this.paramDataLength;
            length = (param.value != null ? param.value.length : 0);
            this.paramLengths[p] = length;
            this.paramDataLength += length;
            this.paramTypes[p] = 2;
            this.paramRefs_Int[i] = param;
            p++;
        }
        if (this.paramDataLength > 0) {
            if (this.paramData == null) {
                this.paramData = new Float32Array(this.paramDataLength);
            }
            else if (this.paramDataLength > this.paramData.length) {
                var data = new Float32Array(this.paramDataLength);
                data.set(this.paramData);
                this.paramData = data;
            }
        }
        var boolIndex = 0;
        var floatIndex = 0;
        var intIndex = 0;
        var paramPosition = 0;
        var boolParam, floatParam, intParam;
        for (let i = 0; i < this.paramCount; i++) {
            length = this.paramLengths[i];
            if (i < boolCount) {
                boolParam = this.paramRefs_Bool[boolIndex];
                boolIndex++;
                for (let j = 0; j < length; j++) {
                    this.paramData[paramPosition] = boolParam.value[j] ? 1 : 0;
                    paramPosition++;
                }
            }
            else if (i < boolCount + floatCount) {
                floatParam = this.paramRefs_Float[floatIndex];
                floatIndex++;
                for (let j = 0; j < length; j++) {
                    this.paramData[paramPosition] = floatParam.value[j];
                    paramPosition++;
                }
            }
            else {
                intParam = this.paramRefs_Int[intIndex];
                intIndex++;
                for (let j = 0; j < length; j++) {
                    this.paramData[paramPosition] = intParam.value[j];
                    paramPosition++;
                }
            }
        }
        this.shader = shader;
    }
}

/**
    Defines a bitmap fill. The bitmap can be smoothed, repeated or tiled to
    fill the area; or manipulated using a transformation matrix.
    Use a GraphicsBitmapFill object with the `Graphics.drawGraphicsData()`
    method. Drawing a GraphicsBitmapFill object is the equivalent of calling
    the `Graphics.beginBitmapFill()` method.
**/
class GraphicsBitmapFill {
    /**
        Creates a new GraphicsBitmapFill object.

        @param bitmapData A transparent or opaque bitmap image that contains
                          the bits to display.
        @param matrix     A matrix object (of the openfl.geom.Matrix class),
                          which you use to define transformations on the
                          bitmap.
        @param repeat     If `true`, the bitmap image repeats in a tiled
                          pattern. If `false`, the bitmap image does not
                          repeat, and the edges of the bitmap are used for any
                          fill area that extends beyond the bitmap.
        @param smooth     If `false`, upscaled bitmap images are rendered
                          using a nearest-neighbor algorithm and appear
                          pixelated. If `true`, upscaled bitmap images are
                          rendered using a bilinear algorithm. Rendering that
                          uses the nearest-neighbor algorithm is usually
                          faster.
    **/
    constructor(bitmapData = null, matrix = null, repeat = true, smooth = false) {
        this.bitmapData = bitmapData;
        this.matrix = matrix;
        this.repeat = repeat;
        this.smooth = smooth;
        this.__graphicsDataType = GraphicsDataType$1.BITMAP;
        this.__graphicsFillType = GraphicsFillType$1.BITMAP_FILL;
    }
}

/**
    Indicates the end of a graphics fill. Use a GraphicsEndFill object with the
    `Graphics.drawGraphicsData()` method.

    Drawing a GraphicsEndFill object is the equivalent of calling the
    `Graphics.endFill()` method.
**/
class GraphicsEndFill {
    /**
        Creates an object to use with the `Graphics.drawGraphicsData()`
        method to end the fill, explicitly.
    **/
    constructor() {
        this.__graphicsDataType = GraphicsDataType$1.END;
        this.__graphicsFillType = GraphicsFillType$1.END_FILL;
    }
}

var openfl$d;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The InterpolationMethod class provides values for the
            `interpolationMethod` parameter in the
            `Graphics.beginGradientFill()` and
            `Graphics.lineGradientStyle()` methods. This parameter
            determines the RGB space to use when rendering the gradient.
        **/
        let InterpolationMethod;
        (function (InterpolationMethod) {
            /**
                Specifies that the RGB interpolation method should be used. This means
                that the gradient is rendered with exponential sRGB(standard RGB) space.
                The sRGB space is a W3C-endorsed standard that defines a non-linear
                conversion between red, green, and blue component values and the actual
                intensity of the visible component color.
    
                For example, consider a simple linear gradient between two colors(with
                the `spreadMethod` parameter set to
                `SpreadMethod.REFLECT`). The different interpolation methods
                affect the appearance as follows:
            **/
            InterpolationMethod["LINEAR_RGB"] = "linearRGB";
            /**
                Specifies that the RGB interpolation method should be used. This means
                that the gradient is rendered with exponential sRGB(standard RGB) space.
                The sRGB space is a W3C-endorsed standard that defines a non-linear
                conversion between red, green, and blue component values and the actual
                intensity of the visible component color.
    
                For example, consider a simple linear gradient between two colors(with
                the `spreadMethod` parameter set to
                `SpreadMethod.REFLECT`). The different interpolation methods
                affect the appearance as follows:
            **/
            InterpolationMethod["RGB"] = "rgb";
        })(InterpolationMethod = display.InterpolationMethod || (display.InterpolationMethod = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$d || (openfl$d = {}));
var InterpolationMethod = openfl$d.display.InterpolationMethod;

var openfl$e;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The SpreadMethod class provides values for the `spreadMethod`
            parameter in the `beginGradientFill()` and
            `lineGradientStyle()` methods of the Graphics class.
        
            The following example shows the same gradient fill using various spread
            methods:
        **/
        let SpreadMethod;
        (function (SpreadMethod) {
            /**
                Specifies that the gradient use the _pad_ spread method.
            **/
            SpreadMethod["PAD"] = "pad";
            /**
                Specifies that the gradient use the _reflect_ spread method.
            **/
            SpreadMethod["REFLECT"] = "reflect";
            /**
                Specifies that the gradient use the _repeat_ spread method.
            **/
            SpreadMethod["REPEAT"] = "repeat";
        })(SpreadMethod = display.SpreadMethod || (display.SpreadMethod = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$e || (openfl$e = {}));
var SpreadMethod = openfl$e.display.SpreadMethod;

/**
    Defines a gradient fill.
    Use a GraphicsGradientFill object with the `Graphics.drawGraphicsData()`
    method. Drawing a GraphicsGradientFill object is the equivalent of calling
    the `Graphics.beginGradientFill()` method.
**/
class GraphicsGradientFill {
    /**
        Creates a new GraphicsGradientFill object.

        @param type                A value from the GradientType class that
                                   specifies which gradient type to use:
                                   `GradientType.LINEAR` or
                                   `GradientType.RADIAL`.
        @param matrix              A transformation matrix as defined by the
                                   openfl.geom.Matrix class. The
                                   openfl.geom.Matrix class includes a
                                   `createGradientBox()` method, which lets
                                   you conveniently set up the matrix for use
                                   with the `beginGradientFill()` method.
        @param spreadMethod        A value from the SpreadMethod class that
                                   specifies which spread method to use,
                                   either: `SpreadMethod.PAD`,
                                   `SpreadMethod.REFLECT`, or
                                   `SpreadMethod.REPEAT`.
        @param interpolationMethod A value from the InterpolationMethod class
                                   that specifies which value to use:
                                   `InterpolationMethod.LINEAR_RGB` or
                                   `InterpolationMethod.RGB`
        @param focalPointRatio     A number that controls the location of the
                                   focal point of the gradient. A value of 0
                                   sets the focal point in the center. A value
                                   of 1 sets the focal point at one border of
                                   the gradient circle. A value of -1 sets the
                                   focal point at the other border of the
                                   gradient circle. A value less than -1 or
                                   greater than 1 is rounded to -1 or 1,
                                   respectively.
    **/
    constructor(type = null, colors = null, alphas = null, ratios = null, matrix = null, spreadMethod = null, interpolationMethod = null, focalPointRatio = 0) {
        if (type == null) {
            type = GradientType.LINEAR;
        }
        if (spreadMethod == null) {
            spreadMethod = SpreadMethod.PAD;
        }
        if (interpolationMethod == null) {
            interpolationMethod = InterpolationMethod.RGB;
        }
        this.type = type;
        this.colors = colors;
        this.alphas = alphas;
        this.ratios = ratios;
        this.matrix = matrix;
        this.spreadMethod = spreadMethod;
        this.interpolationMethod = interpolationMethod;
        this.focalPointRatio = focalPointRatio;
        this.__graphicsDataType = GraphicsDataType$1.GRADIENT;
        this.__graphicsFillType = GraphicsFillType$1.GRADIENT_FILL;
    }
}

var openfl$f;
(function (openfl) {
    var display;
    (function (display) {
        /**
            Defines the values to use for specifying path-drawing commands.
    
            The values in this class are used by the
            `Graphics.drawPath()` method, or stored in the
            `commands` vector of a GraphicsPath object.
        **/
        let GraphicsPathCommand;
        (function (GraphicsPathCommand) {
            /**
                Specifies a drawing command that draws a curve from the current drawing position
                to the x- and y-coordinates specified in the data vector, using a 2 control points.
            **/
            GraphicsPathCommand[GraphicsPathCommand["CUBIC_CURVE_TO"] = 6] = "CUBIC_CURVE_TO";
            /**
                Specifies a drawing command that draws a curve from the current drawing position
                to the x- and y-coordinates specified in the data vector, using a control point.
                This command produces the same effect as the `Graphics.lineTo()` method, and uses
                two points in the data vector control and anchor: (cx, cy, ax, ay).
            **/
            GraphicsPathCommand[GraphicsPathCommand["CURVE_TO"] = 3] = "CURVE_TO";
            /**
                Specifies a drawing command that draws a line from the current drawing position to
                the x- and y-coordinates specified in the data vector. This command produces the
                same effect as the `Graphics.lineTo()` method, and uses one point in the data
                vector: (x,y).
            **/
            GraphicsPathCommand[GraphicsPathCommand["LINE_TO"] = 2] = "LINE_TO";
            /**
                Specifies a drawing command that moves the current drawing position to the x- and
                y-coordinates specified in the data vector. This command produces the same effect as
                the `Graphics.moveTo()` method, and uses one point in the data vector: (x,y).
            **/
            GraphicsPathCommand[GraphicsPathCommand["MOVE_TO"] = 1] = "MOVE_TO";
            /**
                Represents the default "do nothing" command.
            **/
            GraphicsPathCommand[GraphicsPathCommand["NO_OP"] = 0] = "NO_OP";
            /**
                Specifies a "line to" drawing command, but uses two sets of coordinates (four
                values) instead of one set. This command allows you to switch between "line to"
                and "curve to" commands without changing the number of data values used per command.
                This command uses two sets in the data vector: one dummy location and one (x,y)
                location.
    
                The `WIDE_LINE_TO` and `WIDE_MOVE_TO` command variants consume the same number of
                parameters as does the `CURVE_TO` command.
            **/
            GraphicsPathCommand[GraphicsPathCommand["WIDE_LINE_TO"] = 5] = "WIDE_LINE_TO";
            /**
                Specifies a "move to" drawing command, but uses two sets of coordinates (four
                values) instead of one set. This command allows you to switch between "move to"
                and "curve to" commands without changing the number of data values used per
                command. This command uses two sets in the data vector: one dummy location and one
                (x,y) location.
    
                The `WIDE_LINE_TO` and `WIDE_MOVE_TO` command variants consume the same number of
                parameters as does the `CURVE_TO` command.
            **/
            GraphicsPathCommand[GraphicsPathCommand["WIDE_MOVE_TO"] = 4] = "WIDE_MOVE_TO";
        })(GraphicsPathCommand = display.GraphicsPathCommand || (display.GraphicsPathCommand = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$f || (openfl$f = {}));
var GraphicsPathCommand = openfl$f.display.GraphicsPathCommand;

var openfl$g;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The GraphicsPathWinding class provides values for the
            `openfl.display.GraphicsPath.winding` property and the
            `openfl.display.Graphics.drawPath()` method to determine the
            direction to draw a path. A clockwise path is positively wound, and a
            counter-clockwise path is negatively wound:
        
            ![positive and negative winding directions](/images/winding_positive_negative.gif)
        
            When paths intersect or overlap, the winding direction determines the
            rules for filling the areas created by the intersection or overlap:
        
            ![a comparison of even-odd and non-zero winding rules](/images/winding_rules_evenodd_nonzero.gif)
        **/
        let GraphicsPathWinding;
        (function (GraphicsPathWinding) {
            /**
                Establishes the even-odd winding type. The even-odd winding type is the rule
                used by all of the original drawing API and is the default type for the
                `openfl.display.Graphics.drawPath()` method. Any overlapping paths will
                alternate between open and closed fills. If two squares drawn with the same
                fill intersect, the area of the intersection is not filled. Adjacent areas are not
                the same (neither both filled nor both unfilled).
            **/
            GraphicsPathWinding["EVEN_ODD"] = "evenOdd";
            /**
                Establishes the non-zero winding type. The non-zero winding type determines that
                when paths of opposite winding intersect, the intersection area is unfilled
                (as with the even-odd winding type). For paths of the same winding, the
                intersection area is filled.
            **/
            GraphicsPathWinding["NON_ZERO"] = "nonZero";
        })(GraphicsPathWinding = display.GraphicsPathWinding || (display.GraphicsPathWinding = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$g || (openfl$g = {}));
var GraphicsPathWinding = openfl$g.display.GraphicsPathWinding;

/**
    A collection of drawing commands and the coordinate parameters for those
    commands.

    Use a GraphicsPath object with the
    `Graphics.drawGraphicsData()` method. Drawing a GraphicsPath
    object is the equivalent of calling the `Graphics.drawPath()`
    method.

    The GraphicsPath class also has its own set of methods
    (`curveTo()`, `lineTo()`, `moveTo()`
    `wideLineTo()` and `wideMoveTo()`) similar to those
    in the Graphics class for making adjustments to the
    `GraphicsPath.commands` and `GraphicsPath.data`
    vector arrays.
**/
let GraphicsPath = /** @class */ (() => {
    class GraphicsPath {
        /**
            Creates a new GraphicsPath object.
    
            @param winding Specifies the winding rule using a value defined in the
                            GraphicsPathWinding class.
        **/
        constructor(commands = null, data = null, winding = GraphicsPathWinding.EVEN_ODD) {
            this.commands = commands;
            this.data = data;
            this.winding = winding;
            this.__graphicsDataType = GraphicsDataType$1.PATH;
        }
        /**
            Adds a new "cubicCurveTo" command to the commands vector and new coordinates to
            the data vector.
    
            @param	controlX1	A number that specifies the horizontal position of the first
            control point relative to the registration point of the parent display object.
            @param	controlY1	A number that specifies the vertical position of the first
            control point relative to the registration point of the parent display object.
            @param	controlX2	A number that specifies the horizontal position of the second
            control point relative to the registration point of the parent display object.
            @param	controlY2	A number that specifies the vertical position of the second
            control point relative to the registration point of the parent display object.
            @param	anchorX	A number that specifies the horizontal position of the next anchor
            point relative to the registration point of the parent display object.
            @param	anchorY	A number that specifies the vertical position of the next anchor
            point relative to the registration point of the parent display object.
        **/
        cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
            if (this.commands == null)
                this.commands = new Vector();
            if (this.data == null)
                this.data = new Vector();
            this.commands.push(GraphicsPathCommand.CUBIC_CURVE_TO);
            var data = this.data;
            data.push(controlX1);
            data.push(controlY1);
            data.push(controlX2);
            data.push(controlY2);
            data.push(anchorX);
            data.push(anchorY);
        }
        /**
            Adds a new "curveTo" command to the `commands` vector and new
            coordinates to the `data` vector.
    
            @param controlX A number that specifies the horizontal position of the
                            control point relative to the registration point of the
                            parent display object.
            @param controlY A number that specifies the vertical position of the
                            control point relative to the registration point of the
                            parent display object.
            @param anchorX  A number that specifies the horizontal position of the
                            next anchor point relative to the registration point of
                            the parent display object.
            @param anchorY  A number that specifies the vertical position of the next
                            anchor point relative to the registration point of the
                            parent display object.
        **/
        curveTo(controlX, controlY, anchorX, anchorY) {
            if (this.commands == null)
                this.commands = new Vector();
            if (this.data == null)
                this.data = new Vector();
            this.commands.push(GraphicsPathCommand.CURVE_TO);
            var data = this.data;
            data.push(controlX);
            data.push(controlY);
            data.push(anchorX);
            data.push(anchorY);
        }
        /**
            Adds a new "lineTo" command to the `commands` vector and new
            coordinates to the `data` vector.
    
            @param x The x coordinate of the destination point for the line.
            @param y The y coordinate of the destination point for the line.
        **/
        lineTo(x, y) {
            if (this.commands == null)
                this.commands = new Vector();
            if (this.data == null)
                this.data = new Vector();
            this.commands.push(GraphicsPathCommand.LINE_TO);
            this.data.push(x);
            this.data.push(y);
        }
        /**
            Adds a new "moveTo" command to the `commands` vector and new
            coordinates to the `data` vector.
    
            @param x The x coordinate of the destination point.
            @param y The y coordinate of the destination point.
        **/
        moveTo(x, y) {
            if (this.commands == null)
                this.commands = new Vector();
            if (this.data == null)
                this.data = new Vector();
            this.commands.push(GraphicsPathCommand.MOVE_TO);
            this.data.push(x);
            this.data.push(y);
        }
        /**
            Adds a new "wideLineTo" command to the `commands` vector and
            new coordinates to the `data` vector.
    
            @param x The x-coordinate of the destination point for the line.
            @param y The y-coordinate of the destination point for the line.
        **/
        wideLineTo(x, y) {
            if (this.commands == null)
                this.commands = new Vector();
            if (this.data == null)
                this.data = new Vector();
            this.commands.push(GraphicsPathCommand.LINE_TO);
            this.data.push(x);
            this.data.push(y);
        }
        /**
            Adds a new "wideMoveTo" command to the `commands` vector and
            new coordinates to the `data` vector.
    
            @param x The x-coordinate of the destination point.
            @param y The y-coordinate of the destination point.
        **/
        wideMoveTo(x, y) {
            if (this.commands == null)
                this.commands = new Vector();
            if (this.data == null)
                this.data = new Vector();
            this.commands.push(GraphicsPathCommand.MOVE_TO);
            this.data.push(x);
            this.data.push(y);
        }
        __drawCircle(x, y, radius) {
            this.__drawRoundRect(x - radius, y - radius, radius * 2, radius * 2, radius * 2, radius * 2);
        }
        __drawEllipse(x, y, width, height) {
            this.__drawRoundRect(x, y, width, height, width, height);
        }
        __drawRect(x, y, width, height) {
            this.moveTo(x, y);
            this.lineTo(x + width, y);
            this.lineTo(x + width, y + height);
            this.lineTo(x, y + height);
            this.lineTo(x, y);
        }
        __drawRoundRect(x, y, width, height, ellipseWidth, ellipseHeight) {
            ellipseWidth *= 0.5;
            ellipseHeight *= 0.5;
            if (ellipseWidth > width / 2)
                ellipseWidth = width / 2;
            if (ellipseHeight > height / 2)
                ellipseHeight = height / 2;
            var xe = x + width, ye = y + height, cx1 = -ellipseWidth + (ellipseWidth * GraphicsPath.SIN45), cx2 = -ellipseWidth + (ellipseWidth * GraphicsPath.TAN22), cy1 = -ellipseHeight + (ellipseHeight * GraphicsPath.SIN45), cy2 = -ellipseHeight + (ellipseHeight * GraphicsPath.TAN22);
            this.moveTo(xe, ye - ellipseHeight);
            this.curveTo(xe, ye + cy2, xe + cx1, ye + cy1);
            this.curveTo(xe + cx2, ye, xe - ellipseWidth, ye);
            this.lineTo(x + ellipseWidth, ye);
            this.curveTo(x - cx2, ye, x - cx1, ye + cy1);
            this.curveTo(x, ye + cy2, x, ye - ellipseHeight);
            this.lineTo(x, y + ellipseHeight);
            this.curveTo(x, y - cy2, x - cx1, y - cy1);
            this.curveTo(x - cx2, y, x + ellipseWidth, y);
            this.lineTo(xe - ellipseWidth, y);
            this.curveTo(xe + cx2, y, xe + cx1, y - cy1);
            this.curveTo(xe, y - cy2, xe, y + ellipseHeight);
            this.lineTo(xe, ye - ellipseHeight);
        }
    }
    GraphicsPath.SIN45 = 0.70710678118654752440084436210485;
    GraphicsPath.TAN22 = 0.4142135623730950488016887242097;
    return GraphicsPath;
})();

/**
    Defines a solid fill.

    Use a GraphicsSolidFill object with the
    `Graphics.drawGraphicsData()` method. Drawing a
    GraphicsSolidFill object is the equivalent of calling the
    `Graphics.beginFill()` method.
**/
class GraphicsSolidFill {
    /**
        Creates a new GraphicsSolidFill object.

        @param color The color value. Valid values are in the hexadecimal format
                     0xRRGGBB.
        @param alpha The alpha transparency value. Valid values are 0(fully
                     transparent) to 1(fully opaque).
    **/
    constructor(color = 0, alpha = 1) {
        this.alpha = alpha;
        this.color = color;
        this.__graphicsDataType = GraphicsDataType$1.SOLID;
        this.__graphicsFillType = GraphicsFillType$1.SOLID_FILL;
    }
}

var openfl$h;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The JointStyle class is an enumeration of constant values that specify the
            joint style to use in drawing lines. These constants are provided for use
            as values in the `joints` parameter of the
            `openfl.display.Graphics.lineStyle()` method. The method supports
            three types of joints: miter, round, and bevel, as the following example
            shows:
        **/
        let JointStyle;
        (function (JointStyle) {
            /**
                Specifies beveled joints in the `joints` parameter of the
                `openfl.display.Graphics.lineStyle()` method.
            **/
            JointStyle["BEVEL"] = "bevel";
            /**
                Specifies mitered joints in the `joints` parameter of the
                `openfl.display.Graphics.lineStyle()` method.
            **/
            JointStyle["MITER"] = "miter";
            /**
                Specifies round joints in the `joints` parameter of the
                `openfl.display.Graphics.lineStyle()` method.
            **/
            JointStyle["ROUND"] = "round";
        })(JointStyle = display.JointStyle || (display.JointStyle = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$h || (openfl$h = {}));
var JointStyle = openfl$h.display.JointStyle;

var openfl$i;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The LineScaleMode class provides values for the `scaleMode`
            parameter in the `Graphics.lineStyle()` method.
        **/
        let LineScaleMode;
        (function (LineScaleMode) {
            /**
                With this setting used as the `scaleMode` parameter of the
                `lineStyle()` method, the thickness of the line scales
                _only_ vertically. For example, consider the following circles, drawn
                with a one-pixel line, and each with the `scaleMode` parameter
                set to `LineScaleMode.VERTICAL`. The circle on the left is
                scaled only vertically, and the circle on the right is scaled both
                vertically and horizontally.
            **/
            LineScaleMode["HORIZONTAL"] = "horizontal";
            /**
                With this setting used as the `scaleMode` parameter of the
                `lineStyle()` method, the thickness of the line never scales.
            **/
            LineScaleMode["NONE"] = "none";
            /**
                With this setting used as the `scaleMode` parameter of the
                `lineStyle()` method, the thickness of the line always scales
                when the object is scaled(the default).
            **/
            LineScaleMode["NORMAL"] = "normal";
            /**
                With this setting used as the `scaleMode` parameter of the
                `lineStyle()` method, the thickness of the line scales
                _only_ horizontally. For example, consider the following circles,
                drawn with a one-pixel line, and each with the `scaleMode`
                parameter set to `LineScaleMode.HORIZONTAL`. The circle on the
                left is scaled only horizontally, and the circle on the right is scaled
                both vertically and horizontally.
            **/
            LineScaleMode["VERTICAL"] = "vertical";
        })(LineScaleMode = display.LineScaleMode || (display.LineScaleMode = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$i || (openfl$i = {}));
var LineScaleMode = openfl$i.display.LineScaleMode;

/**
    Defines a line style or stroke.

    Use a GraphicsStroke object with the
    `Graphics.drawGraphicsData()` method. Drawing a GraphicsStroke
    object is the equivalent of calling one of the methods of the Graphics
    class that sets the line style, such as the
    `Graphics.lineStyle()` method, the
    `Graphics.lineBitmapStyle()` method, or the
    `Graphics.lineGradientStyle()` method.
**/
class GraphicsStroke {
    /**
        Creates a new GraphicsStroke object.

        @param pixelHinting A Boolean value that specifies whether to hint strokes
                            to full pixels. This affects both the position of
                            anchors of a curve and the line stroke size itself.
                            With `pixelHinting` set to
                            `true`, Flash Player hints line widths to
                            full pixel widths. With `pixelHinting` set
                            to `false`, disjoints can appear for curves
                            and straight lines. For example, the following
                            illustrations show how Flash Player renders two
                            rounded rectangles that are identical, except that the
                            `pixelHinting` parameter used in the
                            `lineStyle()` method is set differently
                           (the images are scaled by 200%, to emphasize the
                            difference):

                            If a value is not supplied, the line does not use
                            pixel hinting.
        @param scaleMode    A value from the LineScaleMode class that specifies
                            which scale mode to use:

                             *  `LineScaleMode.NORMAL` - Always
                            scale the line thickness when the object is scaled
                           (the default).
                             *  `LineScaleMode.NONE` - Never scale
                            the line thickness.
                             *  `LineScaleMode.VERTICAL` - Do not
                            scale the line thickness if the object is scaled
                            vertically _only_. For example, consider the
                            following circles, drawn with a one-pixel line, and
                            each with the `scaleMode` parameter set to
                            `LineScaleMode.VERTICAL`. The circle on the
                            left is scaled vertically only, and the circle on the
                            right is scaled both vertically and horizontally:

                             *  `LineScaleMode.HORIZONTAL` - Do not
                            scale the line thickness if the object is scaled
                            horizontally _only_. For example, consider the
                            following circles, drawn with a one-pixel line, and
                            each with the `scaleMode` parameter set to
                            `LineScaleMode.HORIZONTAL`. The circle on
                            the left is scaled horizontally only, and the circle
                            on the right is scaled both vertically and
                            horizontally:

        @param caps         A value from the CapsStyle class that specifies the
                            type of caps at the end of lines. Valid values are:
                            `CapsStyle.NONE`,
                            `CapsStyle.ROUND`, and
                            `CapsStyle.SQUARE`. If a value is not
                            indicated, Flash uses round caps.

                            For example, the following illustrations show the
                            different `capsStyle` settings. For each
                            setting, the illustration shows a blue line with a
                            thickness of 30(for which the `capsStyle`
                            applies), and a superimposed black line with a
                            thickness of 1(for which no `capsStyle`
                            applies):
        @param joints       A value from the JointStyle class that specifies the
                            type of joint appearance used at angles. Valid values
                            are: `JointStyle.BEVEL`,
                            `JointStyle.MITER`, and
                            `JointStyle.ROUND`. If a value is not
                            indicated, Flash uses round joints.

                            For example, the following illustrations show the
                            different `joints` settings. For each
                            setting, the illustration shows an angled blue line
                            with a thickness of 30(for which the
                            `jointStyle` applies), and a superimposed
                            angled black line with a thickness of 1(for which no
                            `jointStyle` applies):

                            **Note:** For `joints` set to
                            `JointStyle.MITER`, you can use the
                            `miterLimit` parameter to limit the length
                            of the miter.
    **/
    constructor(thickness = null, pixelHinting = false, scaleMode = LineScaleMode.NORMAL, caps = CapsStyle.NONE, joints = JointStyle.ROUND, miterLimit = 3, fill = null) {
        if (thickness == null)
            thickness = NaN;
        this.caps = caps;
        this.fill = fill;
        this.joints = joints;
        this.miterLimit = miterLimit;
        this.pixelHinting = pixelHinting;
        this.scaleMode = scaleMode;
        this.thickness = thickness;
        this.__graphicsDataType = GraphicsDataType$1.STROKE;
    }
}

// import openfl._internal.renderer.canvas.CanvasGraphics;
/**
    The Graphics class contains a set of methods that you can use to create a
    vector shape. Display objects that support drawing include Sprite and Shape
    objects. Each of these classes includes a `graphics` property
    that is a Graphics object. The following are among those helper functions
    provided for ease of use: `drawRect()`,
    `drawRoundRect()`, `drawCircle()`, and
    `drawEllipse()`.

    You cannot create a Graphics object directly from ActionScript code. If
    you call `new Graphics()`, an exception is thrown.

    The Graphics class is final; it cannot be subclassed.
**/
let Graphics = /** @class */ (() => {
    class Graphics {
        constructor(owner) {
            this.__owner = owner;
            this.__commands = new DrawCommandBuffer();
            this.__strokePadding = 0;
            this.__positionX = 0;
            this.__positionY = 0;
            this.__renderTransform = new Matrix();
            this.__usedShaderBuffers = new Array();
            this.__worldTransform = new Matrix();
            this.__width = 0;
            this.__height = 0;
            this.__renderData = new DisplayObjectRenderData();
            this.__shaderBufferPool = new ObjectPool(() => new ShaderBuffer());
            this.__setDirty();
            moveTo(0, 0);
        }
        /**
            Fills a drawing area with a bitmap image. The bitmap can be repeated or
            tiled to fill the area. The fill remains in effect until you call the
            `beginFill()`, `beginBitmapFill()`,
            `beginGradientFill()`, or `beginShaderFill()`
            method. Calling the `clear()` method clears the fill.
    
            The application renders the fill whenever three or more points are
            drawn, or when the `endFill()` method is called.
    
            @param bitmap A transparent or opaque bitmap image that contains the bits
                          to be displayed.
            @param matrix A matrix object(of the openfl.geom.Matrix class), which you
                          can use to define transformations on the bitmap. For
                          example, you can use the following matrix to rotate a bitmap
                          by 45 degrees(pi/4 radians):
    
            ```haxe
            matrix = new openfl.geom.Matrix();
                      matrix.rotate(Math.PI / 4);
                      ```
    
            @param repeat If `true`, the bitmap image repeats in a tiled
                          pattern. If `false`, the bitmap image does not
                          repeat, and the edges of the bitmap are used for any fill
                          area that extends beyond the bitmap.
    
                          For example, consider the following bitmap(a 20 x
                          20-pixel checkerboard pattern):
    
                          ![20 by 20 pixel checkerboard](/images/movieClip_beginBitmapFill_repeat_1.jpg)
    
                          When `repeat` is set to `true`(as
                          in the following example), the bitmap fill repeats the
                          bitmap:
    
                          ![60 by 60 pixel checkerboard](/images/movieClip_beginBitmapFill_repeat_2.jpg)
    
                          When `repeat` is set to `false`,
                          the bitmap fill uses the edge pixels for the fill area
                          outside the bitmap:
    
                          ![60 by 60 pixel image with no repeating](/images/movieClip_beginBitmapFill_repeat_3.jpg)
            @param smooth If `false`, upscaled bitmap images are rendered
                          by using a nearest-neighbor algorithm and look pixelated. If
                          `true`, upscaled bitmap images are rendered by
                          using a bilinear algorithm. Rendering by using the nearest
                          neighbor algorithm is faster.
        **/
        beginBitmapFill(bitmap, matrix = null, repeat = true, smooth = false) {
            this.__commands.beginBitmapFill(bitmap, matrix != null ? matrix.clone() : null, repeat, smooth);
            this.__visible = true;
        }
        /**
            Specifies a simple one-color fill that subsequent calls to other Graphics
            methods(such as `lineTo()` or `drawCircle()`) use
            when drawing. The fill remains in effect until you call the
            `beginFill()`, `beginBitmapFill()`,
            `beginGradientFill()`, or `beginShaderFill()`
            method. Calling the `clear()` method clears the fill.
    
            The application renders the fill whenever three or more points are
            drawn, or when the `endFill()` method is called.
    
            @param color The color of the fill(0xRRGGBB).
            @param alpha The alpha value of the fill(0.0 to 1.0).
        **/
        beginFill(color = 0, alpha = 1) {
            this.__commands.beginFill(color & 0xFFFFFF, alpha);
            if (alpha > 0)
                this.__visible = true;
        }
        /**
            Specifies a gradient fill used by subsequent calls to other Graphics
            methods(such as `lineTo()` or `drawCircle()`) for
            the object. The fill remains in effect until you call the
            `beginFill()`, `beginBitmapFill()`,
            `beginGradientFill()`, or `beginShaderFill()`
            method. Calling the `clear()` method clears the fill.
    
            The application renders the fill whenever three or more points are
            drawn, or when the `endFill()` method is called.
    
            @param	type	A value from the GradientType class that specifies which gradient type to use:
            `GradientType.LINEAR` or `GradientType.RADIAL`.
    
            @param	colors	An array of RGB hexadecimal color values used in the gradient; for example, red is 0xFF0000,
            blue is 0x0000FF, and so on. You can specify up to 15 colors. For each color, specify a corresponding value
            in the `alphas` and `ratios` parameters.
    
            @param	alphas	An array of alpha values for the corresponding colors in the `colors` array; valid values
            are 0 to 1. If the value is less than 0, the default is 0. If the value is greater than 1, the default is 1.
    
            @param	ratios	An array of color distribution ratios; valid values are 0-255. This value defines the
            percentage of the width where the color is sampled at 100%. The value 0 represents the left position in the
            gradient box, and 255 represents the right position in the gradient box.
    
            **Note:** This value represents positions in the gradient box, not the coordinate space of the final gradient,
            which can be wider or thinner than the gradient box. Specify a value for each value in the `colors` parameter.
    
            For example, for a linear gradient that includes two colors, blue and green, the following example illustrates
            the placement of the colors in the gradient based on different values in the ratios array:
    
            | ratios | Gradient |
            | --- | --- |
            | `[0, 127]` | ![linear gradient blue to green with ratios 0 and 127](/images/gradient-ratios-1.jpg) |
            | `[0, 255]` | ![linear gradient blue to green with ratios 0 and 255](/images/gradient-ratios-2.jpg) |
            | `[127, 255]` | ![linear gradient blue to green with ratios 127 and 255](/images/gradient-ratios-3.jpg) |
    
            The values in the array must increase sequentially; for example, `[0, 63, 127, 190, 255]`.
    
            @param	matrix	A transformation matrix as defined by the openfl.geom.Matrix class. The openfl.geom.Matrix
            class includes a `createGradientBox()` method, which lets you conveniently set up the matrix for use with the
            `beginGradientFill()` method.
    
            @param	spreadMethod	A value from the SpreadMethod class that specifies which spread method to use, either:
            `SpreadMethod.PAD`, `SpreadMethod.REFLECT`, or `SpreadMethod.REPEAT`.
    
            For example, consider a simple linear gradient between two colors:
    
            ```as3
            import flash.geom.*
            import flash.display.*
            var fillType:String = GradientType.LINEAR;
            var colors:Array = [0xFF0000, 0x0000FF];
            var alphas:Array = [1, 1];
            var ratios:Array = [0x00, 0xFF];
            var matr:Matrix = new Matrix();
            matr.createGradientBox(20, 20, 0, 0, 0);
            var spreadMethod:String = SpreadMethod.PAD;
            this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);
            this.graphics.drawRect(0,0,100,100);
            ```
    
            This example uses `SpreadMethod.PAD` for the spread method, and the gradient fill looks like the following:
    
            ![linear gradient with SpreadMethod.PAD](/images/beginGradientFill_spread_pad.jpg)
    
            If you use SpreadMethod.REFLECT for the spread method, the gradient fill looks like the following:
    
            ![linear gradient with SpreadMethod.REFLECT](/images/beginGradientFill_spread_reflect.jpg)
    
            If you use SpreadMethod.REPEAT for the spread method, the gradient fill looks like the following:
    
            ![linear gradient with SpreadMethod.REPEAT](/images/beginGradientFill_spread_repeat.jpg)
    
            @param	interpolationMethod	A value from the InterpolationMethod class that specifies which value to use:
            `InterpolationMethod.LINEAR_RGB` or `InterpolationMethod.RGB`
    
            For example, consider a simple linear gradient between two colors (with the `spreadMethod` parameter set to
            `SpreadMethod.REFLECT`). The different interpolation methods affect the appearance as follows:
    
            | | |
            | --- | --- |
            | ![linear gradient with InterpolationMethod.LINEAR_RGB](/images/beginGradientFill_interp_linearrgb.jpg)<br>`InterpolationMethod.LINEAR_RGB` | ![linear gradient with InterpolationMethod.RGB](/images/beginGradientFill_interp_rgb.jpg)<br>`InterpolationMethod.RGB` |
    
            @param	focalPointRatio	A number that controls the location of the focal point of the gradient. 0 means that
            the focal point is in the center. 1 means that the focal point is at one border of the gradient circle. -1
            means that the focal point is at the other border of the gradient circle. A value less than -1 or greater
            than 1 is rounded to -1 or 1. For example, the following example shows a `focalPointRatio` set to 0.75:
    
            ![radial gradient with focalPointRatio set to 0.75](/images/radial_sketch.jpg)
    
            @throws ArgumentError If the `type` parameter is not valid.
        **/
        beginGradientFill(type, colors, alphas, ratios, matrix = null, spreadMethod = SpreadMethod.PAD, interpolationMethod = InterpolationMethod.RGB, focalPointRatio = 0) {
            if (colors == null || colors.length == 0)
                return;
            if (alphas == null) {
                alphas = [];
                for (let i = 0; i < colors.length; i++) {
                    alphas.push(1);
                }
            }
            if (ratios == null) {
                ratios = [];
                for (let i = 0; i < colors.length; i++) {
                    ratios.push(Math.ceil((i / colors.length) * 255));
                }
            }
            if (alphas.length < colors.length || ratios.length < colors.length)
                return;
            this.__commands.beginGradientFill(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio);
            for (let alpha of alphas) {
                if (alpha > 0) {
                    this.__visible = true;
                    break;
                }
            }
        }
        /**
            Specifies a shader fill used by subsequent calls to other Graphics
            methods (such as `lineTo()` or `drawCircle()`) for the object. The
            fill remains in effect until you call the `beginFill()`,
            `beginBitmapFill()`, `beginGradientFill()`, or `beginShaderFill()`
            method. Calling the `clear()` method clears the fill.
            The application renders the fill whenever three or more points are
            drawn, or when the `endFill()` method is called.
    
            Shader fills are not supported under GPU rendering; filled areas will
            be colored cyan.
    
            @param shader The shader to use for the fill. This Shader instance is
                          not required to specify an image input. However, if an
                          image input is specified in the shader, the input must
                          be provided manually. To specify the input, set the
                          `input` property of the corresponding ShaderInput
                          property of the `Shader.data` property.
                          When you pass a Shader instance as an argument the
                          shader is copied internally. The drawing fill operation
                          uses that internal copy, not a reference to the original
                          shader. Any changes made to the shader, such as changing
                          a parameter value, input, or bytecode, are not applied
                          to the copied shader that's used for the fill.
            @param matrix A matrix object (of the openfl.geom.Matrix class), which
                          you can use to define transformations on the shader. For
                          example, you can use the following matrix to rotate a
                          shader by 45 degrees (pi/4 radians):
    
                          ```haxe
                          matrix = new openfl.geom.Matrix();
                          matrix.rotate(Math.PI / 4);
                          ```
    
                          The coordinates received in the shader are based on the
                          matrix that is specified for the `matrix` parameter. For
                          a default (`null`) matrix, the coordinates in the shader
                          are local pixel coordinates which can be used to sample
                          an input.
            @throws ArgumentError When the shader output type is not compatible
                                  with this operation (the shader must specify a
                                  `pixel3` or `pixel4` output).
            @throws ArgumentError When the shader specifies an image input that
                                  isn't provided.
            @throws ArgumentError When a ByteArray or Vector.<Number> instance is
                                  used as an input and the `width` and `height`
                                  properties aren't specified for the ShaderInput,
                                  or the specified values don't match the amount
                                  of data in the input object. See the
                                  `ShaderInput.input` property for more
                                  information.
        **/
        beginShaderFill(shader, matrix = null) {
            if (shader != null) {
                var shaderBuffer = this.__shaderBufferPool.get();
                this.__usedShaderBuffers.push(shaderBuffer);
                shaderBuffer.update(shader);
                this.__commands.beginShaderFill(shaderBuffer);
            }
        }
        /**
            Clears the graphics that were drawn to this Graphics object, and resets
            fill and line style settings.
    
        **/
        clear() {
            for (let shaderBuffer of this.__usedShaderBuffers) {
                this.__shaderBufferPool.release(shaderBuffer);
            }
            this.__usedShaderBuffers.length = 0;
            this.__commands.clear();
            this.__strokePadding = 0;
            if (this.__bounds != null) {
                this.__setDirty();
                this.__transformDirty = true;
                this.__bounds = null;
                this.__owner.__localBoundsDirty = true;
            }
            this.__visible = false;
            this.__positionX = 0;
            this.__positionY = 0;
            moveTo(0, 0);
        }
        /**
            Copies all of drawing commands from the source Graphics object into
            the calling Graphics object.
    
            @param sourceGraphics The Graphics object from which to copy the
                                  drawing commands.
        **/
        copyFrom(sourceGraphics) {
            this.__bounds = sourceGraphics.__bounds != null ? sourceGraphics.__bounds.clone() : null;
            this.__owner.__localBoundsDirty = true;
            this.__commands = sourceGraphics.__commands.copy();
            this.__setDirty();
            this.__strokePadding = sourceGraphics.__strokePadding;
            this.__positionX = sourceGraphics.__positionX;
            this.__positionY = sourceGraphics.__positionY;
            this.__transformDirty = true;
            this.__visible = sourceGraphics.__visible;
        }
        /**
            Draws a cubic Bezier curve from the current drawing position to the specified
            anchor point. Cubic Bezier curves consist of two anchor points and two control
            points. The curve interpolates the two anchor points and curves toward the two
            control points.
    
            ![cubic bezier](/images/cubic_bezier.png)
    
            The four points you use to draw a cubic Bezier curve with the `cubicCurveTo()`
            method are as follows:
    
            * The current drawing position is the first anchor point.
            * The `anchorX` and `anchorY` parameters specify the second anchor point.
            * The `controlX1` and `controlY1` parameters specify the first control point.
            * The `controlX2` and `controlY2` parameters specify the second control point.
    
            If you call the `cubicCurveTo()` method before calling the `moveTo()` method, your
            curve starts at position (0, 0).
    
            If the `cubicCurveTo()` method succeeds, the OpenFL runtime sets the current
            drawing position to (`anchorX`, `anchorY`). If the `cubicCurveTo()` method fails,
            the current drawing position remains unchanged.
    
            If your movie clip contains content created with the Flash drawing tools, the
            results of calls to the `cubicCurveTo()` method are drawn underneath that content.
    
            @param	controlX1	Specifies the horizontal position of the first control point
            relative to the registration point of the parent display object.
            @param	controlY1	Specifies the vertical position of the first control point
            relative to the registration point of the parent display object.
            @param	controlX2	Specifies the horizontal position of the second control point
            relative to the registration point of the parent display object.
            @param	controlY2	Specifies the vertical position of the second control point
            relative to the registration point of the parent display object.
            @param	anchorX	Specifies the horizontal position of the anchor point relative to
            the registration point of the parent display object.
            @param	anchorY	Specifies the vertical position of the anchor point relative to
            the registration point of the parent display object.
        **/
        cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
            this.__inflateBounds(this.__positionX - this.__strokePadding, this.__positionY - this.__strokePadding);
            this.__inflateBounds(this.__positionX + this.__strokePadding, this.__positionY + this.__strokePadding);
            var ix1, iy1, ix2, iy2;
            ix1 = anchorX;
            ix2 = anchorX;
            if (!(((controlX1 < anchorX && controlX1 > this.__positionX) || (controlX1 > anchorX && controlX1 < this.__positionX))
                && ((controlX2 < anchorX && controlX2 > this.__positionX) || (controlX2 > anchorX && controlX2 < this.__positionX)))) {
                var u = (2 * this.__positionX - 4 * controlX1 + 2 * controlX2);
                var v = (controlX1 - this.__positionX);
                var w = (-this.__positionX + 3 * controlX1 + anchorX - 3 * controlX2);
                var t1 = (-u + Math.sqrt(u * u - 4 * v * w)) / (2 * w);
                var t2 = (-u - Math.sqrt(u * u - 4 * v * w)) / (2 * w);
                if (t1 > 0 && t1 < 1) {
                    ix1 = this.__calculateBezierCubicPoint(t1, this.__positionX, controlX1, controlX2, anchorX);
                }
                if (t2 > 0 && t2 < 1) {
                    ix2 = this.__calculateBezierCubicPoint(t2, this.__positionX, controlX1, controlX2, anchorX);
                }
            }
            iy1 = anchorY;
            iy2 = anchorY;
            if (!(((controlY1 < anchorY && controlY1 > this.__positionX) || (controlY1 > anchorY && controlY1 < this.__positionX))
                && ((controlY2 < anchorY && controlY2 > this.__positionX) || (controlY2 > anchorY && controlY2 < this.__positionX)))) {
                var u = (2 * this.__positionX - 4 * controlY1 + 2 * controlY2);
                var v = (controlY1 - this.__positionX);
                var w = (-this.__positionX + 3 * controlY1 + anchorY - 3 * controlY2);
                var t1 = (-u + Math.sqrt(u * u - 4 * v * w)) / (2 * w);
                var t2 = (-u - Math.sqrt(u * u - 4 * v * w)) / (2 * w);
                if (t1 > 0 && t1 < 1) {
                    iy1 = this.__calculateBezierCubicPoint(t1, this.__positionX, controlY1, controlY2, anchorY);
                }
                if (t2 > 0 && t2 < 1) {
                    iy2 = this.__calculateBezierCubicPoint(t2, this.__positionX, controlY1, controlY2, anchorY);
                }
            }
            this.__inflateBounds(ix1 - this.__strokePadding, iy1 - this.__strokePadding);
            this.__inflateBounds(ix1 + this.__strokePadding, iy1 + this.__strokePadding);
            this.__inflateBounds(ix2 - this.__strokePadding, iy2 - this.__strokePadding);
            this.__inflateBounds(ix2 + this.__strokePadding, iy2 + this.__strokePadding);
            this.__positionX = anchorX;
            this.__positionY = anchorY;
            this.__inflateBounds(this.__positionX - this.__strokePadding, this.__positionY - this.__strokePadding);
            this.__inflateBounds(this.__positionX + this.__strokePadding, this.__positionY + this.__strokePadding);
            this.__commands.cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY);
            this.__setDirty();
        }
        /**
            Draws a quadratic curve using the current line style from the current drawing
            position to(anchorX, anchorY) and using the control point that
            (`controlX`, `controlY`) specifies. The current
            drawing position is then set to(`anchorX`,
            `anchorY`). If the movie clip in which you are drawing contains
            content created with the Flash drawing tools, calls to the
            `curveTo()` method are drawn underneath this content. If you
            call the `curveTo()` method before any calls to the
            `moveTo()` method, the default of the current drawing position
            is(0, 0). If any of the parameters are missing, this method fails and the
            current drawing position is not changed.
    
            The curve drawn is a quadratic Bezier curve. Quadratic Bezier curves
            consist of two anchor points and one control point. The curve interpolates
            the two anchor points and curves toward the control point.
    
            ![quadratic bezier](quad_bezier.png)
    
            @param controlX A number that specifies the horizontal position of the
                            control point relative to the registration point of the
                            parent display object.
            @param controlY A number that specifies the vertical position of the
                            control point relative to the registration point of the
                            parent display object.
            @param anchorX  A number that specifies the horizontal position of the
                            next anchor point relative to the registration point of
                            the parent display object.
            @param anchorY  A number that specifies the vertical position of the next
                            anchor point relative to the registration point of the
                            parent display object.
        **/
        curveTo(controlX, controlY, anchorX, anchorY) {
            this.__inflateBounds(this.__positionX - this.__strokePadding, this.__positionY - this.__strokePadding);
            this.__inflateBounds(this.__positionX + this.__strokePadding, this.__positionY + this.__strokePadding);
            var ix, iy;
            if ((controlX < anchorX && controlX > this.__positionX) || (controlX > anchorX && controlX < this.__positionX)) {
                ix = anchorX;
            }
            else {
                var tx = ((this.__positionX - controlX) / (this.__positionX - 2 * controlX + anchorX));
                ix = this.__calculateBezierQuadPoint(tx, this.__positionX, controlX, anchorX);
            }
            if ((controlY < anchorY && controlY > this.__positionY) || (controlY > anchorY && controlY < this.__positionY)) {
                iy = anchorY;
            }
            else {
                var ty = ((this.__positionY - controlY) / (this.__positionY - (2 * controlY) + anchorY));
                iy = this.__calculateBezierQuadPoint(ty, this.__positionY, controlY, anchorY);
            }
            this.__inflateBounds(ix - this.__strokePadding, iy - this.__strokePadding);
            this.__inflateBounds(ix + this.__strokePadding, iy + this.__strokePadding);
            this.__positionX = anchorX;
            this.__positionY = anchorY;
            this.__commands.curveTo(controlX, controlY, anchorX, anchorY);
            this.__setDirty();
        }
        /**
            Draws a circle. Set the line style, fill, or both before you call the
            `drawCircle()` method, by calling the `linestyle()`,
            `lineGradientStyle()`, `beginFill()`,
            `beginGradientFill()`, or `beginBitmapFill()`
            method.
    
            @param x      The _x_ location of the center of the circle relative
                          to the registration point of the parent display object(in
                          pixels).
            @param y      The _y_ location of the center of the circle relative
                          to the registration point of the parent display object(in
                          pixels).
            @param radius The radius of the circle(in pixels).
        **/
        drawCircle(x, y, radius) {
            if (radius <= 0)
                return;
            this.__inflateBounds(x - radius - this.__strokePadding, y - radius - this.__strokePadding);
            this.__inflateBounds(x + radius + this.__strokePadding, y + radius + this.__strokePadding);
            this.__commands.drawCircle(x, y, radius);
            this.__setDirty();
        }
        /**
            Draws an ellipse. Set the line style, fill, or both before you call the
            `drawEllipse()` method, by calling the
            `linestyle()`, `lineGradientStyle()`,
            `beginFill()`, `beginGradientFill()`, or
            `beginBitmapFill()` method.
    
            @param x      The _x_ location of the top-left of the bounding-box of
                          the ellipse relative to the registration point of the parent
                          display object(in pixels).
            @param y      The _y_ location of the top left of the bounding-box of
                          the ellipse relative to the registration point of the parent
                          display object(in pixels).
            @param width  The width of the ellipse(in pixels).
            @param height The height of the ellipse(in pixels).
        **/
        drawEllipse(x, y, width, height) {
            if (width <= 0 || height <= 0)
                return;
            this.__inflateBounds(x - this.__strokePadding, y - this.__strokePadding);
            this.__inflateBounds(x + width + this.__strokePadding, y + height + this.__strokePadding);
            this.__commands.drawEllipse(x, y, width, height);
            this.__setDirty();
        }
        /**
            Submits a series of IGraphicsData instances for drawing. This method
            accepts a Vector containing objects including paths, fills, and strokes
            that implement the IGraphicsData interface. A Vector of IGraphicsData
            instances can refer to a part of a shape, or a complex fully defined set
            of data for rendering a complete shape.
    
             Graphics paths can contain other graphics paths. If the
            `graphicsData` Vector includes a path, that path and all its
            sub-paths are rendered during this operation.
    
        **/
        drawGraphicsData(graphicsData) {
            var fill;
            var bitmapFill;
            var gradientFill;
            var shaderFill;
            var stroke;
            var path;
            var trianglePath;
            var quadPath;
            for (let graphics of graphicsData) {
                switch (graphics.__graphicsDataType) {
                    case GraphicsDataType$1.SOLID:
                        fill = graphics;
                        this.beginFill(fill.color, fill.alpha);
                        break;
                    case GraphicsDataType$1.BITMAP:
                        bitmapFill = graphics;
                        this.beginBitmapFill(bitmapFill.bitmapData, bitmapFill.matrix, bitmapFill.repeat, bitmapFill.smooth);
                        break;
                    case GraphicsDataType$1.GRADIENT:
                        gradientFill = graphics;
                        this.beginGradientFill(gradientFill.type, gradientFill.colors, gradientFill.alphas, gradientFill.ratios, gradientFill.matrix, gradientFill.spreadMethod, gradientFill.interpolationMethod, gradientFill.focalPointRatio);
                        break;
                    case GraphicsDataType$1.SHADER:
                        shaderFill = graphics;
                        this.beginShaderFill(shaderFill.shader, shaderFill.matrix);
                        break;
                    case GraphicsDataType$1.STROKE:
                        stroke = graphics;
                        if (stroke.fill != null) {
                            var thickness = stroke.thickness;
                            if (Number.isNaN(thickness)) {
                                thickness = null;
                            }
                            switch (stroke.fill.__graphicsFillType) {
                                case GraphicsFillType$1.SOLID_FILL:
                                    fill = stroke.fill;
                                    this.lineStyle(thickness, fill.color, fill.alpha, stroke.pixelHinting, stroke.scaleMode, stroke.caps, stroke.joints, stroke.miterLimit);
                                    break;
                                case GraphicsFillType$1.BITMAP_FILL:
                                    bitmapFill = stroke.fill;
                                    this.lineStyle(thickness, 0, 1, stroke.pixelHinting, stroke.scaleMode, stroke.caps, stroke.joints, stroke.miterLimit);
                                    this.lineBitmapStyle(bitmapFill.bitmapData, bitmapFill.matrix, bitmapFill.repeat, bitmapFill.smooth);
                                    break;
                                case GraphicsFillType$1.GRADIENT_FILL:
                                    gradientFill = stroke.fill;
                                    this.lineStyle(thickness, 0, 1, stroke.pixelHinting, stroke.scaleMode, stroke.caps, stroke.joints, stroke.miterLimit);
                                    this.lineGradientStyle(gradientFill.type, gradientFill.colors, gradientFill.alphas, gradientFill.ratios, gradientFill.matrix, gradientFill.spreadMethod, gradientFill.interpolationMethod, gradientFill.focalPointRatio);
                                    break;
                            }
                        }
                        else {
                            this.lineStyle();
                        }
                        break;
                    case GraphicsDataType$1.PATH:
                        path = graphics;
                        this.drawPath(path.commands, path.data, path.winding);
                        break;
                    case GraphicsDataType$1.TRIANGLE_PATH:
                        trianglePath = graphics;
                        this.drawTriangles(trianglePath.vertices, trianglePath.indices, trianglePath.uvtData, trianglePath.culling);
                        break;
                    case GraphicsDataType$1.END:
                        this.endFill();
                        break;
                    case GraphicsDataType$1.QUAD_PATH:
                        quadPath = graphics;
                        this.drawQuads(quadPath.rects, quadPath.indices, quadPath.transforms);
                        break;
                }
            }
        }
        /**
            Submits a series of commands for drawing. The `drawPath()`
            method uses vector arrays to consolidate individual `moveTo()`,
            `lineTo()`, and `curveTo()` drawing commands into a
            single call. The `drawPath()` method parameters combine drawing
            commands with x- and y-coordinate value pairs and a drawing direction. The
            drawing commands are values from the GraphicsPathCommand class. The x- and
            y-coordinate value pairs are Numbers in an array where each pair defines a
            coordinate location. The drawing direction is a value from the
            GraphicsPathWinding class.
    
            Generally, drawings render faster with `drawPath()` than
            with a series of individual `lineTo()` and
            `curveTo()` methods.
    
            The `drawPath()` method uses a uses a floating computation
            so rotation and scaling of shapes is more accurate and gives better
            results. However, curves submitted using the `drawPath()`
            method can have small sub-pixel alignment errors when used in conjunction
            with the `lineTo()` and `curveTo()` methods.
    
            The `drawPath()` method also uses slightly different rules
            for filling and drawing lines. They are:
    
            * When a fill is applied to rendering a path:
                * A sub-path of less than 3 points is not rendered.(But note that the
                stroke rendering will still occur, consistent with the rules for strokes
                below.)
                * A sub-path that isn't closed(the end point is not equal to the
                begin point) is implicitly closed.
            * When a stroke is applied to rendering a path:
                * The sub-paths can be composed of any number of points.
                * The sub-path is never implicitly closed.
    
            @param	commands	A Vector of integers representing drawing commands. The set
            of accepted values is defined by the constants in the GraphicsPathCommand class.
            @param	data	A Vector of Number instances where each pair of numbers is treated
            as a coordinate location (an x, y pair). The x- and y-coordinate value pairs are
            not Point objects; the data vector is a series of numbers where each group of two
            numbers represents a coordinate location.
            @param	winding	Specifies the winding rule using a value defined in the
            GraphicsPathWinding class.
        **/
        drawPath(commands, data, winding = GraphicsPathWinding.EVEN_ODD) {
            var dataIndex = 0;
            if (winding == GraphicsPathWinding.NON_ZERO)
                this.__commands.windingNonZero();
            for (let command of commands) {
                switch (command) {
                    case GraphicsPathCommand.MOVE_TO:
                        this.moveTo(data[dataIndex], data[dataIndex + 1]);
                        dataIndex += 2;
                        break;
                    case GraphicsPathCommand.LINE_TO:
                        this.lineTo(data[dataIndex], data[dataIndex + 1]);
                        dataIndex += 2;
                        break;
                    case GraphicsPathCommand.WIDE_MOVE_TO:
                        this.moveTo(data[dataIndex + 2], data[dataIndex + 3]);
                        break;
                    case GraphicsPathCommand.WIDE_LINE_TO:
                        this.lineTo(data[dataIndex + 2], data[dataIndex + 3]);
                        break;
                    case GraphicsPathCommand.CURVE_TO:
                        this.curveTo(data[dataIndex], data[dataIndex + 1], data[dataIndex + 2], data[dataIndex + 3]);
                        dataIndex += 4;
                        break;
                    case GraphicsPathCommand.CUBIC_CURVE_TO:
                        this.cubicCurveTo(data[dataIndex], data[dataIndex + 1], data[dataIndex + 2], data[dataIndex + 3], data[dataIndex + 4], data[dataIndex + 5]);
                        dataIndex += 6;
                        break;
                }
            }
            // TODO: Reset to EVEN_ODD after current path is filled?
            // if (winding == GraphicsPathWinding.NON_ZERO) __commands.windingEvenOdd ();
        }
        /**
            Renders a set of quadrilaterals. This is similar to calling `drawRect`
            repeatedly, but each rectangle can use a transform value to rotate, scale
            or skew the result.
    
            Any type of fill can be used, but if the fill has a transform matrix
            that transform matrix is ignored.
    
            The optional `indices` parameter allows the use of either repeated
            rectangle geometry, or allows the use of a subset of a broader rectangle
            data Vector, such as Tileset `rectData`.
    
            @param rects A Vector containing rectangle coordinates in
                         [ x0, y0, width0, height0, x1, y1 ... ] format.
            @param indices A Vector containing optional index values to reference
                           the data contained in `rects`. Each index is a rectangle
                           index in the Vector, not an array index. If this parameter
                           is ommitted, each index from `rects` will be used in order.
            @param transforms A Vector containing optional transform data to adjust
                              _x_, _y_, _a_, _b_, _c_ or _d_ value for the resulting
                              quadrilateral. A `transforms` Vector that is double the
                              size of the draw count (the length of `indices`, or if
                              omitted, the rectangle count in `rects`) will be treated
                              as [ x, y, ... ] pairs. A `transforms` Vector that is
                              four times the size of the draw count will be used as
                              matrix [ a, b, c, d, ... ] values. A `transforms` object
                              which is six times the draw count in size will use full
                              matrix [ a, b, c, d, tx, ty, ... ] values per draw.
        **/
        drawQuads(rects, indices = null, transforms = null) {
            if (rects == null)
                return;
            var hasIndices = (indices != null);
            var transformABCD = false, transformXY = false;
            var length = hasIndices ? indices.length : Math.floor(rects.length / 4);
            if (length == 0)
                return;
            if (transforms != null) {
                if (transforms.length >= length * 6) {
                    transformABCD = true;
                    transformXY = true;
                }
                else if (transforms.length >= length * 4) {
                    transformABCD = true;
                }
                else if (transforms.length >= length * 2) {
                    transformXY = true;
                }
            }
            var tileRect = Rectangle.__pool.get();
            var tileTransform = Matrix.__pool.get();
            var minX = Number.POSITIVE_INFINITY;
            var minY = Number.POSITIVE_INFINITY;
            var maxX = Number.NEGATIVE_INFINITY;
            var maxY = Number.NEGATIVE_INFINITY;
            var ri, ti;
            for (let i = 0; i < length; i++) {
                ri = (hasIndices ? (indices[i] * 4) : i * 4);
                if (ri < 0)
                    continue;
                tileRect.setTo(0, 0, rects[ri + 2], rects[ri + 3]);
                if (tileRect.width <= 0 || tileRect.height <= 0) {
                    continue;
                }
                if (transformABCD && transformXY) {
                    ti = i * 6;
                    tileTransform.setTo(transforms[ti], transforms[ti + 1], transforms[ti + 2], transforms[ti + 3], transforms[ti + 4], transforms[ti + 5]);
                }
                else if (transformABCD) {
                    ti = i * 4;
                    tileTransform.setTo(transforms[ti], transforms[ti + 1], transforms[ti + 2], transforms[ti + 3], tileRect.x, tileRect.y);
                }
                else if (transformXY) {
                    ti = i * 2;
                    tileTransform.tx = transforms[ti];
                    tileTransform.ty = transforms[ti + 1];
                }
                else {
                    tileTransform.tx = tileRect.x;
                    tileTransform.ty = tileRect.y;
                }
                tileRect.__transform(tileRect, tileTransform);
                if (minX > tileRect.x)
                    minX = tileRect.x;
                if (minY > tileRect.y)
                    minY = tileRect.y;
                if (maxX < tileRect.right)
                    maxX = tileRect.right;
                if (maxY < tileRect.bottom)
                    maxY = tileRect.bottom;
            }
            this.__inflateBounds(minX, minY);
            this.__inflateBounds(maxX, maxY);
            this.__commands.drawQuads(rects, indices, transforms);
            this.__setDirty();
            this.__visible = true;
            Rectangle.__pool.release(tileRect);
            Matrix.__pool.release(tileTransform);
        }
        /**
            Draws a rectangle. Set the line style, fill, or both before you call the
            `drawRect()` method, by calling the `linestyle()`,
            `lineGradientStyle()`, `beginFill()`,
            `beginGradientFill()`, or `beginBitmapFill()`
            method.
    
            @param x      A number indicating the horizontal position relative to the
                          registration point of the parent display object(in pixels).
            @param y      A number indicating the vertical position relative to the
                          registration point of the parent display object(in pixels).
            @param width  The width of the rectangle(in pixels).
            @param height The height of the rectangle(in pixels).
            @throws ArgumentError If the `width` or `height`
                                  parameters are not a number
                                 (`Number.NaN`).
        **/
        drawRect(x, y, width, height) {
            if (width == 0 && height == 0)
                return;
            var xSign = width < 0 ? -1 : 1;
            var ySign = height < 0 ? -1 : 1;
            this.__inflateBounds(x - this.__strokePadding * xSign, y - this.__strokePadding * ySign);
            this.__inflateBounds(x + width + this.__strokePadding * xSign, y + height + this.__strokePadding * ySign);
            this.__commands.drawRect(x, y, width, height);
            this.__setDirty();
        }
        /**
            Draws a rounded rectangle. Set the line style, fill, or both before you
            call the `drawRoundRect()` method, by calling the
            `linestyle()`, `lineGradientStyle()`,
            `beginFill()`, `beginGradientFill()`, or
            `beginBitmapFill()` method.
    
            @param x             A number indicating the horizontal position relative
                                 to the registration point of the parent display
                                 object(in pixels).
            @param y             A number indicating the vertical position relative to
                                 the registration point of the parent display object
                                (in pixels).
            @param width         The width of the round rectangle(in pixels).
            @param height        The height of the round rectangle(in pixels).
            @param ellipseWidth  The width of the ellipse used to draw the rounded
                                 corners(in pixels).
            @param ellipseHeight The height of the ellipse used to draw the rounded
                                 corners(in pixels). Optional; if no value is
                                 specified, the default value matches that provided
                                 for the `ellipseWidth` parameter.
            @throws ArgumentError If the `width`, `height`,
                                  `ellipseWidth` or
                                  `ellipseHeight` parameters are not a
                                  number(`Number.NaN`).
        **/
        drawRoundRect(x, y, width, height, ellipseWidth, ellipseHeight = null) {
            if (width == 0 && height == 0)
                return;
            var xSign = width < 0 ? -1 : 1;
            var ySign = height < 0 ? -1 : 1;
            this.__inflateBounds(x - this.__strokePadding * xSign, y - this.__strokePadding * ySign);
            this.__inflateBounds(x + width + this.__strokePadding * xSign, y + height + this.__strokePadding * ySign);
            this.__commands.drawRoundRect(x, y, width, height, ellipseWidth, ellipseHeight);
            this.__setDirty();
        }
        /**
            Undocumented method
        **/
        drawRoundRectComplex(x, y, width, height, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {
            if (width <= 0 || height <= 0)
                return;
            this.__inflateBounds(x - this.__strokePadding, y - this.__strokePadding);
            this.__inflateBounds(x + width + this.__strokePadding, y + height + this.__strokePadding);
            var xw = x + width;
            var yh = y + height;
            var minSize = width < height ? width * 2 : height * 2;
            topLeftRadius = topLeftRadius < minSize ? topLeftRadius : minSize;
            topRightRadius = topRightRadius < minSize ? topRightRadius : minSize;
            bottomLeftRadius = bottomLeftRadius < minSize ? bottomLeftRadius : minSize;
            bottomRightRadius = bottomRightRadius < minSize ? bottomRightRadius : minSize;
            var anchor = (1 - Math.sin(45 * (Math.PI / 180)));
            var control = (1 - Math.tan(22.5 * (Math.PI / 180)));
            var a = bottomRightRadius * anchor;
            var s = bottomRightRadius * control;
            this.moveTo(xw, yh - bottomRightRadius);
            this.curveTo(xw, yh - s, xw - a, yh - a);
            this.curveTo(xw - s, yh, xw - bottomRightRadius, yh);
            a = bottomLeftRadius * anchor;
            s = bottomLeftRadius * control;
            this.lineTo(x + bottomLeftRadius, yh);
            this.curveTo(x + s, yh, x + a, yh - a);
            this.curveTo(x, yh - s, x, yh - bottomLeftRadius);
            a = topLeftRadius * anchor;
            s = topLeftRadius * control;
            this.lineTo(x, y + topLeftRadius);
            this.curveTo(x, y + s, x + a, y + a);
            this.curveTo(x + s, y, x + topLeftRadius, y);
            a = topRightRadius * anchor;
            s = topRightRadius * control;
            this.lineTo(xw - topRightRadius, y);
            this.curveTo(xw - s, y, xw - a, y + a);
            this.curveTo(xw, y + s, xw, y + topRightRadius);
            this.lineTo(xw, yh - bottomRightRadius);
            this.__setDirty();
        }
        /**
            Renders a set of triangles, typically to distort bitmaps and give them a
            three-dimensional appearance. The `drawTriangles()` method maps
            either the current fill, or a bitmap fill, to the triangle faces using a
            set of(u,v) coordinates.
    
             Any type of fill can be used, but if the fill has a transform matrix
            that transform matrix is ignored.
    
             A `uvtData` parameter improves texture mapping when a
            bitmap fill is used.
    
            @param culling Specifies whether to render triangles that face in a
                           specified direction. This parameter prevents the rendering
                           of triangles that cannot be seen in the current view. This
                           parameter can be set to any value defined by the
                           TriangleCulling class.
        **/
        drawTriangles(vertices, indices = null, uvtData = null, culling = TriangleCulling.NONE) {
            if (vertices == null || vertices.length == 0)
                return;
            var vertLength = Math.floor(vertices.length / 2);
            if (indices == null) {
                // TODO: Allow null indices
                if (vertLength % 3 != 0) {
                    throw new ArgumentError("Not enough vertices to close a triangle.");
                }
                indices = new Vector();
                for (let i = 0; i < vertLength; i++) {
                    indices.push(i);
                }
            }
            if (culling == null) {
                culling = TriangleCulling.NONE;
            }
            var x, y;
            var minX = Number.POSITIVE_INFINITY;
            var minY = Number.POSITIVE_INFINITY;
            var maxX = Number.NEGATIVE_INFINITY;
            var maxY = Number.NEGATIVE_INFINITY;
            for (let i = 0; i < vertLength; i++) {
                x = vertices[i * 2];
                y = vertices[i * 2 + 1];
                if (minX > x)
                    minX = x;
                if (minY > y)
                    minY = y;
                if (maxX < x)
                    maxX = x;
                if (maxY < y)
                    maxY = y;
            }
            this.__inflateBounds(minX, minY);
            this.__inflateBounds(maxX, maxY);
            this.__commands.drawTriangles(vertices, indices, uvtData, culling);
            this.__setDirty();
            this.__visible = true;
        }
        /**
            Applies a fill to the lines and curves that were added since the last call
            to the `beginFill()`, `beginGradientFill()`, or
            `beginBitmapFill()` method. Flash uses the fill that was
            specified in the previous call to the `beginFill()`,
            `beginGradientFill()`, or `beginBitmapFill()`
            method. If the current drawing position does not equal the previous
            position specified in a `moveTo()` method and a fill is
            defined, the path is closed with a line and then filled.
    
        **/
        endFill() {
            this.__commands.endFill();
        }
        /**
            Specifies a bitmap to use for the line stroke when drawing lines.
    
            The bitmap line style is used for subsequent calls to Graphics methods
            such as the `lineTo()` method or the `drawCircle()`
            method. The line style remains in effect until you call the
            `lineStyle()` or `lineGradientStyle()` methods, or
            the `lineBitmapStyle()` method again with different parameters.
    
    
            You can call the `lineBitmapStyle()` method in the middle of
            drawing a path to specify different styles for different line segments
            within a path.
    
            Call the `lineStyle()` method before you call the
            `lineBitmapStyle()` method to enable a stroke, or else the
            value of the line style is `undefined`.
    
            Calls to the `clear()` method set the line style back to
            `undefined`.
    
            @param bitmap The bitmap to use for the line stroke.
            @param matrix An optional transformation matrix as defined by the
                          openfl.geom.Matrix class. The matrix can be used to scale or
                          otherwise manipulate the bitmap before applying it to the
                          line style.
            @param repeat Whether to repeat the bitmap in a tiled fashion.
            @param smooth Whether smoothing should be applied to the bitmap.
        **/
        lineBitmapStyle(bitmap, matrix = null, repeat = true, smooth = false) {
            this.__commands.lineBitmapStyle(bitmap, matrix != null ? matrix.clone() : null, repeat, smooth);
        }
        /**
            Specifies a gradient to use for the stroke when drawing lines.
    
            The gradient line style is used for subsequent calls to Graphics
            methods such as the `lineTo()` methods or the
            `drawCircle()` method. The line style remains in effect until
            you call the `lineStyle()` or `lineBitmapStyle()`
            methods, or the `lineGradientStyle()` method again with
            different parameters.
    
            You can call the `lineGradientStyle()` method in the middle
            of drawing a path to specify different styles for different line segments
            within a path.
    
            Call the `lineStyle()` method before you call the
            `lineGradientStyle()` method to enable a stroke, or else the
            value of the line style is `undefined`.
    
            Calls to the `clear()` method set the line style back to
            `undefined`.
    
            @param	type	A value from the GradientType class that specifies which gradient type to use:
            `GradientType.LINEAR` or `GradientType.RADIAL`.
    
            @param	colors	An array of RGB hex color values to be used in the gradient (for example, red is 0xFF0000,
            blue is 0x0000FF, and so on).
    
            @param	alphas	An array of alpha values for the corresponding colors in the `colors` array; valid values
            are 0 to 1. If the value is less than 0, the default is 0. If the value is greater than 1, the default is 1.
    
            @param	ratios	An array of color distribution ratios; valid values are from 0 to 255. This value defines the
            percentage of the width where the color is sampled at 100%. The value 0 represents the left position in the
            gradient box, and 255 represents the right position in the gradient box. This value represents positions in
            the gradient box, not the coordinate space of the final gradient, which can be wider or thinner than the
            gradient box. Specify a value for each value in the `colors` parameter.
    
            For example, for a linear gradient that includes two colors, blue and green, the following figure illustrates
            the placement of the colors in the gradient based on different values in the `ratios` array:
    
            | ratios | Gradient |
            | --- | --- |
            | `[0, 127]` | ![linear gradient blue to green with ratios 0 and 127](/images/gradient-ratios-1.jpg) |
            | `[0, 255]` | ![linear gradient blue to green with ratios 0 and 255](/images/gradient-ratios-2.jpg) |
            | `[127, 255]` | ![linear gradient blue to green with ratios 127 and 255](/images/gradient-ratios-3.jpg) |
    
            The values in the array must increase sequentially; for example, `[0, 63, 127, 190, 255]`.
    
            @param	matrix	A transformation matrix as defined by the openfl.geom.Matrix class. The openfl.geom.Matrix
            class includes a `createGradientBox()` method, which lets you conveniently set up the matrix for use with the
            `lineGradientStyle()` method.
    
            @param	spreadMethod	A value from the SpreadMethod class that specifies which spread method to use:
    
            | | | |
            | --- | --- | --- |
            | ![linear gradient with SpreadMethod.PAD](/images/beginGradientFill_spread_pad.jpg)<br>`SpreadMethod.PAD` | ![linear gradient with SpreadMethod.REFLECT](/images/beginGradientFill_spread_reflect.jpg)<br>`SpreadMethod.REFLECT` | ![linear gradient with SpreadMethod.REPEAT](/images/beginGradientFill_spread_repeat.jpg)<br>`SpreadMethod.REPEAT` |
    
            @param	interpolationMethod	A value from the InterpolationMethod class that specifies which value to use. For
            example, consider a simple linear gradient between two colors (with the `spreadMethod` parameter set to
            `SpreadMethod.REFLECT`). The different interpolation methods affect the appearance as follows:
    
            | | |
            | --- | --- |
            | ![linear gradient with InterpolationMethod.LINEAR_RGB](/images/beginGradientFill_interp_linearrgb.jpg)<br>`InterpolationMethod.LINEAR_RGB` | ![linear gradient with InterpolationMethod.RGB](/images/beginGradientFill_interp_rgb.jpg)<br>`InterpolationMethod.RGB` |
    
            @param	focalPointRatio	A number that controls the location of the focal point of the gradient. The value 0
            means the focal point is in the center. The value 1 means the focal point is at one border of the gradient
            circle. The value -1 means that the focal point is at the other border of the gradient circle. Values less
            than -1 or greater than 1 are rounded to -1 or 1. The following image shows a gradient with a
            `focalPointRatio` of -0.75:
    
            ![radial gradient with focalPointRatio set to 0.75](/images/radial_sketch.jpg)
        **/
        lineGradientStyle(type, colors, alphas, ratios, matrix = null, spreadMethod = SpreadMethod.PAD, interpolationMethod = InterpolationMethod.RGB, focalPointRatio = 0) {
            this.__commands.lineGradientStyle(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio);
        }
        /**
            Specifies a shader to use for the line stroke when drawing lines.
    
            The shader line style is used for subsequent calls to Graphics methods such as the `lineTo()` method or the
            `drawCircle()` method. The line style remains in effect until you call the `lineStyle()` or
            `lineGradientStyle()` methods, or the `lineBitmapStyle()` method again with different parameters.
    
            You can call the `lineShaderStyle()` method in the middle of drawing a path to specify different styles for
            different line segments within a path.
    
            Call the `lineStyle()` method before you call the `lineShaderStyle()` method to enable a stroke, or else the
            value of the line style is undefined.
    
            Calls to the `clear()` method set the line style back to undefined.
        **/
        // @:require(flash10) public lineShaderStyle (shader:Shader, ?matrix:Matrix):Void;
        /**
            Specifies a line style used for subsequent calls to Graphics methods such
            as the `lineTo()` method or the `drawCircle()`
            method. The line style remains in effect until you call the
            `lineGradientStyle()` method, the
            `lineBitmapStyle()` method, or the `lineStyle()`
            method with different parameters.
    
            You can call the `lineStyle()` method in the middle of
            drawing a path to specify different styles for different line segments
            within the path.
    
            **Note: **Calls to the `clear()` method set the line
            style back to `undefined`.
    
            **Note: **Flash Lite 4 supports only the first three parameters
            (`thickness`, `color`, and `alpha`).
    
            @param thickness    An integer that indicates the thickness of the line in
                                points; valid values are 0-255. If a number is not
                                specified, or if the parameter is undefined, a line is
                                not drawn. If a value of less than 0 is passed, the
                                default is 0. The value 0 indicates hairline
                                thickness; the maximum thickness is 255. If a value
                                greater than 255 is passed, the default is 255.
            @param color        A hexadecimal color value of the line; for example,
                                red is 0xFF0000, blue is 0x0000FF, and so on. If a
                                value is not indicated, the default is 0x000000
                               (black). Optional.
            @param alpha        A number that indicates the alpha value of the color
                                of the line; valid values are 0 to 1. If a value is
                                not indicated, the default is 1(solid). If the value
                                is less than 0, the default is 0. If the value is
                                greater than 1, the default is 1.
            @param pixelHinting (Not supported in Flash Lite 4) A Boolean value that
                                specifies whether to hint strokes to full pixels. This
                                affects both the position of anchors of a curve and
                                the line stroke size itself. With
                                `pixelHinting` set to `true`,
                                line widths are adjusted to full pixel widths. With
                                `pixelHinting` set to `false`,
                                disjoints can appear for curves and straight lines.
                                For example, the following illustrations show how
                                Flash Player or Adobe AIR renders two rounded
                                rectangles that are identical, except that the
                                `pixelHinting` parameter used in the
                                `lineStyle()` method is set differently
                               (the images are scaled by 200%, to emphasize the
                                difference):
    
                                ![pixelHinting false and pixelHinting true](/images/lineStyle_pixelHinting.jpg)
    
                                If a value is not supplied, the line does not use
                                pixel hinting.
            @param scaleMode   (Not supported in Flash Lite 4) A value from the
                                LineScaleMode class that specifies which scale mode to
                                use:
    
                                 *  `LineScaleMode.NORMAL` - Always
                                scale the line thickness when the object is scaled
                               (the default).
                                 *  `LineScaleMode.NONE` - Never scale
                                the line thickness.
                                 *  `LineScaleMode.VERTICAL` - Do not
                                scale the line thickness if the object is scaled
                                vertically _only_. For example, consider the
                                following circles, drawn with a one-pixel line, and
                                each with the `scaleMode` parameter set to
                                `LineScaleMode.VERTICAL`. The circle on the
                                left is scaled vertically only, and the circle on the
                                right is scaled both vertically and horizontally:
    
                                ![A circle scaled vertically, and a circle scaled both vertically and horizontally.](/images/LineScaleMode_VERTICAL.jpg)
    
                                 *  `LineScaleMode.HORIZONTAL` - Do not
                                scale the line thickness if the object is scaled
                                horizontally _only_. For example, consider the
                                following circles, drawn with a one-pixel line, and
                                each with the `scaleMode` parameter set to
                                `LineScaleMode.HORIZONTAL`. The circle on
                                the left is scaled horizontally only, and the circle
                                on the right is scaled both vertically and
                                horizontally:
    
                                ![A circle scaled horizontally, and a circle scaled both vertically and horizontally.](/images/LineScaleMode_HORIZONTAL.jpg)
    
            @param caps        (Not supported in Flash Lite 4) A value from the
                                CapsStyle class that specifies the type of caps at the
                                end of lines. Valid values are:
                                `CapsStyle.NONE`,
                                `CapsStyle.ROUND`, and
                                `CapsStyle.SQUARE`. If a value is not
                                indicated, Flash uses round caps.
    
                                For example, the following illustrations show the
                                different `capsStyle` settings. For each
                                setting, the illustration shows a blue line with a
                                thickness of 30(for which the `capsStyle`
                                applies), and a superimposed black line with a
                                thickness of 1(for which no `capsStyle`
                                applies):
    
                                ![NONE, ROUND, and SQUARE](/images/linecap.jpg)
    
            @param joints      (Not supported in Flash Lite 4) A value from the
                                JointStyle class that specifies the type of joint
                                appearance used at angles. Valid values are:
                                `JointStyle.BEVEL`,
                                `JointStyle.MITER`, and
                                `JointStyle.ROUND`. If a value is not
                                indicated, Flash uses round joints.
    
                                For example, the following illustrations show the
                                different `joints` settings. For each
                                setting, the illustration shows an angled blue line
                                with a thickness of 30(for which the
                                `jointStyle` applies), and a superimposed
                                angled black line with a thickness of 1(for which no
                                `jointStyle` applies):
    
                                ![MITER, ROUND, and BEVEL](/images/linejoin.jpg)
    
                                **Note:** For `joints` set to
                                `JointStyle.MITER`, you can use the
                                `miterLimit` parameter to limit the length
                                of the miter.
            @param miterLimit  (Not supported in Flash Lite 4) A number that
                                indicates the limit at which a miter is cut off. Valid
                                values range from 1 to 255(and values outside that
                                range are rounded to 1 or 255). This value is only
                                used if the `jointStyle` is set to
                                `"miter"`. The `miterLimit`
                                value represents the length that a miter can extend
                                beyond the point at which the lines meet to form a
                                joint. The value expresses a factor of the line
                                `thickness`. For example, with a
                                `miterLimit` factor of 2.5 and a
                                `thickness` of 10 pixels, the miter is cut
                                off at 25 pixels.
    
                                For example, consider the following angled lines,
                                each drawn with a `thickness` of 20, but
                                with `miterLimit` set to 1, 2, and 4.
                                Superimposed are black reference lines showing the
                                meeting points of the joints:
    
                                ![lines with miterLimit set to 1, 2, and 4](/images/miterLimit.jpg)
    
                                Notice that a given `miterLimit` value
                                has a specific maximum angle for which the miter is
                                cut off. The following table lists some examples:
    
                                | miterLimit value: | Angles smaller than this are cut off: |
                                | --- | --- |
                                | 1.414 | 90 degrees |
                                | 2 | 60 degrees |
                                | 4 | 30 degrees |
                                | 8 | 15 degrees |
    
        **/
        lineStyle(thickness = null, color = 0, alpha = 1, pixelHinting = false, scaleMode = LineScaleMode.NORMAL, caps = null, joints = null, miterLimit = 3) {
            if (thickness != null) {
                if (joints == JointStyle.MITER) {
                    if (thickness > this.__strokePadding)
                        this.__strokePadding = thickness;
                }
                else {
                    if (thickness / 2 > this.__strokePadding)
                        this.__strokePadding = thickness / 2;
                }
            }
            this.__commands.lineStyle(thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit);
            if (thickness != null)
                this.__visible = true;
        }
        /**
            Draws a line using the current line style from the current drawing
            position to(`x`, `y`); the current drawing position
            is then set to(`x`, `y`). If the display object in
            which you are drawing contains content that was created with the Flash
            drawing tools, calls to the `lineTo()` method are drawn
            underneath the content. If you call `lineTo()` before any calls
            to the `moveTo()` method, the default position for the current
            drawing is(_0, 0_). If any of the parameters are missing, this
            method fails and the current drawing position is not changed.
    
            @param x A number that indicates the horizontal position relative to the
                     registration point of the parent display object(in pixels).
            @param y A number that indicates the vertical position relative to the
                     registration point of the parent display object(in pixels).
        **/
        lineTo(x, y) {
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
                return;
            }
            // TODO: Should we consider the origin instead, instead of inflating in all directions?
            this.__inflateBounds(this.__positionX - this.__strokePadding, this.__positionY - this.__strokePadding);
            this.__inflateBounds(this.__positionX + this.__strokePadding, this.__positionY + this.__strokePadding);
            this.__positionX = x;
            this.__positionY = y;
            this.__inflateBounds(this.__positionX - this.__strokePadding, this.__positionY - this.__strokePadding);
            this.__inflateBounds(this.__positionX + this.__strokePadding * 2, this.__positionY + this.__strokePadding);
            this.__commands.lineTo(x, y);
            this.__setDirty();
        }
        /**
            Moves the current drawing position to(`x`, `y`). If
            any of the parameters are missing, this method fails and the current
            drawing position is not changed.
    
            @param x A number that indicates the horizontal position relative to the
                     registration point of the parent display object(in pixels).
            @param y A number that indicates the vertical position relative to the
                     registration point of the parent display object(in pixels).
        **/
        moveTo(x, y) {
            this.__positionX = x;
            this.__positionY = y;
            this.__commands.moveTo(x, y);
        }
        overrideBlendMode(blendMode) {
            if (blendMode == null)
                blendMode = BlendMode.NORMAL;
            this.__commands.overrideBlendMode(blendMode);
        }
        /**
            Queries a Sprite or Shape object (and optionally, its children) for its vector
            graphics content. The result is a Vector of IGraphicsData objects. Transformations
            are applied to the display object before the query, so the returned paths are all
            in the same coordinate space. Coordinates in the result data set are relative to
            the stage, not the display object being sampled.
    
            The result includes the following types of objects, with the specified limitations:
    
            * GraphicsSolidFill
            * GraphicsGradientFill
                * All properties of the gradient fill are returned by `readGraphicsData()`.
                * The matrix returned is close to, but not exactly the same as, the input
                matrix.
            * GraphicsEndFill
            * GraphicsBitmapFill
                * The matrix returned is close to, but not exactly the same as, the input
                matrix.
                * `repeat` is always `true`.
                * `smooth` is always `false`.
            * GraphicsStroke
                * `thickness` is supported.
                * `fill` supports GraphicsSolidFill, GraphicsGradientFill, and GraphicsBitmapFill
                as described previously
                * All other properties have default values.
            * GraphicsPath
                * The only supported commands are `MOVE_TO`, `CURVE_TO`, and `LINE_TO`.
    
            The following visual elements and transformations can't be represented and are not
            included in the result:
    
            * Masks
            * Text, with one exception: Static text that is defined with anti-alias type
            "anti-alias for animation" is rendered as vector shapes so it is included in the
            result.
            * Shader fills
            * Blend modes
            * 9-slice scaling
            * Triangles (created with the `drawTriangles()` method)
            * Opaque background
            * `scrollRect` settings
            * 2.5D transformations
            * Non-visible objects (objects whose `visible` property is `false`)
    
            @param	recurse	whether the runtime should also query display object children of
            the current display object. A recursive query can take more time and memory to
            execute. The results are returned in a single flattened result set, not separated
            by display object.
            @returns	A Vector of IGraphicsData objects representing the vector graphics
            content of the related display object
        **/
        readGraphicsData(recurse = true) {
            var graphicsData = new Vector();
            this.__owner.__readGraphicsData(graphicsData, recurse);
            return graphicsData;
        }
        __calculateBezierCubicPoint(t, p1, p2, p3, p4) {
            var iT = 1 - t;
            return p1 * (iT * iT * iT) + 3 * p2 * t * (iT * iT) + 3 * p3 * iT * (t * t) + p4 * (t * t * t);
        }
        __calculateBezierQuadPoint(t, p1, p2, p3) {
            var iT = 1 - t;
            return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;
        }
        __cleanup() {
            if (this.__bounds != null && this.__renderData.canvas != null) {
                this.__setDirty();
                this.__transformDirty = true;
            }
            this.__bitmap = null;
            this.__renderData.dispose();
        }
        __getBounds(rect, matrix) {
            if (this.__bounds == null)
                return;
            var bounds = Rectangle.__pool.get();
            this.__bounds.__transform(bounds, matrix);
            rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
            Rectangle.__pool.release(bounds);
        }
        __hitTest(x, y, shapeFlag, matrix) {
            if (this.__bounds == null)
                return false;
            var px = matrix.__transformInverseX(x, y);
            var py = matrix.__transformInverseY(x, y);
            if (px > this.__bounds.x && py > this.__bounds.y && this.__bounds.contains(px, py)) {
                if (shapeFlag) {
                    return CanvasGraphics.hitTest(this, px, py);
                }
                return true;
            }
            return false;
        }
        __inflateBounds(x, y) {
            if (this.__bounds == null) {
                this.__bounds = new Rectangle(x, y, 0, 0);
                this.__owner.__localBoundsDirty = true;
                this.__transformDirty = true;
            }
            else {
                if (x < this.__bounds.x) {
                    this.__bounds.width += this.__bounds.x - x;
                    this.__bounds.x = x;
                    this.__owner.__localBoundsDirty = true;
                    this.__transformDirty = true;
                }
                if (y < this.__bounds.y) {
                    this.__bounds.height += this.__bounds.y - y;
                    this.__bounds.y = y;
                    this.__owner.__localBoundsDirty = true;
                    this.__transformDirty = true;
                }
                if (x > this.__bounds.x + this.__bounds.width) {
                    this.__owner.__localBoundsDirty = true;
                    this.__bounds.width = x - this.__bounds.x;
                }
                if (y > this.__bounds.y + this.__bounds.height) {
                    this.__owner.__localBoundsDirty = true;
                    this.__bounds.height = y - this.__bounds.y;
                }
            }
        }
        __readGraphicsData(graphicsData) {
            var data = new DrawCommandReader(this.__commands);
            var path = null, stroke;
            for (let type of this.__commands.types) {
                switch (type) {
                    case DrawCommandType$1.CUBIC_CURVE_TO:
                    case DrawCommandType$1.CURVE_TO:
                    case DrawCommandType$1.LINE_TO:
                    case DrawCommandType$1.MOVE_TO:
                    case DrawCommandType$1.DRAW_CIRCLE:
                    case DrawCommandType$1.DRAW_ELLIPSE:
                    case DrawCommandType$1.DRAW_RECT:
                    case DrawCommandType$1.DRAW_ROUND_RECT:
                        if (path == null) {
                            path = new GraphicsPath();
                        }
                        break;
                    default:
                        if (path != null) {
                            graphicsData.push(path);
                            path = null;
                        }
                }
                switch (type) {
                    case DrawCommandType$1.CUBIC_CURVE_TO:
                        var c = data.readCubicCurveTo();
                        path.cubicCurveTo(c.controlX1, c.controlY1, c.controlX2, c.controlY2, c.anchorX, c.anchorY);
                        break;
                    case DrawCommandType$1.CURVE_TO:
                        var c2 = data.readCurveTo();
                        path.curveTo(c2.controlX, c2.controlY, c2.anchorX, c2.anchorY);
                        break;
                    case DrawCommandType$1.LINE_TO:
                        var c3 = data.readLineTo();
                        path.lineTo(c3.x, c3.y);
                        break;
                    case DrawCommandType$1.MOVE_TO:
                        var c4 = data.readMoveTo();
                        path.moveTo(c4.x, c4.y);
                        break;
                    case DrawCommandType$1.DRAW_CIRCLE:
                        var c5 = data.readDrawCircle();
                        path.__drawCircle(c5.x, c5.y, c5.radius);
                        break;
                    case DrawCommandType$1.DRAW_ELLIPSE:
                        var c6 = data.readDrawEllipse();
                        path.__drawEllipse(c6.x, c6.y, c6.width, c6.height);
                        break;
                    case DrawCommandType$1.DRAW_RECT:
                        var c7 = data.readDrawRect();
                        path.__drawRect(c7.x, c7.y, c7.width, c7.height);
                        break;
                    case DrawCommandType$1.DRAW_ROUND_RECT:
                        var c8 = data.readDrawRoundRect();
                        path.__drawRoundRect(c8.x, c8.y, c8.width, c8.height, c8.ellipseWidth, c8.ellipseHeight != null ? c8.ellipseHeight : c8.ellipseWidth);
                        break;
                    case DrawCommandType$1.LINE_GRADIENT_STYLE:
                        // TODO
                        var c9 = data.readLineGradientStyle();
                        // stroke = new GraphicsStroke (c.thickness, c.pixelHinting, c.scaleMode, c.caps, c.joints, c.miterLimit);
                        // stroke.fill = new GraphicsGradientFill (c.type, c.colors, c.alphas, c.ratios, c.matrix, c.spreadMethod, c.interpolationMethod, c.focalPointRatio);
                        // graphicsData.push (stroke);
                        break;
                    case DrawCommandType$1.LINE_BITMAP_STYLE:
                        // TODO
                        var c10 = data.readLineBitmapStyle();
                        path = null;
                        // stroke = new GraphicsStroke (c.thickness, c.pixelHinting, c.scaleMode, c.caps, c.joints, c.miterLimit);
                        // stroke.fill = new GraphicsBitmapFill (c.bitmap, c.matrix, c.repeat, c.smooth);
                        // graphicsData.push (stroke);
                        break;
                    case DrawCommandType$1.LINE_STYLE:
                        var c11 = data.readLineStyle();
                        stroke = new GraphicsStroke(c11.thickness, c11.pixelHinting, c11.scaleMode, c11.caps, c11.joints, c11.miterLimit);
                        stroke.fill = new GraphicsSolidFill(c11.color, c11.alpha);
                        graphicsData.push(stroke);
                        break;
                    case DrawCommandType$1.END_FILL:
                        data.readEndFill();
                        graphicsData.push(new GraphicsEndFill());
                        break;
                    case DrawCommandType$1.BEGIN_BITMAP_FILL:
                        var c12 = data.readBeginBitmapFill();
                        graphicsData.push(new GraphicsBitmapFill(c12.bitmap, c12.matrix, c12.repeat, c12.smooth));
                        break;
                    case DrawCommandType$1.BEGIN_FILL:
                        var c13 = data.readBeginFill();
                        graphicsData.push(new GraphicsSolidFill(c13.color, 1));
                        break;
                    case DrawCommandType$1.BEGIN_GRADIENT_FILL:
                        var c14 = data.readBeginGradientFill();
                        graphicsData.push(new GraphicsGradientFill(c14.type, c14.colors, c14.alphas, c14.ratios, c14.matrix, c14.spreadMethod, c14.interpolationMethod, c14.focalPointRatio));
                        break;
                    // case DrawCommandType.BEGIN_SHADER_FILL:
                    // break;
                    default:
                        data.skip(type);
                }
            }
            if (path != null) {
                graphicsData.push(path);
            }
        }
        __setDirty(value = true) {
            if (value && this.__owner != null) {
                this.__owner.__setRenderDirty();
            }
            if (value) {
                this.__softwareDirty = true;
                this.__hardwareDirty = true;
            }
            this.__dirty = true;
        }
        __update(displayMatrix) {
            if (this.__bounds == null || this.__bounds.width <= 0 || this.__bounds.height <= 0)
                return;
            var parentTransform = this.__owner.__renderTransform;
            var scaleX = 1.0, scaleY = 1.0;
            if (parentTransform != null) {
                if (parentTransform.b == 0) {
                    scaleX = Math.abs(parentTransform.a);
                }
                else {
                    scaleX = Math.sqrt(parentTransform.a * parentTransform.a + parentTransform.b * parentTransform.b);
                }
                if (parentTransform.c == 0) {
                    scaleY = Math.abs(parentTransform.d);
                }
                else {
                    scaleY = Math.sqrt(parentTransform.c * parentTransform.c + parentTransform.d * parentTransform.d);
                }
            }
            else {
                return;
            }
            if (displayMatrix != null) {
                if (displayMatrix.b == 0) {
                    scaleX *= displayMatrix.a;
                }
                else {
                    scaleX *= Math.sqrt(displayMatrix.a * displayMatrix.a + displayMatrix.b * displayMatrix.b);
                }
                if (displayMatrix.c == 0) {
                    scaleY *= displayMatrix.d;
                }
                else {
                    scaleY *= Math.sqrt(displayMatrix.c * displayMatrix.c + displayMatrix.d * displayMatrix.d);
                }
            }
            // #if openfl_disable_graphics_upscaling
            // if (scaleX > 1) scaleX = 1;
            // if (scaleY > 1) scaleY = 1;
            // #end
            var width = this.__bounds.width * scaleX;
            var height = this.__bounds.height * scaleY;
            if (width < 1 || height < 1) {
                if (this.__width >= 1 || this.__height >= 1)
                    this.__setDirty();
                this.__width = 0;
                this.__height = 0;
                return;
            }
            if (Graphics.maxTextureWidth != null && width > Graphics.maxTextureWidth) {
                width = Graphics.maxTextureWidth;
                scaleX = Graphics.maxTextureWidth / this.__bounds.width;
            }
            if (Graphics.maxTextureWidth != null && height > Graphics.maxTextureHeight) {
                height = Graphics.maxTextureHeight;
                scaleY = Graphics.maxTextureHeight / this.__bounds.height;
            }
            this.__renderTransform.a = width / this.__bounds.width;
            this.__renderTransform.d = height / this.__bounds.height;
            var inverseA = (1 / this.__renderTransform.a);
            var inverseD = (1 / this.__renderTransform.d);
            // Inlined & simplified `__worldTransform.concat (parentTransform)` below:
            this.__worldTransform.a = inverseA * parentTransform.a;
            this.__worldTransform.b = inverseA * parentTransform.b;
            this.__worldTransform.c = inverseD * parentTransform.c;
            this.__worldTransform.d = inverseD * parentTransform.d;
            var x = this.__bounds.x;
            var y = this.__bounds.y;
            var tx = x * parentTransform.a + y * parentTransform.c + parentTransform.tx;
            var ty = x * parentTransform.b + y * parentTransform.d + parentTransform.ty;
            // Floor the world position for crisp graphics rendering
            this.__worldTransform.tx = Math.floor(tx);
            this.__worldTransform.ty = Math.floor(ty);
            // Offset the rendering with the subpixel offset removed by Math.floor above
            this.__renderTransform.tx = this.__worldTransform.__transformInverseX(tx, ty);
            this.__renderTransform.ty = this.__worldTransform.__transformInverseY(tx, ty);
            // Calculate the size to contain the graphics and an extra subpixel
            // We used to add tx and ty from __renderTransform instead of 1.0
            // but it improves performance if we keep the size consistent when the
            // extra pixel isn't needed
            var newWidth = Math.ceil(width + 1.0);
            var newHeight = Math.ceil(height + 1.0);
            // Mark dirty if render size changed
            if (newWidth != this.__width || newHeight != this.__height) {
                // #if!openfl_disable_graphics_upscaling
                this.__setDirty();
                // #end
            }
            this.__width = newWidth;
            this.__height = newHeight;
        }
    }
    Graphics.maxTextureHeight = null;
    Graphics.maxTextureWidth = null;
    return Graphics;
})();

/**
    An object dispatches a FocusEvent object when the user changes the focus
    from one object in the display list to another. There are four types of
    focus events:

    * `FocusEvent.FOCUS_IN`
    * `FocusEvent.FOCUS_OUT`
    * `FocusEvent.KEY_FOCUS_CHANGE`
    * `FocusEvent.MOUSE_FOCUS_CHANGE`
**/
let FocusEvent = /** @class */ (() => {
    class FocusEvent extends Event {
        /**
            Creates an Event object with specific information relevant to focus
            events. Event objects are passed as parameters to event listeners.
    
            @param type          The type of the event. Possible values are:
                                 `FocusEvent.FOCUS_IN`,
                                 `FocusEvent.FOCUS_OUT`,
                                 `FocusEvent.KEY_FOCUS_CHANGE`, and
                                 `FocusEvent.MOUSE_FOCUS_CHANGE`.
            @param bubbles       Determines whether the Event object participates in
                                 the bubbling stage of the event flow.
            @param cancelable    Determines whether the Event object can be canceled.
            @param relatedObject Indicates the complementary InteractiveObject
                                 instance that is affected by the change in focus. For
                                 example, when a `focusIn` event occurs,
                                 `relatedObject` represents the
                                 InteractiveObject that has lost focus.
            @param shiftKey      Indicates whether the Shift key modifier is
                                 activated.
            @param keyCode       Indicates the code of the key pressed to trigger a
                                 `keyFocusChange` event.
        **/
        constructor(type, bubbles = false, cancelable = false, relatedObject = null, shiftKey = false, keyCode = 0) {
            super(type, bubbles, cancelable);
            this.keyCode = keyCode;
            this.shiftKey = shiftKey;
            this.relatedObject = relatedObject;
        }
        clone() {
            var event = new FocusEvent(this.__type, this.__bubbles, this.__cancelable, this.relatedObject, this.shiftKey, this.keyCode);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("FocusEvent", "type", "bubbles", "cancelable", "relatedObject", "shiftKey", "keyCode");
        }
        __init() {
            super.__init();
            this.keyCode = 0;
            this.shiftKey = false;
            this.relatedObject = null;
        }
    }
    /**
        Defines the value of the `type` property of a `focusIn` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `keyCode` | 0; applies only to `keyFocusChange` events. |
        | `relatedObject` | The complementary InteractiveObject instance that is affected by the change in focus. |
        | `shiftKey` | `false`; applies only to `keyFocusChange` events. |
        | `target` | The InteractiveObject instance that has just received focus. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `direction` | The direction from which focus was assigned. This property reports the value of the `direction` parameter of the `assignFocus()` method of the stage. If the focus changed through some other means, the value will always be `FocusDirection.NONE`. Applies only to `focusIn` events. For all other focus events the value will be `FocusDirection.NONE`. |
    **/
    FocusEvent.FOCUS_IN = "focusIn";
    /**
        Defines the value of the `type` property of a `focusOut` event object.

        This event has the following properties:

        |Property | Value || --- | --- || `bubbles` | `true` || `cancelable` | `false`;
        there is no default behavior to
        cancel. || `currentTarget` | The
        object that is actively processing the Event object with an event
        listener. || `keyCode` | 0; applies
        only to `keyFocusChange`
        events. || `relatedObject` | The
        complementary InteractiveObject instance that is affected by the
        change in
        focus. || `shiftKey` | `false`;
        applies only to `keyFocusChange`
        events. || `target` | The
        InteractiveObject instance that has just lost focus. The `target` is
        not always the object in the display list that registered the event
        listener. Use the `currentTarget` property to access the object in the
        display list that is currently processing the event.
         |
    **/
    FocusEvent.FOCUS_OUT = "focusOut";
    /**
        Defines the value of the `type` property of a `keyFocusChange` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true`; call the `preventDefault()` method to cancel default behavior. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `keyCode` | The key code value of the key pressed to trigger a `keyFocusChange` event. |
        | `relatedObject` | The complementary InteractiveObject instance that is affected by the change in focus. |
        | `shiftKey` | `true` if the Shift key modifier is activated; `false` otherwise. |
        | `target` | The InteractiveObject instance that currently has focus. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    FocusEvent.KEY_FOCUS_CHANGE = "keyFocusChange";
    /**
        Defines the value of the `type` property of a `mouseFocusChange` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true`; call the `preventDefault()` method to cancel default behavior. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `keyCode` | 0; applies only to `keyFocusChange` events. |
        | `relatedObject` | The complementary InteractiveObject instance that is affected by the change in focus. |
        | `shiftKey` | `false`; applies only to `keyFocusChange` events. |
        | `target` | The InteractiveObject instance that currently has focus. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    FocusEvent.MOUSE_FOCUS_CHANGE = "mouseFocusChange";
    FocusEvent.__pool = new ObjectPool(() => new FocusEvent(null), (event) => event.__init());
    return FocusEvent;
})();

/**
        The KeyLocation class contains constants that indicate the location of a
        key pressed on the keyboard or keyboard-like input device.
        The KeyLocation constants are used in the `KeyboardEvent.keyLocation`
        property.
    **/
var KeyLocation;
(function (KeyLocation) {
    /**
        Indicates the key activated is in the left key location (there is more
        than one possible location for this key). Example: The left Shift key
        on a PC 101 Key US keyboard.
    **/
    KeyLocation[KeyLocation["LEFT"] = 1] = "LEFT";
    /**
        Indicates the key activation originated on the numeric keypad or with a virtual
        key corresponding to the numeric keypad. Example: The 1 key on a PC 101 Key US
        keyboard located on the numeric pad.
    **/
    KeyLocation[KeyLocation["NUM_PAD"] = 3] = "NUM_PAD";
    /**
        Indicates the key activated is in the right key location (there is
        more than one possible location for this key). Example: The right
        Shift key on a PC 101 Key US keyboard.
    **/
    KeyLocation[KeyLocation["RIGHT"] = 2] = "RIGHT";
    /**
        Indicates the key activation is not distinguished as the left or right
        version of the key, and did not originate on the numeric keypad (or
        did not originate with a virtual key corresponding to the numeric
        keypad). Example: The Q key on a PC 101 Key US keyboard.
    **/
    KeyLocation[KeyLocation["STANDARD"] = 0] = "STANDARD";
})(KeyLocation || (KeyLocation = {}));
var KeyLocation$1 = KeyLocation;

/**
    A KeyboardEvent object id dispatched in response to user input through a
    keyboard. There are two types of keyboard events:
    `KeyboardEvent.KEY_DOWN` and `KeyboardEvent.KEY_UP`

    Because mappings between keys and specific characters vary by device and
    operating system, use the TextEvent event type for processing character
    input.

    To listen globally for key events, listen on the Stage for the capture
    and target or bubble phase.
**/
let KeyboardEvent = /** @class */ (() => {
    class KeyboardEvent extends Event {
        /**
            Creates an Event object that contains specific information about keyboard
            events. Event objects are passed as parameters to event listeners.
    
            @param type             The type of the event. Possible values are:
                                    `KeyboardEvent.KEY_DOWN` and
                                    `KeyboardEvent.KEY_UP`
            @param bubbles          Determines whether the Event object participates
                                    in the bubbling stage of the event flow.
            @param cancelable       Determines whether the Event object can be
                                    canceled.
            @param charCodeValue    The character code value of the key pressed or
                                    released. The character code values returned are
                                    English keyboard values. For example, if you press
                                    Shift+3, the `Keyboard.charCode()`
                                    property returns # on a Japanese keyboard, just as
                                    it does on an English keyboard.
            @param keyCodeValue     The key code value of the key pressed or released.
            @param keyLocationValue The location of the key on the keyboard.
            @param ctrlKeyValue     On Windows, indicates whether the Ctrl key is
                                    activated. On Mac, indicates whether either the
                                    Ctrl key or the Command key is activated.
            @param altKeyValue      Indicates whether the Alt key modifier is
                                    activated(Windows only).
            @param shiftKeyValue    Indicates whether the Shift key modifier is
                                    activated.
            @param commandKeyValue  Indicates whether the Command key modifier is
                                    activated.
        **/
        constructor(type, bubbles = false, cancelable = false, charCodeValue = 0, keyCodeValue = 0, keyLocationValue = null, ctrlKeyValue = false, altKeyValue = false, shiftKeyValue = false, controlKeyValue = false, commandKeyValue = false) {
            super(type, bubbles, cancelable);
            this.charCode = charCodeValue;
            this.keyCode = keyCodeValue;
            this.keyLocation = keyLocationValue != null ? keyLocationValue : KeyLocation$1.STANDARD;
            this.ctrlKey = ctrlKeyValue;
            this.altKey = altKeyValue;
            this.shiftKey = shiftKeyValue;
            this.controlKey = controlKeyValue;
            this.commandKey = commandKeyValue;
        }
        clone() {
            var event = new KeyboardEvent(this.__type, this.__bubbles, this.__cancelable, this.charCode, this.keyCode, this.keyLocation, this.ctrlKey, this.altKey, this.shiftKey, this.controlKey, this.commandKey);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("KeyboardEvent", "type", "bubbles", "cancelable", "charCode", "keyCode", "keyLocation", "ctrlKey", "altKey", "shiftKey");
        }
        __init() {
            super.__init();
            this.charCode = 0;
            this.keyCode = 0;
            this.keyLocation = KeyLocation$1.STANDARD;
            this.ctrlKey = false;
            this.altKey = false;
            this.shiftKey = false;
            this.controlKey = false;
            this.commandKey = false;
        }
    }
    /**
        The `KeyboardEvent.KEY_DOWN` constant defines the value of the `type`
        property of a `keyDown` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true` in AIR, `false` in Flash Player; in AIR, canceling this event prevents the character from being entered into a text field. |
        | `charCode` | The character code value of the key pressed or released. |
        | `commandKey` | `true` on Mac if the Command key is active. Otherwise, `false` |
        | `controlKey` | `true` on Windows and Linux if the Ctrl key is active. `true` on Mac if either the Control key is active. Otherwise, `false` |
        | `ctrlKey` | `true` on Windows and Linux if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `keyCode` | The key code value of the key pressed or released. |
        | `keyLocation` | The location of the key on the keyboard. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `target` | The InteractiveObject instance with focus. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    KeyboardEvent.KEY_DOWN = "keyDown";
    /**
        The `KeyboardEvent.KEY_UP` constant defines the value of the `type`
        property of a `keyUp` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `charCode` | Contains the character code value of the key pressed or released. |
        | `commandKey` | `true` on Mac if the Command key is active. Otherwise, `false` |
        | `controlKey` | `true` on Windows and Linux if the Ctrl key is active. `true` on Mac if either the Control key is active. Otherwise, `false` |
        | `ctrlKey` | `true` on Windows if the Ctrl key is active. `true` on Mac if either the Ctrl key or the Command key is active. Otherwise, `false`. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `keyCode` | The key code value of the key pressed or released. |
        | `keyLocation` | The location of the key on the keyboard. |
        | `shiftKey` | `true` if the Shift key is active; `false` if it is inactive. |
        | `target` | The InteractiveObject instance with focus. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
    **/
    KeyboardEvent.KEY_UP = "keyUp";
    KeyboardEvent.__pool = new ObjectPool(() => new KeyboardEvent(null), (event) => event.__init());
    return KeyboardEvent;
})();

/**
    An object dispatches a TextEvent object when a user enters text in a text
    field or clicks a hyperlink in an HTML-enabled text field. There are two
    types of text events: `TextEvent.LINK` and
    `TextEvent.TEXT_INPUT`.
**/
let TextEvent = /** @class */ (() => {
    class TextEvent extends Event {
        /**
            Creates an Event object that contains information about text events. Event
            objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access this
                              information through the inherited `type`
                              property. Possible values are:
                              `TextEvent.LINK` and
                              `TextEvent.TEXT_INPUT`.
            @param bubbles    Determines whether the Event object participates in the
                              bubbling phase of the event flow. Event listeners can
                              access this information through the inherited
                              `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through the
                              inherited `cancelable` property.
            @param text       One or more characters of text entered by the user.
                              Event listeners can access this information through the
                              `text` property.
        **/
        constructor(type, bubbles = false, cancelable = false, text = "") {
            super(type, bubbles, cancelable);
            this.text = text;
        }
        clone() {
            var event = new TextEvent(this.__type, this.__bubbles, this.__cancelable, this.text);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("TextEvent", "type", "bubbles", "cancelable", "text");
        }
        __init() {
            super.__init();
            this.text = "";
        }
    }
    /**
        Defines the value of the `type` property of a `link` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The text field containing the hyperlink that has been clicked. The `target` is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        | `text` | The remainder of the URL after "event:" |
    **/
    TextEvent.LINK = "link";
    /**
        Defines the value of the `type` property of a `textInput` event
        object.
        **Note:** This event is not dispatched for the Delete or Backspace
        keys.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true`; call the `preventDefault()` method to cancel default behavior. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The text field into which characters are being entered. The target is not always the object in the display list that registered the event listener. Use the `currentTarget` property to access the object in the display list that is currently processing the event. |
        |`text` | The character or sequence of characters entered by the user. |
    **/
    TextEvent.TEXT_INPUT = "textInput";
    TextEvent.__pool = new ObjectPool(() => new TextEvent(null), (event) => event.__init());
    return TextEvent;
})();

/**
    The URLRequestDefaults class includes static properties that you can set to define
    default values for the properties of the URLRequest class. It also includes a static
    method, `URLRequestDefaults.setLoginCredentialsForHost()`, which lets you define
    default authentication credentials for requests. The URLRequest class defines the
    information to use in an HTTP request.

    Any properties set in a URLRequest objectthose static properties set for the
    URLRequestDefaults class.

    URLRequestDefault settings only apply to content in the caller's application domain,
    with one exception: settings made by calling
    `URLRequestDefaults.setLoginCredentialsForHost()` apply to all application domains in
    the currently running application.

    Only Adobe® AIR® content running in the application security sandbox can use the
    URLRequestDefaults class. Other content will result in a SecurityError being thrown
    when accessing the members or properties of this class.
**/
let URLRequestDefaults = /** @class */ (() => {
    class URLRequestDefaults {
    }
    // public static authenticate:Bool;
    // public static cacheResponse:Bool;
    /**
        The default setting for the `followRedirects` property of URLRequest objects.
        Setting the `followRedirects` property in a URLRequest object overrides this
        default setting. This setting does not apply to URLRequest objects used in file
        upload or RTMP requests.

        The default value is `true`.
    **/
    URLRequestDefaults.followRedirects = true;
    /**
        The default setting for the `idleTimeout` property of URLRequest objects and
        HTMLLoader objects.

        The idle timeout is the amount of time (in milliseconds) that the client waits for
        a response from the server, after the connection is established, before abandoning
        the request.

        This defines the default idle timeout used by the URLRequest or HTMLLoader object.
        Setting the `idleTimeout` property in a URLRequest object or an HTMLLoader object
        overrides this default setting.

        When this property is set to 0 (the default), the runtime uses the default idle
        timeout value defined by the operating system. The default idle timeout value
        varies between operating systems (such as Mac OS, Linux, or Windows) and between
        operating system versions.

        This setting does not apply to URLRequest objects used in file upload or RTMP
        requests.

        The default value is 0.
    **/
    URLRequestDefaults.idleTimeout = 0;
    /**
        The default setting for the manageCookies property of URLRequest objects. Setting
        the manageCookies property in a URLRequest object overrides this default setting.

        **Note:** This setting does not apply to URLRequest objects used in file upload
        or RTMP requests.

        The default value is `true`.
    **/
    URLRequestDefaults.manageCookies = false;
    return URLRequestDefaults;
})();

/**
        The URLRequestMethod class provides values that specify whether the
        URLRequest object should use the `POST` method or the
        `GET` method when sending data to a server.
    **/
var URLRequestMethod;
(function (URLRequestMethod) {
    /**
        Specifies that the URLRequest object is a `DELETE`.
    **/
    URLRequestMethod["DELETE"] = "DELETE";
    /**
        Specifies that the URLRequest object is a `GET`.
    **/
    URLRequestMethod["GET"] = "GET";
    /**
        Specifies that the URLRequest object is a `HEAD`.
    **/
    URLRequestMethod["HEAD"] = "HEAD";
    /**
        Specifies that the URLRequest object is `OPTIONS`.
    **/
    URLRequestMethod["OPTIONS"] = "OPTIONS";
    /**
        Specifies that the URLRequest object is a `POST`.

        _Note:_ For content running in Adobe AIR, when using the
        `navigateToURL()` function, the runtime treats a URLRequest
        that uses the POST method(one that has its `method` property
        set to `URLRequestMethod.POST`) as using the GET method.
    **/
    URLRequestMethod["POST"] = "POST";
    /**
        Specifies that the URLRequest object is a `PUT`.
    **/
    URLRequestMethod["PUT"] = "PUT";
})(URLRequestMethod || (URLRequestMethod = {}));
var URLRequestMethod$1 = URLRequestMethod;

/**
    The URLRequest class captures all of the information in a single HTTP
    request. URLRequest objects are passed to the `load()` methods
    of the Loader, URLStream, and URLLoader classes, and to other loading
    operations, to initiate URL downloads. They are also passed to the
    `upload()` and `download()` methods of the
    FileReference class.

    A SWF file in the local-with-filesystem sandbox may not load data from,
    or provide data to, a resource that is in the network sandbox.

    By default, the calling SWF file and the URL you load must be in the
    same domain. For example, a SWF file at www.adobe.com can load data only
    from sources that are also at www.adobe.com. To load data from a different
    domain, place a URL policy file on the server hosting the data.

        However, in Adobe AIR, content in the application security sandbox
    (content installed with the AIR application) is not restricted by these
    security limitations. For content running in Adobe AIR, files in the
    application security sandbox can access URLs using any of the following URL
    schemes:


    * `http` and `https`
    * `file`
    * `app-storage`
    * `app`


    Content running in Adobe AIR that is not in the application security
    sandbox observes the same restrictions as content running in the browser
    (in Flash Player), and loading is governed by the content's domain and any
    permissions granted in URL policy files.

    For more information related to security, see the Flash Player Developer
    Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).
**/
class URLRequest {
    /**
        Creates a URLRequest object. If `System.useCodePage` is
        `true`, the request is encoded using the system code page,
        rather than Unicode. If `System.useCodePage` is
        `false`, the request is encoded using Unicode, rather than the
        system code page.

        @param url The URL to be requested. You can set the URL later by using the
                   `url` property.
    **/
    constructor(url = null) {
        if (url != null) {
            this.url = url;
        }
        this.contentType = null; // "application/x-www-form-urlencoded";
        this.followRedirects = URLRequestDefaults.followRedirects;
        if (URLRequestDefaults.idleTimeout > 0) {
            this.idleTimeout = URLRequestDefaults.idleTimeout;
        }
        else {
            this.idleTimeout = 30000;
        }
        this.manageCookies = URLRequestDefaults.manageCookies;
        this.method = URLRequestMethod$1.GET;
        this.requestHeaders = [];
        this.userAgent = URLRequestDefaults.userAgent;
    }
}

/**
    The TextFormat class represents character formatting information. Use the
    TextFormat class to create specific text formatting for text fields. You
    can apply text formatting to both static and dynamic text fields. The
    properties of the TextFormat class apply to device and embedded fonts.
    However, for embedded fonts, bold and italic text actually require
    specific fonts. If you want to display bold or italic text with an
    embedded font, you need to embed the bold and italic variations of that
    font.

    You must use the constructor `new TextFormat()` to create a TextFormat
    object before setting its properties. When you apply a TextFormat object
    to a text field using the `TextField.defaultTextFormat` property or the
    `TextField.setTextFormat()` method, only its defined properties are
    applied. Use the `TextField.defaultTextFormat` property to apply
    formatting BEFORE you add text to the `TextField`, and the
    `setTextFormat()` method to add formatting AFTER you add text to the
    `TextField`. The TextFormat properties are `null` by default because if
    you don't provide values for the properties, Flash Player uses its own
    default formatting. The default formatting that Flash Player uses for each
    property (if property's value is `null`) is as follows:

    | | |
    | --- | --- |
    | align = "left" | |
    | blockIndent = 0 | |
    | bold = false | |
    | bullet = false | |
    | color = 0x000000 | |
    | font = "Times New Roman" (default font is Times on Mac OS X) | |
    | indent = 0 | |
    | italic = false | |
    | kerning = false | |
    | leading = 0 | |
    | leftMargin = 0 | |
    | letterSpacing = 0 | |
    | rightMargin = 0 | |
    | size = 12 | |
    | tabStops = [] (empty array) | |
    | target = "" (empty string) | |
    | underline = false | |
    | url = "" (empty string) | |

    The default formatting for each property is also described in each
    property description.
**/
class TextFormat {
    /**
        Creates a TextFormat object with the specified properties. You can then
        change the properties of the TextFormat object to change the formatting of
        text fields.

        Any parameter may be set to `null` to indicate that it is
        not defined. All of the parameters are optional; any omitted parameters
        are treated as `null`.

        @param font        The name of a font for text as a string.
        @param size        An integer that indicates the size in pixels.
        @param color       The color of text using this text format. A number
                           containing three 8-bit RGB components; for example,
                           0xFF0000 is red, and 0x00FF00 is green.
        @param bold        A Boolean value that indicates whether the text is
                           boldface.
        @param italic      A Boolean value that indicates whether the text is
                           italicized.
        @param underline   A Boolean value that indicates whether the text is
                           underlined.
        @param url         The URL to which the text in this text format
                           hyperlinks. If `url` is an empty string, the
                           text does not have a hyperlink.
        @param target      The target window where the hyperlink is displayed. If
                           the target window is an empty string, the text is
                           displayed in the default target window
                           `_self`. If the `url` parameter
                           is set to an empty string or to the value
                           `null`, you can get or set this property,
                           but the property will have no effect.
        @param align       The alignment of the paragraph, as a TextFormatAlign
                           value.
        @param leftMargin  Indicates the left margin of the paragraph, in pixels.
        @param rightMargin Indicates the right margin of the paragraph, in pixels.
        @param indent      An integer that indicates the indentation from the left
                           margin to the first character in the paragraph.
        @param leading     A number that indicates the amount of leading vertical
                           space between lines.
    **/
    constructor(font = null, size = null, color = null, bold = null, italic = null, underline = null, url = null, target = null, align = null, leftMargin = null, rightMargin = null, indent = null, leading = null) {
        this.font = font;
        this.size = size;
        this.color = color;
        this.bold = bold;
        this.italic = italic;
        this.underline = underline;
        this.url = url;
        this.target = target;
        this.align = align;
        this.leftMargin = leftMargin;
        this.rightMargin = rightMargin;
        this.indent = indent;
        this.leading = leading;
    }
    /** @hidden */
    clone() {
        var newFormat = new TextFormat(this.font, this.size, this.color, this.bold, this.italic, this.underline, this.url, this.target);
        newFormat.align = this.align;
        newFormat.leftMargin = this.leftMargin;
        newFormat.rightMargin = this.rightMargin;
        newFormat.indent = this.indent;
        newFormat.leading = this.leading;
        newFormat.blockIndent = this.blockIndent;
        newFormat.bullet = this.bullet;
        newFormat.kerning = this.kerning;
        newFormat.letterSpacing = this.letterSpacing;
        newFormat.tabStops = this.tabStops;
        newFormat.__ascent = this.__ascent;
        newFormat.__descent = this.__descent;
        return newFormat;
    }
    __merge(format) {
        if (format.font != null)
            this.font = format.font;
        if (format.size != null)
            this.size = format.size;
        if (format.color != null)
            this.color = format.color;
        if (format.bold != null)
            this.bold = format.bold;
        if (format.italic != null)
            this.italic = format.italic;
        if (format.underline != null)
            this.underline = format.underline;
        if (format.url != null)
            this.url = format.url;
        if (format.target != null)
            this.target = format.target;
        if (format.align != null)
            this.align = format.align;
        if (format.leftMargin != null)
            this.leftMargin = format.leftMargin;
        if (format.rightMargin != null)
            this.rightMargin = format.rightMargin;
        if (format.indent != null)
            this.indent = format.indent;
        if (format.leading != null)
            this.leading = format.leading;
        if (format.blockIndent != null)
            this.blockIndent = format.blockIndent;
        if (format.bullet != null)
            this.bullet = format.bullet;
        if (format.kerning != null)
            this.kerning = format.kerning;
        if (format.letterSpacing != null)
            this.letterSpacing = format.letterSpacing;
        if (format.tabStops != null)
            this.tabStops = format.tabStops;
        if (format.__ascent != null)
            this.__ascent = format.__ascent;
        if (format.__descent != null)
            this.__descent = format.__descent;
    }
}

/**
    The TextLineMetrics class contains information about the text position and
    measurements of a _line of text_ within a text field. All measurements are
    in pixels. Objects of this class are returned by the
    `openfl.text.TextField.getLineMetrics()` method.
    For measurements related to the text field containing the line of text
    (for example, the "Text Field height" measurement in the diagram), see
    openfl.text.TextField.

    The following diagram indicates the points and measurements of a text
    field and the line of text the field contains:

    ![An image illustrating text metrics](/images/text-metrics.jpg)
**/
class TextLineMetrics {
    /**
        Creates a TextLineMetrics object. The TextLineMetrics object contains
        information about the text metrics of a line of text in a text field.
        Objects of this class are returned by the
        openfl.text.TextField.getLineMetrics() method.

        @param x           The left position of the first character in pixels.
        @param width       The width of the text of the selected lines (not
                           necessarily the complete text) in pixels.
        @param height      The height of the text of the selected lines (not
                           necessarily the complete text) in pixels.
        @param ascent      The length from the baseline to the top of the line
                           height in pixels.
        @param descent     The length from the baseline to the bottom depth of
                           the line in pixels.
        @param leading     The measurement of the vertical distance between the
                           lines of text.
    **/
    constructor(x, width, height, ascent, descent, leading) {
        this.x = x;
        this.width = width;
        this.height = height;
        this.ascent = ascent;
        this.descent = descent;
        this.leading = leading;
    }
}

/**
        The Keyboard class is used to build an interface that can be controlled by
        a user with a standard keyboard. You can use the methods and properties of
        the Keyboard class without using a constructor. The properties of the
        Keyboard class are constants representing the keys that are most commonly
        used to control games.
    **/
let Keyboard = /** @class */ (() => {
    class Keyboard {
        /**
            Specifies whether the last key pressed is accessible by other SWF files.
            By default, security restrictions prevent code from a SWF file in one
            domain from accessing a keystroke generated from a SWF file in another
            domain.
    
            @return The value `true` if the last key pressed can be
                    accessed. If access is not permitted, this method returns
                    `false`.
        **/
        static isAccessible() {
            // default browser security restrictions are always enforced
            return false;
        }
        // Get & Set Methods
        /**
            Specifies whether the Caps Lock key is activated(`true`) or
            not(`false`).
        **/
        static get capsLock() {
            return Keyboard.__capsLock;
        }
        /**
            Specifies whether the Num Lock key is activated(`true`) or not
            (`false`).
        **/
        static numLock() {
            return Keyboard.__numLock;
        }
    }
    /**
        Constant associated with the key code value for the 0 key(48).
    **/
    Keyboard.NUMBER_0 = 48;
    /**
        Constant associated with the key code value for the 1 key(49).
    **/
    Keyboard.NUMBER_1 = 49;
    /**
        Constant associated with the key code value for the 2 key(50).
    **/
    Keyboard.NUMBER_2 = 50;
    /**
        Constant associated with the key code value for the 3 key(51).
    **/
    Keyboard.NUMBER_3 = 51;
    /**
        Constant associated with the key code value for the 4 key(52).
    **/
    Keyboard.NUMBER_4 = 52;
    /**
        Constant associated with the key code value for the 5 key(53).
    **/
    Keyboard.NUMBER_5 = 53;
    /**
        Constant associated with the key code value for the 6 key(54).
    **/
    Keyboard.NUMBER_6 = 54;
    /**
        Constant associated with the key code value for the 7 key(55).
    **/
    Keyboard.NUMBER_7 = 55;
    /**
        Constant associated with the key code value for the 8 key(56).
    **/
    Keyboard.NUMBER_8 = 56;
    /**
        Constant associated with the key code value for the 9 key(57).
    **/
    Keyboard.NUMBER_9 = 57;
    /**
        Constant associated with the key code value for the A key(65).
    **/
    Keyboard.A = 65;
    /**
        Constant associated with the key code value for the B key(66).
    **/
    Keyboard.B = 66;
    /**
        Constant associated with the key code value for the C key(67).
    **/
    Keyboard.C = 67;
    /**
        Constant associated with the key code value for the D key(68).
    **/
    Keyboard.D = 68;
    /**
        Constant associated with the key code value for the E key(69).
    **/
    Keyboard.E = 69;
    /**
        Constant associated with the key code value for the F key(70).
    **/
    Keyboard.F = 70;
    /**
        Constant associated with the key code value for the G key(71).
    **/
    Keyboard.G = 71;
    /**
        Constant associated with the key code value for the H key(72).
    **/
    Keyboard.H = 72;
    /**
        Constant associated with the key code value for the I key(73).
    **/
    Keyboard.I = 73;
    /**
        Constant associated with the key code value for the J key(74).
    **/
    Keyboard.J = 74;
    /**
        Constant associated with the key code value for the K key(75).
    **/
    Keyboard.K = 75;
    /**
        Constant associated with the key code value for the L key(76).
    **/
    Keyboard.L = 76;
    /**
        Constant associated with the key code value for the M key(77).
    **/
    Keyboard.M = 77;
    /**
        Constant associated with the key code value for the N key(78).
    **/
    Keyboard.N = 78;
    /**
        Constant associated with the key code value for the O key(79).
    **/
    Keyboard.O = 79;
    /**
        Constant associated with the key code value for the P key(80).
    **/
    Keyboard.P = 80;
    /**
        Constant associated with the key code value for the Q key(81).
    **/
    Keyboard.Q = 81;
    /**
        Constant associated with the key code value for the R key(82).
    **/
    Keyboard.R = 82;
    /**
        Constant associated with the key code value for the S key(83).
    **/
    Keyboard.S = 83;
    /**
        Constant associated with the key code value for the T key(84).
    **/
    Keyboard.T = 84;
    /**
        Constant associated with the key code value for the U key(85).
    **/
    Keyboard.U = 85;
    /**
        Constant associated with the key code value for the V key(85).
    **/
    Keyboard.V = 86;
    /**
        Constant associated with the key code value for the W key(87).
    **/
    Keyboard.W = 87;
    /**
        Constant associated with the key code value for the X key(88).
    **/
    Keyboard.X = 88;
    /**
        Constant associated with the key code value for the Y key(89).
    **/
    Keyboard.Y = 89;
    /**
        Constant associated with the key code value for the Z key(90).
    **/
    Keyboard.Z = 90;
    /**
        Constant associated with the key code value for the number 0 key on the
        number pad(96).
    **/
    Keyboard.NUMPAD_0 = 96;
    /**
        Constant associated with the key code value for the number 1 key on the
        number pad(97).
    **/
    Keyboard.NUMPAD_1 = 97;
    /**
        Constant associated with the key code value for the number 2 key on the
        number pad(98).
    **/
    Keyboard.NUMPAD_2 = 98;
    /**
        Constant associated with the key code value for the number 3 key on the
        number pad(99).
    **/
    Keyboard.NUMPAD_3 = 99;
    /**
        Constant associated with the key code value for the number 4 key on the
        number pad(100).
    **/
    Keyboard.NUMPAD_4 = 100;
    /**
        Constant associated with the key code value for the number 5 key on the
        number pad(101).
    **/
    Keyboard.NUMPAD_5 = 101;
    /**
        Constant associated with the key code value for the number 6 key on the
        number pad(102).
    **/
    Keyboard.NUMPAD_6 = 102;
    /**
        Constant associated with the key code value for the number 7 key on the
        number pad(103).
    **/
    Keyboard.NUMPAD_7 = 103;
    /**
        Constant associated with the key code value for the number 8 key on the
        number pad(104).
    **/
    Keyboard.NUMPAD_8 = 104;
    /**
        Constant associated with the key code value for the number 9 key on the
        number pad(105).
    **/
    Keyboard.NUMPAD_9 = 105;
    /**
        Constant associated with the key code value for the multiplication key on
        the number pad(106).
    **/
    Keyboard.NUMPAD_MULTIPLY = 106;
    /**
        Constant associated with the key code value for the addition key on the
        number pad(107).
    **/
    Keyboard.NUMPAD_ADD = 107;
    /**
        Constant associated with the key code value for the Enter key on the
        number pad(108).
    **/
    Keyboard.NUMPAD_ENTER = 108;
    /**
        Constant associated with the key code value for the subtraction key on the
        number pad(109).
    **/
    Keyboard.NUMPAD_SUBTRACT = 109;
    /**
        Constant associated with the key code value for the decimal key on the
        number pad(110).
    **/
    Keyboard.NUMPAD_DECIMAL = 110;
    /**
        Constant associated with the key code value for the division key on the
        number pad(111).
    **/
    Keyboard.NUMPAD_DIVIDE = 111;
    /**
        Constant associated with the key code value for the F1 key(112).
    **/
    Keyboard.F1 = 112;
    /**
        Constant associated with the key code value for the F2 key(113).
    **/
    Keyboard.F2 = 113;
    /**
        Constant associated with the key code value for the F3 key(114).
    **/
    Keyboard.F3 = 114;
    /**
        Constant associated with the key code value for the F4 key(115).
    **/
    Keyboard.F4 = 115;
    /**
        Constant associated with the key code value for the F5 key(116).
    **/
    Keyboard.F5 = 116;
    /**
        Constant associated with the key code value for the F6 key(117).
    **/
    Keyboard.F6 = 117;
    /**
        Constant associated with the key code value for the F7 key(118).
    **/
    Keyboard.F7 = 118;
    /**
        Constant associated with the key code value for the F8 key(119).
    **/
    Keyboard.F8 = 119;
    /**
        Constant associated with the key code value for the F9 key(120).
    **/
    Keyboard.F9 = 120;
    /**
        Constant associated with the key code value for the F10 key(121).
    **/
    Keyboard.F10 = 121; //  F10 is used by browser.
    /**
        Constant associated with the key code value for the F11 key(122).
    **/
    Keyboard.F11 = 122;
    /**
        Constant associated with the key code value for the F12 key(123).
    **/
    Keyboard.F12 = 123;
    /**
        Constant associated with the key code value for the F13 key(124).
    **/
    Keyboard.F13 = 124;
    /**
        Constant associated with the key code value for the F14 key(125).
    **/
    Keyboard.F14 = 125;
    /**
        Constant associated with the key code value for the F15 key(126).
    **/
    Keyboard.F15 = 126;
    /**
        Constant associated with the key code value for the Backspace key(8).
    **/
    Keyboard.BACKSPACE = 8;
    /**
        Constant associated with the key code value for the Tab key(9).
    **/
    Keyboard.TAB = 9;
    /**
        Constant associated with the key code value for the Alternate(Option) key
        (18).
    **/
    Keyboard.ALTERNATE = 18;
    /**
        Constant associated with the key code value for the Enter key(13).
    **/
    Keyboard.ENTER = 13;
    /**
        Constant associated with the Mac command key(15). This constant is
        currently only used for setting menu key equivalents.
    **/
    Keyboard.COMMAND = 15;
    /**
        Constant associated with the key code value for the Shift key(16).
    **/
    Keyboard.SHIFT = 16;
    /**
        Constant associated with the key code value for the Control key(17).
    **/
    Keyboard.CONTROL = 17;
    /** @hidden */
    Keyboard.BREAK = 19;
    /**
        Constant associated with the key code value for the Caps Lock key(20).
    **/
    Keyboard.CAPS_LOCK = 20;
    /**
        Constant associated with the pseudo-key code for the the number pad(21).
        Use to set numpad modifier on key equivalents
    **/
    Keyboard.NUMPAD = 21;
    /**
        Constant associated with the key code value for the Escape key(27).
    **/
    Keyboard.ESCAPE = 27;
    /**
        Constant associated with the key code value for the Spacebar(32).
    **/
    Keyboard.SPACE = 32;
    /**
        Constant associated with the key code value for the Page Up key(33).
    **/
    Keyboard.PAGE_UP = 33;
    /**
        Constant associated with the key code value for the Page Down key(34).
    **/
    Keyboard.PAGE_DOWN = 34;
    /**
        Constant associated with the key code value for the End key(35).
    **/
    Keyboard.END = 35;
    /**
        Constant associated with the key code value for the Home key(36).
    **/
    Keyboard.HOME = 36;
    /**
        Constant associated with the key code value for the Left Arrow key(37).
    **/
    Keyboard.LEFT = 37;
    /**
        Constant associated with the key code value for the Right Arrow key(39).
    **/
    Keyboard.RIGHT = 39;
    /**
        Constant associated with the key code value for the Up Arrow key(38).
    **/
    Keyboard.UP = 38;
    /**
        Constant associated with the key code value for the Down Arrow key(40).
    **/
    Keyboard.DOWN = 40;
    /**
        Constant associated with the key code value for the Insert key(45).
    **/
    Keyboard.INSERT = 45;
    /**
        Constant associated with the key code value for the Delete key(46).
    **/
    Keyboard.DELETE = 46;
    /** @hidden */
    Keyboard.NUMLOCK = 144;
    /**
        Constant associated with the key code value for the ; key(186).
    **/
    Keyboard.SEMICOLON = 186;
    /**
        Constant associated with the key code value for the:Int = key(187).
    **/
    Keyboard.EQUAL = 187;
    /**
        Constant associated with the key code value for the , key(188).
    **/
    Keyboard.COMMA = 188;
    /**
        Constant associated with the key code value for the - key(189).
    **/
    Keyboard.MINUS = 189;
    /**
        Constant associated with the key code value for the . key(190).
    **/
    Keyboard.PERIOD = 190;
    /**
        Constant associated with the key code value for the / key(191).
    **/
    Keyboard.SLASH = 191;
    /**
        Constant associated with the key code value for the ` key(192).
    **/
    Keyboard.BACKQUOTE = 192;
    /**
        Constant associated with the key code value for the [ key(219).
    **/
    Keyboard.LEFTBRACKET = 219;
    /**
        Constant associated with the key code value for the \ key(220).
    **/
    Keyboard.BACKSLASH = 220;
    /**
        Constant associated with the key code value for the ] key(221).
    **/
    Keyboard.RIGHTBRACKET = 221;
    /**
        Constant associated with the key code value for the ' key(222).
    **/
    Keyboard.QUOTE = 222;
    return Keyboard;
})();

/**
    The MouseCursor class is an enumeration of constant values used in setting
    the `cursor` property of the Mouse class.
**/
var MouseCursor;
(function (MouseCursor) {
    /**
        Used to specify that the arrow cursor should be used.
    **/
    MouseCursor["ARROW"] = "arrow";
    /**
        Used to specify that the cursor should be selected automatically based
        on the object under the mouse.
    **/
    MouseCursor["AUTO"] = "auto";
    /**
        Used to specify that the button pressing hand cursor should be used.
    **/
    MouseCursor["BUTTON"] = "button";
    /**
        Used to specify that the dragging hand cursor should be used.
    **/
    MouseCursor["HAND"] = "hand";
    /**
        Used to specify that the I-beam cursor should be used.
    **/
    MouseCursor["IBEAM"] = "ibeam";
    // protected __CROSSHAIR = "crosshair";
    // protected __CUSTOM = "custom";
    // protected __MOVE = "move";
    // protected __RESIZE_NESW = "resize_nesw";
    // protected __RESIZE_NS = "resize_ns";
    // protected __RESIZE_NWSE = "resize_nwse";
    // protected __RESIZE_WE = "resize_we";
    // protected __WAIT = "wait";
    // protected __WAIT_ARROW = "waitarrow";
})(MouseCursor || (MouseCursor = {}));
var MouseCursor$1 = MouseCursor;

/**
    The Scene class includes properties for identifying the name, labels, and number
    of frames in a scene. A Scene object instance is created in Flash Professional,
    not by writing ActionScript code. The MovieClip class includes a `currentScene`
    property, which is a Scene object that identifies the scene in which the playhead
    is located in the timeline of the MovieClip instance. The `scenes` property of
    the MovieClip class is an array of Scene objects. Also, the `gotoAndPlay()` and
    `gotoAndStop()` methods of the MovieClip class use Scene objects as parameters.
**/
class Scene {
    constructor(name, labels, numFrames) {
        this.name = name;
        this.labels = labels;
        this.numFrames = numFrames;
    }
}

/**
    The Sprite class is a basic display list building block: a display list
    node that can display graphics and can also contain children.

    A Sprite object is similar to a movie clip, but does not have a
    timeline. Sprite is an appropriate base class for objects that do not
    require timelines. For example, Sprite would be a logical base class for
    user interface(UI) components that typically do not use the timeline.

    The Sprite class is new in ActionScript 3.0. It provides an alternative
    to the functionality of the MovieClip class, which retains all the
    functionality of previous ActionScript releases to provide backward
    compatibility.
**/
class Sprite extends DisplayObjectContainer {
    /**
        Creates a new Sprite instance. After you create the Sprite instance, call
        the `DisplayObjectContainer.addChild()` or
        `DisplayObjectContainer.addChildAt()` method to add the Sprite
        to a parent DisplayObjectContainer.
    **/
    constructor() {
        super();
        this.__buttonMode = false;
        this.useHandCursor = true;
    }
    /**
        Lets the user drag the specified sprite. The sprite remains draggable
        until explicitly stopped through a call to the
        `Sprite.stopDrag()` method, or until another sprite is made
        draggable. Only one sprite is draggable at a time.

        Three-dimensional display objects follow the pointer and
        `Sprite.startDrag()` moves the object within the
        three-dimensional plane defined by the display object. Or, if the display
        object is a two-dimensional object and the child of a three-dimensional
        object, the two-dimensional object moves within the three dimensional
        plane defined by the three-dimensional parent object.

        @param lockCenter Specifies whether the draggable sprite is locked to the
                          center of the pointer position(`true`), or
                          locked to the point where the user first clicked the
                          sprite(`false`).
        @param bounds     Value relative to the coordinates of the Sprite's parent
                          that specify a constraint rectangle for the Sprite.
    **/
    startDrag(lockCenter = false, bounds = null) {
        if (this.stage != null) {
            this.stage.__startDrag(this, lockCenter, bounds);
        }
    }
    /**
        Lets the user drag the specified sprite on a touch-enabled device. The
        sprite remains draggable until explicitly stopped through a call to
        the `Sprite.stopTouchDrag()` method, or until another sprite is made
        draggable. Only one sprite is draggable at a time.
        Three-dimensional display objects follow the pointer and
        `Sprite.startTouchDrag()` moves the object within the
        three-dimensional plane defined by the display object. Or, if the
        display object is a two-dimensional object and the child of a
        three-dimensional object, the two-dimensional object moves within the
        three dimensional plane defined by the three-dimensional parent
        object.

        @param touchPointID An integer to assign to the touch point.
        @param lockCenter   Specifies whether the draggable sprite is locked
                            to the center of the pointer position (`true`), or
                            locked to the point where the user first clicked
                            the sprite (`false`).
        @param bounds       Value relative to the coordinates of the Sprite's
                            parent that specify a constraint rectangle for the
                            Sprite.
    **/
    // /** @hidden */ @:dox(hide) public startTouchDrag (touchPointID:Int, lockCenter:Bool = false, bounds:Rectangle = null):Void;
    /**
        Ends the `startDrag()` method. A sprite that was made draggable
        with the `startDrag()` method remains draggable until a
        `stopDrag()` method is added, or until another sprite becomes
        draggable. Only one sprite is draggable at a time.

    **/
    stopDrag() {
        if (this.stage != null) {
            this.stage.__stopDrag(this);
        }
    }
    /**
        Ends the `startTouchDrag()` method, for use with touch-enabled
        devices. A sprite that was made draggable with the `startTouchDrag()`
        method remains draggable until a `stopTouchDrag()` method is added, or
        until another sprite becomes draggable. Only one sprite is draggable
        at a time.

        @param touchPointID The integer assigned to the touch point in the
                            `startTouchDrag` method.
    **/
    // /** @hidden */ @:dox(hide) public stopTouchDrag (touchPointID:Int):Void;
    __getCursor() {
        return (this.__buttonMode && this.useHandCursor) ? MouseCursor$1.BUTTON : null;
    }
    __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        if (interactiveOnly && !this.mouseEnabled && !this.mouseChildren)
            return false;
        if (!hitObject.visible || this.__isMask)
            return this.__hitTestHitArea(x, y, shapeFlag, stack, interactiveOnly, hitObject);
        if (this.mask != null && !this.mask.__hitTestMask(x, y))
            return this.__hitTestHitArea(x, y, shapeFlag, stack, interactiveOnly, hitObject);
        if (this.__scrollRect != null) {
            var point = Point.__pool.get();
            point.setTo(x, y);
            this.__getRenderTransform().__transformInversePoint(point);
            if (!this.__scrollRect.containsPoint(point)) {
                Point.__pool.release(point);
                return this.__hitTestHitArea(x, y, shapeFlag, stack, true, hitObject);
            }
            Point.__pool.release(point);
        }
        if (super.__hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject)) {
            return (stack == null || interactiveOnly);
        }
        else if (this.hitArea == null && this.__graphics != null && this.__graphics.__hitTest(x, y, shapeFlag, this.__getRenderTransform())) {
            if (stack != null && (!interactiveOnly || this.mouseEnabled)) {
                stack.push(hitObject);
            }
            return true;
        }
        return this.__hitTestHitArea(x, y, shapeFlag, stack, interactiveOnly, hitObject);
    }
    __hitTestHitArea(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        if (this.hitArea != null) {
            if (!this.hitArea.mouseEnabled) {
                this.hitArea.mouseEnabled = true;
                var hitTest = this.hitArea.__hitTest(x, y, shapeFlag, null, true, hitObject);
                this.hitArea.mouseEnabled = false;
                if (stack != null && hitTest) {
                    stack[stack.length] = hitObject;
                }
                return hitTest;
            }
        }
        return false;
    }
    __hitTestMask(x, y) {
        if (super.__hitTestMask(x, y)) {
            return true;
        }
        else if (this.__graphics != null && this.__graphics.__hitTest(x, y, true, this.__getRenderTransform())) {
            return true;
        }
        return false;
    }
    // Get & Set Methods
    /**
        Specifies the display object over which the sprite is being dragged,
        or on which the sprite was dropped.
    **/
    get dropTarget() {
        return this.__dropTarget;
    }
    /**
        Specifies the Graphics object that belongs to this sprite where vector
        drawing commands can occur.
    **/
    get graphics() {
        if (this.__graphics == null) {
            this.__graphics = new Graphics(this);
        }
        return this.__graphics;
    }
    get tabEnabled() {
        return (this.__tabEnabled == null ? this.__buttonMode : this.__tabEnabled);
    }
    /**
        Specifies the button mode of this sprite. If `true`, this
        sprite behaves as a button, which means that it triggers the display of
        the hand cursor when the pointer passes over the sprite and can receive a
        `click` event if the enter or space keys are pressed when the
        sprite has focus. You can suppress the display of the hand cursor by
        setting the `useHandCursor` property to `false`, in
        which case the pointer is displayed.

        Although it is better to use the SimpleButton class to create buttons,
        you can use the `buttonMode` property to give a sprite some
        button-like functionality. To include a sprite in the tab order, set the
        `tabEnabled` property(inherited from the InteractiveObject
        class and `false` by default) to `true`.
        Additionally, consider whether you want the children of your sprite to be
        user input enabled. Most buttons do not enable user input interactivity
        for their child objects because it confuses the event flow. To disable
        user input interactivity for all child objects, you must set the
        `mouseChildren` property(inherited from the
        DisplayObjectContainer class) to `false`.

        If you use the `buttonMode` property with the MovieClip
        class(which is a subclass of the Sprite class), your button might have
        some added functionality. If you include frames labeled _up, _over, and
        _down, Flash Player provides automatic state changes(functionality
        similar to that provided in previous versions of ActionScript for movie
        clips used as buttons). These automatic state changes are not available
        for sprites, which have no timeline, and thus no frames to label.
    **/
    get buttonMode() {
        return this.__buttonMode;
    }
    set buttonMode(value) {
        this.__buttonMode = value;
    }
}

/**
    The MovieClip class inherits from the following classes: Sprite,
    DisplayObjectContainer, InteractiveObject, DisplayObject, and
    EventDispatcher.

    Unlike the Sprite object, a MovieClip object has a timeline.

    In Flash Professional, the methods for the MovieClip class provide the
    same functionality as actions that target movie clips. Some additional
    methods do not have equivalent actions in the Actions toolbox in the
    Actions panel in the Flash authoring tool.

    Children instances placed on the Stage in Flash Professional cannot be
    accessed by code from within the constructor of a parent instance since
    they have not been created at that point in code execution. Before
    accessing the child, the parent must instead either create the child
    instance by code or delay access to a callback that listens for
    the child to dispatch its `Event.ADDED_TO_STAGE` event.

    If you modify any of the following properties of a MovieClip object that
    contains a motion tween, the playhead is stopped in that MovieClip object:
    `alpha`, `blendMode`, `filters`,
    `height`, `opaqueBackground`, `rotation`,
    `scaleX`, `scaleY`, `scale9Grid`,
    `scrollRect`, `transform`, `visible`,
    `width`, `x`, or `y`. However, it does not
    stop the playhead in any child MovieClip objects of that MovieClip
    object.

    **Note:**Flash Lite 4 supports the MovieClip.opaqueBackground
    property only if FEATURE_BITMAPCACHE is defined. The default configuration
    of Flash Lite 4 does not define FEATURE_BITMAPCACHE. To enable the
    MovieClip.opaqueBackground property for a suitable device, define
    FEATURE_BITMAPCACHE in your project.
**/
class MovieClip extends Sprite {
    /**
        Creates a new MovieClip instance. After creating the MovieClip, call the
        `addChild()` or `addChildAt()` method of a display
        object container that is onstage.
    **/
    constructor() {
        super();
        this.__enabled = true;
        this.__type = DisplayObjectType$1.MOVIE_CLIP;
        if (MovieClip.__constructor != null) {
            var method = MovieClip.__constructor;
            MovieClip.__constructor = null;
            method(this);
        }
    }
    addFrameScript(index, method) {
        if (this.__timeline != null) {
            this.__timeline.__addFrameScript(index, method);
        }
    }
    /**
        Attaches a Timeline object to the current movie clip.

        A movie clip with a timeline will support additional movie clip features
        such as `play()`, `gotoAndPlay()`, `stop()` and `prevFrame()`.

        @param	timeline	The Timeline to attach to this MovieClip
    **/
    attachTimeline(timeline) {
        this.__timeline = timeline;
        if (timeline != null) {
            timeline.__attachMovieClip(this);
            this.play();
        }
    }
    /**
        Creates a new MovieClip instance from a Timeline.

        @param	timeline	A Timeline instance
        @returns	A MovieClip attached to the Timeline
    **/
    static fromTimeline(timeline) {
        var movieClip = new MovieClip();
        movieClip.attachTimeline(timeline);
        return movieClip;
    }
    /**
        Starts playing the SWF file at the specified frame. This happens after all
        remaining actions in the frame have finished executing. To specify a scene
        as well as a frame, specify a value for the `scene` parameter.

        @param frame A number representing the frame number, or a string
                     representing the label of the frame, to which the playhead is
                     sent. If you specify a number, it is relative to the scene
                     you specify. If you do not specify a scene, the current scene
                     determines the global frame number to play. If you do specify
                     a scene, the playhead jumps to the frame number in the
                     specified scene.
        @param scene The name of the scene to play. This parameter is optional.
    **/
    gotoAndPlay(frame, scene = null) {
        if (this.__timeline != null) {
            this.__timeline.__gotoAndPlay(frame, scene);
        }
    }
    /**
        Brings the playhead to the specified frame of the movie clip and stops it
        there. This happens after all remaining actions in the frame have finished
        executing. If you want to specify a scene in addition to a frame, specify
        a `scene` parameter.

        @param frame A number representing the frame number, or a string
                     representing the label of the frame, to which the playhead is
                     sent. If you specify a number, it is relative to the scene
                     you specify. If you do not specify a scene, the current scene
                     determines the global frame number at which to go to and
                     stop. If you do specify a scene, the playhead goes to the
                     frame number in the specified scene and stops.
        @param scene The name of the scene. This parameter is optional.
        @throws ArgumentError If the `scene` or `frame`
                              specified are not found in this movie clip.
    **/
    gotoAndStop(frame, scene = null) {
        if (this.__timeline != null) {
            this.__timeline.__gotoAndStop(frame, scene);
        }
    }
    /**
        Sends the playhead to the next frame and stops it. This happens after all
        remaining actions in the frame have finished executing.

    **/
    nextFrame() {
        if (this.__timeline != null) {
            this.__timeline.__nextFrame();
        }
    }
    /**
        Moves the playhead to the next scene of the MovieClip instance. This happens
        after all remaining actions in the frame have finished executing.
    **/
    nextScene() {
        if (this.__timeline != null) {
            this.__timeline.__nextScene();
        }
    }
    /**
        Moves the playhead in the timeline of the movie clip.

    **/
    play() {
        if (this.__timeline != null) {
            this.__timeline.__play();
        }
    }
    /**
        Sends the playhead to the previous frame and stops it. This happens after
        all remaining actions in the frame have finished executing.

    **/
    prevFrame() {
        if (this.__timeline != null) {
            this.__timeline.__prevFrame();
        }
    }
    /**
        Moves the playhead to the previous scene of the MovieClip instance. This
        happens after all remaining actions in the frame have finished executing.
    **/
    prevScene() {
        if (this.__timeline != null) {
            this.__timeline.__prevScene();
        }
    }
    /**
        Stops the playhead in the movie clip.

    **/
    stop() {
        if (this.__timeline != null) {
            this.__timeline.__stop();
        }
    }
    __stopAllMovieClips() {
        super.__stopAllMovieClips();
        stop();
    }
    __tabTest(stack) {
        if (!this.__enabled)
            return;
        super.__tabTest(stack);
    }
    // Event Handlers
    __onMouseDown(event) {
        if (this.__enabled && this.__hasDown) {
            this.gotoAndStop("_down");
        }
        this.__mouseIsDown = true;
        this.stage.addEventListener(MouseEvent.MOUSE_UP, this.__onMouseUp, true);
    }
    __onMouseUp(event) {
        this.__mouseIsDown = false;
        if (this.stage != null) {
            this.stage.removeEventListener(MouseEvent.MOUSE_UP, this.__onMouseUp);
        }
        if (!this.__buttonMode) {
            return;
        }
        if (event.target == this && this.__enabled && this.__hasOver) {
            this.gotoAndStop("_over");
        }
        else if (this.__enabled && this.__hasUp) {
            this.gotoAndStop("_up");
        }
    }
    __onRollOut(event) {
        if (!this.__enabled)
            return;
        if (this.__mouseIsDown && this.__hasOver) {
            this.gotoAndStop("_over");
        }
        else if (this.__hasUp) {
            this.gotoAndStop("_up");
        }
    }
    __onRollOver(event) {
        if (this.__enabled && this.__hasOver) {
            this.gotoAndStop("_over");
        }
    }
    // Getters & Setters
    set buttonMode(value) {
        if (this.__buttonMode != value) {
            if (value) {
                this.__hasDown = false;
                this.__hasOver = false;
                this.__hasUp = false;
                for (let frameLabel of this.currentLabels) {
                    switch (frameLabel.name) {
                        case "_up":
                            this.__hasUp = true;
                            break;
                        case "_over":
                            this.__hasOver = true;
                            break;
                        case "_down":
                            this.__hasDown = true;
                            break;
                    }
                }
                if (this.__hasDown || this.__hasOver || this.__hasUp) {
                    this.addEventListener(MouseEvent.ROLL_OVER, this.__onRollOver);
                    this.addEventListener(MouseEvent.ROLL_OUT, this.__onRollOut);
                    this.addEventListener(MouseEvent.MOUSE_DOWN, this.__onMouseDown);
                }
            }
            else {
                this.removeEventListener(MouseEvent.ROLL_OVER, this.__onRollOver);
                this.removeEventListener(MouseEvent.ROLL_OUT, this.__onRollOut);
                this.removeEventListener(MouseEvent.MOUSE_DOWN, this.__onMouseDown);
            }
            this.__buttonMode = value;
        }
    }
    /**
        Specifies the number of the frame in which the playhead is located in the
        timeline of the MovieClip instance. If the movie clip has multiple scenes,
        this value is the frame number in the current scene.
    **/
    get currentFrame() {
        if (this.__timeline != null) {
            return this.__timeline.__currentFrame;
        }
        else {
            return 1;
        }
    }
    /**
        The label at the current frame in the timeline of the MovieClip instance.
        If the current frame has no label, `currentLabel` is
        `null`.
    **/
    get currentFrameLabel() {
        if (this.__timeline != null) {
            return this.__timeline.__currentFrameLabel;
        }
        else {
            return null;
        }
    }
    /**
        The current label in which the playhead is located in the timeline of the
        MovieClip instance. If the current frame has no label,
        `currentLabel` is set to the name of the previous frame that
        includes a label. If the current frame and previous frames do not include
        a label, `currentLabel` returns `null`.
    **/
    get currentLabel() {
        if (this.__timeline != null) {
            return this.__timeline.__currentLabel;
        }
        else {
            return null;
        }
    }
    /**
        Returns an array of FrameLabel objects from the current scene. If the
        MovieClip instance does not use scenes, the array includes all frame
        labels from the entire MovieClip instance.
    **/
    get currentLabels() {
        if (this.__timeline != null) {
            return this.__timeline.__currentLabels.slice();
        }
        else {
            return [];
        }
    }
    /**
        The current scene in which the playhead is located in the timeline of
        the MovieClip instance.
    **/
    get currentScene() {
        if (this.__timeline != null) {
            return this.__timeline.__currentScene;
        }
        else {
            if (this.__scene == null) {
                this.__scene = new Scene("", [], 1);
            }
            return this.__scene;
        }
    }
    /**
        A Boolean value that indicates whether a movie clip is enabled. The
        default value of `enabled` is `true`. If
        `enabled` is set to `false`, the movie clip's Over,
        Down, and Up frames are disabled. The movie clip continues to receive
        events(for example, `mouseDown`, `mouseUp`,
        `keyDown`, and `keyUp`).

        The `enabled` property governs only the button-like
        properties of a movie clip. You can change the `enabled`
        property at any time; the modified movie clip is immediately enabled or
        disabled. If `enabled` is set to `false`, the object
        is not included in automatic tab ordering.
    **/
    get enabled() {
        return this.__enabled;
    }
    set enabled(value) {
        this.__enabled = value;
    }
    /**
        The number of frames that are loaded from a streaming SWF file. You can
        use the `framesLoaded` property to determine whether the
        contents of a specific frame and all the frames before it loaded and are
        available locally in the browser. You can also use it to monitor the
        downloading of large SWF files. For example, you might want to display a
        message to users indicating that the SWF file is loading until a specified
        frame in the SWF file finishes loading.

        If the movie clip contains multiple scenes, the
        `framesLoaded` property returns the number of frames loaded for
        _all_ scenes in the movie clip.
    **/
    get framesLoaded() {
        if (this.__timeline != null) {
            return this.__timeline.__framesLoaded;
        }
        else {
            return 1;
        }
    }
    /**
        A Boolean value that indicates whether a movie clip is curently playing.
    **/
    get isPlaying() {
        if (this.__timeline != null) {
            return this.__timeline.__isPlaying;
        }
        else {
            return false;
        }
    }
    /**
        An array of Scene objects, each listing the name, the number of frames, and
        the frame labels for a scene in the MovieClip instance.
    **/
    get scenes() {
        if (this.__timeline != null) {
            return this.__timeline.scenes.slice();
        }
        else {
            return [this.currentScene];
        }
    }
    /**
        The total number of frames in the MovieClip instance.

        If the movie clip contains multiple frames, the
        `totalFrames` property returns the total number of frames in
        _all_ scenes in the movie clip.
    **/
    get totalFrames() {
        if (this.__timeline != null) {
            return this.__timeline.__totalFrames;
        }
        else {
            return 1;
        }
    }
}

/**
    The URLLoaderDataFormat class provides values that specify how downloaded
    data is received.
**/
var URLLoaderDataFormat;
(function (URLLoaderDataFormat) {
    /**
        Specifies that downloaded data is received as raw binary data.
    **/
    URLLoaderDataFormat["BINARY"] = "binary";
    /**
        Specifies that downloaded data is received as text.
    **/
    URLLoaderDataFormat["TEXT"] = "text";
    /**
        Specifies that downloaded data is received as URL-encoded variables.
    **/
    URLLoaderDataFormat["VARIABLES"] = "variables";
})(URLLoaderDataFormat || (URLLoaderDataFormat = {}));
var URLLoaderDataFormat$1 = URLLoaderDataFormat;

/**
    The URLLoader class downloads data from a URL as text, binary data, or
    URL-encoded variables. It is useful for downloading text files, XML, or
    other information to be used in a dynamic, data-driven application.

    A URLLoader object downloads all of the data from a URL before making it
    available to code in the applications. It sends out notifications about the
    progress of the download, which you can monitor through the
    `bytesLoaded` and `bytesTotal` properties, as well as
    through dispatched events.

    When loading very large video files, such as FLV's, out-of-memory errors
    may occur.

    When you use this class in Flash Player and in AIR application content
    in security sandboxes other than then application security sandbox,
    consider the following security model:


    * A SWF file in the local-with-filesystem sandbox may not load data
    from, or provide data to, a resource that is in the network sandbox.
    *  By default, the calling SWF file and the URL you load must be in
    exactly the same domain. For example, a SWF file at www.adobe.com can load
    data only from sources that are also at www.adobe.com. To load data from a
    different domain, place a URL policy file on the server hosting the
    data.


    For more information related to security, see the Flash Player Developer
    Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).

    @event complete           Dispatched after all the received data is decoded
                              and placed in the data property of the URLLoader
                              object. The received data may be accessed once
                              this event has been dispatched.
    @event httpResponseStatus Dispatched if a call to the load() method
                              attempts to access data over HTTP, and Adobe AIR
                              is able to detect and return the status code for
                              the request.
    @event httpStatus         Dispatched if a call to URLLoader.load() attempts
                              to access data over HTTP. For content running in
                              Flash Player, this event is only dispatched if
                              the current Flash Player environment is able to
                              detect and return the status code for the
                              request.(Some browser environments may not be
                              able to provide this information.) Note that the
                              `httpStatus` event(if any) is sent
                              before(and in addition to) any
                              `complete` or `error`
                              event.
    @event ioError            Dispatched if a call to URLLoader.load() results
                              in a fatal error that terminates the download.
    @event open               Dispatched when the download operation commences
                              following a call to the
                              `URLLoader.load()` method.
    @event progress           Dispatched when data is received as the download
                              operation progresses.

                              Note that with a URLLoader object, it is not
                              possible to access the data until it has been
                              received completely. So, the progress event only
                              serves as a notification of how far the download
                              has progressed. To access the data before it's
                              entirely downloaded, use a URLStream object.
    @event securityError      Dispatched if a call to URLLoader.load() attempts
                              to load data from a server outside the security
                              sandbox. Also dispatched if a call to
                              `URLLoader.load()` attempts to load a
                              SWZ file and the certificate is invalid or the
                              digest string does not match the component.
**/
class URLLoader extends EventDispatcher {
    /**
        Creates a URLLoader object.

        @param request A URLRequest object specifying the URL to download. If this
                       parameter is omitted, no load operation begins. If
                       specified, the load operation begins immediately(see the
                       `load` entry for more information).
    **/
    constructor(request = null) {
        super();
        this.bytesLoaded = 0;
        this.bytesTotal = 0;
        this.dataFormat = URLLoaderDataFormat$1.TEXT;
        if (request != null) {
            this.load(request);
        }
    }
    /**
        Closes the load operation in progress. Any load operation in progress is
        immediately terminated. If no URL is currently being streamed, an invalid
        stream error is thrown.

    **/
    close() {
        // TODO
        // __backend.close();
    }
    /**
        Sends and loads data from the specified URL. The data can be received as
        text, raw binary data, or URL-encoded variables, depending on the value
        you set for the `dataFormat` property. Note that the default
        value of the `dataFormat` property is text. If you want to send
        data to the specified URL, you can set the `data` property in
        the URLRequest object.

        **Note:** If a file being loaded contains non-ASCII characters(as
        found in many non-English languages), it is recommended that you save the
        file with UTF-8 or UTF-16 encoding as opposed to a non-Unicode format like
        ASCII.

         A SWF file in the local-with-filesystem sandbox may not load data
        from, or provide data to, a resource that is in the network sandbox.

         By default, the calling SWF file and the URL you load must be in
        exactly the same domain. For example, a SWF file at www.adobe.com can load
        data only from sources that are also at www.adobe.com. To load data from a
        different domain, place a URL policy file on the server hosting the
        data.

        You cannot connect to commonly reserved ports. For a complete list of
        blocked ports, see "Restricting Networking APIs" in the _ActionScript
        3.0 Developer's Guide_.

         In Flash Player 10 and later, if you use a multipart Content-Type(for
        example "multipart/form-data") that contains an upload(indicated by a
        "filename" parameter in a "content-disposition" header within the POST
        body), the POST operation is subject to the security rules applied to
        uploads:

        * The POST operation must be performed in response to a user-initiated
        action, such as a mouse click or key press.
        * If the POST operation is cross-domain(the POST target is not on the
        same server as the SWF file that is sending the POST request), the target
        server must provide a URL policy file that permits cross-domain
        access.

        Also, for any multipart Content-Type, the syntax must be valid
        (according to the RFC2046 standards). If the syntax appears to be invalid,
        the POST operation is subject to the security rules applied to
        uploads.

        For more information related to security, see the Flash Player
        Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).

        @param request A URLRequest object specifying the URL to download.
        @throws ArgumentError `URLRequest.requestHeader` objects may
                              not contain certain prohibited HTTP request headers.
                              For more information, see the URLRequestHeader class
                              description.
        @throws MemoryError   This error can occur for the following reasons: 1)
                              Flash Player or AIR cannot convert the
                              `URLRequest.data` parameter from UTF8 to
                              MBCS. This error is applicable if the URLRequest
                              object passed to `load()` is set to
                              perform a `GET` operation and if
                              `System.useCodePage` is set to
                              `true`. 2) Flash Player or AIR cannot
                              allocate memory for the `POST` data. This
                              error is applicable if the URLRequest object passed
                              to `load` is set to perform a
                              `POST` operation.
        @throws SecurityError Local untrusted files may not communicate with the
                              Internet. This may be worked around by reclassifying
                              this file as local-with-networking or trusted.
        @throws SecurityError You are trying to connect to a commonly reserved
                              port. For a complete list of blocked ports, see
                              "Restricting Networking APIs" in the _ActionScript
                              3.0 Developer's Guide_.
        @throws TypeError     The value of the request parameter or the
                              `URLRequest.url` property of the
                              URLRequest object passed are `null`.
        @event complete           Dispatched after data has loaded successfully.
        @event httpResponseStatus Dispatched if a call to the `load()`
                                  method attempts to access data over HTTP and
                                  Adobe AIR is able to detect and return the
                                  status code for the request.
        @event httpStatus         If access is over HTTP, and the current Flash
                                  Player environment supports obtaining status
                                  codes, you may receive these events in addition
                                  to any `complete` or
                                  `error` event.
        @event ioError            The load operation could not be completed.
        @event open               Dispatched when a load operation commences.
        @event progress           Dispatched when data is received as the download
                                  operation progresses.
        @event securityError      A load operation attempted to retrieve data from
                                  a server outside the caller's security sandbox.
                                  This may be worked around using a policy file on
                                  the server.
        @event securityError      A load operation attempted to load a SWZ file(a
                                  Adobe platform component), but the certificate
                                  is invalid or the digest does not match the
                                  component.
    **/
    load(request) {
        // TODO
        // __backend.load(request);
    }
}

class Lib$1 {
    static as(v, c) {
        return v;
    }
    static attach(name) {
        return new MovieClip();
    }
    /**
        Cancels a specified `setInterval()` call.

        @param	id	The ID of the `setInterval()` call, which you set to a variable, as
        in the following:
    **/
    static clearInterval(id) {
        window.clearInterval(id);
    }
    /**
        Cancels a specified `setTimeout()` call.

        @param	id	The ID of the `setTimeout()` call, which you set to a variable, as in
        the following
    **/
    static clearTimeout(id) {
        window.clearTimeout(id);
    }
    /**
        Returns a reference to the class object of the class specified by the `name`
        parameter.

        @param	name	The name of a class.
        @returns	Returns a reference to the class object of the class specified by the
        `name` parameter.
        @throws	ReferenceError	No public definition exists with the specified name.
    **/
    static getDefinitionByName(name) {
        return null;
    }
    /**
        Returns the fully qualified class name of an object.

        @param	value	The object for which a fully qualified class name is desired. Any
        ActionScript value may be passed to this method including all available
        ActionScript types, object instances, primitive types such as uint, and class
        objects.
        @returns	String	A string containing the fully qualified class name.
    **/
    static getQualifiedClassName(value) {
        var _a;
        return (_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name;
    }
    /**
        Returns the fully qualified class name of the base class of the object specified
        by the value parameter. This provides a quicker way of retrieving the
        base class name than `describeType()`, but also doesn't provide all the
        information `describeType()` does.

        After you retrieve the name of a class with this function, you can convert the
        class name to a class reference with the `getDefinitionByName()` function.

        **Note:** This restricts itself to instance hierarchies, whereas the
        `describeType()` uses class object hierarchies if the value parameter is
        a data type. Calling `describeType()` on a data type returns the superclass based
        on the class object hierarchy, in which all class objects inherit from Class. The
        `getQualifiedSuperclassName()` function, however, ignores the class object
        hierarchy and returns the superclass based on the more familiar instance
        hierarchy. For example, calling `getQualifiedSuperclassName(String)` returns
        Object although technically the String class object inherits from Class. In other
        words, the results are the same whether you use an instance of a type or the type
        itself.

        @param	value	Any value.
        @returns	A fully qualified base class name, or null if none exists.

    **/
    static getQualifiedSuperclassName(value) {
        return null;
    }
    /**
        Used to compute relative time. For a Flash runtime processing ActionScript 3.0,
        this method returns the number of milliseconds that have elapsed since the Flash
        runtime virtual machine for ActionScript 3.0 (AVM2) started. For a Flash runtime
        processing ActionScript 2.0, this method returns the number of milliseconds since
        the Flash runtime began initialization. Flash runtimes use two virtual machines to
        process ActionScript. AVM1 is the ActionScript virtual machine used to run
        ActionScript 1.0 and 2.0. AVM2 is the ActionScript virtual machine used to run
        ActionScript 3.0. The getTimer() method behavior for AVM1 is different than the
        behavior for AVM2.

        For a calendar date (timestamp), see the Date object.

        @returns	The number of milliseconds since the runtime was initialized (while
        processing ActionScript 2.0), or since the virtual machine started (while
        processing ActionScript 3.0). If the runtime starts playing one SWF file, and
        another SWF file is loaded later, the return value is relative to when the first
        SWF file was loaded.
    **/
    static getTimer() {
        return window.performance.now();
    }
    static getURL(request, target = null) {
        Lib$1.navigateToURL(request, target);
    }
    /**
        Opens or replaces a window in the application that contains the Flash Player
        container (usually a browser). In Adobe AIR, the opens a URL in the
        default system web browser

        **Important Security Note**

        Developers often pass URL values to the `navigateToURL()` that were
        obtained from external sources such as FlashVars. Attackers may try to manipulate
        these external sources to perform attacks such as cross-site scripting. Therefore,
        developers should validate all URLs before passing them to this function.

        Good data validation for URLs can mean different things depending on the usage of
        the URL within the overall application. The most common data validation techniques
        include validating that the URL is of the appropriate scheme. For instance,
        unintentionally allowing javascript: URLs may result in cross-site scripting.
        Validating that the URL is a within your domain can ensure that the SWF file can't
        be used as an open-redirector by people who conduct phishing attacks. For additional
        security, you may also choose to validate the path of the URL and to validate that
        the URL conforms to the RFC guidelines

        For example, the following code shows a simple example of performing data validation
        by denying any URL that does not begin with http:// or https:// and validating that
        the URL is within your domain name. This example may not be appropriate for all
        web applications and you should consider whether additional checks against the URL
        are necessary.

        ```as3
        // AS3 Regular expression pattern match for URLs that start with http:// and https:// plus your domain name.
        function checkProtocol (flashVarURL:String):Boolean {
            // Get the domain name for the SWF if it is not known at compile time.
            // If the domain is known at compile time, then the following two lines can be replaced with a hard coded string.
            var my_lc:LocalConnection = new LocalConnection();
            var domainName:String = my_lc.domain;
            // Build the RegEx to test the URL.
            // This RegEx assumes that there is at least one "/" after the
            // domain. http://www.mysite.com will not match.
            var pattern:RegExp = new RegExp("^http[s]?\:\\/\\/([^\\/]+)\\/");
            var result:Object = pattern.exec(flashVarURL);
            if (result == null || result[1] != domainName || flashVarURL.length >= 4096) {
            return (false);
            }
            return (true);
        }
        ```

        For local content running in a browser, calls to the `navigateToURL()` method that
        specify a "javascript:" pseudo-protocol (via a URLRequest object passed as the first
        parameter) are only permitted if the SWF file and the containing web page (if there
        is one) are in the local-trusted security sandbox. Some browsers do not support using
        the javascript protocol with the `navigateToURL()` method. Instead, consider using the
        `call()` method of the ExternalInterface API to invoke JavaScript methods within the
        enclosing HTML page.

        In Flash Player, and in non-application sandboxes in Adobe AIR, you cannot connect to
        commonly reserved ports. For a complete list of blocked ports, see "Restricting
        Networking APIs" in the ActionScript 3.0 Developer's Guide.

        In Flash Player 10 and later running in a browser, using this method programmatically
        to open a pop-up window may not be successful. Various browsers (and browser
        configurations) may block pop-up windows at any time; it is not possible to guarantee
        any pop-up window will appear. However, for the best chance of success, use this
        method to open a pop-up window only in code that executes as a direct result of a
        user action (for example, in an event handler for a mouse click or key-press event.)

        In Flash Player 10 and later, if you use a multipart Content-Type (for example
        "multipart/form-data") that contains an upload (indicated by a "filename" parameter
        in a "content-disposition" header within the POST body), the POST operation is subject
        to the security rules applied to uploads:

        * The POST operation must be performed in response to a user-initiated action, such
        as a mouse click or key press.
        * If the POST operation is cross-domain (the POST target is not on the same server
        as the SWF file that is sending the POST request), the target server must provide
        a URL policy file that permits cross-domain access.

        Also, for any multipart Content-Type, the syntax must be valid (according to the
        RFC2046 standards). If the syntax appears to be invalid, the POST operation is
        subject to the security rules applied to uploads.

        In AIR, on mobile platforms, the sms: and tel: URI schemes are supported. On
        Android, vipaccess:, connectpro:, and market: URI schemes are supported. The URL
        syntax is subject to the platform conventions. For example, on Android, the URI
        scheme must be lower case. When you navigate to a URL using one of these schemes,
        the runtime opens the URL in the default application for handling the scheme. Thus,
        navigating to tel:+5555555555 opens the phone dialer with the specified number
        already entered. A separate application or utility, such as a phone dialer must be
        available to process the URL.

        The following code shows how you can invoke the VIP Access and Connect Pro
        applications on Android:

        ```as3
        //Invoke the VIP Access Application.
        navigateToURL(new URLRequest("vipaccess://com.verisign.mvip.main?action=securitycode"));

        //Invoke the Connect Pro Application.
        navigateToURL(new URLRequest("connectpro://"));
        ```

        @param	request	A URLRequest object that specifies the URL to navigate to.
        For content running in Adobe AIR, when using the `navigateToURL()` function, the
        runtime treats a URLRequest that uses the POST method (one that has its method
        property set to `URLRequestMethod.POST`) as using the GET method.

        @param	window	The browser window or HTML frame in which to display the document
        indicated by the request parameter. You can enter the name of a specific window or
        use one of the following values:

        * `"_self"` specifies the current frame in the current window.
        * `"_blank"` specifies a new window.
        * `"_parent"` specifies the parent of the current frame.
        * `"_top"` specifies the top-level frame in the current window.

        If you do not specify a value for this parameter, a new empty window is created.
        In the stand-alone player, you can either specify a new ("_blank") window or a
        named window. The other values don't apply.

        **Note:** When code in a SWF file that is running in the local-with-filesystem
        sandbox calls the `navigateToURL()` and specifies a custom window name
        for the window parameter, the window name is transfered into a random name. The
        name is in the form "_flashXXXXXXXX", where each X represents a random hexadecimal
        digit. Within the same session (until you close the containing browser window),
        if you call the again and specify the same name for the window parameter,
        the same random string is used.

        @throws	IOError	The digest property of the request object is not null. You should
        only set the digest property of a URLRequest object for use calling the
        `URLLoader.load()` method when loading a SWZ file (an Adobe platform component).
        @throws	SecurityError	In Flash Player (and in non-application sandbox content in
        Adobe AIR), this error is thrown in the following situations:
        * Local untrusted SWF files may not communicate with the Internet. You can avoid
        this situation by reclassifying this SWF file as local-with-networking or trusted.
        * A navigate operation attempted to evaluate a scripting pseudo-URL, but the
        containing document (usually an HTML document in a browser) is from a sandbox to
        which you do not have access. You can avoid this situation by specifying
        `allowScriptAccess="always"` in the containing document.
        * You cannot navigate the special windows "_self", "_top", or "_parent" if your
        SWF file is contained by an HTML page that has set the allowScriptAccess to
        "none", or to "sameDomain" when the domains of the HTML file and the SWF file do
        not match.
        * You cannot navigate a window with a nondefault name from within a SWF file that
        is in the local-with-filesystem sandbox.
        * You cannot connect to commonly reserved ports. For a complete list of blocked
        ports, see "Restricting Networking APIs" in the ActionScript 3.0 Developer's Guide.
        @throws	Error	If the method is not called in response to a user action, such as a
         mouse event or keypress event. This requirement only applies to content in Flash
         Player and to non-application sandbox content in Adobe AIR.
    **/
    static navigateToURL(request, target = null) {
        var _a;
        if (target == null) {
            target = "_blank";
        }
        var uri = (_a = request.url) !== null && _a !== void 0 ? _a : "";
        if (typeof request.data === "object") {
            var query = "";
            for (let field in request.data) {
                if (query.length > 0)
                    query += "&";
                query += encodeURIComponent(field) + "=" + encodeURIComponent(request.data[field]);
            }
            if (uri.indexOf("?") > -1) {
                uri += "&" + query;
            }
            else {
                uri += "?" + query;
            }
        }
        window.open(uri, target);
    }
    static notImplemented() {
    }
    static preventDefaultTouchMove() {
        document.addEventListener("touchmove", (event) => {
            event.preventDefault();
        }, false);
    }
    /**
        Sends a URL request to a server, but ignores any response.

        To examine the server response, use the `URLLoader.load()` method instead.

        You cannot connect to commonly reserved ports. For a complete list of blocked
        ports, see "Restricting Networking APIs" in the ActionScript 3.0 Developer's Guide.

        You can prevent a SWF file from using this method by setting the `allowNetworking`
        parameter of the the object and embed tags in the HTML page that contains the SWF
        content.

        In Flash Player 10 and later, if you use a multipart Content-Type (for example
        "multipart/form-data") that contains an upload (indicated by a "filename" parameter
        in a "content-disposition" header within the POST body), the POST operation is
        subject to the security rules applied to uploads:

        * The POST operation must be performed in response to a user-initiated action,
        such as a mouse click or key press.
        * If the POST operation is cross-domain (the POST target is not on the same server
        as the SWF file that is sending the POST request), the target server must provide
        a URL policy file that permits cross-domain access.

        Also, for any multipart Content-Type, the syntax must be valid (according to the
        RFC2046 standards). If the syntax appears to be invalid, the POST operation is
        subject to the security rules applied to uploads.

        For more information related to security, see the Flash Player Developer Center
        Topic: Security.

        @param	request	A URLRequest object specifying the URL to send data to.
        @throws	SecurityError	Local untrusted SWF files cannot communicate with the
        Internet. You can avoid this situation by reclassifying this SWF file as
        local-with-networking or trusted.
        @throws	SecurityError	You cannot connect to commonly reserved ports. For a
        complete list of blocked ports, see "Restricting Networking APIs" in the
        ActionScript 3.0 Developer's Guide.
    **/
    static sendToURL(request) {
        var urlLoader = new URLLoader();
        urlLoader.load(request);
    }
    /**
        Runs a at a specified interval (in milliseconds).

        Instead of using the `setInterval()` method, consider creating a Timer object, with
        the specified interval, using 0 as the `repeatCount` parameter (which sets the timer
        to repeat indefinitely).

        If you intend to use the `clearInterval()` method to cancel the `setInterval()`
        call, be sure to assign the `setInterval()` call to a variable (which the
        `clearInterval()` will later reference). If you do not call the
        `clearInterval()` to cancel the `setInterval()` call, the object
        containing the set timeout closure will not be garbage collected.

        @param	closure	The name of the to execute. Do not include quotation
        marks or parentheses, and do not specify parameters of the to call. For
        example, use `functionName`, not `functionName()` or `functionName(param)`.
        @param	delay	The interval, in milliseconds.
        @param	args	An optional list of arguments that are passed to the closure
        function.
        @returns	Unique numeric identifier for the timed process. Use this identifier
        to cancel the process, by calling the `clearInterval()` method.

    **/
    static setInterval(closure, delay, ...args) {
        return window.setInterval.apply(this, arguments);
    }
    /**
        Runs a specified after a specified delay (in milliseconds).

        Instead of using this method, consider creating a Timer object, with the specified
        interval, using 1 as the `repeatCount` parameter (which sets the timer to run only
        once).

        If you intend to use the `clearTimeout()` method to cancel the `setTimeout()` call,
        be sure to assign the `setTimeout()` call to a variable (which the
        `clearTimeout()` will later reference). If you do not call the
        `clearTimeout()` to cancel the `setTimeout()` call, the object containing
        the set timeout closure will not be garbage collected.

        @param	closure	The name of the to execute. Do not include quotation marks
        or parentheses, and do not specify parameters of the to call. For
        example, use `functionName`, not `functionName()` or `functionName(param)`.
        @param	delay	The delay, in milliseconds, until the is executed.
        @param	args	An optional list of arguments that are passed to the closure
        function.
        @returns	Unique numeric identifier for the timed process. Use this identifier to
        cancel the process, by calling the `clearTimeout()` method.
    **/
    static setTimeout(closure, delay, ...args) {
        return window.setTimeout.apply(this, arguments);
    }
    static trace(arg) {
        console.log(arg);
    }
    // Get & Set Methods
    static get current() {
        if (Lib.current == null)
            Lib.current = new MovieClip();
        return Lib.current;
    }
}

/**
    The TextField class is used to create display objects for text display and
    input. <ph outputclass="flexonly">You can use the TextField class to
    perform low-level text rendering. However, in Flex, you typically use the
    Label, Text, TextArea, and TextInput controls to process text. <ph
    outputclass="flashonly">You can give a text field an instance name in the
    Property inspector and use the methods and properties of the TextField
    class to manipulate it with ActionScript. TextField instance names are
    displayed in the Movie Explorer and in the Insert Target Path dialog box in
    the Actions panel.

    To create a text field dynamically, use the `TextField()`
    constructor.

    The methods of the TextField class let you set, select, and manipulate
    text in a dynamic or input text field that you create during authoring or
    at runtime.

    ActionScript provides several ways to format your text at runtime. The
    TextFormat class lets you set character and paragraph formatting for
    TextField objects. You can apply Cascading Style Sheets(CSS) styles to
    text fields by using the `TextField.styleSheet` property and the
    StyleSheet class. You can use CSS to style built-in HTML tags, define new
    formatting tags, or apply styles. You can assign HTML formatted text, which
    optionally uses CSS styles, directly to a text field. HTML text that you
    assign to a text field can contain embedded media(movie clips, SWF files,
    GIF files, PNG files, and JPEG files). The text wraps around the embedded
    media in the same way that a web browser wraps text around media embedded
    in an HTML document.

    Flash Player supports a subset of HTML tags that you can use to format
    text. See the list of supported HTML tags in the description of the
    `htmlText` property.

    @event change                    Dispatched after a control value is
                                     modified, unlike the
                                     `textInput` event, which is
                                     dispatched before the value is modified.
                                     Unlike the W3C DOM Event Model version of
                                     the `change` event, which
                                     dispatches the event only after the
                                     control loses focus, the ActionScript 3.0
                                     version of the `change` event
                                     is dispatched any time the control
                                     changes. For example, if a user types text
                                     into a text field, a `change`
                                     event is dispatched after every keystroke.
    @event link                      Dispatched when a user clicks a hyperlink
                                     in an HTML-enabled text field, where the
                                     URL begins with "event:". The remainder of
                                     the URL after "event:" is placed in the
                                     text property of the LINK event.

                                     **Note:** The default behavior,
                                     adding the text to the text field, occurs
                                     only when Flash Player generates the
                                     event, which in this case happens when a
                                     user attempts to input text. You cannot
                                     put text into a text field by sending it
                                     `textInput` events.
    @event scroll                    Dispatched by a TextField object
                                     _after_ the user scrolls.
    @event textInput                 Flash Player dispatches the
                                     `textInput` event when a user
                                     enters one or more characters of text.
                                     Various text input methods can generate
                                     this event, including standard keyboards,
                                     input method editors(IMEs), voice or
                                     speech recognition systems, and even the
                                     act of pasting plain text with no
                                     formatting or style information.
    @event textInteractionModeChange Flash Player dispatches the
                                     `textInteractionModeChange`
                                     event when a user changes the interaction
                                     mode of a text field. for example on
                                     Android, one can toggle from NORMAL mode
                                     to SELECTION mode using context menu
                                     options
**/
let TextField = /** @class */ (() => {
    class TextField extends InteractiveObject {
        /**
            Creates a new TextField instance. After you create the TextField instance,
            call the `addChild()` or `addChildAt()` method of
            the parent DisplayObjectContainer object to add the TextField instance to
            the display list.
    
            The default size for a text field is 100 x 100 pixels.
        **/
        constructor() {
            super();
            this.__renderedOnCanvasWhileOnDOM = false;
            this.__forceCachedBitmapUpdate = false;
            this.__type = DisplayObjectType$1.TEXTFIELD;
            this.__caretIndex = -1;
            this.__cursorTimerID = 0;
            this.__displayAsPassword = false;
            this.__graphics = new Graphics(this);
            this.__textEngine = new TextEngine(this);
            this.__layoutDirty = true;
            this.__offsetX = 0;
            this.__offsetY = 0;
            this.__mouseWheelEnabled = true;
            this.__text = "";
            this.doubleClickEnabled = true;
            if (TextField.__defaultTextFormat == null) {
                TextField.__defaultTextFormat = new TextFormat("Times New Roman", 12, 0x000000, false, false, false, "", "", TextFormatAlign$1.LEFT, 0, 0, 0, 0);
                TextField.__defaultTextFormat.blockIndent = 0;
                TextField.__defaultTextFormat.bullet = false;
                TextField.__defaultTextFormat.letterSpacing = 0;
                TextField.__defaultTextFormat.kerning = false;
            }
            this.__textFormat = TextField.__defaultTextFormat.clone();
            this.__textEngine.textFormatRanges.push(new TextFormatRange(this.__textFormat, 0, 0));
            // __backend = new TextFieldBackend(this);
            this.addEventListener(MouseEvent.MOUSE_DOWN, this.this_onMouseDown);
            this.addEventListener(FocusEvent.FOCUS_IN, this.this_onFocusIn);
            this.addEventListener(FocusEvent.FOCUS_OUT, this.this_onFocusOut);
            this.addEventListener(KeyboardEvent.KEY_DOWN, this.this_onKeyDown);
            this.addEventListener(MouseEvent.MOUSE_WHEEL, this.this_onMouseWheel);
            this.addEventListener(MouseEvent.DOUBLE_CLICK, this.this_onDoubleClick);
        }
        /**
            Appends the string specified by the `newText` parameter to the
            end of the text of the text field. This method is more efficient than an
            addition assignment(`+=`) on a `text` property
            (such as `someTextField.text += moreText`), particularly for a
            text field that contains a significant amount of content.
    
            @param newText The string to append to the existing text.
        **/
        appendText(text) {
            if (text == null || text == "")
                return;
            this.__dirty = true;
            this.__layoutDirty = true;
            this.__setRenderDirty();
            this.__updateText(this.__text + text);
            this.__textEngine.textFormatRanges[this.__textEngine.textFormatRanges.length - 1].end = this.__text.length;
            this.__updateScrollV();
            this.__updateScrollH();
        }
        // copyRichText() : string;
        /**
            Returns a rectangle that is the bounding box of the character.
    
            @param charIndex The zero-based index value for the character (for
                             example, the first position is 0, the second position is
                             1, and so on).
            @return A rectangle with `x` and `y` minimum and
                    maximum values defining the bounding box of the character.
        **/
        getCharBoundaries(charIndex) {
            if (charIndex < 0 || charIndex > this.__text.length - 1)
                return null;
            var rect = new Rectangle();
            if (this.__getCharBoundaries(charIndex, rect)) {
                return rect;
            }
            else {
                return null;
            }
        }
        /**
            Returns the zero-based index value of the character at the point specified
            by the `x` and `y` parameters.
    
            @param x The _x_ coordinate of the character.
            @param y The _y_ coordinate of the character.
            @return The zero-based index value of the character(for example, the
                    first position is 0, the second position is 1, and so on). Returns
                    -1 if the point is not over any character.
        **/
        getCharIndexAtPoint(x, y) {
            if (x <= 2 || x > this.width + 4 || y <= 0 || y > this.height + 4)
                return -1;
            this.__updateLayout();
            x += this.scrollH;
            for (let i = 0; i < this.scrollV; i++) {
                y += this.__textEngine.lineHeights[i];
            }
            for (let group of this.__textEngine.layoutGroups) {
                if (y >= group.offsetY && y <= group.offsetY + group.height) {
                    if (x >= group.offsetX && x <= group.offsetX + group.width) {
                        var advance = 0.0;
                        for (let i = 0; i < group.positions.length; i++) {
                            advance += group.getAdvance(i);
                            if (x <= group.offsetX + advance) {
                                return group.startIndex + i;
                            }
                        }
                        return group.endIndex;
                    }
                }
            }
            return -1;
        }
        /**
            Given a character index, returns the index of the first character in
            the same paragraph.
    
            @param charIndex The zero-based index value of the character (for
                             example, the first character is 0, the second
                             character is 1, and so on).
            @return The zero-based index value of the first character in the same
                    paragraph.
            @throws RangeError The character index specified is out of range.
        **/
        getFirstCharInParagraph(charIndex) {
            if (charIndex < 0 || charIndex > this.text.length)
                return -1;
            var index = this.__textEngine.getLineBreakIndex();
            var startIndex = 0;
            while (index > -1) {
                if (index < charIndex) {
                    startIndex = index + 1;
                }
                else if (index >= charIndex) {
                    break;
                }
                index = this.__textEngine.getLineBreakIndex(index + 1);
            }
            return startIndex;
        }
        /**
            Returns a DisplayObject reference for the given `id`, for an image or
            SWF file that has been added to an HTML-formatted text field by using
            an `<img>` tag. The `<img>` tag is in the following format:
    
            ```html
            <img src='filename.jpg' id='instanceName' />
            ```
    
            @param id The `id` to match (in the `id` attribute of the `<img>`
                      tag).
            @return The display object corresponding to the image or SWF file with
                    the matching `id` attribute in the `<img>` tag of the text
                    field. For media loaded from an external source, this object
                    is a Loader object, and, once loaded, the media object is a
                    child of that Loader object. For media embedded in the SWF
                    file, it is the loaded object. If no `<img>` tag with the
                    matching `id` exists, the method returns `null`.
        **/
        // getImageReference(id : string) : openfl.display.DisplayObject;
        /**
            Returns the zero-based index value of the line at the point specified by
            the `x` and `y` parameters.
    
            @param x The _x_ coordinate of the line.
            @param y The _y_ coordinate of the line.
            @return The zero-based index value of the line(for example, the first
                    line is 0, the second line is 1, and so on). Returns -1 if the
                    point is not over any line.
        **/
        getLineIndexAtPoint(x, y) {
            this.__updateLayout();
            if (x <= 2 || x > this.width + 4 || y <= 0 || y > this.height + 4)
                return -1;
            for (let i = 0; i < this.scrollV - 1; i++) {
                y += this.__textEngine.lineHeights[i];
            }
            for (let group of this.__textEngine.layoutGroups) {
                if (y >= group.offsetY && y <= group.offsetY + group.height) {
                    return group.lineIndex;
                }
            }
            return -1;
        }
        /**
            Returns the zero-based index value of the line containing the
            character specified by the `charIndex` parameter.
    
            @param charIndex The zero-based index value of the character (for
                             example, the first character is 0, the second
                             character is 1, and so on).
            @return The zero-based index value of the line.
            @throws RangeError The character index specified is out of range.
        **/
        getLineIndexOfChar(charIndex) {
            if (charIndex < 0 || charIndex > this.__text.length)
                return -1;
            this.__updateLayout();
            for (let group of this.__textEngine.layoutGroups) {
                if (group.startIndex <= charIndex && group.endIndex >= charIndex) {
                    return group.lineIndex;
                }
            }
            return -1;
        }
        /**
            Returns the number of characters in a specific text line.
    
            @param lineIndex The line number for which you want the length.
            @return The number of characters in the line.
            @throws RangeError The line number specified is out of range.
        **/
        getLineLength(lineIndex) {
            this.__updateLayout();
            if (lineIndex < 0 || lineIndex > this.__textEngine.numLines - 1)
                return 0;
            var startIndex = -1;
            var endIndex = -1;
            for (let group of this.__textEngine.layoutGroups) {
                if (group.lineIndex == lineIndex) {
                    if (startIndex == -1)
                        startIndex = group.startIndex;
                }
                else if (group.lineIndex == lineIndex + 1) {
                    endIndex = group.startIndex;
                    break;
                }
            }
            if (endIndex == -1)
                endIndex = this.__text.length;
            return endIndex - startIndex;
        }
        /**
            Returns metrics information about a given text line.
    
            @param lineIndex The line number for which you want metrics information.
            @return A TextLineMetrics object.
            @throws RangeError The line number specified is out of range.
        **/
        getLineMetrics(lineIndex) {
            this.__updateLayout();
            var ascender = this.__textEngine.lineAscents[lineIndex];
            var descender = this.__textEngine.lineDescents[lineIndex];
            var leading = this.__textEngine.lineLeadings[lineIndex];
            var lineHeight = this.__textEngine.lineHeights[lineIndex];
            var lineWidth = this.__textEngine.lineWidths[lineIndex];
            // TODO: Handle START and END based on language (don't assume LTR)
            var margin = 2;
            switch (this.__textFormat.align) {
                case TextFormatAlign$1.RIGHT:
                case TextFormatAlign$1.END:
                    margin = (this.__textEngine.width - lineWidth) - 2;
                    break;
                case TextFormatAlign$1.CENTER:
                    margin = (this.__textEngine.width - lineWidth) / 2;
                    break;
            }
            return new TextLineMetrics(margin, lineWidth, lineHeight, ascender, descender, leading);
        }
        /**
            Returns the character index of the first character in the line that the
            `lineIndex` parameter specifies.
    
            @param lineIndex The zero-based index value of the line(for example, the
                             first line is 0, the second line is 1, and so on).
            @return The zero-based index value of the first character in the line.
            @throws RangeError The line number specified is out of range.
        **/
        getLineOffset(lineIndex) {
            this.__updateLayout();
            if (lineIndex < 0 || lineIndex > this.__textEngine.numLines - 1)
                return -1;
            for (let group of this.__textEngine.layoutGroups) {
                if (group.lineIndex == lineIndex) {
                    return group.startIndex;
                }
            }
            return 0;
        }
        /**
            Returns the text of the line specified by the `lineIndex`
            parameter.
    
            @param lineIndex The zero-based index value of the line(for example, the
                             first line is 0, the second line is 1, and so on).
            @return The text string contained in the specified line.
            @throws RangeError The line number specified is out of range.
        **/
        getLineText(lineIndex) {
            this.__updateLayout();
            if (lineIndex < 0 || lineIndex > this.__textEngine.numLines - 1)
                return null;
            var startIndex = -1;
            var endIndex = -1;
            for (let group of this.__textEngine.layoutGroups) {
                if (group.lineIndex == lineIndex) {
                    if (startIndex == -1)
                        startIndex = group.startIndex;
                }
                else if (group.lineIndex == lineIndex + 1) {
                    endIndex = group.startIndex;
                    break;
                }
            }
            if (endIndex == -1)
                endIndex = this.__text.length;
            return this.__textEngine.text.substring(startIndex, endIndex);
        }
        /**
            Given a character index, returns the length of the paragraph
            containing the given character. The length is relative to the first
            character in the paragraph (as returned by
            `getFirstCharInParagraph()`), not to the character index passed in.
    
            @param charIndex The zero-based index value of the character (for
                             example, the first character is 0, the second
                             character is 1, and so on).
            @return Returns the number of characters in the paragraph.
            @throws RangeError The character index specified is out of range.
        **/
        getParagraphLength(charIndex) {
            if (charIndex < 0 || charIndex > this.text.length)
                return -1;
            var startIndex = this.getFirstCharInParagraph(charIndex);
            if (charIndex >= this.text.length)
                return this.text.length - startIndex + 1;
            var endIndex = this.__textEngine.getLineBreakIndex(charIndex) + 1;
            if (endIndex == 0)
                endIndex = this.__text.length;
            return endIndex - startIndex;
        }
        // getRawText() : string;
        /**
            Returns a TextFormat object that contains formatting information for
            the range of text that the `beginIndex` and `endIndex` parameters
            specify. Only properties that are common to the entire text specified
            are set in the resulting TextFormat object. Any property that is
            _mixed_, meaning that it has different values at different points in
            the text, has a value of `null`.
            If you do not specify values for these parameters, this method is
            applied to all the text in the text field.
    
            The following table describes three possible usages:
    
            | Usage | Description |
            | --- | --- |
            | `my_textField.getTextFormat()` | Returns a TextFormat object containing formatting information for all text in a text field. Only properties that are common to all text in the text field are set in the resulting TextFormat object. Any property that is _mixed_, meaning that it has different values at different points in the text, has a value of `null`. |
            | `my_textField.getTextFormat(beginIndex:Number)` | Returns a TextFormat object containing a copy of the text format of the character at the `beginIndex` position. |
            | `my_textField.getTextFormat(beginIndex:Number,endIndex:Number)` | Returns a TextFormat object containing formatting information for the span of text from `beginIndex` to `endIndex-1`. Only properties that are common to all of the text in the specified range are set in the resulting TextFormat object. Any property that is mixed (that is, has different values at different points in the range) has its value set to `null`. |
    
            @return The TextFormat object that represents the formatting
                    properties for the specified text.
            @throws RangeError The `beginIndex` or `endIndex` specified is out of
                               range.
        **/
        getTextFormat(beginIndex = -1, endIndex = -1) {
            var format = null;
            if (beginIndex >= this.text.length || beginIndex < -1 || endIndex > this.text.length || endIndex < -1)
                throw new RangeError("The supplied index is out of bounds");
            if (beginIndex == -1)
                beginIndex = 0;
            if (endIndex == -1)
                endIndex = this.text.length;
            if (beginIndex >= endIndex)
                return new TextFormat();
            for (let group of this.__textEngine.textFormatRanges) {
                if ((group.start <= beginIndex && group.end > beginIndex) || (group.start < endIndex && group.end >= endIndex)) {
                    if (format == null) {
                        format = group.format.clone();
                    }
                    else {
                        if (group.format.font != format.font)
                            format.font = null;
                        if (group.format.size != format.size)
                            format.size = null;
                        if (group.format.color != format.color)
                            format.color = null;
                        if (group.format.bold != format.bold)
                            format.bold = null;
                        if (group.format.italic != format.italic)
                            format.italic = null;
                        if (group.format.underline != format.underline)
                            format.underline = null;
                        if (group.format.url != format.url)
                            format.url = null;
                        if (group.format.target != format.target)
                            format.target = null;
                        if (group.format.align != format.align)
                            format.align = null;
                        if (group.format.leftMargin != format.leftMargin)
                            format.leftMargin = null;
                        if (group.format.rightMargin != format.rightMargin)
                            format.rightMargin = null;
                        if (group.format.indent != format.indent)
                            format.indent = null;
                        if (group.format.leading != format.leading)
                            format.leading = null;
                        if (group.format.blockIndent != format.blockIndent)
                            format.blockIndent = null;
                        if (group.format.bullet != format.bullet)
                            format.bullet = null;
                        if (group.format.kerning != format.kerning)
                            format.kerning = null;
                        if (group.format.letterSpacing != format.letterSpacing)
                            format.letterSpacing = null;
                        if (group.format.tabStops != format.tabStops)
                            format.tabStops = null;
                    }
                }
            }
            if (format == null)
                format = new TextFormat();
            return format;
        }
        /**
            Returns true if an embedded font is available with the specified
            `fontName` and `fontStyle` where `Font.fontType` is
            `openfl.text.FontType.EMBEDDED`. Starting with Flash Player 10, two
            kinds of embedded fonts can appear in a SWF file. Normal embedded
            fonts are only used with TextField objects. CFF embedded fonts are
            only used with the openfl.text.engine classes. The two types are
            distinguished by the `fontType` property of the `Font` class, as
            returned by the `enumerateFonts()` function.
            TextField cannot use a font of type `EMBEDDED_CFF`. If `embedFonts` is
            set to `true` and the only font available at run time with the
            specified name and style is of type `EMBEDDED_CFF`, Flash Player fails
            to render the text, as if no embedded font were available with the
            specified name and style.
    
            If both `EMBEDDED` and `EMBEDDED_CFF` fonts are available with the
            same name and style, the `EMBEDDED` font is selected and text renders
            with the `EMBEDDED` font.
    
            @param fontName  The name of the embedded font to check.
            @param fontStyle Specifies the font style to check. Use
                             `openfl.text.FontStyle`
            @return `true` if a compatible embedded font is available, otherwise
                    `false`.
            @throws ArgumentError The `fontStyle` specified is not a member of
                                  `openfl.text.FontStyle`.
        **/
        // @:require(flash10) static isFontCompatible(fontName : string, fontStyle : string)  : boolean;
        /**
            Replaces the current selection with the contents of the `value`
            parameter. The text is inserted at the position of the current
            selection, using the current default character format and default
            paragraph format. The text is not treated as HTML.
            You can use the `replaceSelectedText()` method to insert and delete
            text without disrupting the character and paragraph formatting of the
            rest of the text.
    
            **Note:** This method does not work if a style sheet is applied to the
            text field.
    
            @param value The string to replace the currently selected text.
            @throws Error This method cannot be used on a text field with a style
                          sheet.
        **/
        replaceSelectedText(value) {
            this.__replaceSelectedText(value, false);
        }
        /**
            Replaces the range of characters that the `beginIndex` and `endIndex`
            parameters specify with the contents of the `newText` parameter. As
            designed, the text from `beginIndex` to `endIndex-1` is replaced.
            **Note:** This method does not work if a style sheet is applied to the
            text field.
    
            @param beginIndex The zero-based index value for the start position of
                              the replacement range.
            @param endIndex   The zero-based index position of the first character
                              after the desired text span.
            @param newText    The text to use to replace the specified range of
                              characters.
            @throws Error This method cannot be used on a text field with a style
                          sheet.
        **/
        replaceText(beginIndex, endIndex, newText) {
            this.__replaceText(beginIndex, endIndex, newText, false);
        }
        /**
            Sets as selected the text designated by the index values of the first and
            last characters, which are specified with the `beginIndex` and
            `endIndex` parameters. If the two parameter values are the
            same, this method sets the insertion point, as if you set the
            `caretIndex` property.
    
            @param beginIndex The zero-based index value of the first character in the
                              selection(for example, the first character is 0, the
                              second character is 1, and so on).
            @param endIndex   The zero-based index value of the last character in the
                              selection.
        **/
        setSelection(beginIndex, endIndex) {
            this.__selectionIndex = beginIndex;
            this.__caretIndex = endIndex;
            this.__updateScrollV();
            this.__stopCursorTimer();
            this.__startCursorTimer();
        }
        /**
            Applies the text formatting that the `format` parameter
            specifies to the specified text in a text field. The value of
            `format` must be a TextFormat object that specifies the desired
            text formatting changes. Only the non-null properties of
            `format` are applied to the text field. Any property of
            `format` that is set to `null` is not applied. By
            default, all of the properties of a newly created TextFormat object are
            set to `null`.
    
            **Note:** This method does not work if a style sheet is applied to
            the text field.
    
            The `setTextFormat()` method changes the text formatting
            applied to a range of characters or to the entire body of text in a text
            field. To apply the properties of format to all text in the text field, do
            not specify values for `beginIndex` and `endIndex`.
            To apply the properties of the format to a range of text, specify values
            for the `beginIndex` and the `endIndex` parameters.
            You can use the `length` property to determine the index
            values.
    
            The two types of formatting information in a TextFormat object are
            character level formatting and paragraph level formatting. Each character
            in a text field can have its own character formatting settings, such as
            font name, font size, bold, and italic.
    
            For paragraphs, the first character of the paragraph is examined for
            the paragraph formatting settings for the entire paragraph. Examples of
            paragraph formatting settings are left margin, right margin, and
            indentation.
    
            Any text inserted manually by the user, or replaced by the
            `replaceSelectedText()` method, receives the default text field
            formatting for new text, and not the formatting specified for the text
            insertion point. To set the default formatting for new text, use
            `defaultTextFormat`.
    
            @param format A TextFormat object that contains character and paragraph
                          formatting information.
            @throws Error      This method cannot be used on a text field with a style
                               sheet.
            @throws RangeError The `beginIndex` or `endIndex`
                               specified is out of range.
        **/
        setTextFormat(format, beginIndex = 0, endIndex = 0) {
            var max = this.text.length;
            var range;
            if (beginIndex < 0)
                beginIndex = 0;
            if (endIndex < 0)
                endIndex = 0;
            if (endIndex == 0) {
                if (beginIndex == 0) {
                    endIndex = max;
                }
                else {
                    endIndex = beginIndex + 1;
                }
            }
            if (endIndex < beginIndex)
                return;
            if (beginIndex == 0 && endIndex >= max) {
                // set text format for the whole textfield
                this.__textFormat.__merge(format);
                for (let i = 0; i < this.__textEngine.textFormatRanges.length; i++) {
                    range = this.__textEngine.textFormatRanges[i];
                    range.format.__merge(format);
                }
            }
            else {
                var index = 0;
                var newRange;
                while (index < this.__textEngine.textFormatRanges.length) {
                    range = this.__textEngine.textFormatRanges[index];
                    if (range.start == beginIndex && range.end == endIndex) {
                        // set format range matches an existing range exactly
                        range.format.__merge(format);
                        break;
                    }
                    else if (range.start >= beginIndex && range.end <= endIndex) {
                        // set format range completely encompasses this existing range
                        range.format.__merge(format);
                    }
                    else if (range.start >= beginIndex && range.start < endIndex && range.end > beginIndex) {
                        // set format range is within the first part of the range
                        newRange = new TextFormatRange(range.format.clone(), range.start, endIndex);
                        newRange.format.__merge(format);
                        this.__textEngine.textFormatRanges.insertAt(index, newRange);
                        range.start = endIndex;
                        index++;
                    }
                    else if (range.start < beginIndex && range.end > beginIndex && range.end >= endIndex) {
                        // set format range is within the second part of the range
                        newRange = new TextFormatRange(range.format.clone(), beginIndex, range.end);
                        newRange.format.__merge(format);
                        this.__textEngine.textFormatRanges.insertAt(index + 1, newRange);
                        range.end = beginIndex;
                        index++;
                    }
                    index++;
                    // TODO: Remove duplicates?
                }
            }
            this.__dirty = true;
            this.__layoutDirty = true;
            this.__setRenderDirty();
        }
        __allowMouseFocus() {
            return this.__textEngine.type == TextFieldType$1.INPUT || this.tabEnabled || this.selectable;
        }
        __caretBeginningOfLine() {
            if (this.__selectionIndex == this.__caretIndex || this.__caretIndex < this.__selectionIndex) {
                this.__caretIndex = this.getLineOffset(this.getLineIndexOfChar(this.__caretIndex));
            }
            else {
                this.__selectionIndex = this.getLineOffset(this.getLineIndexOfChar(this.__selectionIndex));
            }
        }
        __caretEndOfLine() {
            var lineIndex;
            if (this.__selectionIndex == this.__caretIndex) {
                lineIndex = this.getLineIndexOfChar(this.__caretIndex);
            }
            else {
                lineIndex = this.getLineIndexOfChar(Math.max(this.__caretIndex, this.__selectionIndex));
            }
            if (lineIndex < this.__textEngine.numLines - 1) {
                this.__caretIndex = this.getLineOffset(lineIndex + 1) - 1;
            }
            else {
                this.__caretIndex = this.__text.length;
            }
        }
        __caretNextCharacter() {
            if (this.__caretIndex < this.__text.length) {
                this.__caretIndex++;
            }
        }
        __caretNextLine(lineIndex = null, caretIndex = null) {
            if (lineIndex == null) {
                lineIndex = this.getLineIndexOfChar(this.__caretIndex);
            }
            if (lineIndex < this.__textEngine.numLines - 1) {
                if (caretIndex == null) {
                    caretIndex = this.__caretIndex;
                }
                this.__caretIndex = this.__getCharIndexOnDifferentLine(caretIndex, lineIndex + 1);
            }
            else {
                this.__caretIndex = this.__text.length;
            }
        }
        __caretPreviousCharacter() {
            if (this.__caretIndex > 0) {
                this.__caretIndex--;
            }
        }
        __caretPreviousLine(lineIndex = null, caretIndex = null) {
            if (lineIndex == null) {
                lineIndex = this.getLineIndexOfChar(this.__caretIndex);
            }
            if (lineIndex > 0) {
                if (caretIndex == null) {
                    caretIndex = this.__caretIndex;
                }
                this.__caretIndex = this.__getCharIndexOnDifferentLine(caretIndex, lineIndex - 1);
            }
            else {
                this.__caretIndex = 0;
            }
        }
        __disableInput() {
            if (this.__inputEnabled && this.stage != null) {
                // this.__backend.disableInput();
                this.__inputEnabled = false;
                this.__stopCursorTimer();
            }
        }
        __dispatch(event) {
            if (event.eventPhase == EventPhase$1.AT_TARGET && event.type == MouseEvent.MOUSE_UP) {
                var group = this.__getGroup(this.mouseX, this.mouseY, true);
                if (group != null) {
                    var url = group.format.url;
                    if (url != null && url != "") {
                        if (url.startsWith("event:")) {
                            this.dispatchEvent(new TextEvent(TextEvent.LINK, false, false, url.substr(6)));
                        }
                        else {
                            Lib$1.getURL(new URLRequest(url));
                        }
                    }
                }
            }
            return super.__dispatch(event);
        }
        __enableInput() {
            if (this.stage != null) {
                // this.__backend.enableInput();
                if (!this.__inputEnabled) {
                    this.__inputEnabled = true;
                    this.__startCursorTimer();
                }
            }
        }
        __getAdvance(position) {
            return position;
        }
        __getBounds(rect, matrix) {
            this.__updateLayout();
            var bounds = Rectangle.__pool.get();
            bounds.copyFrom(this.__textEngine.bounds);
            matrix.tx += this.__offsetX;
            matrix.ty += this.__offsetY;
            bounds.__transform(bounds, matrix);
            rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
            Rectangle.__pool.release(bounds);
        }
        __getCharBoundaries(charIndex, rect) {
            if (charIndex < 0 || charIndex > this.__text.length - 1)
                return false;
            this.__updateLayout();
            for (let group of this.__textEngine.layoutGroups) {
                if (charIndex >= group.startIndex && charIndex < group.endIndex) {
                    try {
                        var x = group.offsetX;
                        for (let i = 0; i < (charIndex - group.startIndex); i++) {
                            x += group.getAdvance(i);
                        }
                        // TODO: Is this actually right for combining characters?
                        var lastPosition = group.getAdvance(charIndex - group.startIndex);
                        rect.setTo(x, group.offsetY, lastPosition, group.ascent + group.descent);
                        return true;
                    }
                    catch (e) { }
                }
            }
            return false;
        }
        __getCharIndexOnDifferentLine(charIndex, lineIndex) {
            if (charIndex < 0 || charIndex > this.__text.length)
                return -1;
            if (lineIndex < 0 || lineIndex > this.__textEngine.numLines - 1)
                return -1;
            var x = null, y = null;
            for (let group of this.__textEngine.layoutGroups) {
                if (charIndex >= group.startIndex && charIndex <= group.endIndex) {
                    x = group.offsetX;
                    for (let i = 0; i < (charIndex - group.startIndex); i++) {
                        x += group.getAdvance(i);
                    }
                    if (y != null)
                        return this.__getPosition(x, y);
                }
                if (group.lineIndex == lineIndex) {
                    y = group.offsetY + group.height / 2;
                    for (let i = 0; i < this.scrollV - 1; i++) {
                        y -= this.__textEngine.lineHeights[i];
                    }
                    if (x != null)
                        return this.__getPosition(x, y);
                }
            }
            return -1;
        }
        __getCursor() {
            var group = this.__getGroup(this.mouseX, this.mouseY, true);
            if (group != null && group.format.url != "") {
                return MouseCursor$1.BUTTON;
            }
            else if (this.__textEngine.selectable) {
                return MouseCursor$1.IBEAM;
            }
            return null;
        }
        __getGroup(x, y, precise = false) {
            this.__updateLayout();
            x += this.scrollH;
            for (let i = 0; i < this.scrollV - 1; i++) {
                y += this.__textEngine.lineHeights[i];
            }
            if (!precise && y > this.__textEngine.textHeight)
                y = this.__textEngine.textHeight;
            var firstGroup = true;
            var group, nextGroup;
            for (let i = 0; i < this.__textEngine.layoutGroups.length; i++) {
                group = this.__textEngine.layoutGroups[i];
                if (i < this.__textEngine.layoutGroups.length - 1) {
                    nextGroup = this.__textEngine.layoutGroups[i + 1];
                }
                else {
                    nextGroup = null;
                }
                if (firstGroup) {
                    if (y < group.offsetY)
                        y = group.offsetY;
                    if (x < group.offsetX)
                        x = group.offsetX;
                    firstGroup = false;
                }
                if ((y >= group.offsetY && y <= group.offsetY + group.height) || (!precise && nextGroup == null)) {
                    if ((x >= group.offsetX && x <= group.offsetX + group.width)
                        || (!precise && (nextGroup == null || nextGroup.lineIndex != group.lineIndex))) {
                        return group;
                    }
                }
            }
            return null;
        }
        __getPosition(x, y) {
            var group = this.__getGroup(x, y);
            if (group == null) {
                return this.__text.length;
            }
            var advance = 0.0;
            for (let i = 0; i < group.positions.length; i++) {
                advance += group.getAdvance(i);
                if (x <= group.offsetX + advance) {
                    if (x <= group.offsetX + (advance - group.getAdvance(i)) + (group.getAdvance(i) / 2)) {
                        return group.startIndex + i;
                    }
                    else {
                        return (group.startIndex + i < group.endIndex) ? group.startIndex + i + 1 : group.endIndex;
                    }
                }
            }
            return group.endIndex;
        }
        __getRenderBounds(rect, matrix) {
            if (this.__scrollRect == null) {
                this.__updateLayout();
                var bounds = Rectangle.__pool.get();
                bounds.copyFrom(this.__textEngine.bounds);
                // matrix.tx += this.__offsetX;
                // matrix.ty += this.__offsetY;
                bounds.__transform(bounds, matrix);
                rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
                Rectangle.__pool.release(bounds);
            }
            else {
                super.__getRenderBounds(rect, matrix);
            }
        }
        __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
            if (!hitObject.visible || this.__isMask || (interactiveOnly && !this.mouseEnabled))
                return false;
            if (this.mask != null && !this.mask.__hitTestMask(x, y))
                return false;
            this.__getRenderTransform();
            this.__updateLayout();
            var px = this.__renderTransform.__transformInverseX(x, y);
            var py = this.__renderTransform.__transformInverseY(x, y);
            if (this.__textEngine.bounds.contains(px, py)) {
                if (stack != null) {
                    stack.push(hitObject);
                }
                return true;
            }
            return false;
        }
        __hitTestMask(x, y) {
            this.__getRenderTransform();
            this.__updateLayout();
            var px = this.__renderTransform.__transformInverseX(x, y);
            var py = this.__renderTransform.__transformInverseY(x, y);
            if (this.__textEngine.bounds.contains(px, py)) {
                return true;
            }
            return false;
        }
        __replaceSelectedText(value, restrict = true) {
            if (value == null)
                value = "";
            if (value == "" && this.__selectionIndex == this.__caretIndex)
                return;
            var startIndex = this.__caretIndex < this.__selectionIndex ? this.__caretIndex : this.__selectionIndex;
            var endIndex = this.__caretIndex > this.__selectionIndex ? this.__caretIndex : this.__selectionIndex;
            if (startIndex == endIndex && this.__textEngine.maxChars > 0 && this.__text.length == this.__textEngine.maxChars)
                return;
            if (startIndex > this.__text.length)
                startIndex = this.__text.length;
            if (endIndex > this.__text.length)
                endIndex = this.__text.length;
            if (endIndex < startIndex) {
                var cache = endIndex;
                endIndex = startIndex;
                startIndex = cache;
            }
            if (startIndex < 0)
                startIndex = 0;
            this.__replaceText(startIndex, endIndex, value, restrict);
            var i = startIndex + value.length;
            if (i > this.__text.length)
                i = this.__text.length;
            this.setSelection(i, i);
            // TODO: Solution where this is not run twice (run inside replaceText above)
            this.__updateScrollH();
        }
        __replaceText(beginIndex, endIndex, newText, restrict) {
            if (endIndex < beginIndex || beginIndex < 0 || endIndex > this.__text.length || newText == null)
                return;
            if (restrict) {
                newText = this.__textEngine.restrictText(newText);
                if (this.__textEngine.maxChars > 0) {
                    var removeLength = (endIndex - beginIndex);
                    var maxLength = this.__textEngine.maxChars - this.__text.length + removeLength;
                    if (maxLength <= 0) {
                        newText = "";
                    }
                    else if (maxLength < newText.length) {
                        newText = newText.substr(0, maxLength);
                    }
                }
            }
            this.__updateText(this.__text.substring(0, beginIndex) + newText + this.__text.substring(endIndex));
            if (endIndex > this.__text.length)
                endIndex = this.__text.length;
            var offset = newText.length - (endIndex - beginIndex);
            var i = 0;
            var range;
            while (i < this.__textEngine.textFormatRanges.length) {
                range = this.__textEngine.textFormatRanges[i];
                if (beginIndex == endIndex) {
                    if (range.end < beginIndex) ;
                    else if (range.start > endIndex) {
                        // shift range, range is after insertion point
                        range.start += offset;
                        range.end += offset;
                    }
                    else {
                        if (range.start < range.end && range.end == beginIndex && i < this.__textEngine.textFormatRanges.length - 1) ;
                        else {
                            // add to range, insertion point is within range
                            range.end += offset;
                        }
                    }
                }
                else {
                    if (range.end < beginIndex) ;
                    else if (range.start >= endIndex) {
                        // shift range, range is completely after selection
                        range.start += offset;
                        range.end += offset;
                    }
                    else if (range.start >= beginIndex && range.end <= endIndex) {
                        // delete range, range is encompassed by selection
                        if (this.__textEngine.textFormatRanges.length > 1) {
                            this.__textEngine.textFormatRanges.splice(i, 1);
                        }
                        else {
                            // don't delete if it's the last range though, just modify properties
                            range.start = 0;
                            range.end = newText.length;
                        }
                    }
                    else if (range.start <= beginIndex) {
                        if (range.end < endIndex) {
                            // modify range, range ends before the selection ends
                            range.end = beginIndex;
                        }
                        else {
                            // modify range, range ends where or after the selection ends
                            range.end += offset;
                        }
                    }
                    else {
                        // modify range, selection begins before the range
                        // for deletion: entire range shifts leftward
                        // for addition: added text gains the format of endIndex
                        range.start = beginIndex;
                        range.end += offset;
                    }
                }
                i++;
            }
            this.__updateScrollV();
            this.__updateScrollH();
            this.__dirty = true;
            this.__layoutDirty = true;
            this.__setRenderDirty();
        }
        __startCursorTimer() {
            this.__cursorTimerID = window.setTimeout(this.__startCursorTimer, 600);
            this.__showCursor = !this.__showCursor;
            this.__dirty = true;
            this.__setRenderDirty();
        }
        __startTextInput() {
            if (this.__caretIndex < 0) {
                this.__caretIndex = this.__text.length;
                this.__selectionIndex = this.__caretIndex;
            }
            var enableInput = (DisplayObject.__supportDOM ? this.__renderedOnCanvasWhileOnDOM : true);
            if (enableInput) {
                this.__enableInput();
            }
        }
        __stopCursorTimer() {
            if (this.__cursorTimerID != 0) {
                window.clearTimeout(this.__cursorTimerID);
                this.__cursorTimerID = 0;
            }
            if (this.__showCursor) {
                this.__showCursor = false;
                this.__dirty = true;
                this.__setRenderDirty();
            }
        }
        __stopTextInput() {
            var disableInput = (DisplayObject.__supportDOM ? this.__renderedOnCanvasWhileOnDOM : true);
            if (disableInput) {
                this.__disableInput();
            }
        }
        __update(transformOnly, updateChildren) {
            var transformDirty = this.__transformDirty;
            this.__updateSingle(transformOnly, updateChildren);
            if (transformDirty) {
                this.__renderTransform.__translateTransformed(this.__offsetX, this.__offsetY);
            }
        }
        __updateLayout() {
            if (this.__layoutDirty) {
                var cacheWidth = this.__textEngine.width;
                this.__textEngine.update();
                if (this.__textEngine.autoSize != TextFieldAutoSize$1.NONE) {
                    if (this.__textEngine.width != cacheWidth) {
                        switch (this.__textEngine.autoSize) {
                            case TextFieldAutoSize$1.RIGHT:
                                this.x += cacheWidth - this.__textEngine.width;
                                break;
                            case TextFieldAutoSize$1.CENTER:
                                this.x += (cacheWidth - this.__textEngine.width) / 2;
                                break;
                        }
                    }
                    this.__textEngine.getBounds();
                }
                this.__layoutDirty = false;
            }
        }
        __updateScrollH() {
            if (!this.multiline && this.type == TextFieldType$1.INPUT) {
                this.__layoutDirty = true;
                this.__updateLayout();
                var offsetX = this.__textEngine.textWidth - this.__textEngine.width + 4;
                if (offsetX > 0) {
                    // TODO: Handle __selectionIndex on drag select?
                    // TODO: Update scrollH by one character width at a time when able
                    if (this.__caretIndex >= this.text.length) {
                        this.scrollH = Math.ceil(offsetX);
                    }
                    else {
                        var caret = Rectangle.__pool.get();
                        this.__getCharBoundaries(this.__caretIndex, caret);
                        if (caret.x < this.scrollH) {
                            this.scrollH = Math.floor(caret.x - 2);
                        }
                        else if (caret.x > this.scrollH + this.__textEngine.width) {
                            this.scrollH = Math.ceil(caret.x - this.__textEngine.width - 2);
                        }
                        Rectangle.__pool.release(caret);
                    }
                }
                else {
                    this.scrollH = 0;
                }
            }
        }
        __updateScrollV() {
            this.__layoutDirty = true;
            this.__updateLayout();
            var lineIndex = this.getLineIndexOfChar(this.__caretIndex);
            if (lineIndex == -1 && this.__caretIndex > 0) {
                // new paragraph
                lineIndex = this.getLineIndexOfChar(this.__caretIndex - 1) + 1;
            }
            if (lineIndex + 1 < this.scrollV) {
                this.scrollV = lineIndex + 1;
            }
            else if (lineIndex + 1 > this.bottomScrollV) {
                var i = lineIndex, tempHeight = 0.0;
                while (i >= 0) {
                    if (tempHeight + this.__textEngine.lineHeights[i] <= this.height - 4) {
                        tempHeight += this.__textEngine.lineHeights[i];
                        i--;
                    }
                    else
                        break;
                }
                this.scrollV = i + 2;
            }
            else {
                // TODO: can this be avoided? this doesn't need to hit the setter each time, just a couple times
                this.scrollV = this.scrollV;
            }
        }
        __updateText(value) {
            if (DisplayObject.__supportDOM && this.__renderedOnCanvasWhileOnDOM) {
                this.__forceCachedBitmapUpdate = this.__text != value;
            }
            // applies maxChars and restrict on text
            this.__textEngine.text = value;
            this.__text = this.__textEngine.text;
            if (this.__text.length < this.__caretIndex) {
                this.__selectionIndex = this.__caretIndex = this.__text.length;
            }
            if (!this.__displayAsPassword || DisplayObject.__supportDOM && !this.__renderedOnCanvasWhileOnDOM) {
                this.__textEngine.text = this.__text;
            }
            else {
                var length = this.text.length;
                var mask = "";
                for (let i = 0; i < length; i++) {
                    mask += "*";
                }
                this.__textEngine.text = mask;
            }
        }
        // Getters & Setters
        /**
            The type of anti-aliasing used for this text field. Use
            `openfl.text.AntiAliasType` constants for this property. You can
            control this setting only if the font is embedded(with the
            `embedFonts` property set to `true`). The default
            setting is `openfl.text.AntiAliasType.NORMAL`.
    
            To set values for this property, use the following string values:
        **/
        get antiAliasType() {
            return this.__textEngine.antiAliasType;
        }
        set antiAliasType(value) {
            if (value != this.__textEngine.antiAliasType) ;
            this.__textEngine.antiAliasType = value;
        }
        /**
            Controls automatic sizing and alignment of text fields. Acceptable values
            for the `TextFieldAutoSize` constants:
            `TextFieldAutoSize.NONE`(the default),
            `TextFieldAutoSize.LEFT`, `TextFieldAutoSize.RIGHT`,
            and `TextFieldAutoSize.CENTER`.
    
            If `autoSize` is set to `TextFieldAutoSize.NONE`
            (the default) no resizing occurs.
    
            If `autoSize` is set to `TextFieldAutoSize.LEFT`,
            the text is treated as left-justified text, meaning that the left margin
            of the text field remains fixed and any resizing of a single line of the
            text field is on the right margin. If the text includes a line break(for
            example, `"\n"` or `"\r"`), the bottom is also
            resized to fit the next line of text. If `wordWrap` is also set
            to `true`, only the bottom of the text field is resized and the
            right side remains fixed.
    
            If `autoSize` is set to
            `TextFieldAutoSize.RIGHT`, the text is treated as
            right-justified text, meaning that the right margin of the text field
            remains fixed and any resizing of a single line of the text field is on
            the left margin. If the text includes a line break(for example,
            `"\n" or "\r")`, the bottom is also resized to fit the next
            line of text. If `wordWrap` is also set to `true`,
            only the bottom of the text field is resized and the left side remains
            fixed.
    
            If `autoSize` is set to
            `TextFieldAutoSize.CENTER`, the text is treated as
            center-justified text, meaning that any resizing of a single line of the
            text field is equally distributed to both the right and left margins. If
            the text includes a line break(for example, `"\n"` or
            `"\r"`), the bottom is also resized to fit the next line of
            text. If `wordWrap` is also set to `true`, only the
            bottom of the text field is resized and the left and right sides remain
            fixed.
    
            @throws ArgumentError The `autoSize` specified is not a member
                                  of openfl.text.TextFieldAutoSize.
        **/
        get autoSize() {
            return this.__textEngine.autoSize;
        }
        set autoSize(value) {
            if (value != this.__textEngine.autoSize) {
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.autoSize = value;
        }
        /**
            Specifies whether the text field has a background fill. If
            `true`, the text field has a background fill. If
            `false`, the text field has no background fill. Use the
            `backgroundColor` property to set the background color of a
            text field.
    
            @default false
        **/
        get background() {
            return this.__textEngine.background;
        }
        set background(value) {
            if (value != this.__textEngine.background) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.background = value;
        }
        /**
            The color of the text field background. The default value is
            `0xFFFFFF`(white). This property can be retrieved or set, even
            if there currently is no background, but the color is visible only if the
            text field has the `background` property set to
            `true`.
        **/
        get backgroundColor() {
            return this.__textEngine.backgroundColor;
        }
        set backgroundColor(value) {
            if (value != this.__textEngine.backgroundColor) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.backgroundColor = value;
        }
        /**
            Specifies whether the text field has a border. If `true`, the
            text field has a border. If `false`, the text field has no
            border. Use the `borderColor` property to set the border color.
    
            @default false
        **/
        get border() {
            return this.__textEngine.border;
        }
        set border(value) {
            if (value != this.__textEngine.border) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.border = value;
        }
        /**
            The color of the text field border. The default value is
            `0x000000`(black). This property can be retrieved or set, even
            if there currently is no border, but the color is visible only if the text
            field has the `border` property set to `true`.
        **/
        get borderColor() {
            return this.__textEngine.borderColor;
        }
        set borderColor(value) {
            if (value != this.__textEngine.borderColor) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.borderColor = value;
        }
        /**
            An integer(1-based index) that indicates the bottommost line that is
            currently visible in the specified text field. Think of the text field as
            a window onto a block of text. The `scrollV` property is the
            1-based index of the topmost visible line in the window.
    
            All the text between the lines indicated by `scrollV` and
            `bottomScrollV` is currently visible in the text field.
        **/
        get bottomScrollV() {
            this.__updateLayout();
            return this.__textEngine.bottomScrollV;
        }
        /**
            The index of the insertion point(caret) position. If no insertion point
            is displayed, the value is the position the insertion point would be if
            you restored focus to the field(typically where the insertion point last
            was, or 0 if the field has not had focus).
    
            Selection span indexes are zero-based(for example, the first position
            is 0, the second position is 1, and so on).
        **/
        get caretIndex() {
            return this.__caretIndex;
        }
        /**
            Specifies the format applied to newly inserted text, such as text entered
            by a user or text inserted with the `replaceSelectedText()`
            method.
    
            **Note:** When selecting characters to be replaced with
            `setSelection()` and `replaceSelectedText()`, the
            `defaultTextFormat` will be applied only if the text has been
            selected up to and including the last character. Here is an example:
    
            ```
            var my_txt:TextField new TextField();
            my_txt.text = "Flash Macintosh version"; my_fmt:TextFormat = new
            TextFormat(); my_fmt.color = 0xFF0000; my_txt.defaultTextFormat = my_fmt;
            my_txt.setSelection(6,15); // partial text selected - defaultTextFormat
            not applied my_txt.setSelection(6,23); // text selected to end -
            defaultTextFormat applied my_txt.replaceSelectedText("Windows version");
            ```
    
            When you access the `defaultTextFormat` property, the
            returned TextFormat object has all of its properties defined. No property
            is `null`.
    
            **Note:** You can't set this property if a style sheet is applied to
            the text field.
    
            @throws Error This method cannot be used on a text field with a style
                          sheet.
        **/
        get defaultTextFormat() {
            return this.__textFormat.clone();
        }
        set defaultTextFormat(value) {
            this.__textFormat.__merge(value);
            this.__layoutDirty = true;
            this.__dirty = true;
            this.__setRenderDirty();
        }
        /**
            Specifies whether the text field is a password text field. If the value of
            this property is `true`, the text field is treated as a
            password text field and hides the input characters using asterisks instead
            of the actual characters. If `false`, the text field is not
            treated as a password text field. When password mode is enabled, the Cut
            and Copy commands and their corresponding keyboard shortcuts will not
            function. This security mechanism prevents an unscrupulous user from using
            the shortcuts to discover a password on an unattended computer.
    
            @default false
        **/
        get displayAsPassword() {
            return this.__displayAsPassword;
        }
        set displayAsPassword(value) {
            if (value != this.__displayAsPassword) {
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
                this.__displayAsPassword = value;
                this.__updateText(this.__text);
            }
        }
        /**
            Specifies whether to render by using embedded font outlines. If
            `false`, Flash Player renders the text field by using device
            fonts.
    
            If you set the `embedFonts` property to `true`
            for a text field, you must specify a font for that text by using the
            `font` property of a TextFormat object applied to the text
            field. If the specified font is not embedded in the SWF file, the text is
            not displayed.
    
            @default false
        **/
        get embedFonts() {
            return this.__textEngine.embedFonts;
        }
        set embedFonts(value) {
            // if (value != this.__textEngine.embedFonts) {
            //
            // __dirty = true;
            // __layoutDirty = true;
            //
            // }
            this.__textEngine.embedFonts = value;
        }
        /**
            The type of grid fitting used for this text field. This property
            applies only if the `openfl.text.AntiAliasType` property of the text
            field is set to `openfl.text.AntiAliasType.ADVANCED`.
            The type of grid fitting used determines whether Flash Player forces
            strong horizontal and vertical lines to fit to a pixel or subpixel
            grid, or not at all.
    
            For the `openfl.text.GridFitType` property, you can use the following
            string values:
    
            | String value | Description |
            | --- | --- |
            | `openfl.text.GridFitType.NONE` | Specifies no grid fitting. Horizontal and vertical lines in the glyphs are not forced to the pixel grid. This setting is recommended for animation or for large font sizes. |
            | `openfl.text.GridFitType.PIXEL` | Specifies that strong horizontal and vertical lines are fit to the pixel grid. This setting works only for left-aligned text fields. To use this setting, the `openfl.dispaly.AntiAliasType` property of the text field must be set to `openfl.text.AntiAliasType.ADVANCED`. This setting generally provides the best legibility for left-aligned text. |
            | `openfl.text.GridFitType.SUBPIXEL` | Specifies that strong horizontal and vertical lines are fit to the subpixel grid on an LCD monitor. To use this setting, the `openfl.text.AntiAliasType` property of the text field must be set to `openfl.text.AntiAliasType.ADVANCED`. The `openfl.text.GridFitType.SUBPIXEL` setting is often good for right-aligned or centered dynamic text, and it is sometimes a useful trade-off for animation versus text quality. |
    
            @default pixel
        **/
        get gridFitType() {
            return this.__textEngine.gridFitType;
        }
        set gridFitType(value) {
            // if (value != this.__textEngine.gridFitType) {
            //
            // __dirty = true;
            // __layoutDirty = true;
            //
            // }
            this.__textEngine.gridFitType = value;
        }
        get height() {
            this.__updateLayout();
            return this.__textEngine.height * Math.abs(this.scaleY);
        }
        set height(value) {
            if (value != this.__textEngine.height) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
                this.__setRenderDirty();
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__textEngine.height = value;
            }
            this.__textEngine.height * Math.abs(this.scaleY);
        }
        /**
            Contains the HTML representation of the text field contents.
            Flash Player supports the following HTML tags:
    
            | Tag |  Description  |
            | --- | --- |
            | Anchor tag | The `<a>` tag creates a hypertext link and supports the following attributes:<ul><li>`target`: Specifies the name of the target window where you load the page. Options include `_self`, `_blank`, `_parent`, and `_top`. The `_self` option specifies the current frame in the current window, `_blank` specifies a new window, `_parent` specifies the parent of the current frame, and `_top` specifies the top-level frame in the current window.</li><li>`href`: Specifies a URL or an ActionScript `link` event.The URL can be either absolute or relative to the location of the SWF file that is loading the page. An example of an absolute reference to a URL is `http://www.adobe.com`; an example of a relative reference is `/index.html`. Absolute URLs must be prefixed with http://; otherwise, Flash Player or AIR treats them as relative URLs. You can use the `link` event to cause the link to execute an ActionScript in a SWF file instead of opening a URL. To specify a `link` event, use the event scheme instead of the http scheme in your `href` attribute. An example is `href="event:myText"` instead of `href="http://myURL"`; when the user clicks a hypertext link that contains the event scheme, the text field dispatches a `link` TextEvent with its `text` property set to "`myText`". You can then create an ActionScript that executes whenever the link TextEvent is dispatched. You can also define `a:link`, `a:hover`, and `a:active` styles for anchor tags by using style sheets.</li></ul> |
            | Bold tag | The `<b>` tag renders text as bold. A bold typeface must be available for the font used. |
            | Break tag | The `<br>` tag creates a line break in the text field. Set the text field to be a multiline text field to use this tag.  |
            | Font tag | The `<font>` tag specifies a font or list of fonts to display the text.The font tag supports the following attributes:<ul><li>`color`: Only hexadecimal color (`#FFFFFF`) values are supported.</li><li>`face`: Specifies the name of the font to use. As shown in the following example, you can specify a list of comma-delimited font names, in which case Flash Player selects the first available font. If the specified font is not installed on the local computer system or isn't embedded in the SWF file, Flash Player selects a substitute font.</li><li>`size`: Specifies the size of the font. You can use absolute pixel sizes, such as 16 or 18, or relative point sizes, such as +2 or -4.</li></ul> |
            | Image tag | The `<img>` tag lets you embed external image files (JPEG, GIF, PNG), SWF files, and movie clips inside text fields. Text automatically flows around images you embed in text fields. You must set the text field to be multiline to wrap text around an image.<br>The `<img>` tag supports the following attributes:<ul><li>`src`: Specifies the URL to an image or SWF file, or the linkage identifier for a movie clip symbol in the library. This attribute is required; all other attributes are optional. External files (JPEG, GIF, PNG, and SWF files) do not show until they are downloaded completely.</li><li>`width`: The width of the image, SWF file, or movie clip being inserted, in pixels.</li><li>`height`: The height of the image, SWF file, or movie clip being inserted, in pixels.</li><li>`align`: Specifies the horizontal alignment of the embedded image within the text field. Valid values are `left` and `right`. The default value is `left`.</li><li>`hspace`: Specifies the amount of horizontal space that surrounds the image where no text appears. The default value is 8.</li><li>`vspace`: Specifies the amount of vertical space that surrounds the image where no text appears. The default value is 8.</li><li>`id`: Specifies the name for the movie clip instance (created by Flash Player) that contains the embedded image file, SWF file, or movie clip. This approach is used to control the embedded content with ActionScript.</li><li>`checkPolicyFile`: Specifies that Flash Player checks for a URL policy file on the server associated with the image domain. If a policy file exists, SWF files in the domains listed in the file can access the data of the loaded image, for example, by calling the `BitmapData.draw()` method with this image as the `source` parameter. For more information related to security, see the Flash Player Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).</li></ul>Flash displays media embedded in a text field at full size. To specify the dimensions of the media you are embedding, use the `<img>` tag `height` and `width` attributes. <br>In general, an image embedded in a text field appears on the line following the `<img>` tag. However, when the `<img>` tag is the first character in the text field, the image appears on the first line of the text field.<br>For AIR content in the application security sandbox, AIR ignores `img` tags in HTML content in ActionScript TextField objects. This is to prevent possible phishing attacks. |
            | Italic tag | The `<i>` tag displays the tagged text in italics. An italic typeface must be available for the font used. |
            | List item tag | The `<li>` tag places a bullet in front of the text that it encloses.<br>**Note:** Because Flash Player and AIR do not recognize ordered and unordered list tags (`<ol>` and `<ul>`, they do not modify how your list is rendered. All lists are unordered and all list items use bullets. |
            | Paragraph tag | The `<p>` tag creates a new paragraph. The text field must be set to be a multiline text field to use this tag. The `<p>` tag supports the following attributes:<ul><li>align: Specifies alignment of text within the paragraph; valid values are `left`, `right`, `justify`, and `center`.</li><li>class: Specifies a CSS style class defined by a openfl.text.StyleSheet object.</li></ul> |
            | Span tag | The `<span>` tag is available only for use with CSS text styles. It supports the following attribute:<ul><li>class: Specifies a CSS style class defined by a openfl.text.StyleSheet object.</li></ul> |
            | Text format tag | The `<textformat>` tag lets you use a subset of paragraph formatting properties of the TextFormat class within text fields, including line leading, indentation, margins, and tab stops. You can combine `<textformat>` tags with the built-in HTML tags.<br>The `<textformat>` tag has the following attributes:<li>`blockindent`: Specifies the block indentation in points; corresponds to `TextFormat.blockIndent`.</li><li>`indent`: Specifies the indentation from the left margin to the first character in the paragraph; corresponds to `TextFormat.indent`. Both positive and negative numbers are acceptable.</li><li>`leading`: Specifies the amount of leading (vertical space) between lines; corresponds to `TextFormat.leading`. Both positive and negative numbers are acceptable.</li><li>`leftmargin`: Specifies the left margin of the paragraph, in points; corresponds to `TextFormat.leftMargin`.</li><li>`rightmargin`: Specifies the right margin of the paragraph, in points; corresponds to `TextFormat.rightMargin`.</li><li>`tabstops`: Specifies custom tab stops as an array of non-negative integers; corresponds to `TextFormat.tabStops`.</li></ul> |
            | Underline tag | The `<u>` tag underlines the tagged text. |
    
            Flash Player and AIR support the following HTML entities:
    
            | Entity | Description |
            | --- | --- |
            | &amp;lt; | < (less than) |
            | &amp;gt; | > (greater than) |
            | &amp;amp; | & (ampersand) |
            | &amp;quot; | " (double quotes) |
            | &amp;apos; | ' (apostrophe, single quote) |
    
            Flash Player and AIR also support explicit character codes, such as
            &#38; (ASCII ampersand) and &#x20AC; (Unicode € symbol).
        **/
        get htmlText() {
            return this.__isHTML ? this.__rawHtmlText : this.__text;
        }
        set htmlText(value) {
            if (!this.__isHTML || this.__text != value) {
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
            }
            this.__isHTML = true;
            this.__rawHtmlText = value;
            value = HTMLParser.parse(value, this.__textFormat, this.__textEngine.textFormatRanges);
            if (DisplayObject.__supportDOM) {
                if (this.__textEngine.textFormatRanges.length > 1) {
                    this.__textEngine.textFormatRanges.splice(1, this.__textEngine.textFormatRanges.length - 1);
                }
                var range = this.__textEngine.textFormatRanges[0];
                range.format = this.__textFormat;
                range.start = 0;
                if (this.__renderedOnCanvasWhileOnDOM) {
                    range.end = value.length;
                    this.__updateText(value);
                }
                else {
                    range.end = this.__rawHtmlText.length;
                    this.__updateText(this.__rawHtmlText);
                }
            }
            else {
                this.__updateText(value);
            }
            this.__updateScrollV();
        }
        /**
            The number of characters in a text field. A character such as tab
            (`\t`) counts as one character.
        **/
        get length() {
            if (this.__text != null) {
                return this.__text.length;
            }
            return 0;
        }
        /**
            The maximum number of characters that the text field can contain, as
            entered by a user. A script can insert more text than
            `maxChars` allows; the `maxChars` property indicates
            only how much text a user can enter. If the value of this property is
            `0`, a user can enter an unlimited amount of text.
    
            @default 0
        **/
        get maxChars() {
            return this.__textEngine.maxChars;
        }
        set maxChars(value) {
            if (value != this.__textEngine.maxChars) {
                this.__textEngine.maxChars = value;
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
            }
        }
        /**
            The maximum value of `scrollH`.
        **/
        get maxScrollH() {
            this.__updateLayout();
            return this.__textEngine.maxScrollH;
        }
        /**
            The maximum value of `scrollV`.
        **/
        get maxScrollV() {
            this.__updateLayout();
            return this.__textEngine.maxScrollV;
        }
        /**
            A Boolean value that indicates whether Flash Player automatically scrolls
            multiline text fields when the user clicks a text field and rolls the mouse wheel.
            By default, this value is `true`. This property is useful if you want to prevent
            mouse wheel scrolling of text fields, or implement your own text field scrolling.
        **/
        get mouseWheelEnabled() {
            return this.__mouseWheelEnabled;
        }
        set mouseWheelEnabled(value) {
            this.__mouseWheelEnabled = value;
        }
        /**
            Indicates whether field is a multiline text field. If the value is
            `true`, the text field is multiline; if the value is
            `false`, the text field is a single-line text field. In a field
            of type `TextFieldType.INPUT`, the `multiline` value
            determines whether the `Enter` key creates a new line(a value
            of `false`, and the `Enter` key is ignored). If you
            paste text into a `TextField` with a `multiline`
            value of `false`, newlines are stripped out of the text.
    
            @default false
        **/
        get multiline() {
            return this.__textEngine.multiline;
        }
        set multiline(value) {
            if (value != this.__textEngine.multiline) {
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__updateText(this.__text);
                // __updateScrollV();
                this.__updateScrollH();
                this.__setRenderDirty();
            }
            this.__textEngine.multiline = value;
        }
        /**
            Defines the number of text lines in a multiline text field. If
            `wordWrap` property is set to `true`, the number of
            lines increases when text wraps.
        **/
        get numLines() {
            this.__updateLayout();
            return this.__textEngine.numLines;
        }
        /**
            Indicates the set of characters that a user can enter into the text field.
            If the value of the `restrict` property is `null`,
            you can enter any character. If the value of the `restrict`
            property is an empty string, you cannot enter any character. If the value
            of the `restrict` property is a string of characters, you can
            enter only characters in the string into the text field. The string is
            scanned from left to right. You can specify a range by using the hyphen
            (-) character. Only user interaction is restricted; a script can put any
            text into the text field. <ph outputclass="flashonly">This property does
            not synchronize with the Embed font options in the Property inspector.
    
            If the string begins with a caret(^) character, all characters are
            initially accepted and succeeding characters in the string are excluded
            from the set of accepted characters. If the string does not begin with a
            caret(^) character, no characters are initially accepted and succeeding
            characters in the string are included in the set of accepted
            characters.
    
            The following example allows only uppercase characters, spaces, and
            numbers to be entered into a text field:
            `my_txt.restrict = "A-Z 0-9";`
    
            The following example includes all characters, but excludes lowercase
            letters:
            `my_txt.restrict = "^a-z";`
    
            You can use a backslash to enter a ^ or - verbatim. The accepted
            backslash sequences are \-, \^ or \\. The backslash must be an actual
            character in the string, so when specified in ActionScript, a double
            backslash must be used. For example, the following code includes only the
            dash(-) and caret(^):
            `my_txt.restrict = "\\-\\^";`
    
            The ^ can be used anywhere in the string to toggle between including
            characters and excluding characters. The following code includes only
            uppercase letters, but excludes the uppercase letter Q:
            `my_txt.restrict = "A-Z^Q";`
    
            You can use the `\u` escape sequence to construct
            `restrict` strings. The following code includes only the
            characters from ASCII 32(space) to ASCII 126(tilde).
            `my_txt.restrict = "\u0020-\u007E";`
    
            @default null
        **/
        get restrict() {
            return this.__textEngine.restrict;
        }
        set restrict(value) {
            if (this.__textEngine.restrict != value) {
                this.__textEngine.restrict = value;
                this.__updateText(this.__text);
            }
        }
        /**
            The current horizontal scrolling position. If the `scrollH`
            property is 0, the text is not horizontally scrolled. This property value
            is an integer that represents the horizontal position in pixels.
    
            The units of horizontal scrolling are pixels, whereas the units of
            vertical scrolling are lines. Horizontal scrolling is measured in pixels
            because most fonts you typically use are proportionally spaced; that is,
            the characters can have different widths. Flash Player performs vertical
            scrolling by line because users usually want to see a complete line of
            text rather than a partial line. Even if a line uses multiple fonts, the
            height of the line adjusts to fit the largest font in use.
    
            **Note: **The `scrollH` property is zero-based, not
            1-based like the `scrollV` vertical scrolling property.
        **/
        get scrollH() {
            return this.__textEngine.scrollH;
        }
        set scrollH(value) {
            this.__updateLayout();
            if (value > this.__textEngine.maxScrollH)
                value = this.__textEngine.maxScrollH;
            if (value < 0)
                value = 0;
            if (value != this.__textEngine.scrollH) {
                this.__dirty = true;
                this.__setRenderDirty();
                this.__textEngine.scrollH = value;
                this.dispatchEvent(new Event(Event.SCROLL));
            }
        }
        /**
            The vertical position of text in a text field. The `scrollV`
            property is useful for directing users to a specific paragraph in a long
            passage, or creating scrolling text fields.
    
            The units of vertical scrolling are lines, whereas the units of
            horizontal scrolling are pixels. If the first line displayed is the first
            line in the text field, scrollV is set to 1(not 0). Horizontal scrolling
            is measured in pixels because most fonts are proportionally spaced; that
            is, the characters can have different widths. Flash performs vertical
            scrolling by line because users usually want to see a complete line of
            text rather than a partial line. Even if there are multiple fonts on a
            line, the height of the line adjusts to fit the largest font in use.
        **/
        get scrollV() {
            return this.__textEngine.scrollV;
        }
        set scrollV(value) {
            this.__updateLayout();
            if (value > 0 && value != this.__textEngine.scrollV) {
                this.__dirty = true;
                this.__setRenderDirty();
                this.__textEngine.scrollV = value;
                this.dispatchEvent(new Event(Event.SCROLL));
            }
        }
        /**
            A Boolean value that indicates whether the text field is selectable. The
            value `true` indicates that the text is selectable. The
            `selectable` property controls whether a text field is
            selectable, not whether a text field is editable. A dynamic text field can
            be selectable even if it is not editable. If a dynamic text field is not
            selectable, the user cannot select its text.
    
            If `selectable` is set to `false`, the text in
            the text field does not respond to selection commands from the mouse or
            keyboard, and the text cannot be copied with the Copy command. If
            `selectable` is set to `true`, the text in the text
            field can be selected with the mouse or keyboard, and the text can be
            copied with the Copy command. You can select text this way even if the
            text field is a dynamic text field instead of an input text field.
    
            @default true
        **/
        get selectable() {
            return this.__textEngine.selectable;
        }
        set selectable(value) {
            if (value != this.__textEngine.selectable && this.type == TextFieldType$1.INPUT) {
                if (this.stage != null && this.stage.focus == this) {
                    this.__startTextInput();
                }
                else if (!value) {
                    this.__stopTextInput();
                }
            }
            this.__textEngine.selectable = value;
        }
        /**
            The zero-based character index value of the first character in the current
            selection. For example, the first character is 0, the second character is
            1, and so on. If no text is selected, this property is the value of
            `caretIndex`.
        **/
        get selectionBeginIndex() {
            return Math.min(this.__caretIndex, this.__selectionIndex);
        }
        /**
            The zero-based character index value of the last character in the current
            selection. For example, the first character is 0, the second character is
            1, and so on. If no text is selected, this property is the value of
            `caretIndex`.
        **/
        get selectionEndIndex() {
            return Math.max(this.__caretIndex, this.__selectionIndex);
        }
        /**
            The sharpness of the glyph edges in this text field. This property applies
            only if the `openfl.text.AntiAliasType` property of the text
            field is set to `openfl.text.AntiAliasType.ADVANCED`. The range
            for `sharpness` is a number from -400 to 400. If you attempt to
            set `sharpness` to a value outside that range, Flash sets the
            property to the nearest value in the range(either -400 or 400).
    
            @default 0
        **/
        get sharpness() {
            return this.__textEngine.sharpness;
        }
        set sharpness(value) {
            if (value != this.__textEngine.sharpness) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.sharpness = value;
        }
        get tabEnabled() {
            return (this.__tabEnabled == null ? this.__textEngine.type == TextFieldType$1.INPUT : this.__tabEnabled);
        }
        /**
            A string that is the current text in the text field. Lines are separated
            by the carriage return character(`'\r'`, ASCII 13). This
            property contains unformatted text in the text field, without HTML tags.
    
            To get the text in HTML form, use the `htmlText`
            property.
        **/
        get text() {
            return this.__text;
        }
        set text(value) {
            if (this.__isHTML || this.__text != value) {
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
            }
            else {
                return;
            }
            if (this.__textEngine.textFormatRanges.length > 1) {
                this.__textEngine.textFormatRanges.splice(1, this.__textEngine.textFormatRanges.length - 1);
            }
            var range = this.__textEngine.textFormatRanges[0];
            range.format = this.__textFormat;
            range.start = 0;
            range.end = value.length;
            this.__isHTML = false;
            this.__updateText(value);
            this.__updateScrollV();
        }
        /**
            The color of the text in a text field, in hexadecimal format. The
            hexadecimal color system uses six digits to represent color values. Each
            digit has 16 possible values or characters. The characters range from 0-9
            and then A-F. For example, black is `0x000000`; white is
            `0xFFFFFF`.
    
            @default 0(0x000000)
        **/
        get textColor() {
            return this.__textFormat.color;
        }
        set textColor(value) {
            if (value != this.__textFormat.color) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            for (let range of this.__textEngine.textFormatRanges) {
                range.format.color = value;
            }
            this.__textFormat.color = value;
        }
        /**
            The height of the text in pixels.
        **/
        get textHeight() {
            this.__updateLayout();
            return this.__textEngine.textHeight;
        }
        /**
            The width of the text in pixels.
        **/
        get textWidth() {
            this.__updateLayout();
            return this.__textEngine.textWidth;
        }
        /**
            The type of the text field. Either one of the following TextFieldType
            constants: `TextFieldType.DYNAMIC`, which specifies a dynamic
            text field, which a user cannot edit, or `TextFieldType.INPUT`,
            which specifies an input text field, which a user can edit.
    
            @default dynamic
            @throws ArgumentError The `type` specified is not a member of
                                  openfl.text.TextFieldType.
        **/
        get type() {
            return this.__textEngine.type;
        }
        set type(value) {
            if (value != this.__textEngine.type) {
                if (value == TextFieldType$1.INPUT) {
                    this.addEventListener(Event.ADDED_TO_STAGE, this.this_onAddedToStage);
                    this.this_onFocusIn(null);
                    this.__textEngine.__useIntAdvances = true;
                }
                else {
                    this.removeEventListener(Event.ADDED_TO_STAGE, this.this_onAddedToStage);
                    this.__stopTextInput();
                    this.__textEngine.__useIntAdvances = null;
                }
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.type = value;
        }
        get width() {
            this.__updateLayout();
            return this.__textEngine.width * Math.abs(this.__scaleX);
        }
        set width(value) {
            if (value != this.__textEngine.width) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
                this.__setRenderDirty();
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__textEngine.width = value;
            }
            this.__textEngine.width * Math.abs(this.__scaleX);
        }
        /**
            A Boolean value that indicates whether the text field has word wrap. If
            the value of `wordWrap` is `true`, the text field
            has word wrap; if the value is `false`, the text field does not
            have word wrap. The default value is `false`.
        **/
        get wordWrap() {
            return this.__textEngine.wordWrap;
        }
        set wordWrap(value) {
            if (value != this.__textEngine.wordWrap) {
                this.__dirty = true;
                this.__layoutDirty = true;
                this.__setRenderDirty();
            }
            this.__textEngine.wordWrap = value;
        }
        get x() {
            return this.__transform.tx + this.__offsetX;
        }
        set x(value) {
            if (value != this.__transform.tx + this.__offsetX) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
            }
            this.__transform.tx = value - this.__offsetX;
        }
        get y() {
            return this.__transform.ty + this.__offsetY;
        }
        set y(value) {
            if (value != this.__transform.ty + this.__offsetY) {
                this.__setTransformDirty();
                this.__setParentRenderDirty();
            }
            this.__transform.ty = value - this.__offsetY;
        }
        // Event Handlers
        stage_onMouseMove(event) {
            if (this.stage == null)
                return;
            if (this.selectable && this.__selectionIndex >= 0) {
                this.__updateLayout();
                var position = this.__getPosition(this.mouseX + this.scrollH, this.mouseY);
                if (position != this.__caretIndex) {
                    this.__caretIndex = position;
                    var setDirty = true;
                    if (DisplayObject.__supportDOM) {
                        if (this.__renderedOnCanvasWhileOnDOM) {
                            this.__forceCachedBitmapUpdate = true;
                        }
                        setDirty = false;
                    }
                    if (setDirty) {
                        this.__dirty = true;
                        this.__setRenderDirty();
                    }
                }
            }
        }
        stage_onMouseUp(event) {
            if (this.stage == null)
                return;
            this.stage.removeEventListener(MouseEvent.MOUSE_MOVE, this.stage_onMouseMove);
            this.stage.removeEventListener(MouseEvent.MOUSE_UP, this.stage_onMouseUp);
            if (this.stage.focus == this) {
                this.__getWorldTransform();
                this.__updateLayout();
                var upPos = this.__getPosition(this.mouseX + this.scrollH, this.mouseY);
                var leftPos;
                var rightPos;
                leftPos = Math.round(Math.min(this.__selectionIndex, upPos));
                rightPos = Math.round(Math.max(this.__selectionIndex, upPos));
                this.__selectionIndex = leftPos;
                this.__caretIndex = rightPos;
                if (this.__inputEnabled) {
                    this.this_onFocusIn(null);
                    this.__stopCursorTimer();
                    this.__startCursorTimer();
                    if (DisplayObject.__supportDOM && this.__renderedOnCanvasWhileOnDOM) {
                        this.__forceCachedBitmapUpdate = true;
                    }
                }
            }
        }
        this_onAddedToStage(event) {
            this.this_onFocusIn(null);
        }
        this_onFocusIn(event) {
            if (this.type == TextFieldType$1.INPUT && this.stage != null && this.stage.focus == this) {
                this.__startTextInput();
            }
        }
        this_onFocusOut(event) {
            this.__stopCursorTimer();
            // TODO: Better system
            if (event.relatedObject == null || !(event.relatedObject instanceof TextField)) {
                this.__stopTextInput();
            }
            else {
                if (this.stage != null) ;
                this.__inputEnabled = false;
            }
            if (this.__selectionIndex != this.__caretIndex) {
                this.__selectionIndex = this.__caretIndex;
                this.__dirty = true;
                this.__setRenderDirty();
            }
        }
        this_onKeyDown(event) {
            if (this.type == TextFieldType$1.INPUT) {
                switch (event.keyCode) {
                    case Keyboard.NUMPAD_ENTER:
                        if (this.__textEngine.multiline) {
                            var te = new TextEvent(TextEvent.TEXT_INPUT, true, true, "\n");
                            this.dispatchEvent(te);
                            if (!te.isDefaultPrevented()) {
                                this.__replaceSelectedText("\n", true);
                                this.dispatchEvent(new Event(Event.CHANGE, true));
                            }
                        }
                        break;
                    case Keyboard.BACKSPACE:
                        if (this.__selectionIndex == this.__caretIndex && this.__caretIndex > 0) {
                            this.__selectionIndex = this.__caretIndex - 1;
                        }
                        if (this.__selectionIndex != this.__caretIndex) {
                            this.replaceSelectedText("");
                            this.__selectionIndex = this.__caretIndex;
                            this.dispatchEvent(new Event(Event.CHANGE, true));
                        }
                        break;
                    case Keyboard.DELETE:
                        if (this.__selectionIndex == this.__caretIndex && this.__caretIndex < this.__text.length) {
                            this.__selectionIndex = this.__caretIndex + 1;
                        }
                        if (this.__selectionIndex != this.__caretIndex) {
                            this.replaceSelectedText("");
                            this.__selectionIndex = this.__caretIndex;
                            this.dispatchEvent(new Event(Event.CHANGE, true));
                        }
                        break;
                    case Keyboard.LEFT:
                        if (this.selectable) {
                            if (event.commandKey) {
                                this.__caretBeginningOfLine();
                                if (!event.shiftKey) {
                                    this.__selectionIndex = this.__caretIndex;
                                }
                            }
                            else if (event.shiftKey) {
                                this.__caretPreviousCharacter();
                            }
                            else {
                                if (this.__selectionIndex == this.__caretIndex) {
                                    this.__caretPreviousCharacter();
                                }
                                else {
                                    this.__caretIndex = Math.min(this.__caretIndex, this.__selectionIndex);
                                }
                                this.__selectionIndex = this.__caretIndex;
                            }
                            this.__updateScrollH();
                            this.__updateScrollV();
                            this.__stopCursorTimer();
                            this.__startCursorTimer();
                        }
                        break;
                    case Keyboard.RIGHT:
                        if (this.selectable) {
                            if (event.commandKey) {
                                this.__caretEndOfLine();
                                if (!event.shiftKey) {
                                    this.__selectionIndex = this.__caretIndex;
                                }
                            }
                            else if (event.shiftKey) {
                                this.__caretNextCharacter();
                            }
                            else {
                                if (this.__selectionIndex == this.__caretIndex) {
                                    this.__caretNextCharacter();
                                }
                                else {
                                    this.__caretIndex = Math.max(this.__caretIndex, this.__selectionIndex);
                                }
                                this.__selectionIndex = this.__caretIndex;
                            }
                            this.__updateScrollH();
                            this.__updateScrollV();
                            this.__stopCursorTimer();
                            this.__startCursorTimer();
                        }
                        break;
                    case Keyboard.DOWN:
                        if (this.selectable) {
                            if (!this.__textEngine.multiline)
                                return;
                            if (event.shiftKey) {
                                this.__caretNextLine();
                            }
                            else {
                                if (this.__selectionIndex == this.__caretIndex) {
                                    this.__caretNextLine();
                                }
                                else {
                                    var lineIndex = this.getLineIndexOfChar(Math.max(this.__caretIndex, this.__selectionIndex));
                                    this.__caretNextLine(lineIndex, Math.min(this.__caretIndex, this.__selectionIndex));
                                }
                                this.__selectionIndex = this.__caretIndex;
                            }
                            this.__updateScrollV();
                            this.__stopCursorTimer();
                            this.__startCursorTimer();
                        }
                        break;
                    case Keyboard.UP:
                        if (this.selectable) {
                            if (!this.__textEngine.multiline)
                                return;
                            if (event.shiftKey) {
                                this.__caretPreviousLine();
                            }
                            else {
                                if (this.__selectionIndex == this.__caretIndex) {
                                    this.__caretPreviousLine();
                                }
                                else {
                                    var lineIndex = this.getLineIndexOfChar(Math.min(this.__caretIndex, this.__selectionIndex));
                                    this.__caretPreviousLine(lineIndex, Math.min(this.__caretIndex, this.__selectionIndex));
                                }
                                this.__selectionIndex = this.__caretIndex;
                            }
                            this.__updateScrollV();
                            this.__stopCursorTimer();
                            this.__startCursorTimer();
                        }
                        break;
                    case Keyboard.HOME:
                        if (this.selectable) {
                            this.__caretBeginningOfLine();
                            this.__stopCursorTimer();
                            this.__startCursorTimer();
                        }
                        break;
                    case Keyboard.END:
                        if (this.selectable) {
                            this.__caretEndOfLine();
                            this.__stopCursorTimer();
                            this.__startCursorTimer();
                        }
                        break;
                    case Keyboard.C:
                        if (event.ctrlKey) {
                            if (this.__caretIndex != this.__selectionIndex) {
                                Clipboard.generalClipboard.setData(ClipboardFormats$1.TEXT_FORMAT, this.__text.substring(this.__caretIndex, this.__selectionIndex));
                            }
                        }
                        break;
                    case Keyboard.X:
                        if (event.ctrlKey) {
                            if (this.__caretIndex != this.__selectionIndex) {
                                Clipboard.generalClipboard.setData(ClipboardFormats$1.TEXT_FORMAT, this.__text.substring(this.__caretIndex, this.__selectionIndex));
                                this.replaceSelectedText("");
                                this.dispatchEvent(new Event(Event.CHANGE, true));
                            }
                        }
                        break;
                    case Keyboard.A:
                        if (this.selectable) {
                            if (event.ctrlKey) {
                                this.__caretIndex = this.__text.length;
                                this.__selectionIndex = 0;
                            }
                        }
                        break;
                }
            }
            else if (this.selectable && event.keyCode == Keyboard.C && (event.commandKey || event.ctrlKey)) {
                if (this.__caretIndex != this.__selectionIndex) {
                    Clipboard.generalClipboard.setData(ClipboardFormats$1.TEXT_FORMAT, this.__text.substring(this.__caretIndex, this.__selectionIndex));
                }
            }
        }
        this_onMouseDown(event) {
            if (!this.selectable && this.type != TextFieldType$1.INPUT)
                return;
            this.__updateLayout();
            this.__caretIndex = this.__getPosition(this.mouseX + this.scrollH, this.mouseY);
            this.__selectionIndex = this.__caretIndex;
            if (!DisplayObject.__supportDOM) {
                this.__dirty = true;
                this.__setRenderDirty();
            }
            this.stage.addEventListener(MouseEvent.MOUSE_MOVE, this.stage_onMouseMove);
            this.stage.addEventListener(MouseEvent.MOUSE_UP, this.stage_onMouseUp);
        }
        this_onMouseWheel(event) {
            if (this.mouseWheelEnabled) {
                this.scrollV -= event.delta;
            }
        }
        this_onDoubleClick(event) {
            if (this.selectable) {
                this.__updateLayout();
                var delimiters = ['\n', '.', '!', '?', ',', ' ', ';', ':', '(', ')', '-', '_', '/'];
                var txtStr = this.__text;
                var leftPos = -1;
                var rightPos = txtStr.length;
                var pos = 0;
                var startPos = Math.max(this.__caretIndex, 1);
                if (txtStr.length > 0 && this.__caretIndex >= 0 && rightPos >= this.__caretIndex) {
                    for (let c of delimiters) {
                        pos = txtStr.lastIndexOf(c, startPos - 1);
                        if (pos > leftPos)
                            leftPos = pos + 1;
                        pos = txtStr.indexOf(c, startPos);
                        if (pos < rightPos && pos != -1)
                            rightPos = pos;
                    }
                    if (leftPos != rightPos) {
                        this.setSelection(leftPos, rightPos);
                        var setDirty = true;
                        if (DisplayObject.__supportDOM) {
                            if (this.__renderedOnCanvasWhileOnDOM) {
                                this.__forceCachedBitmapUpdate = true;
                            }
                            setDirty = false;
                        }
                        if (setDirty) {
                            this.__dirty = true;
                            this.__setRenderDirty();
                        }
                    }
                }
            }
        }
    }
    TextField.__missingFontWarning = new Map();
    return TextField;
})();

/**
    The FPS class provides an easy-to-use monitor to display
    the current frame rate of an OpenFL project
**/
class FPS extends TextField {
    constructor(x = 10, y = 10, color = 0x000000) {
        super();
        this.x = x;
        this.y = y;
        this.__currentFPS = 0;
        this.selectable = false;
        this.mouseEnabled = false;
        this.defaultTextFormat = new TextFormat("_sans", 12, color);
        this.text = "FPS: ";
        this.cacheCount = 0;
        this.currentTime = 0;
        this.times = [];
        // #if flash
        this.addEventListener(Event.ENTER_FRAME, (e) => {
            var time = Lib$1.getTimer();
            this.__enterFrame(time - this.currentTime);
        });
        // #end
    }
    // Event Handlers
    __enterFrame(deltaTime) {
        this.currentTime += deltaTime;
        this.times.push(this.currentTime);
        while (this.times[0] < this.currentTime - 1000) {
            this.times.shift();
        }
        var currentCount = this.times.length;
        this.__currentFPS = Math.round((currentCount + this.cacheCount) / 2);
        if (currentCount != this.cacheCount /*&& visible*/) {
            this.text = "FPS: " + this.__currentFPS;
        }
        this.cacheCount = currentCount;
    }
    // Get & Set Methods
    /**
        The current frame rate, expressed using frames-per-second
    **/
    get currentFPS() {
        return this.__currentFPS;
    }
}

var openfl$j;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The FrameLabel object contains properties that specify a frame number and
            the corresponding label name. The Scene class includes a `labels`
            property, which is an array of FrameLabel objects for the scene.
        **/
        class FrameLabel extends EventDispatcher {
            constructor(name, frame) {
                super();
                this.name = name;
                this.frame = frame;
            }
        }
        display.FrameLabel = FrameLabel;
    })(display = openfl.display || (openfl.display = {}));
})(openfl$j || (openfl$j = {}));
var FrameLabel = openfl$j.display.FrameLabel;

/**
    Defines a set of quadrilaterals. This is similar to using GraphicsPath `drawRect`
    repeatedly, but each rectangle can use a transform value to rotate, scale or skew
    the result.

    Any type of fill can be used, but if the fill has a transform matrix
    that transform matrix is ignored.

    The optional `indices` parameter allows the use of either repeated
    rectangle geometry, or allows the use of a subset of a broader rectangle
    data Vector, such as Tileset `rectData`.
**/
class GraphicsQuadPath {
    /**
        Creates a new GraphicsTrianglePath object.

        @param	rects	A Vector containing rectangle coordinates in [ x0, y0, width0, height0, x1, y1 ... ]
        format.
        @param	indices	A Vector containing optional index values to reference the data contained in
        `rects`
        @param	transforms	A Vector containing optional transform data to adjust _x_, _y_, _a_, _b_, _c_ or _d_
        value for the resulting quadrilateral.
    **/
    constructor(rects = null, indices = null, transforms = null) {
        this.rects = rects;
        this.indices = indices;
        this.transforms = transforms;
        this.__graphicsDataType = GraphicsDataType$1.QUAD_PATH;
    }
}

class GraphicsShader extends Shader {
    constructor(code = null) {
        super(code);
        this.glVertexHeader = `
		attribute float openfl_Alpha;
		attribute vec4 openfl_ColorMultiplier;
		attribute vec4 openfl_ColorOffset;
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;

		varying float openfl_Alphav;
		varying vec4 openfl_ColorMultiplierv;
		varying vec4 openfl_ColorOffsetv;
		varying vec2 openfl_TextureCoordv;

		uniform mat4 openfl_Matrix;
		uniform bool openfl_HasColorTransform;
		uniform vec2 openfl_TextureSize;
	`;
        this.glVertexBody = `
		openfl_Alphav = openfl_Alpha;
		openfl_TextureCoordv = openfl_TextureCoord;

		if (openfl_HasColorTransform)
		{
			openfl_ColorMultiplierv = openfl_ColorMultiplier;
			openfl_ColorOffsetv = openfl_ColorOffset / 255.0;
		}

		gl_Position = openfl_Matrix * openfl_Position;
	`;
        this.glVertexSource = `
		#pragma header

		void main(void)
		{
			#pragma body
		}
	`;
        this.glFragmentHeader = `
		varying float openfl_Alphav;
		varying vec4 openfl_ColorMultiplierv;
		varying vec4 openfl_ColorOffsetv;
		varying vec2 openfl_TextureCoordv;

		uniform bool openfl_HasColorTransform;
		uniform vec2 openfl_TextureSize;
		uniform sampler2D bitmap;
	`;
        this.glFragmentBody = `
		vec4 color = texture2D(bitmap, openfl_TextureCoordv);

		if (color.a == 0.0)
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		}
		else if (openfl_HasColorTransform)
		{
			color = vec4(color.rgb / color.a, color.a);

			mat4 colorMultiplier = mat4(0);
			colorMultiplier[0][0] = openfl_ColorMultiplierv.x;
			colorMultiplier[1][1] = openfl_ColorMultiplierv.y;
			colorMultiplier[2][2] = openfl_ColorMultiplierv.z;
			colorMultiplier[3][3] = 1.0; // openfl_ColorMultiplierv.w;

			color = clamp(openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);

			if (color.a > 0.0)
			{
				gl_FragColor = vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);
			}
			else
			{
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
			}
		}
		else
		{
			gl_FragColor = color * openfl_Alphav;
		}
	`;
        this.glFragmentSource = `
		#pragma header

		void main(void)
		{
			#pragma body
		}
	`;
    }
}

/**
    Defines a shader fill.
    Use a GraphicsShaderFill object with the `Graphics.drawGraphicsData()`
    method. Drawing a GraphicsShaderFill object is the equivalent of calling
    the `Graphics.beginShaderFill()` method.
**/
class GraphicsShaderFill {
    /**
        Creates a new GraphicsShaderFill object.

        @param shader The shader to use for the fill. This Shader instance is
                      not required to specify an image input. However, if an
                      image input is specified in the shader, the input must
                      be provided manually by setting the `input` property of
                      the corresponding ShaderInput property of the
                      `Shader.data` property.
        @param matrix A matrix object (of the openfl.geom.Matrix class), which
                      you can use to define transformations on the shader.
    **/
    constructor(shader, matrix = null) {
        this.shader = shader;
        this.matrix = matrix;
        this.__graphicsDataType = GraphicsDataType$1.SHADER;
        this.__graphicsFillType = GraphicsFillType$1.SHADER_FILL;
    }
}

/**
    Defines an ordered set of triangles that can be rendered using either
    (u,v) fill coordinates or a normal fill. Each triangle in the path is
    represented by three sets of (x, y) coordinates, each of which is one
    point of the triangle.
    The triangle vertices do not contain z coordinates and do not necessarily
    represent 3D faces. However a triangle path can be used to support the
    rendering of 3D geometry in a 2D space.
**/
class GraphicsTrianglePath {
    /**
        Creates a new GraphicsTrianglePath object.

        @param	vertices	A Vector of Numbers where each pair of numbers is treated as a point (an x, y pair).
        Required.
        @param	indices	A Vector of integers or indexes, where every three indexes define a triangle.
        @param	uvtData	A Vector of normalized coordinates used to apply texture mapping.
        @param culling Specifies whether to render triangles that face in a
                       given direction. Used to prevent the rendering of
                       triangles that cannot be seen in the current view. Can
                       be set to any value defined by the TriangleCulling
                       class.
    **/
    constructor(vertices = null, indices = null, uvtData = null, culling = TriangleCulling.NONE) {
        this.vertices = vertices;
        this.indices = indices;
        this.uvtData = uvtData;
        this.culling = culling;
        this.__graphicsDataType = GraphicsDataType$1.TRIANGLE_PATH;
    }
}

var openfl$k;
(function (openfl) {
    var display;
    (function (display) {
        /**
        The JPEGEncoderOptions class defines a compression algorithm for the
        `openfl.display.BitmapData.encode()` method.
    **/
        class JPEGEncoderOptions {
            /**
                Creates a JPEGEncoderOptions object with the specified setting.
    
                @param	quality	The initial quality value.
            **/
            constructor(quality = 80) {
                this.quality = quality;
            }
        }
        display.JPEGEncoderOptions = JPEGEncoderOptions;
    })(display = openfl.display || (openfl.display = {}));
})(openfl$k || (openfl$k = {}));
var JPEGEncoderOptions = openfl$k.display.JPEGEncoderOptions;

/**
    A ProgressEvent object is dispatched when a load operation has begun or a
    socket has received data. These events are usually generated when SWF
    files, images or data are loaded into an application. There are two types
    of progress events: `ProgressEvent.PROGRESS` and
    `ProgressEvent.SOCKET_DATA`. Additionally, in AIR ProgressEvent
    objects are dispatched when a data is sent to or from a child process using
    the NativeProcess class.
**/
let ProgressEvent = /** @class */ (() => {
    class ProgressEvent extends Event {
        /**
            Creates an Event object that contains information about progress events.
            Event objects are passed as parameters to event listeners.
    
            @param type        The type of the event. Possible values
                               are:`ProgressEvent.PROGRESS`,
                               `ProgressEvent.SOCKET_DATA`,
                               `ProgressEvent.STANDARD_ERROR_DATA`,
                               `ProgressEvent.STANDARD_INPUT_PROGRESS`, and
                               `ProgressEvent.STANDARD_OUTPUT_DATA`.
            @param bubbles     Determines whether the Event object participates in the
                               bubbling stage of the event flow.
            @param cancelable  Determines whether the Event object can be canceled.
            @param bytesLoaded The number of items or bytes loaded at the time the
                               listener processes the event.
            @param bytesTotal  The total number of items or bytes that will be loaded
                               if the loading process succeeds.
        **/
        constructor(type, bubbles = false, cancelable = false, bytesLoaded = 0, bytesTotal = 0) {
            super(type, bubbles, cancelable);
            this.bytesLoaded = bytesLoaded;
            this.bytesTotal = bytesTotal;
        }
        clone() {
            var event = new ProgressEvent(this.__type, this.__bubbles, this.__cancelable, this.bytesLoaded, this.bytesTotal);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("ProgressEvent", "type", "bubbles", "cancelable", "bytesLoaded", "bytesTotal");
        }
        __init() {
            super.__init();
            this.bytesLoaded = 0;
            this.bytesTotal = 0;
        }
    }
    /**
        Defines the value of the `type` property of a `progress` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `bytesLoaded` | The number of items or bytes loaded at the time the listener processes the event. |
        | `bytesTotal` | The total number of items or bytes that ultimately will be loaded if the loading process succeeds. |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object reporting progress.  |
    **/
    ProgressEvent.PROGRESS = "progress";
    /**
        Defines the value of the `type` property of a `socketData` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event. |
        | `bytesLoaded` | The number of items or bytes loaded at the time the listener processes the event. |
        | `bytesTotal` | 0; this property is not used by `socketData` event objects. |
        | `target` | The socket reporting progress. |
    **/
    ProgressEvent.SOCKET_DATA = "socketData";
    ProgressEvent.__pool = new ObjectPool(() => new ProgressEvent(null), (event) => event.__init());
    return ProgressEvent;
})();

/**
    The UncaughtErrorEvents class provides a way to receive uncaught error
    events. An instance of this class dispatches an `uncaughtError` event when
    a runtime error occurs and the error isn't detected and handled in your
    code.
    Use the following properties to access an UncaughtErrorEvents instance:

    * `LoaderInfo.uncaughtErrorEvents`: to detect uncaught errors in code
    defined in the same SWF.
    * `Loader.uncaughtErrorEvents`: to detect uncaught errors in code defined
    in the SWF loaded by a Loader object.

    To catch an error directly and prevent an uncaught error event, do the
    following:

    * Use a `<a
    href="../../statements.html#try..catch..finally">try..catch</a>` block to
    isolate code that potentially throws a synchronous error
    * When performing an operation that dispatches an event when an error
    occurs, register a listener for that error event

    If the content loaded by a Loader object is an AVM1 (ActionScript 2) SWF
    file, uncaught errors in the AVM1 SWF file do not result in an
    `uncaughtError` event. In addition, JavaScript errors in HTML content
    loaded in an HTMLLoader object (including a Flex HTML control) do not
    result in an `uncaughtError` event.

    @event uncaughtError Dispatched when an error occurs and developer code
                         doesn't detect and handle the error.
**/
class UncaughtErrorEvents extends EventDispatcher {
    /**
        Creates an UncaughtErrorEvents instance. Developer code shouldn't
        create UncaughtErrorEvents instances directly. To access an
        UncaughtErrorEvents object, use one of the following properties:
        * `LoaderInfo.uncaughtErrorEvents`: to detect uncaught errors in code
        defined in the same SWF.
        * `Loader.uncaughtErrorEvents`: to detect uncaught errors in code
        defined in the SWF loaded by a Loader object.
    **/
    constructor() {
        super();
    }
}

/**
    The ApplicationDomain class is a container for discrete groups of class
    definitions. Application domains are used to partition classes that are in
    the same security domain. They allow multiple definitions of the same
    class to exist and allow children to reuse parent definitions.
    Application domains are used when an external SWF file is loaded through
    the Loader class. All ActionScript 3.0 definitions in the loaded SWF file
    are stored in the application domain, which is specified by the
    `applicationDomain` property of the LoaderContext object that you pass as
    a `context` parameter of the Loader object's `load()` or `loadBytes()`
    method. The LoaderInfo object also contains an `applicationDomain`
    property, which is read-only.

    All code in a SWF file is defined to exist in an application domain. The
    current application domain is where your main application runs. The system
    domain contains all application domains, including the current domain,
    which means that it contains all Flash Player classes.

    Every application domain, except the system domain, has an associated
    parent domain. The parent domain of your main application's application
    domain is the system domain. Loaded classes are defined only when their
    parent doesn't already define them. You cannota loaded class
    definition with a newer definition.

    For usage examples of application domains, see the _ActionScript 3.0
    Developer's Guide_.

    The `ApplicationDomain()` constructor allows you to create an
    ApplicationDomain object.
**/
let ApplicationDomain = /** @class */ (() => {
    class ApplicationDomain {
        /**
            Creates a new application domain.
    
            @param parentDomain If no parent domain is passed in, this application
                                domain takes the system domain as its parent.
        **/
        constructor(parentDomain = null) {
            if (parentDomain != null) {
                this.__parentDomain = parentDomain;
            }
            else {
                this.__parentDomain = ApplicationDomain.__currentDomain;
            }
        }
        /**
            Gets a public definition from the specified application domain. The
            definition can be that of a class, a namespace, or a function.
    
            @param name The name of the definition.
            @return The object associated with the definition.
            @throws ReferenceError No public definition exists with the specified
                                   name.
        **/
        getDefinition(name) {
            // return Type.resolveClass(name);
            return null;
        }
        // /** @hidden */ @:dox(hide) @:require(flash11_3) getQualifiedDefinitionNames() : openfl.Vector<string>;
        /**
            Checks to see if a public definition exists within the specified
            application domain. The definition can be that of a class, a
            namespace, or a function.
    
            @param name The name of the definition.
            @return A value of `true` if the specified definition exists;
                    otherwise, `false`.
        **/
        hasDefinition(name) {
            // return (Type.resolveClass(name) != null);
            return false;
        }
        // Get & Set Methods
        /**
            Gets the current application domain in which your code is executing.
        **/
        static get currentDomain() {
            return ApplicationDomain.__currentDomain;
        }
        /**
            Gets the parent domain of this application domain.
        **/
        get parentDomain() {
            return this.__parentDomain;
        }
    }
    /**
        Gets the minimum memory object length required to be used as
        ApplicationDomain.domainMemory.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public static MIN_DOMAIN_MEMORY_LENGTH (default, null):UInt;
    /**
        Gets and sets the object on which domain-global memory operations will
        operate within this ApplicationDomain.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public domainMemory:ByteArray;
    ApplicationDomain.__currentDomain = new ApplicationDomain(null);
    return ApplicationDomain;
})();

/**
    The LoaderInfo class provides information about a loaded SWF file or a
    loaded image file(JPEG, GIF, or PNG). LoaderInfo objects are available for
    any display object. The information provided includes load progress, the
    URLs of the loader and loaded content, the number of bytes total for the
    media, and the nominal height and width of the media.

    You can access LoaderInfo objects in two ways:

    * The `contentLoaderInfo` property of a openfl.display.Loader
    object -  The `contentLoaderInfo` property is always available
    for any Loader object. For a Loader object that has not called the
    `load()` or `loadBytes()` method, or that has not
    sufficiently loaded, attempting to access many of the properties of the
    `contentLoaderInfo` property throws an error.
    * The `loaderInfo` property of a display object.

    The `contentLoaderInfo` property of a Loader object provides
    information about the content that the Loader object is loading, whereas
    the `loaderInfo` property of a DisplayObject provides
    information about the root SWF file for that display object.

    When you use a Loader object to load a display object(such as a SWF
    file or a bitmap), the `loaderInfo` property of the display
    object is the same as the `contentLoaderInfo` property of the
    Loader object(`DisplayObject.loaderInfo =
    Loader.contentLoaderInfo`). Because the instance of the main class of
    the SWF file has no Loader object, the `loaderInfo` property is
    the only way to access the LoaderInfo for the instance of the main class of
    the SWF file.

    The following diagram shows the different uses of the LoaderInfo
    object - for the instance of the main class of the SWF file, for the
    `contentLoaderInfo` property of a Loader object, and for the
    `loaderInfo` property of a loaded object:

    When a loading operation is not complete, some properties of the
    `contentLoaderInfo` property of a Loader object are not
    available. You can obtain some properties, such as
    `bytesLoaded`, `bytesTotal`, `url`,
    `loaderURL`, and `applicationDomain`. When the
    `loaderInfo` object dispatches the `init` event, you
    can access all properties of the `loaderInfo` object and the
    loaded image or SWF file.

    **Note:** All properties of LoaderInfo objects are read-only.

    The `EventDispatcher.dispatchEvent()` method is not
    applicable to LoaderInfo objects. If you call `dispatchEvent()`
    on a LoaderInfo object, an IllegalOperationError exception is thrown.

    @event complete   Dispatched when data has loaded successfully. In other
                        words, it is dispatched when all the content has been
                        downloaded and the loading has finished. The
                        `complete` event is always dispatched after
                        the `init` event. The `init` event
                        is dispatched when the object is ready to access, though
                        the content may still be downloading.
    @event httpStatus Dispatched when a network request is made over HTTP and
                        an HTTP status code can be detected.
    @event init       Dispatched when the properties and methods of a loaded
                        SWF file are accessible and ready for use. The content,
                        however, can still be downloading. A LoaderInfo object
                        dispatches the `init` event when the following
                        conditions exist:

                        * All properties and methods associated with the
                        loaded object and those associated with the LoaderInfo
                        object are accessible.
                        * The constructors for all child objects have
                        completed.
                        * All ActionScript code in the first frame of the
                        loaded SWF's main timeline has been executed.

                        For example, an `Event.INIT` is dispatched
                        when the first frame of a movie or animation is loaded.
                        The movie is then accessible and can be added to the
                        display list. The complete movie, however, can take
                        longer to download. The `Event.COMPLETE` is
                        only dispatched once the full movie is loaded.

                        The `init` event always precedes the
                        `complete` event.
    @event ioError    Dispatched when an input or output error occurs that
                        causes a load operation to fail.
    @event open       Dispatched when a load operation starts.
    @event progress   Dispatched when data is received as the download
                        operation progresses.
    @event unload     Dispatched by a LoaderInfo object whenever a loaded
                        object is removed by using the `unload()`
                        method of the Loader object, or when a second load is
                        performed by the same Loader object and the original
                        content is removed prior to the load beginning.
**/
let LoaderInfo = /** @class */ (() => {
    class LoaderInfo extends EventDispatcher {
        constructor() {
            super();
            this.__applicationDomain = ApplicationDomain.currentDomain;
            this.__bytesLoaded = 0;
            this.__bytesTotal = 0;
            this.__childAllowsParent = true;
            this.__parameters = {};
        }
        static create(loader) {
            var loaderInfo = new LoaderInfo();
            loaderInfo.__uncaughtErrorEvents = new UncaughtErrorEvents();
            if (loader != null) {
                loaderInfo.__loader = loader;
            }
            else {
                loaderInfo.__url = this.__rootURL;
            }
            return loaderInfo;
        }
        // /** @hidden */ @:dox(hide) public static getLoaderInfoByDefinition (object:Dynamic):LoaderInfo;
        __complete() {
            if (!this.__completed) {
                if (this.__bytesLoaded < this.__bytesTotal) {
                    this.__bytesLoaded = this.__bytesTotal;
                }
                this.__update(this.__bytesLoaded, this.__bytesTotal);
                this.__completed = true;
                this.dispatchEvent(new Event(Event.COMPLETE));
            }
        }
        __update(bytesLoaded, bytesTotal) {
            this.__bytesLoaded = bytesLoaded;
            this.__bytesTotal = bytesTotal;
            this.dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, bytesLoaded, bytesTotal));
        }
        // Get & Set Methods
        /**
            When an external SWF file is loaded, all ActionScript 3.0 definitions
            contained in the loaded class are stored in the
            `applicationDomain` property.
    
            All code in a SWF file is defined to exist in an application domain.
            The current application domain is where your main application runs. The
            system domain contains all application domains, including the current
            domain and all classes used by Flash Player or Adobe AIR.
    
            All application domains, except the system domain, have an associated
            parent domain. The parent domain of your main application's
            `applicationDomain` is the system domain. Loaded classes are
            defined only when their parent doesn't already define them. You cannot
            override a loaded class definition with a newer definition.
    
            For usage examples of application domains, see the "Client System
            Environment" chapter in the _ActionScript 3.0 Developer's Guide_.
    
            @throws SecurityError This security sandbox of the caller is not allowed
                                    to access this ApplicationDomain.
        **/
        get applicationDomain() {
            return this.__applicationDomain;
        }
        /**
            The bytes associated with a LoaderInfo object.
    
            @throws SecurityError If the object accessing this API is prevented from
                                    accessing the loaded object due to security
                                    restrictions. This situation can occur, for
                                    instance, when a Loader object attempts to access
                                    the `contentLoaderInfo.content` property
                                    and it is not granted security permission to access
                                    the loaded content.
    
                                    For more information related to security, see the
                                    Flash Player Developer Center Topic:
                                    [Security](http://www.adobe.com/go/devnet_security_en).
        **/
        get bytes() {
            return this.__bytes;
        }
        /**
            The number of bytes that are loaded for the media. When this number equals
            the value of `bytesTotal`, all of the bytes are loaded.
        **/
        get bytesLoaded() {
            return this.__bytesLoaded;
        }
        /**
            The number of compressed bytes in the entire media file.
    
            Before the first `progress` event is dispatched by this
            LoaderInfo object's corresponding Loader object, `bytesTotal`
            is 0. After the first `progress` event from the Loader object,
            `bytesTotal` reflects the actual number of bytes to be
            downloaded.
        **/
        get bytesTotal() {
            return this.__bytesTotal;
        }
        /**
            Expresses the trust relationship from content(child) to the Loader
            (parent). If the child has allowed the parent access, `true`;
            otherwise, `false`. This property is set to `true`
            if the child object has called the `allowDomain()` method to
            grant permission to the parent domain or if a URL policy is loaded at the
            child domain that grants permission to the parent domain. If child and
            parent are in the same domain, this property is set to `true`.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).
    
            @throws Error Thrown if the file is not downloaded sufficiently to
                            retrieve the requested information.
        **/
        get childAllowsParent() {
            return this.__childAllowsParent;
        }
        // /** @hidden */ @:dox(hide) @:require(flash11_4) public childSandboxBridge:Dynamic;
        /**
            The loaded object associated with this LoaderInfo object.
    
            @throws SecurityError If the object accessing this API is prevented from
                                    accessing the loaded object due to security
                                    restrictions. This situation can occur, for
                                    instance, when a Loader object attempts to access
                                    the `contentLoaderInfo.content` property
                                    and it is not granted security permission to access
                                    the loaded content.
    
                                    For more information related to security, see the
                                    Flash Player Developer Center Topic:
                                    [Security](http://www.adobe.com/go/devnet_security_en).
        **/
        get content() {
            return this.__content;
        }
        /**
            The MIME type of the loaded file. The value is `null` if not
            enough of the file has loaded in order to determine the type. The
            following list gives the possible values:
    
            * `"application/x-shockwave-flash"`
            * `"image/jpeg"`
            * `"image/gif"`
            * `"image/png"`
        **/
        get contentType() {
            return this.__contentType;
        }
        /**
            The nominal frame rate, in frames per second, of the loaded SWF file. This
            number is often an integer, but need not be.
    
            This value may differ from the actual frame rate in use. Flash Player
            or Adobe AIR only uses a single frame rate for all loaded SWF files at any
            one time, and this frame rate is determined by the nominal frame rate of
            the main SWF file. Also, the main frame rate may not be able to be
            achieved, depending on hardware, sound synchronization, and other
            factors.
    
            @throws Error If the file is not downloaded sufficiently to retrieve the
                            requested information.
            @throws Error If the file is not a SWF file.
        **/
        get frameRate() {
            return this.__frameRate;
        }
        /**
            The nominal height of the loaded file. This value might differ from the
            actual height at which the content is displayed, since the loaded content
            or its parent display objects might be scaled.
    
            @throws Error If the file is not downloaded sufficiently to retrieve the
                            requested information.
        **/
        get height() {
            return this.__height;
        }
        // /** @hidden */ @:dox(hide) @:require(flash10_1) public isURLInaccessible (default, null):Bool;
        /**
            The Loader object associated with this LoaderInfo object. If this
            LoaderInfo object is the `loaderInfo` property of the instance
            of the main class of the SWF file, no Loader object is associated.
    
            @throws SecurityError If the object accessing this API is prevented from
                                    accessing the Loader object because of security
                                    restrictions. This can occur, for instance, when a
                                    loaded SWF file attempts to access its
                                    `loaderInfo.loader` property and it is
                                    not granted security permission to access the
                                    loading SWF file.
    
                                    For more information related to security, see the
                                    Flash Player Developer Center Topic:
                                    [Security](http://www.adobe.com/go/devnet_security_en).
        **/
        get loader() {
            return this.__loader;
        }
        /**
            The URL of the SWF file that initiated the loading of the media described
            by this LoaderInfo object. For the instance of the main class of the SWF
            file, this URL is the same as the SWF file's own URL.
        **/
        get loaderURL() {
            return this.__loaderURL;
        }
        /**
            An object that contains name-value pairs that represent the parameters
            provided to the loaded SWF file.
    
            You can use a `for-in` loop to extract all the names and
            values from the `parameters` object.
    
            The two sources of parameters are: the query string in the URL of the
            main SWF file, and the value of the `FlashVars` HTML parameter
            (this affects only the main SWF file).
    
            The `parameters` property replaces the ActionScript 1.0 and
            2.0 technique of providing SWF file parameters as properties of the main
            timeline.
    
            The value of the `parameters` property is null for Loader
            objects that contain SWF files that use ActionScript 1.0 or 2.0. It is
            only non-null for Loader objects that contain SWF files that use
            ActionScript 3.0.
        **/
        get parameters() {
            return this.__parameters;
        }
        /**
            Expresses the trust relationship from Loader(parent) to the content
            (child). If the parent has allowed the child access, `true`;
            otherwise, `false`. This property is set to `true`
            if the parent object called the `allowDomain()` method to grant
            permission to the child domain or if a URL policy file is loaded at the
            parent domain granting permission to the child domain. If child and parent
            are in the same domain, this property is set to `true`.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).
    
            @throws Error Thrown if the file is not downloaded sufficiently to
                            retrieve the requested information.
        **/
        get parentAllowsChild() {
            return this.__parentAllowsChild;
        }
        // /** @hidden */ @:dox(hide) @:require(flash11_4) public parentSandboxBridge:Dynamic;
        /**
            Expresses the domain relationship between the loader and the content:
            `true` if they have the same origin domain; `false`
            otherwise.
    
            @throws Error Thrown if the file is not downloaded sufficiently to
                            retrieve the requested information.
        **/
        get sameDomain() {
            return this.__sameDomain;
        }
        /**
            An EventDispatcher instance that can be used to exchange events across
            security boundaries. Even when the Loader object and the loaded content
            originate from security domains that do not trust one another, both can
            access `sharedEvents` and send and receive events via this
            object.
        **/
        get sharedEvents() {
            return this.__sharedEvents;
        }
        // /** @hidden */ @:dox(hide) public swfVersion (default, null):UInt;
        /**
            An object that dispatches an `uncaughtError` event when an
            unhandled error occurs in code in this LoaderInfo object's SWF file. An
            uncaught error happens when an error is thrown outside of any
            `try..catch` blocks or when an ErrorEvent object is dispatched
            with no registered listeners.
    
            This property is created when the SWF associated with this LoaderInfo
            has finished loading. Until then the `uncaughtErrorEvents`
            property is `null`. In an ActionScript-only project, you can
            access this property during or after the execution of the constructor
            function of the main class of the SWF file. For a Flex project, the
            `uncaughtErrorEvents` property is available after the
            `applicationComplete` event is dispatched.
        **/
        get uncaughtErrorEvents() {
            return this.__uncaughtErrorEvents;
        }
        /**
            The URL of the media being loaded.
    
            Before the first `progress` event is dispatched by this
            LoaderInfo object's corresponding Loader object, the value of the
            `url` property might reflect only the initial URL specified in
            the call to the `load()` method of the Loader object. After the
            first `progress` event, the `url` property reflects
            the media's final URL, after any redirects and relative URLs are
            resolved.
    
            In some cases, the value of the `url` property is truncated;
            see the `isURLInaccessible` property for details.
        **/
        get url() {
            return this.__url;
        }
        /**
            The nominal width of the loaded content. This value might differ from the
            actual width at which the content is displayed, since the loaded content
            or its parent display objects might be scaled.
    
            @throws Error If the file is not downloaded sufficiently to retrieve the
                            requested information.
        **/
        get width() {
            return this.__width;
        }
    }
    LoaderInfo.__rootURL = (document != null ? document.URL : "");
    return LoaderInfo;
})();

/**
    An object dispatches an ErrorEvent object when an error causes an
    asynchronous operation to fail.

    The ErrorEvent class defines only one type of `error` event:
    `ErrorEvent.ERROR`. The ErrorEvent class also serves as the base
    class for several other error event classes, including the AsyncErrorEvent,
    IOErrorEvent, SecurityErrorEvent, SQLErrorEvent, and UncaughtErrorEvent
    classes.

    You can check for `error` events that do not have any
    listeners by registering a listener for the `uncaughtError`
    (UncaughtErrorEvent.UNCAUGHT_ERROR) event.

    An uncaught error also causes an error dialog box displaying the error
    event to appear when content is running in the debugger version of Flash
    Player or the AIR Debug Launcher(ADL) application.
**/
let ErrorEvent = /** @class */ (() => {
    class ErrorEvent extends TextEvent {
        /**
            Creates an Event object that contains information about error events.
            Event objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access this
                              information through the inherited `type`
                              property. There is only one type of error event:
                              `ErrorEvent.ERROR`.
            @param bubbles    Determines whether the Event object bubbles. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through the
                              inherited `cancelable` property.
            @param text       Text to be displayed as an error message. Event
                              listeners can access this information through the
                              `text` property.
            @param id         A reference number to associate with the specific error
                             (supported in Adobe AIR only).
        **/
        constructor(type, bubbles = false, cancelable = false, text = "", id = 0) {
            super(type, bubbles, cancelable, text);
            this.__errorID = id;
        }
        clone() {
            var event = new ErrorEvent(this.__type, this.__bubbles, this.__cancelable, this.text, this.__errorID);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("ErrorEvent", "type", "bubbles", "cancelable", "text", "errorID");
        }
        __init() {
            super.__init();
            this.__errorID = 0;
        }
        // Get & Set Methods
        /**
            Contains the reference number associated with the specific error. For a
            custom ErrorEvent object, this number is the value from the
            `id` parameter supplied in the constructor.
        **/
        get errorID() {
            return this.__errorID;
        }
    }
    /**
        Defines the value of the `type` property of an `error` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object experiencing a network operation failure. |
        | `text` | Text to be displayed as an error message. |
    **/
    ErrorEvent.ERROR = "error";
    ErrorEvent.__pool = new ObjectPool(() => new ErrorEvent(null), (event) => event.__init());
    return ErrorEvent;
})();

/**
    An IOErrorEvent object is dispatched when an error causes input or output
    operations to fail.

    You can check for error events that do not have any listeners by using
    the debugger version of Flash Player or the AIR Debug Launcher(ADL). The
    string defined by the `text` parameter of the IOErrorEvent
    constructor is displayed.
**/
let IOErrorEvent = /** @class */ (() => {
    class IOErrorEvent extends ErrorEvent {
        /**
            Creates an Event object that contains specific information about
            `ioError` events. Event objects are passed as parameters to
            Event listeners.
    
            @param type       The type of the event. Event listeners can access this
                              information through the inherited `type`
                              property. There is only one type of input/output error
                              event: `IOErrorEvent.IO_ERROR`.
            @param bubbles    Determines whether the Event object participates in the
                              bubbling stage of the event flow. Event listeners can
                              access this information through the inherited
                              `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through the
                              inherited `cancelable` property.
            @param text       Text to be displayed as an error message. Event
                              listeners can access this information through the
                              `text` property.
            @param id         A reference number to associate with the specific error
                             (supported in Adobe AIR only).
        **/
        constructor(type, bubbles = true, cancelable = false, text = "", id = 0) {
            super(type, bubbles, cancelable, text, id);
        }
        clone() {
            var event = new IOErrorEvent(this.__type, this.__bubbles, this.__cancelable, this.text, this.__errorID);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("IOErrorEvent", "type", "bubbles", "cancelable", "text", "errorID");
        }
    }
    // /** @hidden */ @:dox(hide) public static DISK_ERROR:String;
    /**
        Defines the value of the `type` property of an `ioError` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `errorID` | A reference number associated with the specific error (AIR only). |
        | `target` | The network object experiencing the input/output error. |
        | `text` | Text to be displayed as an error message. |
    **/
    IOErrorEvent.IO_ERROR = "ioError";
    // /** @hidden */ @:dox(hide) public static NETWORK_ERROR:String;
    // /** @hidden */ @:dox(hide) public static VERIFY_ERROR:String;
    IOErrorEvent.__pool = new ObjectPool(() => new IOErrorEvent(null), (event) => event.__init());
    return IOErrorEvent;
})();

/**
    The AssetCache class is the default cache implementation used
    by openfl.utils.Assets, objects will be cached for the lifetime
    of the application unless removed explicitly, or using Assets
    `unloadLibrary`
**/
class AssetCache {
    /**
        Creates a new AssetCache instance.
    **/
    constructor() {
        this.__enabled = true;
        this.bitmapData = new Map();
        this.font = new Map();
        this.sound = new Map();
    }
    /**
        Clears all cached assets, or all assets with an ID that
        matches an optional prefix.

        For example:

        ```haxe
        Assets.setBitmapData("image1", image1);
        Assets.setBitmapData("assets/image2", image2);

        Assets.clear("assets"); // will clear image2
        Assets.clear("image"); // will clear image1
        ```

        @param	prefix	A ID prefix
    **/
    clear(prefix = null) {
        if (prefix == null) {
            this.bitmapData = new Map();
            this.font = new Map();
            this.sound = new Map();
        }
        else {
            var keys = this.bitmapData.keys();
            for (let key of keys) {
                if (key.startsWith(prefix)) {
                    this.removeBitmapData(key);
                }
            }
            var keys = this.font.keys();
            for (let key of keys) {
                if (key.startsWith(prefix)) {
                    this.removeFont(key);
                }
            }
            var keys = this.sound.keys();
            for (let key of keys) {
                if (key.startsWith(prefix)) {
                    this.removeSound(key);
                }
            }
        }
    }
    /**
        Retrieves a cached BitmapData.

        @param	id	The ID of the cached BitmapData
        @return	The cached BitmapData instance
    **/
    getBitmapData(id) {
        return this.bitmapData.get(id);
    }
    /**
        Retrieves a cached Font.

        @param	id	The ID of the cached Font
        @return	The cached Font instance
    **/
    getFont(id) {
        return this.font.get(id);
    }
    /**
        Retrieves a cached Sound.

        @param	id	The ID of the cached Sound
        @return	The cached Sound instance
    **/
    getSound(id) {
        return this.sound.get(id);
    }
    /**
        Checks whether a BitmapData asset is cached.

        @param	id	The ID of a BitmapData asset
        @return	Whether the object has been cached
    **/
    hasBitmapData(id) {
        return this.bitmapData.has(id);
    }
    /**
        Checks whether a Font asset is cached.

        @param	id	The ID of a Font asset
        @return	Whether the object has been cached
    **/
    hasFont(id) {
        return this.font.has(id);
    }
    /**
        Checks whether a Sound asset is cached.

        @param	id	The ID of a Sound asset
        @return	Whether the object has been cached
    **/
    hasSound(id) {
        return this.sound.delete(id);
    }
    /**
        Removes a BitmapData from the cache.

        @param	id	The ID of a BitmapData asset
        @return	`true` if the asset was removed, `false` if it was not in the cache
    **/
    removeBitmapData(id) {
        return this.bitmapData.delete(id);
    }
    /**
        Removes a Font from the cache.

        @param	id	The ID of a Font asset
        @return	`true` if the asset was removed, `false` if it was not in the cache
    **/
    removeFont(id) {
        return this.font.delete(id);
    }
    /**
        Removes a Sound from the cache.

        @param	id	The ID of a Sound asset
        @return	`true` if the asset was removed, `false` if it was not in the cache
    **/
    removeSound(id) {
        return this.sound.delete(id);
    }
    /**
        Adds or replaces a BitmapData asset in the cache.

        @param	id	The ID of a BitmapData asset
        @param	bitmapData	The matching BitmapData instance
    **/
    setBitmapData(id, bitmapData) {
        this.bitmapData.set(id, bitmapData);
    }
    /**
        Adds or replaces a Font asset in the cache.

        @param	id	The ID of a Font asset
        @param	bitmapData	The matching Font instance
    **/
    setFont(id, font) {
        this.font.set(id, font);
    }
    /**
        Adds or replaces a Sound asset in the cache.

        @param	id	The ID of a Sound asset
        @param	bitmapData	The matching Sound instance
    **/
    setSound(id, sound) {
        this.sound.set(id, sound);
    }
    // Get & Set Methods
    /**
        Whether caching is currently enabled.
    **/
    get enabled() {
        return this.__enabled;
    }
    set enabled(value) {
        this.__enabled = value;
    }
}

/**
    The Assets class provides a cross-platform interface to access
    embedded images, fonts, sounds and other resource files.

    The contents are populated automatically when an application
    is compiled using the OpenFL command-line tools, based on the
    contents of the *.xml project file.

    For most platforms, the assets are included in the same directory
    or namespace as the application, and the paths are handled
    automatically. For web content, the assets are preloaded before
    the start of the rest of the application. You can customize the
    preloader by extending the `NMEPreloader` class,
    and specifying a custom preloader using <window preloader="" />
    in the project file.
**/
let Assets = /** @class */ (() => {
    class Assets {
        static addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false) {
            Assets.dispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);
        }
        static dispatchEvent(event) {
            return Assets.dispatcher.dispatchEvent(event);
        }
        /**
            Returns whether a specific asset exists
            @param	id 		The ID or asset path for the asset
            @param	type	The asset type to match, or null to match any type
            @return		Whether the requested asset ID and type exists
        **/
        static exists(id, type = null) {
            return false;
        }
        /**
            Gets an instance of an embedded bitmap
            @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.png"));
            @param	id		The ID or asset path for the bitmap
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		A new BitmapData object
        **/
        static getBitmapData(id, useCache = true) {
            return null;
        }
        /**
            Gets an instance of an embedded binary asset
            @usage		var bytes = Assets.getBytes ("file.zip");
            @param	id		The ID or asset path for the asset
            @return		A new ByteArray object
        **/
        static getBytes(id) {
            return null;
        }
        /**
            Gets an instance of an embedded font
            @usage		var fontName = Assets.getFont ("font.ttf").fontName;
            @param	id		The ID or asset path for the font
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		A new Font object
        **/
        static getFont(id, useCache = true) {
            return new Font();
        }
        static getLibrary(name) {
            return null;
        }
        /**
            Gets an instance of an included MovieClip
            @usage		var movieClip = Assets.getMovieClip ("library:BouncingBall");
            @param	id		The ID for the MovieClip
            @return		A new MovieClip object
        **/
        static getMovieClip(id) {
            return null;
        }
        static getMusic(id, useCache = true) {
            // TODO: Streaming sound
            return this.getSound(id, useCache);
        }
        /**
            Gets the file path (if available) for an asset
            @usage		var path = Assets.getPath ("file.txt");
            @param	id		The ID or asset path for the asset
            @return		The path to the asset, or null if it does not exist
        **/
        static getPath(id) {
            return null;
        }
        /**
            Gets an instance of an embedded sound
            @usage		var sound = Assets.getSound ("sound.wav");
            @param	id		The ID or asset path for the sound
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		A new Sound object
        **/
        static getSound(id, useCache = true) {
            return null;
        }
        /**
            Gets an instance of an embedded text asset
            @usage		var text = Assets.getText ("text.txt");
            @param	id		The ID or asset path for the asset
            @return		A new String object
        **/
        static getText(id) {
            return null;
        }
        static hasEventListener(type) {
            return Assets.dispatcher.hasEventListener(type);
        }
        static hasLibrary(name) {
            return false;
        }
        /**
            Returns whether an asset is "local", and therefore can be loaded synchronously
            @param	id 		The ID or asset path for the asset
            @param	type	The asset type to match, or null to match any type
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return	Whether the asset is local
        **/
        static isLocal(id, type = null, useCache = true) {
            return false;
        }
        static isValidBitmapData(bitmapData) {
            return true;
        }
        /** @hidden */
        static isValidSound(sound) {
            return true;
        }
        /**
            Returns a list of all embedded assets (by type)
            @param	type	The asset type to match, or null to match any type
            @return	An array of asset ID values
        **/
        static list(type = null) {
            return [];
        }
        /**
            Loads an included bitmap asset asynchronously
            @usage	Assets.loadBitmapData ("image.png").onComplete (handleImage);
            @param	id 		The ID or asset path for the asset
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		Returns a Future<BitmapData>
        **/
        static loadBitmapData(id, useCache = true) {
            if (useCache == null)
                useCache = true;
            return Future.withValue(this.getBitmapData(id, useCache));
        }
        /**
            Loads an included byte asset asynchronously
            @usage	Assets.loadBytes ("file.zip").onComplete (handleBytes);
            @param	id 		The ID or asset path for the asset
            @return		Returns a Future<ByteArray>
        **/
        static loadBytes(id) {
            return Future.withValue(this.getBytes(id));
        }
        /**
            Loads an included font asset asynchronously
            @usage	Assets.loadFont ("font.ttf").onComplete (handleFont);
            @param	id 		The ID or asset path for the asset
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		Returns a Future<Font>
        **/
        static loadFont(id, useCache = true) {
            if (useCache == null)
                useCache = true;
            return Future.withValue(this.getFont(id, useCache));
        }
        /**
            Load an included AssetLibrary
            @param	name		The name of the AssetLibrary to load
            @return		Returns a Future<AssetLibrary>
        **/
        static loadLibrary(name) {
            return Future.withError("Cannot load library");
        }
        /**
            Loads an included music asset asynchronously
            @usage	Assets.loadMusic ("music.ogg").onComplete (handleMusic);
            @param	id 		The ID or asset path for the asset
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		Returns a Future<Sound>
        **/
        static loadMusic(id, useCache = true) {
            if (useCache == null)
                useCache = true;
            return Future.withValue(this.getMusic(id, useCache));
        }
        /**
            Loads an included MovieClip asset asynchronously
            @usage	Assets.loadMovieClip ("library:BouncingBall").onComplete (handleMovieClip);
            @param	id 		The ID for the asset
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		Returns a Future<MovieClip>
        **/
        static loadMovieClip(id) {
            return Future.withValue(this.getMovieClip(id));
        }
        /**
            Loads an included sound asset asynchronously
            @usage	Assets.loadSound ("sound.wav").onComplete (handleSound);
            @param	id 		The ID or asset path for the asset
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		Returns a Future<Sound>
        **/
        static loadSound(id, useCache = true) {
            if (useCache == null)
                useCache = true;
            return Future.withValue(this.getSound(id, useCache));
        }
        /**
            Loads an included text asset asynchronously
            @usage	Assets.loadText ("text.txt").onComplete (handleString);
            @param	id 		The ID or asset path for the asset
            @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
            @return		Returns a Future<string>
        **/
        static loadText(id) {
            return Future.withValue(this.getText(id));
        }
        /**
            Registers a new AssetLibrary with the Assets class
            @param	name		The name (prefix) to use for the library
            @param	library		An AssetLibrary instance to register
        **/
        static registerLibrary(name, library) {
        }
        static removeEventListener(type, listener, capture = false) {
            Assets.dispatcher.removeEventListener(type, listener, capture);
        }
        static resolveClass(name) {
            // return Type.resolveClass(name);
            return null;
        }
        static resolveEnum(name) {
            // var value = Type.resolveEnum(name);
            // return value;
            return null;
        }
        static unloadLibrary(name) {
            if (name == null || name == "") {
                name = "default";
                // TODO: Do we cache with the default prefix?
                Assets.cache.clear(":");
            }
            var library = this.getLibrary(name);
            if (library != null) {
                Assets.cache.clear(name + ":");
            }
        }
        // Event Handlers
        static LimeAssets_onChange() {
            this.dispatchEvent(new Event(Event.CHANGE));
        }
    }
    Assets.cache = new AssetCache();
    Assets.dispatcher = new EventDispatcher();
    return Assets;
})();

/**
    The Loader class is used to load SWF files or image (JPG, PNG, or GIF)
    files. Use the `load()` method to initiate loading. The loaded
    display object is added as a child of the Loader object.

    Use the URLLoader class to load text or binary data.

    The Loader class overrides the following methods that it inherits,
    because a Loader object can only have one child display object - the
    display object that it loads. Calling the following methods throws an
    exception: `addChild()`, `addChildAt()`,
    `removeChild()`, `removeChildAt()`, and
    `setChildIndex()`. To remove a loaded display object, you must
    remove the _Loader_ object from its parent DisplayObjectContainer
    child array.

    **Note:** The ActionScript 2.0 MovieClipLoader and LoadVars classes
    are not used in ActionScript 3.0. The Loader and URLLoader classes replace
    them.

    When you use the Loader class, consider the Flash Player and Adobe AIR
    security model:

    * You can load content from any accessible source.
    * Loading is not allowed if the calling SWF file is in a network
    sandbox and the file to be loaded is local.
    * If the loaded content is a SWF file written with ActionScript 3.0, it
    cannot be cross-scripted by a SWF file in another security sandbox unless
    that cross-scripting arrangement was approved through a call to the
    `System.allowDomain()` or the
    `System.allowInsecureDomain()` method in the loaded content
    file.
    * If the loaded content is an AVM1 SWF file(written using ActionScript
    1.0 or 2.0), it cannot be cross-scripted by an AVM2 SWF file(written using
    ActionScript 3.0). However, you can communicate between the two SWF files
    by using the LocalConnection class.
    * If the loaded content is an image, its data cannot be accessed by a
    SWF file outside of the security sandbox, unless the domain of that SWF
    file was included in a URL policy file at the origin domain of the
    image.
    * Movie clips in the local-with-file-system sandbox cannot script movie
    clips in the local-with-networking sandbox, and the reverse is also
    prevented.
    * You cannot connect to commonly reserved ports. For a complete list of
    blocked ports, see "Restricting Networking APIs" in the _ActionScript 3.0
    Developer's Guide_.

    However, in AIR, content in the `application` security
    sandbox(content installed with the AIR application) are not restricted by
    these security limitations.

    For more information related to security, see the Flash Player Developer
    Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).

    When loading a SWF file from an untrusted source(such as a domain other
    than that of the Loader object's root SWF file), you may want to define a
    mask for the Loader object, to prevent the loaded content(which is a child
    of the Loader object) from drawing to portions of the Stage outside of that
    mask, as shown in the following code:
**/
class Loader extends DisplayObjectContainer {
    /**
        Creates a Loader object that you can use to load files, such as SWF, JPEG,
        GIF, or PNG files. Call the `load()` method to load the asset
        as a child of the Loader instance. You can then add the Loader object to
        the display list(for instance, by using the `addChild()`
        method of a DisplayObjectContainer instance). The asset appears on the
        Stage as it loads.

        You can also use a Loader instance "offlist," that is without adding it
        to a display object container on the display list. In this mode, the
        Loader instance might be used to load a SWF file that contains additional
        modules of an application.

        To detect when the SWF file is finished loading, you can use the events
        of the LoaderInfo object associated with the
        `contentLoaderInfo` property of the Loader object. At that
        point, the code in the module SWF file can be executed to initialize and
        start the module. In the offlist mode, a Loader instance might also be
        used to load a SWF file that contains components or media assets. Again,
        you can use the LoaderInfo object event notifications to detect when the
        components are finished loading. At that point, the application can start
        using the components and media assets in the library of the SWF file by
        instantiating the ActionScript 3.0 classes that represent those components
        and assets.

        To determine the status of a Loader object, monitor the following
        events that the LoaderInfo object associated with the
        `contentLoaderInfo` property of the Loader object:

        * The `open` event is dispatched when loading begins.
        * The `ioError` or `securityError` event is
        dispatched if the file cannot be loaded or if an error occured during the
        load process.
        * The `progress` event fires continuously while the file is
        being loaded.
        * The `complete` event is dispatched when a file completes
        downloading, but before the loaded movie clip's methods and properties are
        available.
        * The `init` event is dispatched after the properties and
        methods of the loaded SWF file are accessible, so you can begin
        manipulating the loaded SWF file. This event is dispatched before the
        `complete` handler. In streaming SWF files, the
        `init` event can occur significantly earlier than the
        `complete` event. For most purposes, use the `init`
        handler.

    **/
    constructor() {
        super();
        this.__contentLoaderInfo = LoaderInfo.create(this);
        this.__uncaughtErrorEvents = this.__contentLoaderInfo.uncaughtErrorEvents;
        this.__unloaded = true;
    }
    addChild(child) {
        throw new Error$1("Error #2069: The Loader class does not implement this method.", 2069);
    }
    addChildAt(child, index) {
        throw new Error$1("Error #2069: The Loader class does not implement this method.", 2069);
    }
    /**
        Cancels a `load()` method operation that is currently in
        progress for the Loader instance.

    **/
    close() {
        // openfl._internal.Lib.notImplemented();
    }
    /**
        Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an
        object that is a child of this Loader object. If you load an animated GIF
        file, only the first frame is displayed. As the Loader object can contain
        only a single child, issuing a subsequent `load()` request
        terminates the previous request, if still pending, and commences a new
        load.

        **Note**: In AIR 1.5 and Flash Player 10, the maximum size for a
        loaded image is 8,191 pixels in width or height, and the total number of
        pixels cannot exceed 16,777,215 pixels.(So, if an loaded image is 8,191
        pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and
        earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height
        and 2,880 pixels in width.

        A SWF file or image loaded into a Loader object inherits the position,
        rotation, and scale properties of the parent display objects of the Loader
        object.

        Use the `unload()` method to remove movies or images loaded
        with this method, or to cancel a load operation that is in progress.

        You can prevent a SWF file from using this method by setting the
        `allowNetworking` parameter of the the `object` and
        `embed` tags in the HTML page that contains the SWF
        content.

        When you use this method, consider the Flash Player security model,
        which is described in the Loader class description.

        In Flash Player 10 and later, if you use a multipart Content-Type(for
        example "multipart/form-data") that contains an upload(indicated by a
        "filename" parameter in a "content-disposition" header within the POST
        body), the POST operation is subject to the security rules applied to
        uploads:

        * The POST operation must be performed in response to a user-initiated
        action, such as a mouse click or key press.
        * If the POST operation is cross-domain(the POST target is not on the
        same server as the SWF file that is sending the POST request), the target
        server must provide a URL policy file that permits cross-domain
        access.

        Also, for any multipart Content-Type, the syntax must be valid
        (according to the RFC2046 standard). If the syntax appears to be invalid,
        the POST operation is subject to the security rules applied to
        uploads.

        For more information related to security, see the Flash Player
        Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).

        @param request The absolute or relative URL of the SWF, JPEG, GIF, or PNG
                       file to be loaded. A relative path must be relative to the
                       main SWF file. Absolute URLs must include the protocol
                       reference, such as http:// or file:///. Filenames cannot
                       include disk drive specifications.
        @param context A LoaderContext object, which has properties that define
                       the following:

                        * Whether or not to check for the existence of a policy
                       file upon loading the object
                        * The ApplicationDomain for the loaded object
                        * The SecurityDomain for the loaded object
                        * The ImageDecodingPolicy for the loaded image
                       object

                       If the `context` parameter is not specified
                       or refers to a null object, the loaded content remains in
                       its own security domain.

                       For complete details, see the description of the
                       properties in the [LoaderContext](../system/LoaderContext.html)
                       class.
        @throws IOError               The `digest` property of the
                                      `request` object is not
                                      `null`. You should only set the
                                      `digest` property of a URLRequest
                                      object when calling the
                                      `URLLoader.load()` method when
                                      loading a SWZ file(an Adobe platform
                                      component).
        @throws IllegalOperationError If the `requestedContentParent`
                                      property of the `context`
                                      parameter is a `Loader`.
        @throws IllegalOperationError If the `LoaderContext.parameters`
                                      parameter is set to non-null and has some
                                      values which are not Strings.
        @throws SecurityError         The value of
                                      `LoaderContext.securityDomain`
                                      must be either `null` or
                                      `SecurityDomain.currentDomain`.
                                      This reflects the fact that you can only
                                      place the loaded media in its natural
                                      security sandbox or your own(the latter
                                      requires a policy file).
        @throws SecurityError         Local SWF files may not set
                                      LoaderContext.securityDomain to anything
                                      other than `null`. It is not
                                      permitted to import non-local media into a
                                      local sandbox, or to place other local media
                                      in anything other than its natural sandbox.
        @throws SecurityError         You cannot connect to commonly reserved
                                      ports. For a complete list of blocked ports,
                                      see "Restricting Networking APIs" in the
                                      _ActionScript 3.0 Developer's Guide_.
        @throws SecurityError         If the `applicationDomain` or
                                      `securityDomain` properties of
                                      the `context` parameter are from
                                      a disallowed domain.
        @throws SecurityError         If a local SWF file is attempting to use the
                                      `securityDomain` property of the
                                      `context` parameter.
        @event asyncError    Dispatched by the `contentLoaderInfo`
                             object if the
                             `LoaderContext.requestedContentParent`
                             property has been specified and it is not possible to
                             add the loaded content as a child to the specified
                             DisplayObjectContainer. This could happen if the
                             loaded content is a
                             `openfl.display.AVM1Movie` or if the
                             `addChild()` call to the
                             requestedContentParent throws an error.
        @event complete      Dispatched by the `contentLoaderInfo`
                             object when the file has completed loading. The
                             `complete` event is always dispatched
                             after the `init` event.
        @event httpStatus    Dispatched by the `contentLoaderInfo`
                             object when a network request is made over HTTP and
                             Flash Player can detect the HTTP status code.
        @event init          Dispatched by the `contentLoaderInfo`
                             object when the properties and methods of the loaded
                             SWF file are accessible. The `init` event
                             always precedes the `complete` event.
        @event ioError       Dispatched by the `contentLoaderInfo`
                             object when an input or output error occurs that
                             causes a load operation to fail.
        @event open          Dispatched by the `contentLoaderInfo`
                             object when the loading operation starts.
        @event progress      Dispatched by the `contentLoaderInfo`
                             object as data is received while load operation
                             progresses.
        @event securityError Dispatched by the `contentLoaderInfo`
                             object if a SWF file in the local-with-filesystem
                             sandbox attempts to load content in the
                             local-with-networking sandbox, or vice versa.
        @event securityError Dispatched by the `contentLoaderInfo`
                             object if the
                             `LoaderContext.requestedContentParent`
                             property has been specified and the security sandbox
                             of the
                             `LoaderContext.requestedContentParent`
                             does not have access to the loaded SWF.
        @event unload        Dispatched by the `contentLoaderInfo`
                             object when a loaded object is removed.
    **/
    load(request, context = null) {
        this.unload();
        this.contentLoaderInfo.__loaderURL = Lib$1.current.loaderInfo.url;
        this.contentLoaderInfo.__url = request.url;
        this.__unloaded = false;
        if (request.contentType == null || request.contentType == "") {
            var extension = "";
            this.__path = request.url;
            var queryIndex = this.__path.indexOf("?");
            if (queryIndex > -1) {
                this.__path = this.__path.substring(0, queryIndex);
            }
            while (this.__path.endsWith("/")) {
                this.__path = this.__path.substring(0, this.__path.length - 1);
            }
            if (this.__path.endsWith(".bundle")) {
                this.__path += "/library.json";
                if (queryIndex > -1) {
                    request.url = this.__path + request.url.substring(queryIndex);
                }
                else {
                    request.url = this.__path;
                }
            }
            var extIndex = this.__path.lastIndexOf(".");
            if (extIndex > -1) {
                extension = this.__path.substring(extIndex + 1);
            }
            var contentType = null;
            switch (extension) {
                case "json":
                    contentType = "application/json";
                    break;
                case "swf":
                    contentType = "application/x-shockwave-flash";
                    break;
                case "jpg":
                case "jpeg":
                    contentType = "image/jpeg";
                    break;
                case "png":
                    contentType = "image/png";
                    break;
                case "gif":
                    contentType = "image/gif";
                    break;
                case "js":
                    contentType = "application/javascript";
                    break;
                default:
                    contentType = "application/x-www-form-urlencoded"; /*throw "Unrecognized file " + request.url;*/
            }
            this.contentLoaderInfo.__contentType = contentType;
        }
        else {
            this.contentLoaderInfo.__contentType = request.contentType;
        }
        if (this.contentLoaderInfo.contentType.indexOf("image/") > -1
            && request.method == URLRequestMethod$1.GET
            && (request.requestHeaders == null || request.requestHeaders.length == 0)
            && request.userAgent == null) {
            BitmapData.loadFromFile(request.url)
                .onComplete(this.BitmapData_onLoad)
                .onError(this.BitmapData_onError)
                .onProgress(this.BitmapData_onProgress);
            return;
        }
        var loader = new URLLoader();
        loader.dataFormat = URLLoaderDataFormat$1.BINARY;
        if (this.contentLoaderInfo.contentType.indexOf("/json") > -1
            || this.contentLoaderInfo.contentType.indexOf("/javascript") > -1
            || this.contentLoaderInfo.contentType.indexOf("/ecmascript") > -1) {
            loader.dataFormat = URLLoaderDataFormat$1.TEXT;
        }
        loader.addEventListener(Event.COMPLETE, this.loader_onComplete);
        loader.addEventListener(IOErrorEvent.IO_ERROR, this.loader_onError);
        loader.addEventListener(ProgressEvent.PROGRESS, this.loader_onProgress);
        loader.load(request);
    }
    /**
        Loads from binary data stored in a ByteArray object.

        The `loadBytes()` method is asynchronous. You must wait for
        the "init" event before accessing the properties of a loaded object.

        When you use this method, consider the Flash Player security model,
        which is described in the Loader class description.

        @param bytes   A ByteArray object. The contents of the ByteArray can be
                       any of the file formats supported by the Loader class: SWF,
                       GIF, JPEG, or PNG.
        @param context A LoaderContext object. Only the
                       `applicationDomain` property of the
                       LoaderContext object applies; the
                       `checkPolicyFile` and
                       `securityDomain` properties of the LoaderContext
                       object do not apply.

                       If the `context` parameter is not specified
                       or refers to a null object, the content is loaded into the
                       current security domain -  a process referred to as "import
                       loading" in Flash Player security documentation.
                       Specifically, if the loading SWF file trusts the remote SWF
                       by incorporating the remote SWF into its code, then the
                       loading SWF can import it directly into its own security
                       domain.

                       For more information related to security, see the Flash
                       Player Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).
        @throws ArgumentError         If the `length` property of the
                                      ByteArray object is not greater than 0.
        @throws IllegalOperationError If the `checkPolicyFile` or
                                      `securityDomain` property of the
                                      `context` parameter are non-null.
        @throws IllegalOperationError If the `requestedContentParent`
                                      property of the `context`
                                      parameter is a `Loader`.
        @throws IllegalOperationError If the `LoaderContext.parameters`
                                      parameter is set to non-null and has some
                                      values which are not Strings.
        @throws SecurityError         If the provided
                                      `applicationDomain` property of
                                      the `context` property is from a
                                      disallowed domain.
        @throws SecurityError         You cannot connect to commonly reserved
                                      ports. For a complete list of blocked ports,
                                      see "Restricting Networking APIs" in the
                                      _ActionScript 3.0 Developer's Guide_.
        @event asyncError    Dispatched by the `contentLoaderInfo`
                             object if the
                             `LoaderContext.requestedContentParent`
                             property has been specified and it is not possible to
                             add the loaded content as a child to the specified
                             DisplayObjectContainer. This could happen if the
                             loaded content is a
                             `openfl.display.AVM1Movie` or if the
                             `addChild()` call to the
                             requestedContentParent throws an error.
        @event complete      Dispatched by the `contentLoaderInfo`
                             object when the operation is complete. The
                             `complete` event is always dispatched
                             after the `init` event.
        @event init          Dispatched by the `contentLoaderInfo`
                             object when the properties and methods of the loaded
                             data are accessible. The `init` event
                             always precedes the `complete` event.
        @event ioError       Dispatched by the `contentLoaderInfo`
                             object when the runtime cannot parse the data in the
                             byte array.
        @event open          Dispatched by the `contentLoaderInfo`
                             object when the operation starts.
        @event progress      Dispatched by the `contentLoaderInfo`
                             object as data is transfered in memory.
        @event securityError Dispatched by the `contentLoaderInfo`
                             object if the
                             `LoaderContext.requestedContentParent`
                             property has been specified and the security sandbox
                             of the
                             `LoaderContext.requestedContentParent`
                             does not have access to the loaded SWF.
        @event unload        Dispatched by the `contentLoaderInfo`
                             object when a loaded object is removed.
    **/
    loadBytes(buffer, context = null) {
        BitmapData.loadFromBytes(buffer).onComplete(this.BitmapData_onLoad).onError(this.BitmapData_onError);
    }
    // publicremoveChild(child:DisplayObject):DisplayObject
    // {
    // 	throw new Error("Error #2069: The Loader class does not implement this method.", 2069);
    // 	return null;
    // }
    removeChildAt(index) {
        throw new Error$1("Error #2069: The Loader class does not implement this method.", 2069);
    }
    setChildIndex(child, index) {
        throw new Error$1("Error #2069: The Loader class does not implement this method.", 2069);
    }
    /**
        Removes a child of this Loader object that was loaded by using the
        `load()` method. The `property` of the associated
        LoaderInfo object is reset to `null`. The child is not
        necessarily destroyed because other objects might have references to it;
        however, it is no longer a child of the Loader object.

        As a best practice, before you unload a child SWF file, you should
        explicitly close any streams in the child SWF file's objects, such as
        LocalConnection, NetConnection, NetStream, and Sound objects. Otherwise,
        audio in the child SWF file might continue to play, even though the child
        SWF file was unloaded. To close streams in the child SWF file, add an
        event listener to the child that listens for the `unload`
        event. When the parent calls `Loader.unload()`, the
        `unload` event is dispatched to the child. The following code
        shows how you might do this:

        ```
        function closeAllStreams(evt:Event) {
            myNetStream.close();
            mySound.close();
            myNetConnection.close();
            myLocalConnection.close();
        }
        myMovieClip.loaderInfo.addEventListener(Event.UNLOAD,
        closeAllStreams);
        ```
    **/
    unload() {
        if (!this.__unloaded) {
            if (this.content != null && this.content.parent == this) {
                super.removeChild(this.content);
            }
            if (this.__library != null) {
                Assets.unloadLibrary(this.contentLoaderInfo.url);
                this.__library = null;
            }
            this.__content = null;
            this.contentLoaderInfo.__url = null;
            this.contentLoaderInfo.__contentType = null;
            this.contentLoaderInfo.__content = null;
            this.contentLoaderInfo.__bytesLoaded = 0;
            this.contentLoaderInfo.__bytesTotal = 0;
            this.contentLoaderInfo.__width = 0;
            this.contentLoaderInfo.__height = 0;
            this.__unloaded = true;
            this.contentLoaderInfo.dispatchEvent(new Event(Event.UNLOAD));
        }
    }
    /**
        Attempts to unload child SWF file contents and stops the execution of
        commands from loaded SWF files. This method attempts to unload SWF files
        that were loaded using `Loader.load()` or
        `Loader.loadBytes()` by removing references to EventDispatcher,
        NetConnection, Timer, Sound, or Video objects of the child SWF file. As a
        result, the following occurs for the child SWF file and the child SWF
        file's display list:

        * Sounds are stopped.
        * Stage event listeners are removed.
        * Event listeners for `enterFrame`,
        `frameConstructed`, `exitFrame`,
        `activate` and `deactivate` are removed.
        * Timers are stopped.
        * Camera and Microphone instances are detached
        * Movie clips are stopped.

        @param gc Provides a hint to the garbage collector to run on the child SWF
                  objects(`true`) or not(`false`). If you
                  are unloading many objects asynchronously, setting the
                  `gc` paramter to `false` might improve
                  application performance. However, if the parameter is set to
                  `false`, media and display objects of the child SWF
                  file might persist in memory after running the
                  `unloadAndStop()` command.
    **/
    unloadAndStop(gc = true) {
        if (this.content != null) {
            this.content.__stopAllMovieClips();
        }
        for (let i = 0; i < this.numChildren; i++) {
            this.getChildAt(i).__stopAllMovieClips();
        }
        this.unload();
    }
    __dispatchError(text) {
        var event = new IOErrorEvent(IOErrorEvent.IO_ERROR);
        event.text = text;
        this.contentLoaderInfo.dispatchEvent(event);
    }
    __setContent(content, width, height) {
        this.__content = content;
        this.contentLoaderInfo.__content = content;
        this.contentLoaderInfo.__width = width;
        this.contentLoaderInfo.__height = height;
        if (content != null) {
            super.addChild(content);
        }
    }
    // Event Handlers
    BitmapData_onError(error) {
        // TODO: Dispatch HTTPStatusEvent
        this.__dispatchError(String(error));
    }
    BitmapData_onLoad(bitmapData) {
        // TODO: Dispatch HTTPStatusEvent
        if (bitmapData == null) {
            this.__dispatchError("Unknown error");
            return;
        }
        this.__setContent(new Bitmap(bitmapData), bitmapData.width, bitmapData.height);
        this.contentLoaderInfo.dispatchEvent(new Event(Event.COMPLETE));
    }
    BitmapData_onProgress(bytesLoaded, bytesTotal) {
        var event = new ProgressEvent(ProgressEvent.PROGRESS);
        event.bytesLoaded = bytesLoaded;
        event.bytesTotal = bytesTotal;
        this.contentLoaderInfo.dispatchEvent(event);
    }
    loader_onComplete(event) {
        // TODO: Dispatch HTTPStatusEvent
        var loader = event.target;
        if (this.contentLoaderInfo.contentType != null
            && (this.contentLoaderInfo.contentType.indexOf("/javascript") > -1 || this.contentLoaderInfo.contentType.indexOf("/ecmascript") > -1)) {
            this.__setContent(new Sprite(), 0, 0);
            // script:ScriptElement = cast Browser.document.createElement ("script");
            // script.innerHTML = loader.data;
            // Browser.document.head.appendChild (script);
            eval("(function () {" + loader.data + "})()");
            this.contentLoaderInfo.dispatchEvent(new Event(Event.COMPLETE));
        }
        else {
            this.contentLoaderInfo.__bytes = loader.data;
            BitmapData.loadFromBytes(loader.data).onComplete(this.BitmapData_onLoad).onError(this.BitmapData_onError);
        }
    }
    loader_onError(event) {
        // TODO: Dispatch HTTPStatusEvent
        event.__target = this.contentLoaderInfo;
        this.contentLoaderInfo.dispatchEvent(event);
    }
    loader_onProgress(event) {
        event.__target = this.contentLoaderInfo;
        this.contentLoaderInfo.dispatchEvent(event);
    }
    // Get & Set Methods
    /**
        Contains the root display object of the SWF file or image(JPG, PNG, or
        GIF) file that was loaded by using the `load()` or
        `loadBytes()` methods.

        @throws SecurityError The loaded SWF file or image file belongs to a
                              security sandbox to which you do not have access.
                              For a loaded SWF file, you can avoid this situation
                              by having the file call the
                              `Security.allowDomain()` method or by
                              having the loading file specify a
                              `loaderContext` parameter with its
                              `securityDomain` property set to
                              `SecurityDomain.currentDomain` when you
                              call the `load()` or
                              `loadBytes()` method.
    **/
    get content() {
        return this.__content;
    }
    /**
        Returns a LoaderInfo object corresponding to the object being loaded.
        LoaderInfo objects are shared between the Loader object and the loaded
        content object. The LoaderInfo object supplies loading progress
        information and statistics about the loaded file.

        Events related to the load are dispatched by the LoaderInfo object
        referenced by the `contentLoaderInfo` property of the Loader
        object. The `contentLoaderInfo` property is set to a valid
        LoaderInfo object, even before the content is loaded, so that you can add
        event listeners to the object prior to the load.

        To detect uncaught errors that happen in a loaded SWF, use the
        `Loader.uncaughtErrorEvents` property, not the
        `Loader.contentLoaderInfo.uncaughtErrorEvents` property.
    **/
    get contentLoaderInfo() {
        return this.__contentLoaderInfo;
    }
    /**
        An object that dispatches an uncaughtError event when an unhandled error occurs in
        the SWF that's loaded by this Loader object. An uncaught error happens when an
        error is thrown outside of any `try..catch` blocks or when an ErrorEvent object is
        dispatched with no registered listeners.

        Note that a Loader object's `uncaughtErrorEvents` property dispatches events that
        bubble through it, not events that it dispatches directly. It never dispatches an
        `uncaughtErrorEvent` in the target phase. It only dispatches the event in the
        capture and bubbling phases. To detect an uncaught error in the current SWF (the
        SWF in which the Loader object is defined) use the `LoaderInfo.uncaughtErrorEvents`
        property instead.

        If the content loaded by the Loader object is an AVM1 (ActionScript 2) SWF file,
        uncaught errors in the AVM1 SWF file do not result in an `uncaughtError` event.
    **/
    get uncaughtErrorEvents() {
        return this.__uncaughtErrorEvents;
    }
}

var openfl$l;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The PNGEncoderOptions class defines a compression algorithm for the
            `openfl.display.BitmapData.encode()` method.
        **/
        class PNGEncoderOptions {
            /**
                Creates a PNGEncoderOptions object, optionally specifying compression settings.
    
                @param	fastCompression	The initial compression mode.
            **/
            constructor(fastCompression = false) {
                this.fastCompression = fastCompression;
            }
        }
        display.PNGEncoderOptions = PNGEncoderOptions;
    })(display = openfl.display || (openfl.display = {}));
})(openfl$l || (openfl$l = {}));
var PNGEncoderOptions = openfl$l.display.PNGEncoderOptions;

var openfl$m;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for sampler mipmap filter mode
        **/
        let Context3DMipFilter;
        (function (Context3DMipFilter) {
            /**
                Select the two closest MIP levels and linearly blend between them (the highest
                quality mode, but has some performance cost).
            **/
            Context3DMipFilter["MIPLINEAR"] = "miplinear";
            /**
                Use the nearest neighbor metric to select MIP levels (the fastest rendering method).
            **/
            Context3DMipFilter["MIPNEAREST"] = "mipnearest";
            /**
                Always use the top level texture (has a performance penalty when downscaling).
            **/
            Context3DMipFilter["MIPNONE"] = "mipnone";
        })(Context3DMipFilter = display3D.Context3DMipFilter || (display3D.Context3DMipFilter = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$m || (openfl$m = {}));
var Context3DMipFilter = openfl$m.display3D.Context3DMipFilter;

/**
    // TODO: Document GLSL Shaders
    A ShaderInput instance represents a single input image for a shader
    kernel. A kernel can be defined to accept zero, one, or more source images
    that are used in the kernel execution. A ShaderInput instance provides a
    mechanism for specifying the input image that is used when the shader
    executes. To specify a value for the input, create a BitmapData,
    ByteArray, or Vector.<Number> instance containing the image data and
    assign it to the `input` property.
    The ShaderInput instance representing a Shader instance's input image is
    accessed as a property of the Shader instance's `data` property. The
    ShaderInput property has the same name as the input's name in the shader
    code. For example, if a shader defines an input named `src`, the
    ShaderInput instance representing the `src` input is available as the
    `src` property, as this example shows:

    ```haxe
    myShader.data.src.input = new BitmapData(50, 50, true, 0xFF990000);
    ```

    For some uses of a Shader instance, you do not need to specify an input
    image, because it is automatically specified by the operation. You only
    need to specify an input when a Shader is used for the following:

    * Shader fill
    * ShaderFilter, only for the second or additional inputs if the shader is
    defined to use more than one input. (The object to which the filter is
    applied is automatically used as the first input.)
    * Shader blend mode, only for the third or additional inputs if the shader
    is defined to use more than two inputs. (The objects being blended are
    automatically used as the first and second inputs.)
    * ShaderJob background execution

    If the shader is being executed using a ShaderJob instance to process a
    ByteArray containing a linear array of data, set the ShaderInput
    instance's `height` to 1 and `width` to the number of 32-bit floating
    point values in the ByteArray. In that case, the input in the shader must
    be defined with the `image1` data type.

    Generally, developer code does not create a ShaderInput instance directly.
    A ShaderInput instance is created for each of a shader's inputs when the
    Shader instance is created.
**/
class ShaderInput {
    /**
        Creates a ShaderInput instance. Developer code does not call the
        ShaderInput constructor directly. A ShaderInput instance is created
        for each of a shader's inputs when the Shader instance is created.
    **/
    constructor() {
        this.__channels = 0;
        this.filter = Context3DTextureFilter.NEAREST;
        this.height = 0;
        this.__index = null;
        this.mipFilter = Context3DMipFilter.MIPNONE;
        this.width = 0;
        this.wrap = Context3DWrapMode.CLAMP;
    }
    // Get & Set Methods
    /**
        The number of channels that a shader input expects. This property must
        be accounted for when the input data is a ByteArray or Vector.<Number>
        instance.
    **/
    get channels() {
        return this.__channels;
    }
    /**
        The zero-based index of the input in the shader, indicating the order
        of the input definitions in the shader.
    **/
    get index() {
        return this.__index;
    }
}

/**
    // TODO: Document GLSL Shaders
    A ShaderJob instance is used to execute a shader operation in stand-alone
    mode. The shader operation executes and returns its result data. It is up
    to the developer to determine how to use the result.
    There are two primary reasons for using a shader in stand-alone mode:

    * Processing non-image data: Using a ShaderJob instance you have control
    over input values and over how the shader result is used. The shader can
    return the result as binary data or number data instead of image data.
    * Background processing: Some shaders are complex and require a notable
    amount of time to execute. Executing a complex shader in the main
    execution of an application could slow down other parts of the application
    such as user interaction or updating the screen. Using a ShaderJob
    instance, you can execute the shader in the background. When the shader is
    executed in this way, the shader operation runs separate from the main
    execution of the application.

    The `shader` property (or constructor parameter) specifies the Shader
    instance representing the shader that is used for the operation. You
    provide any parameter or input that the shader expects using the
    associated ShaderParameter or ShaderInput instance.

    Before execution a ShaderJob operation, you provide an object into which
    the result is written, by setting it as the value of the `target`
    property. When the shader operation completes the result is written into
    the `target` object.

    To begin a background shader operation, call the `start()` method. When
    the operation finishes the result is written into the `target` object. At
    that point the ShaderJob instance dispatches a `complete` event, notifying
    listeners that the result is available.

    To execute a shader synchronously (that is, not running in the
    background), call the `start()` method and pass `true` as an argument. The
    shader runs in the main execution thread and your code pauses until the
    operation completes. When it finishes the result is written into the
    `target` object. At that point the application continues running at the
    next line of code.

    @event complete Dispatched when a ShaderJob that executes asynchronously
                    finishes processing the data using the shader. A ShaderJob
                    instance executes asynchronously when the `start()` method
                    is called with a `false` value for the `waitForCompletion`
                    parameter.
**/
class ShaderJob extends EventDispatcher {
    /**
        @param shader The shader to use for the operation.
        @param target The object into which the result of the shader operation
                        is written. This argument must be a BitmapData,
                        ByteArray, or Vector.<Number> instance.
        @param width  The width of the result data in the `target` if it is a
                        ByteArray or Vector.<Number> instance. The size of the
                        ByteArray or Vector.<Number> instance is enlarged if
                        necessary and existing data is overwritten.
        @param height The height of the result data in the `target` if it is a
                        ByteArray or Vector.<Number> instance. The size of the
                        ByteArray or Vector.<Number> instance is enlarged if
                        necessary and existing data is overwritten.
    **/
    constructor(shader = null, target = null, width = 0, height = 0) {
        super();
        this.height = height;
        this.width = 0;
        this.__progress = 0;
    }
    /**
        Cancels the currently running shader operation. Any result data that
        is already computed is discarded. The `complete` event is not
        dispatched.
        Calling `cancel()` multiple times has no additional effect.

    **/
    cancel() { }
    /**
        Starts a shader operation in synchronous or asynchronous mode,
        according to the value of the `waitForCompletion` parameter.
        In asynchronous mode (when `waitForCompletion` is `false`), which is
        the default, the ShaderJob execution runs in the background. The
        shader operation does not affect the responsiveness of the display or
        other operations. In asynchronous mode the `start()` call returns
        immediately and the program continues with the next line of code. When
        the asynchronous shader operation finishes, the result is available
        and the `complete` event is dispatched.

        Only one background ShaderJob operation executes at a time. Shader
        operations are held in a queue until they execute. If you call the
        `start()` method while a shader operation is executing, the additional
        operation is added to the end of the queue. Later, when its turn
        comes, it executes.

        To execute a shader operation in synchronous mode, call `start()` with
        a `true` value for the `waitForCompletion` parameter (the only
        parameter). Your code pauses at the point where `start()` is called
        until the shader operation completes. At that point the result is
        available and execution continues with the next line of code.

        When you call the `start()` method the Shader instance in the `shader`
        property is copied internally. The shader operation uses that internal
        copy, not a reference to the original shader. Any changes made to the
        shader, such as changing a parameter value, input, or bytecode, are
        not applied to the copied shader that's used for the shader
        processing. To incorporate shader changes into the shader processing,
        call the `cancel()` method (if necessary) and call the `start()`
        method again to restart the shader processing.

        While a shader operation is executing, the `target` object's value is
        not changed. When the operation finishes (and the `complete` event is
        dispatched in asynchronous mode) the entire result is written to the
        `target` object at one time. If the `target` object is a BitmapData
        instance and its `dispose()` method is called before the operation
        finishes, the `complete` event is still dispatched in asynchronous
        mode. However, the result data is not written to the BitmapData object
        because it is in a disposed state.

        @param waitForCompletion Specifies whether to execute the shader in
                                    the background (`false`, the default) or in
                                    the main program execution (`true`).
        @throws ArgumentError When the `target` property is `null` or is not a
                                BitmapData, ByteArray, or Vector.<Number>
                                instance.
        @throws ArgumentError When the shader specifies an image input that
                                isn't provided.
        @throws ArgumentError When a ByteArray or Vector.<Number> instance is
                                used as an input and the `width` and `height`
                                properties aren't specified for the ShaderInput,
                                or the specified values don't match the amount
                                of data in the input object. See the
                                `ShaderInput.input` property for more
                                information.
        @event complete Dispatched when the operation finishes, if the
                        `start()` method is called with a `waitForCompletion`
                        argument of `true`.
    **/
    start(waitForCompletion = false) { }
    // Get & Set Methods
    /**
        The progress of a running shader. This property is a value from 0
        through 1. Zero is the initial value (0% complete). One indicates that
        the shader has completed its operation.
        If the `cancel()` method is called this property becomes `undefined`,
        and its value cannot be used reliably until the shader operation
        starts again.
    **/
    get progress() {
        return this.__progress;
    }
}

/**
    TODO: Document GLSL Shaders

    A ShaderParameter instance represents a single input parameter of a shader
    kernel. A kernel can be defined to accept zero, one, or more parameters
    that are used in the kernel execution. A ShaderParameter provides
    information about the parameter, such as the type of data it expects. It
    also provides a mechanism for setting the parameter value that is used
    when the shader executes. To specify a value or values for the shader
    parameter, create an Array containing the value or values and assign it to
    the `value` property.

    A ShaderParameter instance representing a parameter for a Shader instance
    is accessed as a property of the Shader instance's `data` property. The
    ShaderParameter property has the same name as the parameter's name in the
    shader code. For example, if a shader defines a parameter named `radius`,
    the ShaderParameter instance representing the `radius` parameter is
    available as the `radius` property, as shown here:

    ```haxe
    var radiusParam:ShaderParameter = myShader.data.radius;
    ```

    In addition to the defined properties of the ShaderParameter class, each
    ShaderParameter instance has additional properties corresponding to any
    metadata defined for the parameter. These properties are added to the
    ShaderParameter object when it is created. The properties' names match the
    metadata names specified in the shader's source code. The data type of
    each property varies according to the data type of the corresponding
    metadata. A text metadata value such as "description" is a String
    instance. A metadata property with a non-string value (such as `minValue`
    or `defaultValue`) is represented as an Array instance. The number of
    elements and element data types correspond to the metadata values.

    For example, suppose a shader includes the following two parameter
    declarations:

    ```as3
    parameter float2 size
    <
        description: "The size of the image to which the kernel is applied";
        minValue : number2(0.0, 0.0);
        maxValue : number2(100.0, 100.0);
        defaultValue : number2(50.0, 50.0);
    >;

    parameter float radius
    <
        description: "The radius of the effect";
        minValue: 0.0;
        maxValue: 50.0;
        defaultValue: 25.0;
    >;
    ```

    The ShaderParameter instance corresponding to the `size` parameter has the
    following metadata properties in addition to its built-in properties:

    | Property name | Data type | Value |
    | --- | --- | --- |
    | `name` | String | `"size"` |
    | `description` | String | `"The size of the image to which the kernel is applied"` |
    | `minValue` | Array | `[0, 0]` |
    | `maxValue` | Array | `[100, 100]` |
    | `defaultValue` | Array | `[50, 50]` |

    The ShaderParameter corresponding to the `radius` parameter has the
    following additional properties:

    | Property name | Data type | Value |
    | --- | --- | --- |
    | `name` | String | `"radius"` |
    | `description` | String | `"The radius of the effect"` |
    | `minValue` | Array | `[0]` |
    | `maxValue` | Array | `[50]` |
    | `defaultValue` | Array | `[25]` |

    Generally, developer code does not create a ShaderParameter instance
    directly. A ShaderParameter instance is created for each of a shader's
    parameters when the Shader instance is created.
**/
class ShaderParameter {
    constructor() {
        this.__index = 0;
        // __backend = new ShaderParameterBackend<T>(this);
    }
    // Get & Set Methods
    /**
        The zero-based index of the parameter.
    **/
    get index() {
        return this.__index;
    }
    /** @hidden */
    get name() {
        return this.__name;
    }
    /** @hidden */
    set name(value) {
        // __backend.setName(value);
        this.name = value;
    }
    /**
        The data type of the parameter as defined in the shader. The set of
        possible values for the `type` property is defined by the constants in
        the ShaderParameterType class.
    **/
    get type() {
        return this.__type;
    }
}

var openfl$n;
(function (openfl) {
    var display;
    (function (display) {
        /**
            This class defines the constants that represent the possible values for
            the ShaderParameter class's `type` property. Each constant represents one
            of the data types available in Flash Player for parameters in the Pixel
            Bender shader language.
        **/
        let ShaderParameterType;
        (function (ShaderParameterType) {
            /**
                Indicates that the shader parameter is defined as a `bool` value,
                equivalent to a single Boolean instance in ActionScript.
                Note that even though the parameter only expects a single value, the
                `ShaderParameter.value` property is an Array, so the single value must
                be the only element of an Array assigned to the `value` property, like
                this:
    
                ```haxe
                // assumes the shader has a parameter named "param"
                // whose data type is bool
                myShader.data.param.value = [true];
                ```
            **/
            ShaderParameterType["BOOL"] = "bool";
            /**
                Indicates that the shader parameter is defined as a `bool2` value,
                equivalent to an Array of two Boolean instances in ActionScript.
            **/
            ShaderParameterType["BOOL2"] = "bool2";
            /**
                Indicates that the shader parameter is defined as a `bool3` value,
                equivalent to an Array of three Boolean instances in ActionScript.
            **/
            ShaderParameterType["BOOL3"] = "bool3";
            /**
                Indicates that the shader parameter is defined as a `bool4` value,
                equivalent to an Array of four Boolean instances in ActionScript.
            **/
            ShaderParameterType["BOOL4"] = "bool4";
            /**
                Indicates that the shader parameter is defined as a `float` value,
                equivalent to a single Number instance in ActionScript.
                Note that even though the parameter only expects a single value, the
                `ShaderParameter.value` property is an Array, so the single value must
                be the only element of an Array assigned to the `value` property, like
                this:
    
                ```haxe
                // assumes the shader has a parameter named "param"
                // whose data type is float
                myShader.data.param.value = [22.5];
                ```
            **/
            ShaderParameterType["FLOAT"] = "float";
            /**
                Indicates that the shader parameter is defined as a `float2` value,
                equivalent to an Array of two Number instances in ActionScript.
            **/
            ShaderParameterType["FLOAT2"] = "float2";
            /**
                Indicates that the shader parameter is defined as a `float3` value,
                equivalent to an Array of three Number instances in ActionScript.
            **/
            ShaderParameterType["FLOAT3"] = "float3";
            /**
                Indicates that the shader parameter is defined as a `float4` value,
                equivalent to an Array of four Number instances in ActionScript.
            **/
            ShaderParameterType["FLOAT4"] = "float4";
            /**
                Indicates that the shader parameter is defined as an `int` value,
                equivalent to a single int or uint instance in ActionScript.
                Note that even though the parameter only expects a single value, the
                `ShaderParameter.value` property is an Array, so the single value must
                be the only element of an Array assigned to the `value` property, like
                this:
    
                ```haxe
                // assumes the shader has a parameter named "param"
                // whose data type is int
                myShader.data.param.value = [275];
                ```
            **/
            ShaderParameterType["INT"] = "int";
            /**
                Indicates that the shader parameter is defined as an `int2` value,
                equivalent to an Array of two int or uint instances in ActionScript.
            **/
            ShaderParameterType["INT2"] = "int2";
            /**
                Indicates that the shader parameter is defined as an `int3` value,
                equivalent to an Array of three int or uint instances in ActionScript.
            **/
            ShaderParameterType["INT3"] = "int3";
            /**
                Indicates that the shader parameter is defined as an `int4` value,
                equivalent to an Array of four int or uint instances in ActionScript.
            **/
            ShaderParameterType["INT4"] = "int4";
            /**
                Indicates that the shader parameter is defined as a `float2x2` value,
                equivalent to a 2-by-2 matrix. This matrix is represented as an Array
                of four Number instances in ActionScript.
            **/
            ShaderParameterType["MATRIX2X2"] = "matrix2x2";
            /**
                Indicates that the shader parameter is defined as a `float2x3` value,
                equivalent to a 2-by-3 matrix. This matrix is represented as an Array
                of six Float instances in Haxe.
            **/
            ShaderParameterType["MATRIX2X3"] = "matrix2x3";
            /**
                Indicates that the shader parameter is defined as a `float2x4` value,
                equivalent to a 2-by-4 matrix. This matrix is represented as an Array
                of eight Float instances in Haxe.
            **/
            ShaderParameterType["MATRIX2X4"] = "matrix2x4";
            /**
                Indicates that the shader parameter is defined as a `float3x2` value,
                equivalent to a 3-by-2 matrix. This matrix is represented as an Array
                of six Float instances in Haxe.
            **/
            ShaderParameterType["MATRIX3X2"] = "matrix3x2";
            /**
                Indicates that the shader parameter is defined as a `float3x3` value,
                equivalent to a 3-by-3 matrix. This matrix is represented as an Array
                of nine Number instances in ActionScript.
            **/
            ShaderParameterType["MATRIX3X3"] = "matrix3x3";
            /**
                Indicates that the shader parameter is defined as a `float3x4` value,
                equivalent to a 3-by-4 matrix. This matrix is represented as an Array
                of twelve Float instances in Haxe.
            **/
            ShaderParameterType["MATRIX3X4"] = "matrix3x4";
            /**
                Indicates that the shader parameter is defined as a `float4x2` value,
                equivalent to a 4-by-2 matrix. This matrix is represented as an Array
                of eight Float instances in Haxe.
            **/
            ShaderParameterType["MATRIX4X2"] = "matrix4x2";
            /**
                Indicates that the shader parameter is defined as a `float4x3` value,
                equivalent to a 4-by-3 matrix. This matrix is represented as an Array
                of twelve Float instances in Haxe.
            **/
            ShaderParameterType["MATRIX4X3"] = "matrix4x3";
            /**
                Indicates that the shader parameter is defined as a `float4x4` value,
                equivalent to a 4-by-4 matrix. This matrix is represented as an Array
                of 16 Number instances in ActionScript.
            **/
            ShaderParameterType["MATRIX4X4"] = "matrix4x4";
        })(ShaderParameterType = display.ShaderParameterType || (display.ShaderParameterType = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$n || (openfl$n = {}));
var ShaderParameterType = openfl$n.display.ShaderParameterType;

/**
    This class is used to create lightweight shapes using the ActionScript
    drawing application program interface(API). The Shape class includes a
    `graphics` property, which lets you access methods from the
    Graphics class.

    The Sprite class also includes a `graphics`property, and it
    includes other features not available to the Shape class. For example, a
    Sprite object is a display object container, whereas a Shape object is not
    (and cannot contain child display objects). For this reason, Shape objects
    consume less memory than Sprite objects that contain the same graphics.
    However, a Sprite object supports user input events, while a Shape object
    does not.
**/
class Shape extends DisplayObject {
    /**
        Creates a new Shape object.
    **/
    constructor() {
        super();
        this.__type = DisplayObjectType$1.SHAPE;
    }
    // Get & Set Methods
    /**
        Specifies the Graphics object belonging to this Shape object, where vector
        drawing commands can occur.
    **/
    get graphics() {
        if (this.__graphics == null) {
            this.__graphics = new Graphics(this);
        }
        return this.__graphics;
    }
}

/**
    The SoundTransform class contains properties for volume and panning.
**/
class SoundTransform {
    /**
        Creates a SoundTransform object.

        @param vol     The volume, ranging from 0(silent) to 1(full volume).
        @param panning The left-to-right panning of the sound, ranging from -1
                        (full pan left) to 1(full pan right). A value of 0
                        represents no panning(center).
    **/
    constructor(vol = 1, panning = 0) {
        this.volume = vol;
        this.pan = panning;
        this.leftToLeft = 0;
        this.leftToRight = 0;
        this.rightToLeft = 0;
        this.rightToRight = 0;
    }
    /** @hidden */
    clone() {
        return new SoundTransform(this.volume, this.pan);
    }
}

/**
    The SimpleButton class lets you control all instances of button symbols in
    a SWF file.

    In Flash Professional, you can give a button an instance name in the
    Property inspector. SimpleButton instance names are displayed in the Movie
    Explorer and in the Insert Target Path dialog box in the Actions panel.
    After you create an instance of a button in Flash Professional, you can use
    the methods and properties of the SimpleButton class to manipulate buttons
    with ActionScript.

    In ActionScript 3.0, you use the `new SimpleButton()`
    constructor to create a SimpleButton instance.

    The SimpleButton class inherits from the InteractiveObject class.
**/
class SimpleButton extends InteractiveObject {
    /**
        Creates a new SimpleButton instance. Any or all of the display objects
        that represent the various button states can be set as parameters in the
        constructor.

        @param upState      The initial value for the SimpleButton up state.
        @param overState    The initial value for the SimpleButton over state.
        @param downState    The initial value for the SimpleButton down state.
        @param hitTestState The initial value for the SimpleButton hitTest state.
    **/
    constructor(upState = null, overState = null, downState = null, hitTestState = null) {
        super();
        this.__type = DisplayObjectType$1.SIMPLE_BUTTON;
        this.enabled = true;
        this.trackAsMenu = false;
        this.useHandCursor = true;
        this.__upState = (upState != null) ? upState : new DisplayObject();
        this.__overState = overState;
        this.__downState = downState;
        this.hitTestState = (hitTestState != null) ? hitTestState : new DisplayObject();
        this.addEventListener(MouseEvent.MOUSE_DOWN, this.__this_onMouseDown);
        this.addEventListener(MouseEvent.MOUSE_OUT, this.__this_onMouseOut);
        this.addEventListener(MouseEvent.MOUSE_OVER, this.__this_onMouseOver);
        this.addEventListener(MouseEvent.MOUSE_UP, this.__this_onMouseUp);
        this.__tabEnabled = true;
        this.__setCurrentState(this.__upState);
        if (SimpleButton.__constructor != null) {
            var method = SimpleButton.__constructor;
            SimpleButton.__constructor = null;
            method(this);
        }
    }
    __getBounds(rect, matrix) {
        super.__getBounds(rect, matrix);
        var childWorldTransform = Matrix.__pool.get();
        DisplayObject.__calculateAbsoluteTransform(this.__currentState.__transform, matrix, childWorldTransform);
        this.__currentState.__getBounds(rect, childWorldTransform);
        Matrix.__pool.release(childWorldTransform);
    }
    __getRenderBounds(rect, matrix) {
        if (this.__scrollRect != null) {
            super.__getRenderBounds(rect, matrix);
            return;
        }
        else {
            super.__getBounds(rect, matrix);
        }
        var childWorldTransform = Matrix.__pool.get();
        DisplayObject.__calculateAbsoluteTransform(this.__currentState.__transform, matrix, childWorldTransform);
        this.__currentState.__getRenderBounds(rect, childWorldTransform);
        Matrix.__pool.release(childWorldTransform);
    }
    __getCursor() {
        return (this.useHandCursor && !this.__ignoreEvent && this.enabled) ? MouseCursor$1.BUTTON : null;
    }
    __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        var hitTest = false;
        if (this.__hitTestState != null) {
            if (this.__hitTestState.__hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject)) {
                if (stack != null) {
                    if (stack.length == 0) {
                        stack[0] = hitObject;
                    }
                    else {
                        stack[stack.length - 1] = hitObject;
                    }
                }
                hitTest = (!interactiveOnly || this.mouseEnabled);
            }
        }
        else if (this.__currentState != null) {
            if (!hitObject.visible || this.__isMask || (interactiveOnly && !this.mouseEnabled) || (this.__mask != null && !this.__mask.__hitTestMask(x, y))) {
                hitTest = false;
            }
            else if (this.__currentState.__hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject)) {
                hitTest = interactiveOnly;
            }
        }
        // TODO: Better fix?
        // (this is caused by the "hitObject" logic in hit testing)
        if (stack != null) {
            while (stack.length > 1 && stack[stack.length - 1] == stack[stack.length - 2]) {
                stack.pop();
            }
        }
        return hitTest;
    }
    __hitTestMask(x, y) {
        var hitTest = false;
        if (this.__currentState.__hitTestMask(x, y)) {
            hitTest = true;
        }
        return hitTest;
    }
    __setCurrentState(value) {
        if (this.__currentState != null && this.__currentState != this.__hitTestState) {
            this.__currentState.__renderParent = null;
            this.__currentState.__setTransformDirty();
        }
        if (value != null && value.parent != null) {
            value.parent.removeChild(value);
        }
        if (DisplayObject.__supportDOM && this.__previousStates == null) {
            this.__previousStates = new Vector();
        }
        if (value != this.__currentState) {
            if (DisplayObject.__supportDOM) {
                if (this.__currentState != null) {
                    this.__currentState.__setStageReferences(null);
                    this.__previousStates.push(this.__currentState);
                }
                var index = this.__previousStates.indexOf(value);
                if (index > -1) {
                    this.__previousStates.splice(index, 1);
                }
            }
            if (value != null) {
                value.__renderParent = this;
                value.__setTransformDirty();
                value.__setRenderDirty();
            }
            this.__localBoundsDirty = true;
            this.__setRenderDirty();
        }
        this.__currentState = value;
        return value;
    }
    __setTransformDirty(force = false) {
        // inline super.__setTransformDirty(force);
        this.__transformDirty = true;
        if (this.__currentState != null) {
            this.__currentState.__setTransformDirty(force);
        }
        if (this.__hitTestState != null && this.__hitTestState != this.__currentState) {
            this.__hitTestState.__setTransformDirty(force);
        }
    }
    __update(transformOnly, updateChildren) {
        this.__updateSingle(transformOnly, updateChildren);
        if (updateChildren) {
            if (this.__currentState != null) {
                this.__currentState.__update(transformOnly, true);
            }
            if (this.__hitTestState != null && this.__hitTestState != this.__currentState) {
                this.__hitTestState.__update(transformOnly, true);
            }
        }
    }
    // Getters & Setters
    /**
        Specifies a display object that is used as the visual object for the
        button "Down" state  - the state that the button is in when the user
        selects the `hitTestState` object.
    **/
    get downState() {
        return this.__downState;
    }
    set downState(downState) {
        if (this.__downState != null && this.__currentState == this.__downState) {
            this.__setCurrentState(this.__downState);
        }
        this.__downState = downState;
    }
    /**
        Specifies a display object that is used as the hit testing object for the
        button. For a basic button, set the `hitTestState` property to
        the same display object as the `overState` property. If you do
        not set the `hitTestState` property, the SimpleButton is
        inactive  -  it does not respond to user input events.
    **/
    get hitTestState() {
        return this.__hitTestState;
    }
    set hitTestState(hitTestState) {
        if (this.__hitTestState != null && this.__hitTestState != hitTestState) {
            if (this.__hitTestState != this.__downState && this.__hitTestState != this.__upState && this.__hitTestState != this.__overState) {
                this.__hitTestState.__renderParent = null;
                this.__hitTestState.__setTransformDirty();
            }
        }
        if (hitTestState != null) {
            hitTestState.__renderParent = this;
            hitTestState.__setTransformDirty();
            hitTestState.__setRenderDirty();
        }
        this.__hitTestState = hitTestState;
    }
    /**
        Specifies a display object that is used as the visual object for the
        button over state  -  the state that the button is in when the pointer is
        positioned over the button.
    **/
    get overState() {
        return this.__overState;
    }
    set overState(overState) {
        if (this.__overState != null && this.__currentState == this.__overState) {
            this.__setCurrentState(overState);
        }
        this.__overState = overState;
    }
    /**
        The SoundTransform object assigned to this button. A SoundTransform object
        includes properties for setting volume, panning, left speaker assignment,
        and right speaker assignment. This SoundTransform object applies to all
        states of the button. This SoundTransform object affects only embedded
        sounds.
    **/
    get soundTransform() {
        if (this.__soundTransform == null) {
            this.__soundTransform = new SoundTransform();
        }
        return new SoundTransform(this.__soundTransform.volume, this.__soundTransform.pan);
    }
    set soundTransform(value) {
        this.__soundTransform = new SoundTransform(value.volume, value.pan);
    }
    /**
        Specifies a display object that is used as the visual object for the
        button up state  -  the state that the button is in when the pointer is
        not positioned over the button.
    **/
    get upState() {
        return this.__upState;
    }
    set upState(upState) {
        if (this.__upState != null && this.__currentState == this.__upState) {
            this.__setCurrentState(upState);
        }
        this.__upState = upState;
    }
    // Event Handlers
    __this_onMouseDown(event) {
        if (this.enabled) {
            this.__setCurrentState(this.__downState);
        }
    }
    __this_onMouseOut(event) {
        this.__ignoreEvent = false;
        if (this.__upState != this.__currentState) {
            this.__setCurrentState(this.__upState);
        }
    }
    __this_onMouseOver(event) {
        if (event.buttonDown) {
            this.__ignoreEvent = true;
        }
        if (this.__overState != this.__currentState && this.__overState != null && !this.__ignoreEvent && this.enabled) {
            this.__setCurrentState(this.__overState);
        }
    }
    __this_onMouseUp(event) {
        this.__ignoreEvent = false;
        if (this.enabled && this.__overState != null) {
            this.__setCurrentState(this.__overState);
        }
        else {
            this.__setCurrentState(this.__upState);
        }
    }
}

let TouchData = /** @class */ (() => {
    class TouchData {
        constructor() {
            this.rollOutStack = [];
        }
        reset() {
            this.touchDownTarget = null;
            this.touchOverTarget = null;
            this.rollOutStack.splice(0, this.rollOutStack.length);
        }
    }
    TouchData.__pool = new ObjectPool(() => new TouchData(), (data) => data.reset());
    return TouchData;
})();

var openfl$o;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying the source and destination blend factors.
        
            A blend factor represents a particular four-value vector that is multiplied with the
            source or destination color in the blending formula. The blending formula is:
        
            ```
            result = source * sourceFactor + destination * destinationFactor
            ```
        
            In the formula, the source color is the output color of the pixel shader program.
            The destination color is the color that currently exists in the color buffer, as set
            by previous clear and draw operations.
        
            For example, if the source color is (.6, .6, .6, .4) and the source blend factor is
            `Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA`, then the source part of the blending
            equation is calculated as:
        
            ```
            (.6, .6, .6, .4) * (1-0.4, 1-0.4, 1-0.4, 1-0.4) = (.36, .36, .36, .24)
            ```
        
            The final calculation is clamped to the range [0,1].
        
            **Examples**
        
            The following examples demonstrate the blending math using
            `source color = (.6,.4,.2,.4)`, `destination color = (.8,.8,.8,.5)`, and various blend
            factors.
        
            | Purpose | Source factor | Destination factor | Blend formula | Result |
            | --- | --- | --- | --- | --- |
            | No blending | ONE | ZERO | (.6,.4,.2,.4) * ( 1, 1, 1, 1) + (.8,.8,.8,.5) * ( 0, 0, 0, 0) | ( .6, .4, .2, .4) |
            | Alpha | SOURCE_ALPHA | ONE_MINUS_SOURCE_ALPHA | (.6,.4,.2,.4) * (.4,.4,.4,.4) + (.8,.8,.8,.5) * (.6,.6,.6,.6) | (.72,.64,.56,.46) |
            | Additive | ONE | ONE | (.6,.4,.2,.4) * ( 1, 1, 1, 1) + (.8,.8,.8,.5) * ( 1, 1, 1, 1)	( 1, 1, 1, .9) |
            | Multiply | DESTINATION_COLOR | ZERO | (.6,.4,.2,.4) * (.8,.8,.8,.5) + (.8,.8,.8,.5) * ( 0, 0, 0, 0) | (.48,.32,.16, .2) |
            | Screen | ONE | ONE_MINUS_SOURCE_COLOR | (.6,.4,.2,.4) * ( 1, 1, 1, 1) + (.8,.8,.8,.5) * (.4,.6,.8,.6) | (.92,.88,.68, .7) |
        
            Note that not all combinations of blend factors are useful and that you can sometimes achieve the same effect in different ways.
        **/
        let Context3DBlendFactor;
        (function (Context3DBlendFactor) {
            /**
                The blend factor is (D<sub>a</sub>,D<sub>a</sub>,D<sub>a</sub>,D<sub>a</sub>),
                where D<sub>a</sub> is the alpha component of the fragment color computed by the
                pixel program.
            **/
            Context3DBlendFactor["DESTINATION_ALPHA"] = "destinationAlpha";
            /**
                The blend factor is (D<sub>r</sub>,D<sub>g</sub>,D<sub>b</sub>,D<sub>a</sub>),
                where D<sub>r/g/b/a</sub> is the corresponding component of the current color
                in the color buffer.
            **/
            Context3DBlendFactor["DESTINATION_COLOR"] = "destinationColor";
            /**
                The blend factor is (1,1,1,1).
            **/
            Context3DBlendFactor["ONE"] = "one";
            /**
                The blend factor is (1-D<sub>a</sub>,1-D<sub>a</sub>,1-D<sub>a</sub>,1-D<sub>a</sub>),
                where D<sub>a</sub> is the alpha component of the current color in the color buffer.
            **/
            Context3DBlendFactor["ONE_MINUS_DESTINATION_ALPHA"] = "oneMinusDestinationAlpha";
            /**
                The blend factor is (1-D<sub>r</sub>,1-D<sub>g</sub>,1-D<sub>b</sub>,1-D<sub>a</sub>),
                where D<sub>r/g/b/a</sub> is the corresponding component of the current color in
                the color buffer.
            **/
            Context3DBlendFactor["ONE_MINUS_DESTINATION_COLOR"] = "oneMinusDestinationColor";
            /**
                The blend factor is (1-S<sub>a</sub>,1-S<sub>a</sub>,1-S<sub>a</sub>,1-S<sub>a</sub>),
                where S<sub>a</sub> is the alpha component of the fragment color computed by the
                pixel program.
            **/
            Context3DBlendFactor["ONE_MINUS_SOURCE_ALPHA"] = "oneMinusSourceAlpha";
            /**
                The blend factor is (1-S<sub>r</sub>,1-S<sub>g</sub>,1-S<sub>b</sub>,1-S<sub>a</sub>),
                where S<sub>r/g/b/a</sub> is the corresponding component of the fragment color
                computed by the pixel program.
            **/
            Context3DBlendFactor["ONE_MINUS_SOURCE_COLOR"] = "oneMinusSourceColor";
            /**
                The blend factor is (S<sub>a</sub>,S<sub>a</sub>,S<sub>a</sub>,S<sub>a</sub>),
                where S<sub>a</sub> is the alpha component of the fragment color computed by the
                pixel program.
            **/
            Context3DBlendFactor["SOURCE_ALPHA"] = "sourceAlpha";
            /**
                The blend factor is (S<sub>r</sub>,S<sub>g</sub>,S<sub>b</sub>,S<sub>a</sub>),
                where S<sub>r/g/b/a</sub> is the corresponding component of the fragment color
                computed by the pixel program.
            **/
            Context3DBlendFactor["SOURCE_COLOR"] = "sourceColor";
            /**
                The blend factor is (0,0,0,0).
            **/
            Context3DBlendFactor["ZERO"] = "zero";
        })(Context3DBlendFactor = display3D.Context3DBlendFactor || (display3D.Context3DBlendFactor = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$o || (openfl$o = {}));
var Context3DBlendFactor = openfl$o.display3D.Context3DBlendFactor;

var openfl$p;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying 3D buffer comparisons in the
            `setDepthTest()` and `setStencilAction()` methods of a Context3D instance.
        **/
        let Context3DCompareMode;
        (function (Context3DCompareMode) {
            /**
                The comparison always evaluates as true.
            **/
            Context3DCompareMode["ALWAYS"] = "always";
            /**
                Equal (==).
            **/
            Context3DCompareMode["EQUAL"] = "equal";
            /**
                Greater than (>).
            **/
            Context3DCompareMode["GREATER"] = "greater";
            /**
                Greater than or equal (>=).
            **/
            Context3DCompareMode["GREATER_EQUAL"] = "greaterEqual";
            /**
                Less than (<).
            **/
            Context3DCompareMode["LESS"] = "less";
            /**
                Less than or equal (<=).
            **/
            Context3DCompareMode["LESS_EQUAL"] = "lessEqual";
            /**
                The comparison never evaluates as true.
            **/
            Context3DCompareMode["NEVER"] = "never";
            /**
                Not equal (!=).
            **/
            Context3DCompareMode["NOT_EQUAL"] = "notEqual";
        })(Context3DCompareMode = display3D.Context3DCompareMode || (display3D.Context3DCompareMode = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$p || (openfl$p = {}));
var Context3DCompareMode = openfl$p.display3D.Context3DCompareMode;

var openfl$q;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying stencil actions.
        
            A stencil action specifies how the values in the stencil buffer should be changed.
        **/
        let Context3DStencilAction;
        (function (Context3DStencilAction) {
            /**
                Decrement the stencil buffer value, clamping at 0, the minimum value.
            **/
            Context3DStencilAction["DECREMENT_SATURATE"] = "decrementSaturate";
            /**
                Decrement the stencil buffer value. If the result is less than 0, the minimum
                value, then the buffer value is "wrapped around" to 255.
            **/
            Context3DStencilAction["DECREMENT_WRAP"] = "decrementWrap";
            /**
                Increment the stencil buffer value, clamping at 255, the maximum value.
            **/
            Context3DStencilAction["INCREMENT_SATURATE"] = "incrementSaturate";
            /**
                Increment the stencil buffer value. If the result exceeds 255, the maximum
                value, then the buffer value is "wrapped around" to 0.
            **/
            Context3DStencilAction["INCREMENT_WRAP"] = "incrementWrap";
            /**
                Invert the stencil buffer value, bitwise.
    
                For example, if the 8-bit binary number in the stencil buffer is: 11110000, then
                the value is changed to: 00001111.
            **/
            Context3DStencilAction["INVERT"] = "invert";
            /**
                Keep the current stencil buffer value.
            **/
            Context3DStencilAction["KEEP"] = "keep";
            /**
                Replace the stencil buffer value with the reference value.
            **/
            Context3DStencilAction["SET"] = "set";
            /**
                Set the stencil buffer value to 0.
            **/
            Context3DStencilAction["ZERO"] = "zero";
        })(Context3DStencilAction = display3D.Context3DStencilAction || (display3D.Context3DStencilAction = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$q || (openfl$q = {}));
var Context3DStencilAction = openfl$q.display3D.Context3DStencilAction;

var openfl$r;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Constants to specify the orientation of a triangle relative to the view point.
        **/
        let Context3DTriangleFace;
        (function (Context3DTriangleFace) {
            Context3DTriangleFace["BACK"] = "back";
            Context3DTriangleFace["FRONT"] = "front";
            Context3DTriangleFace["FRONT_AND_BACK"] = "frontAndBack";
            Context3DTriangleFace["NONE"] = "none";
        })(Context3DTriangleFace = display3D.Context3DTriangleFace || (display3D.Context3DTriangleFace = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$r || (openfl$r = {}));
var Context3DTriangleFace = openfl$r.display3D.Context3DTriangleFace;

class Context3DState {
    constructor() {
        this.backBufferEnableDepthAndStencil = false;
        this.blendDestinationAlphaFactor = Context3DBlendFactor.ZERO;
        this.blendSourceAlphaFactor = Context3DBlendFactor.ONE;
        this.blendDestinationRGBFactor = Context3DBlendFactor.ZERO;
        this.blendSourceRGBFactor = Context3DBlendFactor.ONE;
        this.colorMaskRed = true;
        this.colorMaskGreen = true;
        this.colorMaskBlue = true;
        this.colorMaskAlpha = true;
        this.culling = Context3DTriangleFace.NONE;
        this.depthCompareMode = Context3DCompareMode.LESS;
        this.depthMask = true;
        this.samplerStates = new Array();
        this.scissorRectangle = new Rectangle();
        this.stencilCompareMode = Context3DCompareMode.ALWAYS;
        this.stencilDepthFail = Context3DStencilAction.KEEP;
        this.stencilFail = Context3DStencilAction.KEEP;
        this.stencilPass = Context3DStencilAction.KEEP;
        this.stencilReadMask = 0xFF;
        this.stencilReferenceValue = 0;
        this.stencilTriangleFace = Context3DTriangleFace.FRONT_AND_BACK;
        this.stencilWriteMask = 0xFF;
        this.textures = new Array();
        this.__frontFaceGLCCW = true;
        this.__glBlendEquation = 0x8006; // GL.FUNC_ADD
    }
}

class SamplerState {
    constructor(wrap = Context3DWrapMode.CLAMP, filter = Context3DTextureFilter.NEAREST, mipfilter = Context3DMipFilter.MIPNONE, lodBias = 0.0, ignoreSampler = false, centroid = false, textureAlpha = false) {
        this.wrap = wrap;
        this.filter = filter;
        this.mipfilter = mipfilter;
        this.lodBias = lodBias;
        this.ignoreSampler = ignoreSampler;
        this.centroid = centroid;
        this.textureAlpha = textureAlpha;
    }
    clone() {
        var copy = new SamplerState(this.wrap, this.filter, this.mipfilter, this.lodBias, this.ignoreSampler, this.centroid, this.textureAlpha);
        copy.mipmapGenerated = this.mipmapGenerated;
        return copy;
    }
    copyFrom(other) {
        if (other == null || other.ignoreSampler)
            return;
        this.wrap = other.wrap;
        this.filter = other.filter;
        this.mipfilter = other.mipfilter;
        this.lodBias = other.lodBias;
        this.centroid = other.centroid;
        this.textureAlpha = other.textureAlpha;
    }
    equals(other) {
        if (other == null) {
            return false;
        }
        return (this.wrap == other.wrap && this.filter == other.filter && this.mipfilter == other.mipfilter && this.lodBias == other.lodBias && this.textureAlpha == other.textureAlpha);
    }
}

/**
    The TextureBase class is the base class for Context3D texture objects.

    **Note:** You cannot create your own texture classes using TextureBase. To add
    functionality to a texture class, extend either Texture or CubeTexture instead.
**/
class TextureBase extends EventDispatcher {
    constructor(context, width, height, format, optimizeForRenderToTexture, streamingLevels) {
        super();
        this.__context = context;
        this.__width = width;
        this.__height = height;
        this.__format = format;
        this.__optimizeForRenderToTexture = optimizeForRenderToTexture;
        this.__streamingLevels = streamingLevels;
    }
    /**
        Frees all GPU resources associated with this texture. After disposal, calling
        `upload()` or rendering with this object fails.
    **/
    dispose() {
        // __baseBackend.dispose();
    }
}

/**
    The CubeTexture class represents a cube texture uploaded to a rendering context.

    Defines a cube map texture for use during rendering. Cube mapping is used for many
    rendering techniques, such as environment maps, skyboxes, and skylight illumination.

    You cannot create a CubeTexture object directly; use the Context3D
    `createCubeTexture()` instead.
**/
class CubeTexture extends TextureBase {
    constructor(context, size, format, optimizeForRenderToTexture, streamingLevels) {
        super(context, size, size, format, optimizeForRenderToTexture, streamingLevels);
        this.__size = size;
    }
    /**
        Uploads a cube texture in Adobe Texture Format (ATF) from a byte array.

        The byte array must contain all faces and mipmaps for the texture.

        @param	data	a byte array that containing a compressed cube texture including
        mipmaps. The ByteArray object must use the little endian format.
        @param	byteArrayOffset	an optional offset at which to start reading the texture
        data.
        @param	async	If `true`, this returns immediately. Any draw method which
        attempts to use the texture will fail until the upload completes successfully. Upon
        successful upload, this Texture object dispatches `Event.TEXTURE_READY`. Default
        value: `false`.
        @throws	TypeError	Null Pointer Error: when `data` is `null`.
        @throws	ArgumentError	Texture Decoding Failed: when the compression format of
        this object cannot be derived from the format of the compressed data in data.
        @throws	ArgumentError	Texture Needs To Be Square: when the decompressed texture
        does not have equal `width` and `height`.
        @throws	ArgumentError	Texture Size Does Not Match: when the width and height of
        the decompressed texture do not equal the length of the texture's edge.
        @throws	ArgumentError	Miplevel Too Large: if the mip level of the decompressed
        texture is greater than that implied by the length of the texture's edge.
        @throws	ArgumentError	Texture Format Mismatch: if the decoded ATF bytes don't
        contain a texture compatible with this texture's format or is not a cube texture.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
        @throws	RangeError	Bad Input Size: when there is integer overflow of
        `byteArrayOffset` or if `byteArrayOffset` + 6 is greater than the length of `data`,
        or if the number of bytes available from `byteArrayOffset` to the end of the data
        byte array is less than the amount of data required for ATF texture.
    **/
    uploadCompressedTextureFromByteArray(data, byteArrayOffset, async = false) {
        // __backend.uploadCompressedTextureFromByteArray(data, byteArrayOffset, async);
    }
    /**
        Uploads a component of a cube map texture from a BitmapData object.

        This uploads one mip level of one side of the cube map. Call
        `uploadFromBitmapData()` as necessary to upload each mip level and face of the
        cube map.

        @param	source	a bitmap.
        @param	side	A code indicating which side of the cube to upload:
        positive X : 0
        negative X : 1
        positive Y : 2
        negative Y : 3
        positive Z : 4
        negative Z : 5
        @param	miplevel	the mip level to be loaded, level zero being the top-level
        full-resolution image. The default value is zero.
        @throws	TypeError	Null Pointer Error: if source is `null`.
        @throws	ArgumentError	Miplevel Too Large: if the specified mip level is greater
        than that implied by the the texture's dimensions.
        @throws	ArgumentError	Invalid Cube Side: if side is greater than 5.
        @throws	ArgumentError	Invalid BitmapData Error: if source if the BitmapData
        object does not contain a valid cube texture face. The image must be square, with
        sides equal to a power of two, and the correct size for the miplevel specified.
        @throws	ArgumentError	Texture Format Mismatch: if the texture format is
        `Context3DTextureFormat.COMPRESSED` or `Context3DTextureFormat.COMPRESSED_ALPHA`
        and the code is executing on a mobile platform where runtime texture compression
        is not supported.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromBitmapData(source, side, miplevel = 0, generateMipmap = false) {
        // __backend.uploadFromBitmapData(source, side, miplevel, generateMipmap);
    }
    /**
        Uploads a component of a cube map texture from a ByteArray object.

        This uploads one mip level of one side of the cube map. Call
        `uploadFromByteArray()` as neccessary to upload each mip level and face of the
        cube map.

        @param	data	a byte array containing the image in the format specified when
        this CubeTexture object was created. The ByteArray object must use the little
        endian format.
        @param	byteArrayOffset	reading of the byte array starts there.
        @param	side	A code indicating which side of the cube to upload:
        positive X : 0
        negative X : 1
        positive Y : 2
        negative Y : 3
        positive Z : 4
        negative Z : 5
        @param	miplevel	the mip level to be loaded, level zero is the top-level,
        full-resolution image.
        @throws	TypeError	Null Pointer Error: when data is null.
        @throws	ArgumentError	Miplevel Too Large: if the specified mip level is greater than that implied by the Texture's dimensions.
        @throws	RangeError	Bad Input Size: if the number of bytes available from byteArrayOffset to the end of the data byte array is less than the amount of data required for a texture of this mip level or if byteArrayOffset is greater than or equal to the length of data.
        @throws	ArgumentError	Texture Format Mismatch: if the texture format is Context3DTextureFormat.COMPRESSED or Context3DTextureFormat.COMPRESSED_ALPHA and the code is executing on a mobile platform where runtime texture compression is not supported.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromByteArray(data, byteArrayOffset, side, miplevel = 0) {
        // __backend.uploadFromByteArray(data, byteArrayOffset, side, miplevel);
    }
    /**
        Uploads a component of a cube map texture from an ArrayBufferView object.

        This uploads one mip level of one side of the cube map. Call
        `uploadFromTypedArray()` as necessary to upload each mip level and face of the
        cube map.

        @param	data	a typed array containing the image in the format specified when
        this CubeTexture object was created.
        @param	side	A code indicating which side of the cube to upload:
        positive X : 0
        negative X : 1
        positive Y : 2
        negative Y : 3
        positive Z : 4
        negative Z : 5
        @param	miplevel	the mip level to be loaded, level zero is the top-level,
        full-resolution image.
    **/
    uploadFromTypedArray(data, side, miplevel = 0) {
        // __backend.uploadFromTypedArray(data, side, miplevel);
    }
}

/**
    The Rectangle Texture class represents a 2-dimensional texture uploaded to a rendering
    context.

    Defines a 2D texture for use during rendering.

    Texture cannot be instantiated directly. Create instances by using Context3D
    `createRectangleTexture()` method.
**/
class RectangleTexture extends TextureBase {
    constructor(context, width, height, format, optimizeForRenderToTexture) {
        super(context, width, height, format, optimizeForRenderToTexture, 0);
    }
    /**
        Uploads a texture from a BitmapData object.

        @param	source	a bitmap.
        @throws	TypeError	Null Pointer Error: when `source` is `null`.
        @throws	ArgumentError	Invalid BitmapData Error: when `source` does not contain a
        valid texture. The maximum allowed size in any dimension is 4096 or the size of the
        backbuffer, whichever is greater.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromBitmapData(source) {
        // __backend.uploadFromBitmapData(source);
    }
    /**
        Uploads a texture from a ByteArray.

        @param	data	a byte array that is contains enough bytes in the textures internal
        format to fill the texture. rgba textures are read as bytes per texel component (1
        or 4). float textures are read as floats per texel component (1 or 4). The
        ByteArray object must use the little endian format.
        @param	byteArrayOffset	the position in the byte array object at which to start
        reading the texture data.
        @throws	TypeError	Null Pointer Error: when `data` is `null`.
        @throws	RangeError	Bad Input Size: if the number of bytes available from
        `byteArrayOffset` to the end of data byte array is less than the amount of data
        required for a texture, or if `byteArrayOffset` is greater than or equal to the
        length of data.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromByteArray(data, byteArrayOffset) {
        // __backend.uploadFromByteArray(data, byteArrayOffset);
    }
    /**
        Uploads a texture from an ArrayBufferView.

        @param	data	a typed array that contains enough bytes in the textures internal
        format to fill the texture. rgba textures are read as bytes per texel component (1
        or 4). float textures are read as floats per texel component (1 or 4).
    **/
    uploadFromTypedArray(data) {
        // __backend.uploadFromTypedArray(data);
    }
}

/**
    The Texture class represents a 2-dimensional texture uploaded to a rendering context.

    Defines a 2D texture for use during rendering.

    Texture cannot be instantiated directly. Create instances by using Context3D
    `createTexture()` method.
**/
class Texture extends TextureBase {
    constructor(context, width, height, format, optimizeForRenderToTexture, streamingLevels) {
        super(context, width, height, format, optimizeForRenderToTexture, streamingLevels);
    }
    /**
        Uploads a compressed texture in Adobe Texture Format (ATF) from a ByteArray
        object. ATF file version 2 requires SWF version 21 or newer and ATF file version 3
        requires SWF version 29 or newer. For ATF files created with png image without
        alpha the format string given during Context3DObject `createTexture` should be
        `"COMPRESSED"` and for ATF files created with png image with alpha the format
        string given during Context3DObject `createTexture` should be `"COMPRESSED_ALPHA"`.

        @param	data	a byte array that contains a compressed texture including mipmaps.
        The ByteArray object must use the little endian format.
        @param	byteArrayOffset	the position in the byte array at which to start reading
        the texture data.
        @param	async	If true, this returns immediately. Any draw method which
        attempts to use the texture will fail until the upload completes successfully.
        Upon successful upload, this CubeTexture object dispatches `Event.TEXTURE_READY`.
        Default value: `false`.
        @throws	TypeError	Null Pointer Error: when `data` is `null`.
        @throws	ArgumentError	Texture Decoding Failed: when the compression format of
        this object cannot be derived from the format of the compressed data in data or
        when the SWF version is incompatible with the ATF file version.
        @throws	ArgumentError	Texture Size Does Not Match: when the width and height of
        the decompressed texture do not equal the dimensions of this Texture object.
        @throws	ArgumentError	Miplevel Too Large: if the mip level of the decompressed
        texture is greater than that implied by the size of the texture.
        @throws	ArgumentError	Texture Format Mismatch: if the decoded ATF bytes don't
        contain a texture compatible with this texture's format.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
        @throws	RangeError	Bad Input Size: when there is integer overflow of
        `byteArrayOffset` or if `byteArrayOffset` + 6 is greater than the length of `data`,
        or if the number of bytes available from `byteArrayOffset` to the end of the `data`
        byte array is less than the amount of data required for ATF texture.
    **/
    uploadCompressedTextureFromByteArray(data, byteArrayOffset, async = false) {
        // __backend.uploadCompressedTextureFromByteArray(data, byteArrayOffset, async);
    }
    /**
        Uploads a texture from a BitmapData object.

        @param	source	a bitmap.
        @param	miplevel	the mip level to be loaded, level zero being the top-level
        full-resolution image.
        @throws	TypeError	Null Pointer Error: when `source` is `null`.
        @throws	ArgumentError	Miplevel Too Large: if the specified mip level is greater
        than that implied by the larger of the Texture's dimensions.
        @throws	ArgumentError	Invalid BitmapData Error: if `source` if the BitmapData
        object does not contain a valid cube texture face. The image must have sides equal
        to a power of two, and the correct size for the miplevel specified.
        @throws	ArgumentError	Texture Format Mismatch: if the texture format is
        Context3DTextureFormat.COMPRESSED or Context3DTextureFormat.COMPRESSED_ALPHA and
        the code is executing on a mobile platform where runtime texture compression is
        not supported.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromBitmapData(source, miplevel = 0, generateMipmap = false) {
        // __backend.uploadFromBitmapData(source, miplevel, generateMipmap);
    }
    /**
        Uploads a texture from a ByteArray.

        @param	data	a byte array that is contains enough bytes in the textures
        internal format to fill the texture. rgba textures are read as bytes per texel
        component (1 or 4). float textures are read as floats per texel component (1 or 4).
        The ByteArray object must use the little endian format.
        @param	byteArrayOffset	the position in the byte array object at which to start
        reading the texture data.
        @param	miplevel	the mip level to be loaded, level zero is the top-level,
        full-resolution image.
        @throws	TypeError	Null Pointer Error: when `data` is `null`.
        @throws	ArgumentError	Miplevel Too Large: if the specified mip level is greater
        than that implied by the larger of the Texture's dimensions.
        @throws	RangeError	Bad Input Size: if the number of bytes available from
        `byteArrayOffset` to the end of the data byte array is less than the amount of data
        required for a texture of this mip level or if `byteArrayOffset` is greater than or
        equal to the length of data.
        @throws	ArgumentError	Texture Format Mismatch: if the texture format is
        Context3DTextureFormat.COMPRESSED or Context3DTextureFormat.COMPRESSED_ALPHA and
        the code is executing on a mobile platform where runtime texture compression is not
        supported.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromByteArray(data, byteArrayOffset, miplevel = 0) {
        // __backend.uploadFromByteArray(data, byteArrayOffset, miplevel);
    }
    /**
        Uploads a texture from an ArrayBufferView.

        @param	data	a typed array that contains enough bytes in the textures
        internal format to fill the texture. rgba textures are read as bytes per texel
        component (1 or 4). float textures are read as floats per texel component (1 or 4).
        @param	miplevel	the mip level to be loaded, level zero is the top-level,
        full-resolution image.
    **/
    uploadFromTypedArray(data, miplevel = 0) {
        // __backend.uploadFromTypedArray(data, miplevel);
    }
}

/**
    Prior to Flash Player 21, the use of video in Stage3D required the use of the Video
    object (which is not hardware accelerated), copying of video frame to a BitmapData
    object, and loading of the data onto the GPU which is CPU intensive. Thus, Video
    texture object was introduced. It allows hardware decoded video to be used in Stage 3D
    content.

    For Flash Player 22, video texture objects were added to support NetStream and Cameras
    in a manner consistent/ similar to StageVideo. Such textures can be used as source
    textures in the stage3D rendering pipeline. The textures can be used as rectangular,
    RGB, no mipmap textures in the rendering of a scene. They are treated as ARGB texture
    by the shaders (that is, the AGAL shaders do not have to bother about YUV->RGB
    conversion) and so the standard shaders with static images can be used without change.
    The image used by the rendering pipeline is the latest up-to-date frame at the time the
    rendering occurs using this texture. There is no tearing in a video frame, however if
    the same texture is used several times, some of the instances may be from different
    timestamps.
**/
class VideoTexture extends TextureBase {
    constructor(context) {
        super(context, 0, 0, null, false, 0);
    }
    /**
        Specifies a video stream from a camera to be rendered within the texture of the
        VideoTexture object.

        Use this method to attach live video captured by the user to the VideoTexture
        object. To drop the connection to the VideoTexture object, set the value of the
        `theCamera` parameter to `null`.

        @param	theCamera
    **/
    // public attachCamera(theCamera:Camera):Void {}
    /**
        Specifies a video stream to be rendered within the texture of the VideoTexture
        object.

        A video file can be stored on the local file system or on Flash Media Server. If
        the value of the netStream argument is `null`, the video is no longer played in the
        VideoTexture object.

        @param	netStream
    **/
    attachNetStream(netStream) {
        // __backend.attachNetStream(netStream);
    }
    dispose() {
        // __backend.dispose();
    }
    // Get & Set Methods
    /**
        An integer specifying the height of the video stream, in pixels.

        For a live stream, this value is the same as the Camera.height property of the
        Camera object that is capturing the video stream. For a recorded video file, this
        value is the height of the video. The `NetStream.Video.DimensionChange` event is
        dispatched in the case of recorded videos when this value changes.
    **/
    get videoHeight() {
        return this.__videoHeight;
    }
    /**
        An integer specifying the width of the video stream, in pixels.

        For a live stream, this value is the same as the Camera.width property of the
        Camera object that is capturing the video stream. For a recorded video file, this
        value is the width of the video. The `NetStream.Video.DimensionChange` event is
        dispatched in the case of recorded videos when this value changes.
    **/
    get videoWidth() {
        return this.__videoWidth;
    }
}

var openfl$s;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying the buffer usage type.
        **/
        let Context3DBufferUsage;
        (function (Context3DBufferUsage) {
            /**
                Indicates the buffer will be used for drawing and be updated frequently
            **/
            Context3DBufferUsage["DYNAMIC_DRAW"] = "dynamicDraw";
            /**
                Indicates the buffer will be used for drawing and be updated once
    
                This type is the default value for buffers in `Stage3D`.
            **/
            Context3DBufferUsage["STATIC_DRAW"] = "staticDraw";
        })(Context3DBufferUsage = display3D.Context3DBufferUsage || (display3D.Context3DBufferUsage = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$s || (openfl$s = {}));
var Context3DBufferUsage = openfl$s.display3D.Context3DBufferUsage;

var openfl$t;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying Context3D clear masks.
        **/
        let Context3DClearMask;
        (function (Context3DClearMask) {
            /**
                Clear all buffers.
            **/
            Context3DClearMask[Context3DClearMask["ALL"] = 7] = "ALL";
            /**
                Clear only the color buffer.
            **/
            Context3DClearMask[Context3DClearMask["COLOR"] = 1] = "COLOR";
            /**
                Clear only the depth buffer.
            **/
            Context3DClearMask[Context3DClearMask["DEPTH"] = 2] = "DEPTH";
            /**
                Clear only the stencil buffer.
            **/
            Context3DClearMask[Context3DClearMask["STENCIL"] = 4] = "STENCIL";
        })(Context3DClearMask = display3D.Context3DClearMask || (display3D.Context3DClearMask = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$t || (openfl$t = {}));
var Context3DClearMask = openfl$t.display3D.Context3DClearMask;

var openfl$u;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying the Context3D profile.
        **/
        let Context3DProfile;
        (function (Context3DProfile) {
            /**
                Use the default feature support profile.
    
                This profile most closely resembles Stage3D support used in previous releases.
            **/
            Context3DProfile["BASELINE"] = "baseline";
            /**
                Use a constrained feature support profile to target older GPUs
    
                This profile is primarily targeted at devices that only support PS_2.0 level
                shaders like the Intel GMA 9xx series. In addition, this mode tries to improve
                memory bandwidth usage by rendering directly into the back buffer. There are
                several side effects:
    
                * You are limited to 64 ALU and 32 texture instructions per shader.
                * Only four texture read instructions per shader.
                * No support for predicate register. This affects sln/sge/seq/sne, which you
                replace with compound mov/cmp instructions, available with ps_2_0.
                * The Context3D back buffer must always be within the bounds of the stage.
                * Only one instance of a Context3D running in Constrained profile is allowed
                within a Flash Player instance.
                * Standard display list list rendering is driven by `Context3D.present()` instead of
                being based on the SWF frame rate. That is, if a Context3D object is active and
                visible you must call `Context3D.present()` to render the standard display list.
                * Reading back from the back buffer through `Context3D.drawToBitmapData()` might
                include parts of the display list content. Alpha information will be lost.
            **/
            Context3DProfile["BASELINE_CONSTRAINED"] = "baselineConstrained";
            /**
                Use an extended feature support profile to target newer GPUs which support larger
                textures
    
                This profile increases the maximum 2D Texture and RectangleTexture size to 4096x4096
            **/
            Context3DProfile["BASELINE_EXTENDED"] = "baselineExtended";
            /**
                Use an standard profile to target GPUs which support MRT, AGAL2 and float textures.
    
                This profile supports 4 render targets. Increase AGAL commands and register count.
                Add float textures.
            **/
            Context3DProfile["STANDARD"] = "standard";
            /**
                Use an standard profile to target GPUs which support AGAL2 and float textures.
    
                This profile is an alternative to standard profile, which removes MRT and a few
                features in AGAL2 but can reach more GPUs.
            **/
            Context3DProfile["STANDARD_CONSTRAINED"] = "standardConstrained";
            /**
                Use standard extended profile to target GPUs which support AGAL3 and instanced
                drawing feature.
    
                This profile extends the standard profile.
    
                This profile is enabled on mobile platforms from AIR 17.0 and on Windows and Mac
                from AIR 18.0.
            **/
            Context3DProfile["STANDARD_EXTENDED"] = "standardExtended";
        })(Context3DProfile = display3D.Context3DProfile || (display3D.Context3DProfile = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$u || (openfl$u = {}));
var Context3DProfile = openfl$u.display3D.Context3DProfile;

var openfl$v;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying a Program3D source format.
        **/
        let Context3DProgramFormat;
        (function (Context3DProgramFormat) {
            /**
                The program will use the AGAL (Adobe Graphics Assembly Language) format
            **/
            Context3DProgramFormat["AGAL"] = "agal";
            /**
                The program will use the GLSL (GL Shader Language) format
            **/
            Context3DProgramFormat["GLSL"] = "glsl";
        })(Context3DProgramFormat = display3D.Context3DProgramFormat || (display3D.Context3DProgramFormat = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$v || (openfl$v = {}));
var Context3DProgramFormat = openfl$v.display3D.Context3DProgramFormat;

var openfl$w;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying whether a shader program is a fragment
            or a vertex program.
        **/
        let Context3DProgramType;
        (function (Context3DProgramType) {
            /**
                A fragment (or pixel) program.
            **/
            Context3DProgramType["FRAGMENT"] = "fragment";
            /**
                A vertex program.
            **/
            Context3DProgramType["VERTEX"] = "vertex";
        })(Context3DProgramType = display3D.Context3DProgramType || (display3D.Context3DProgramType = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$w || (openfl$w = {}));
var Context3DProgramType = openfl$w.display3D.Context3DProgramType;

var openfl$x;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying vertex buffers.
        **/
        let Context3DVertexBufferFormat;
        (function (Context3DVertexBufferFormat) {
            Context3DVertexBufferFormat["BYTES_4"] = "bytes4";
            Context3DVertexBufferFormat["FLOAT_1"] = "float1";
            Context3DVertexBufferFormat["FLOAT_2"] = "float2";
            Context3DVertexBufferFormat["FLOAT_3"] = "float3";
            Context3DVertexBufferFormat["FLOAT_4"] = "float4";
        })(Context3DVertexBufferFormat = display3D.Context3DVertexBufferFormat || (display3D.Context3DVertexBufferFormat = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$x || (openfl$x = {}));
var Context3DVertexBufferFormat = openfl$x.display3D.Context3DVertexBufferFormat;

/**
    IndexBuffer3D is used to represent lists of vertex indices comprising graphic elements
    retained by the graphics subsystem.

    Indices managed by an IndexBuffer3D object may be used to select vertices from a
    vertex stream. Indices are 16-bit unsigned integers. The maximum allowable index
    value is 65535 (0xffff). The graphics subsystem does not retain a reference to
    vertices provided to this object. Data uploaded to this object may be modified or
    discarded without affecting the stored values.

    IndexBuffer3D cannot be instantiated directly. Create instances by using
    `context3D.createIndexBuffer()`
**/
class IndexBuffer3D {
    constructor(context3D, numIndices, bufferUsage) {
        this.__context = context3D;
        this.__numIndices = numIndices;
        this.__bufferUsage = bufferUsage;
        // __backend = new IndexBuffer3DBackend(this);
    }
    /**
        Free all native GPU resources associated with this object. No `upload()` calls
        on this object will work and using the object in rendering will also fail.
    **/
    dispose() {
        // __backend.dispose();
    }
    /**
        Store in the graphics subsystem vertex indices.

        @param	data	a ByteArray containing index data. Each index is represented by
        16-bits (two bytes) in the array. The number of bytes in data should be
        `byteArrayOffset` plus two times count.
        @param	byteArrayOffset	offset, in bytes, into the data ByteArray from where to
        start reading.
        @param	startOffset	The index in this IndexBuffer3D object of the first index to
        be loaded in this IndexBuffer3D object. A value for `startIndex` not equal to zero
        may be used to load a sub-region of the index data.
        @param	count	The number of indices represented by data.
        @throws	TypeError	kNullPointerError when data is null.
        @throws	RangeError	kBadInputSize when any of `count`, `byteArrayOffset`, or
        `startOffset` is less than 0, or if `byteArrayOffset` is greater than or equal
        to the length of data, or if two times count plus `byteArrayOffset` is greater
        than the length of data, or if `startOffset + count` is greater than `numIndices`
        given in `context3D.createIndexBuffer()`.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromByteArray(data, byteArrayOffset, startOffset, count) {
        // __backend.uploadFromByteArray(data, byteArrayOffset, startOffset, count);
    }
    /**
        Store in the graphics subsystem vertex indices.

        @param	data	an ArrayBufferView containing index data. Each index is represented by
        16-bits (two bytes) in the array.
        @param	byteLength	The number of bytes to read.
    **/
    uploadFromTypedArray(data, byteLength = -1) {
        // __backend.uploadFromTypedArray(data, byteLength);
    }
    /**
        Store in the graphics subsystem vertex indices.

        @param	data	a vector of vertex indices. Only the low 16 bits of each index
        value are used. The length of the vector must be greater than or equal to count.
        @param	startOffset	The index in this IndexBuffer3D object of the first index to
        be loaded. A value for startOffset not equal to zero may be used to load a
        sub-region of the index data.
        @param	count	The number of indices in `data`.
        @throws	TypeError	kNullPointerError when `data` is `null`.
        @throws	RangeError	kBadInputSize when `count is less than 0 or greater than the
        length of `data`, or when `startOffset + count` is greater than `numIndices`
        given in `context3D.createIndexBuffer()`.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromVector(data, startOffset, count) {
        // __backend.uploadFromVector(data, startOffset, count);
    }
}

/**
    The Program3D class represents a pair of rendering programs (also called "shaders")
    uploaded to the rendering context.

    Programs managed by a Program3D object control the entire rendering of triangles
    during a Context3D drawTriangles() call. Upload the binary bytecode to the rendering
    context using the upload method. (Once uploaded, the program in the original byte
    array is no longer referenced; changing or discarding the source byte array does
    not change the program.)

    Programs always consist of two linked parts: A vertex and a fragment program.

    1. The vertex program operates on data defined in VertexBuffer3D objects and is
    responsible for projecting vertices into clip space and passing any required vertex
    data, such as color, to the fragment shader.
    2. The fragment shader operates on the attributes passed to it by the vertex program
    and produces a color for every rasterized fragment of a triangle, resulting in pixel
    colors. Note that fragment programs have several names in 3D programming literature,
    including fragment shader and pixel shader.

    Designate which program pair to use for subsequent rendering operations by passing the
    corresponding Program3D instance to the Context3D `setProgram()` method.

    You cannot create a Program3D object directly; use the Context3D `createProgram()`
    method instead.
**/
class Program3D {
    /** @hidden */
    constructor(context3D, format) {
        this.__context = context3D;
        this.__format = format;
        this.__samplerStates = new Array();
        // __backend = new Program3DBackend(this);
    }
    /**
        Frees all resources associated with this object. After disposing a
        Program3D object, calling `upload()` and rendering using this object will fail.
    **/
    dispose() {
        // __backend.dispose();
    }
    /**
        **BETA**

        Get the index for the specified shader attribute.

        @returns	The index, or -1 if the attribute is not bound or
        was not found in the shader sources
    **/
    getAttributeIndex(name) {
        switch (this.__format) {
            case Context3DProgramFormat.AGAL:
                // TODO: Validate that it exists in the current program
                if (name.startsWith("va")) {
                    return parseFloat(name.substring(2));
                }
                else {
                    return -1;
                }
            case Context3DProgramFormat.GLSL:
                // return __backend.getGLSLAttributeIndex(name);
                return 0;
            default:
                return -1;
        }
    }
    /**
        **BETA**

        Get the index for the specified shader constant.

        @returns	The index, or -1 if the constant is not bound or
        was not found in the shader sources
    **/
    getConstantIndex(name) {
        switch (this.__format) {
            case Context3DProgramFormat.AGAL:
                // TODO: Validate that it exists in the current program
                if (name.startsWith("vc")) {
                    return parseFloat(name.substring(2));
                }
                else if (name.startsWith("fc")) {
                    return parseFloat(name.substring(2));
                }
                else {
                    return -1;
                }
            case Context3DProgramFormat.GLSL:
                // return __backend.getGLSLConstantIndex(name);
                return 0;
            default:
                return -1;
        }
    }
    /**
        Uploads a pair of rendering programs expressed in AGAL (Adobe Graphics Assembly
        Language) bytecode.

        Program bytecode can be created using the Pixel Bender 3D offline tools. It can
        also be created dynamically. The AGALMiniAssembler class is a utility class
        that compiles AGAL assembly language programs to AGAL bytecode. The class is not
        part of the runtime. When you upload the shader programs, the bytecode is
        compiled into the native shader language for the current device (for example,
        OpenGL or Direct3D). The runtime validates the bytecode on upload.

        The programs run whenever the Context3D `drawTriangles()` method is invoked. The
        vertex program is executed once for each vertex in the list of triangles to be
        drawn. The fragment program is executed once for each pixel on a triangle surface.

        The "variables" used by a shader program are called registers. The following
        registers are defined:

        | Name | Number per Fragment program | Number per Vertex program | Purpose |
        | --- | --- | --- | --- |
        | Attribute | n/a | 8 | Vertex shader input; read from a vertex buffer specified using `Context3D.setVertexBufferAt()`. |
        | Constant | 28 | 128 | Shader input; set using the `Context3D.setProgramConstants()` family of functions. |
        | Temporary | 8 | 8 | Temporary register for computation, not accessible outside program. |
        | Output | 1 | 1 | Shader output: in a vertex program, the output is the clipspace position; in a fragment program, the output is a color. |
        | Varying | 8 | 8 | Transfer interpolated data between vertex and fragment shaders. The varying registers from the vertex program are applied as input to the fragment program. Values are interpolated according to the distance from the triangle vertices. |
        | Sampler | 8 | n/a | Fragment shader input; read from a texture specified using `Context3D.setTextureAt()` |

        A vertex program receives input from two sources: vertex buffers and constant
        registers. Specify which vertex data to use for a particular vertex attribute
        register using the Context3D `setVertexBufferAt()` method. You can define up to
        eight input registers for vertex attributes. The vertex attribute values are read
        from the vertex buffer for each vertex in the triangle list and placed in the
        attribute register. Specify constant registers using the Context3D
        `setProgramConstantsFromMatrix()` or `setProgramConstantsFromVector()`
        methods. Constant registers retain the same value for every vertex in the
        triangle list. (You can only modify the constant values between calls to
        `drawTriangles().`)

        The vertex program is responsible for projecting the triangle vertices into
        clip space (the canonical viewing area within ±1 on the x and y axes and 0-1 on
        the z axis) and placing the transformed coordinates in its output register.
        (Typically, the appropriate projection matrix is provided to the shader in a set
        of constant registers.) The vertex program must also copy any vertex attributes
        or computed values needed by the fragment program to a special set of variables
        called varying registers. When a fragment shader runs, the value supplied in a
        varying register is linearly interpolated according to the distance of the
        current fragment from each triangle vertex.

        A fragment program receives input from the varying registers and from a separate
        set of constant registers (set with `setProgramConstantsFromMatrix()` or
        `setProgramConstantsFromVector()`). You can also read texture data from textures
        uploaded to the rendering context using sampler registers. Specify which texture
        to access with a particular sampler register using the Context3D `setTextureAt()`
        method. The fragment program is responsible for setting its output register to a
        color value.

        @param	vertexProgram	AGAL bytecode for the Vertex program. The ByteArray object
        must use the little endian format.
        @param	fragmentProgram	AGAL bytecode for the Fragment program. The ByteArray
        object must use the little endian format.
        @throws	TypeError	Null Pointer Error: if vertexProgram or fragmentProgram is
        `null`.
        @throws	Error	Object Disposed: if the Program3D object was disposed either
        directly by a call to `dispose()`, or indirectly by calling the Context3D
        `dispose()` or because the rendering context was disposed because of device loss.
        @throws	ArgumentError	Agal Program Too Small: when either program code array
        is smaller than 31 bytes length. This is the size of the shader bytecode of a
        one-instruction program.
        @throws	ArgumentError	Program Must Be Little Endian: if either of the program
        byte code arrays is not little endian.
        @throws	Error	Native Shader Compilation Failed: if the output of the AGAL
        translator is not a compilable native shader language program. This error is only
        thrown in release players.
        @throws	Error	Native Shader Compilation Failed OpenGL: if the output of the
        AGAL translator is not a compilable OpengGL shader language program, and
        includes compilation diagnostics. This error is only thrown in debug players.
        @throws	Error	Native Shader Compilation Failed D3D9: if the output of the AGAL
        translator is not a compilable Direct3D shader language program, and includes
        compilation diagnostics. This error is only thrown in debug players.

        The following errors are thrown when the AGAL bytecode validation fails:

        @throws	Error	Not An Agal Program: if the header "magic byte" is wrong. The
        first byte of the bytecode must be 0xa0. This error can indicate that the byte
        array is set to the wrong endian order.
        @throws	Error	Bad Agal Version: if the AGAL version is not supported by the
        current SWF version. The AGAL version must be set to 1 for SWF version 13.
        @throws	Error	Bad Agal Program Type: if the AGAL program type identifier is
        not valid. The third byte in the byte code must be 0xa1. This error can indicates
        that the byte array is set to the wrong endian order.
        @throws	Error	Bad Agal Shader Type: if the shader type code is not either
        fragment or vertex (1 or 0).
        @throws	Error	Invalid Agal Opcode Out Of Range: if an invalid opcode is
        encountered in the token stream.
        @throws	Error	Invalid Agal Opcode Not Implemented: if an invalid opcode is
        encountered in the token stream.
        @throws	Error	Agal Opcode Only Allowed In Fragment Program: if an opcode is
        encountered in the token stream of the vertex program that is only allowed in fragment programs, such as KIL or TEX.
        @throws	Error	Bad Agal Source Operands: if both source operands are constant
        registers. You must compute the result outside the shader program and pass it
        in using a single constant register.
        @throws	Error	Both Operands Are Indirect Reads: if both operands are indirect
        reads.
        @throws	Error	Opcode Destination Must Be All Zero: if a token with an opcode
        (such as KIL) that has no destination sets a non-zero value for the destination
        register.
        @throws	Error	Opcode Destination Must Use Mask: if an opcode that produces
        only a 3 component result is used without masking.
        @throws	Error	Too Many Tokens: if there are too many tokens (more than 200) in
        an AGAL program.
        @throws	Error	Fragment Shader Type: if the fragment program type (byte 6 of
        fragmentProgram parameter) is not set to 1.
        @throws	Error	Vertex Shader Type: if the vertex program type (byte 6 of
        vertexProgram parameter) is not set to 0.
        @throws	Error	Varying Read But Not Written To: if the fragment shader reads a
        varying register that was never written to by the vertex shader.
        @throws	Error	Varying Partial Write: if a varying register is only partially
        written to. All components of a varying register must be written to.
        @throws	Error	Fragment Write All Components: if a fragment color output is only
        partially written to. All four components of the color output must be written to.
        @throws	Error	Vertex Write All Components: if a vertex clip space output is only
        partially written to. All components of the vertex clip space output must be
        written to.
        @throws	Error	Unused Operand: if an unused operand in a token is not set to all
        zero.
        @throws	Error	Sampler Register Only In Fragment: if a texture sampler register
        is used in a vertex program.
        @throws	Error	Sampler Register Second Operand: if a sampler register is used
        as a destination or first operand of an AGAL token.
        @throws	Error	Indirect Only Allowed In Vertex: if indirect addressing is used
        in a fragment program.
        @throws	Error	Indirect Only Into Constant Registers: if indirect addressing
        is used on a non-constant register.
        @throws	Error	Indirect Source Type: if the indirect source type is not
        attribute, constant or temporary register.
        @throws	Error	Indirect Addressing Fields Must Be Zero: if not all indirect
        addressing fields are zero for direct addressing.
        @throws	Error	Varying Registers Only Read In Fragment: if a varying register is
        read in a vertex program. Varying registers can only be written in vertex
        programs and read in fragment programs.
        @throws	Error	Attribute Registers Only Read In Vertex: if an attribute
        registers is read in a fragment program. Attribute registers can only be read
        in vertex programs.
        @throws	Error	Can Not Read Output Register: if an output (position or color)
        register is read. Output registers can only be written to, not read.
        @throws	Error	Temp Register Read Without Write: if a temporary register is read
        without being written to earlier.
        @throws	Error	Temp Register Component Read Without Write: if a specific
        temporary register component is read without being written to earlier.
        @throws	Error	Sampler Register Cannot Be Written To: if a sampler register is
        written to. Sampler registers can only be read, not written to.
        @throws	Error	Varying Registers Write: if a varying register is written to in
        a fragment program. Varying registers can only be written in vertex programs and
        read in fragment programs.
        @throws	Error	Attribute Register Cannot Be Written To: if an attribute
        register is written to. Attribute registers are read-only.
        @throws	Error	Constant Register Cannot Be Written To: if a constant register
        is written to inside a shader program.
        @throws	Error	Destination Writemask Is Zero: if a destination writemask is
        zero. All components of an output register must be set.
        @throws	Error	AGAL Reserved Bits Should Be Zero: if any reserved bits in a
        token are not zero. This indicates an error in creating the bytecode (or
        malformed bytecode).
        @throws	Error	Unknown Register Type: if an invalid register type index is used.
        @throws	Error	Sampler Register Out Of Bounds: if an invalid sampler register
        index is used.
        @throws	Error	Varying Register Out Of Bounds: if an invalid varying register
        index is used.
        @throws	Error	Attribute Register Out Of Bounds: if an invalid attribute
        register index is used.
        @throws	Error	Constant Register Out Of Bounds: if an invalid constant
        register index is used.
        @throws	Error	Output Register Out Of Bounds: if an invalid output register
        index is used.
        @throws	Error	Temporary Register Out Of Bounds: if an invalid temporary
        register index is used.
        @throws	Error	Cube Map Sampler Must Use Clamp: if a cube map sampler does not
        set the wrap mode to clamp.
        @throws	Error	Unknown Sampler Dimension: if a sample uses an unknown sampler
        dimension. (Only 2D and cube textures are supported.)
        @throws	Error	Unknown Filter Mode: if a sampler uses an unknown filter mode.
        (Only nearest neighbor and linear filtering are supported.)
        @throws	Error	Unknown Mipmap Mode: if a sampler uses an unknown mipmap mode.
        (Only none, nearest neighbor, and linear mipmap modes are supported.)
        @throws	Error	Unknown Wrapping Mode if a sampler uses an unknown wrapping mode.
        (Only clamp and repeat wrapping modes are supported.)
        @throws	Error	Unknown Special Flag: if a sampler uses an unknown special flag.
        @throws	Error	Output Color Not Maskable: You cannot mask the color output
        register in a fragment program. All components of the color register must be set.
        @throws	Error	Second Operand Must Be Sampler Register: The AGAL tex opcode must
        have a sampler as the second source operand.
        @throws	Error	Indirect Not Allowed: indirect addressing used where not allowed.
        @throws	Error	Swizzle Must Be Scalar: swizzling error.
        @throws	Error	Cant Swizzle 2nd Source: swizzling error.
        @throws	Error	Second Use Of Sampler Must Have Same Params: all samplers that
        access the same texture must use the same dimension, wrap, filter, special, and
        mipmap settings.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    upload(vertexProgram, fragmentProgram) {
        // __backend.upload(vertexProgram, fragmentProgram);
    }
    /**
        **BETA**

        Uploads a pair of rendering programs expressed in GLSL (GL Shader Language).
    **/
    uploadSources(vertexSource, fragmentSource) {
        // __backend.uploadSources(vertexSource, fragmentSource);
    }
    __getSamplerState(sampler) {
        return this.__samplerStates[sampler];
    }
    __markDirty(isVertex, index, count) {
        // __backend.markDirty(isVertex, index, count);
    }
    __setSamplerState(sampler, state) {
        this.__samplerStates[sampler] = state;
    }
}

/**
    The VertexBuffer3D class represents a set of vertex data uploaded to a rendering context.

    Use a VertexBuffer3D object to define the data associated with each point in a set
    of vertexes. You can upload the vertex data either from a Vector array or a ByteArray.
    (Once uploaded, the data in the original array is no longer referenced; changing or
    discarding the source array does not change the vertex data.)

    The data associated with each vertex is in an application-defined format and is used
    as the input for the vertex shader program. Identify which values belong to which
    vertex program input using the Context3D `setVertexBufferAt()` function. A vertex
    program can use up to eight inputs (also known as vertex attribute registers). Each
    input can require between one and four 32-bit values. For example, the [x,y,z]
    position coordinates of a vertex can be passed to a vertex program as a vector
    containing three 32 bit values. The Context3DVertexBufferFormat class defines
    constants for the supported formats for shader inputs. You can supply up to
    sixty-four 32-bit values (256 bytes) of data for each point (but a single vertex
    shader cannot use all of the data in this case).

    The `setVertexBufferAt()` also identifies which vertex buffer to use for
    rendering any subsequent `drawTriangles()` calls. To render data from a different
    vertex buffer, call setVertexBufferAt() again with the appropriate arguments. (You
    can store data for the same point in multiple vertex buffers, say position data in
    one buffer and texture coordinates in another, but typically rendering is more
    efficient if all the data for a point comes from a single buffer.)

    The Index3DBuffer object passed to the Context3D `drawTriangles()` method organizes
    the vertex data into triangles. Each value in the index buffer is the index to a
    vertex in the vertex buffer. A set of three indexes, in sequence, defines a triangle.

    You cannot create a VertexBuffer3D object directly. Use the Context3D
    `createVertexBuffer()` method instead.

    To free the render context resources associated with a vertex buffer, call the object's
    `dispose()` method.
**/
class VertexBuffer3D {
    constructor(context3D, numVertices, dataPerVertex, bufferUsage) {
        this.__context = context3D;
        this.__numVertices = numVertices;
        this.__dataPerVertex = dataPerVertex;
        this.__bufferUsage = bufferUsage;
        // __backend = new VertexBuffer3DBackend(this);
    }
    /**
        Frees all resources associated with this object. After disposing a vertex
        buffer, calling `upload()` and rendering using this object will fail.
    **/
    dispose() {
        // __backend.dispose();
    }
    /**
        Uploads the data for a set of points to the rendering context from a byte array.

        @param	data	a byte array containing the vertex data. Each data value is four
        bytes long. The number of values in a vertex is specified at buffer creation
        using the data32PerVertex parameter to the Context3D `createVertexBuffer3D()`
        method. The length of the data in bytes must be `byteArrayOffset` plus four times
        the number of values per vertex times the number of vertices. The ByteArray object
        must use the little endian format.
        @param	byteArrayOffset	number of bytes to skip from the beginning of data
        @param	startVertex	The index of the first vertex to be loaded. A value for
        startVertex not equal to zero may be used to load a sub-region of the vertex data.
        @param	numVertices	The number of vertices to be loaded from data.
        @throws	TypeError	Null Pointer Error: when data is `null`.
        @throws	RangeError	Bad Input Size: if `byteArrayOffset` is less than 0, or if
        `byteArrayOffset` is greater than or equal to the length of data, or if no. of
        elements in data - `byteArrayOffset` is less than `numVertices*data32pervertex*4`
        given in Context3D `createVertexBuffer()`.
        @throws	Error	3768: The Stage3D API may not be used during background execution.
    **/
    uploadFromByteArray(data, byteArrayOffset, startVertex, numVertices) {
        // __backend.uploadFromByteArray(data, byteArrayOffset, startVertex, numVertices);
    }
    /**
        Uploads the data for a set of points to the rendering context from a typed array.

        @param	data	a typed array of 32-bit values. A single vertex is comprised of a
        number of values stored sequentially in the vector. The number of values in a
        vertex is specified at buffer creation using the `data32PerVertex` parameter to the
        Context3D `createVertexBuffer3D()` method.
        @param	byteLength	The number of bytes to read.
    **/
    uploadFromTypedArray(data, byteLength = -1) {
        // __backend.uploadFromTypedArray(data, byteLength);
    }
    /**
        Uploads the data for a set of points to the rendering context from a vector array.

        @param	data	a vector of 32-bit values. A single vertex is comprised of a
        number of values stored sequentially in the vector. The number of values in a
        vertex is specified at buffer creation using the data32PerVertex parameter to the
        Context3D `createVertexBuffer3D()` method. The length of the vector must be the
        number of values per vertex times the number of vertexes.
        @param	startVertex	The index of the first vertex to be loaded. A value for
        `startVertex` not equal to zero may be used to load a sub-region of the vertex data.
        @param	numVertices	The number of vertices represented by data.
        @throws	TypeError	Null Pointer Error: when `data` is `null`.
        @throws	RangeError	Bad Input Size: when number of elements in data is less than
        `numVertices * data32PerVertex` given in Context3D `createVertexBuffer()`, or
        when `startVertex + numVertices` is greater than `numVertices` given in Context3D
        `createVertexBuffer()`.
    **/
    uploadFromVector(data, startVertex, numVertices) {
        // __backend.uploadFromVector(data, startVertex, numVertices);
    }
}

/**
    The IOError exception is thrown when some type of input or output failure
    occurs. For example, an IOError exception is thrown if a read/write
    operation is attempted on a socket that has not connected or that has
    become disconnected.
**/
class IOError extends Error$1 {
    /**
        Creates a new IOError object.

        @param message A string associated with the error object.
    **/
    constructor(message = "") {
        super(message);
        this.name = "IOError";
    }
}

/**
    An EOFError exception is thrown when you attempt to read past the end of
    the available data. For example, an EOFError is thrown when one of the read
    methods in the IDataInput interface is called and there is insufficient
    data to satisfy the read request.
**/
class EOFError extends IOError {
    /**
        Creates a new EOFError object.

        @param message A string associated with the error object.
    **/
    constructor(message = null, id = 0) {
        super("End of file was encountered");
        this.name = "EOFError";
        this.__errorID = 2030;
    }
}

/**
    The ObjectEncoding class is used in defining serialization settings in
    classes that serialize objects (such as FileStream, NetStream,
    NetConnection, SharedObject, and ByteArray).

    Object encoding controls how objects are represented in serialized
    formats, such as the Active Message Format (AMF) used by the Flash
    runtime. Flash Player uses AMF to enable efficient communication
    between an application and a remote server. AMF encodes remote procedure
    calls into a compact binary representation that can be transferred over
    HTTP/HTTPS or the RTMP/RTMPS protocol used by Flash Media Server.
    Objects and data values are serialized into this binary format, which
    is generally more compact than other representations, such as XML.

    OpenFL supports additional object encoding formats on non-Flash targets,
    including the Haxe Serialization Format (HXSF) and JavaScript Object
    Notation (JSON) for efficient communication for objects.

    Although AMF support is included in the Flash runtime, use of AMF on
    other targets requires the Haxe "format" library.

    _You can add the "format" library to your project by using
    `<haxelib name="format" />` in an OpenFL project XML file._

    Adobe AIR and Flash Player 9 can serialize in two different formats:
    AMF3 and AMF0. AMF3, the default serialization developed for
    ActionScript 3.0, provides various advantages over AMF0, which is used
    for ActionScript 1.0 and 2.0. AMF3 sends data over the network more
    efficiently than AMF0. AMF3 supports sending `int` and `uint` objects as
    integers and supports data types that are available only in
    ActionScript 3.0, such as ByteArray, XML, and IExternalizable. It is
    available only in ActionScript 3.0 and with servers that use AMF3
    encoding, such as Flex 2.

    The ByteArray, FileStream, NetConnection, NetStream, SharedObject,
    Socket, and URLStream classes contain an `objectEncoding` property that is
    assigned a constant from the ObjectEncoding class. The behavior of the
    `objectEncoding` property differs depending on the object; each class's
    `objectEncoding` property description explains the behavior more
    thoroughly.
**/
var ObjectEncoding;
(function (ObjectEncoding) {
    /**
        Specifies that objects are serialized using the
        Action Message Format for ActionScript 1.0 and 2.0.
    **/
    ObjectEncoding["AMF0"] = "amf0";
    /**
        Specifies that objects are serialized using the
        Action Message Format for ActionScript 3.0.
    **/
    ObjectEncoding["AMF3"] = "amf3";
    /**
        Specifies that objects are serialized using the
        Haxe Serialization Format.
    **/
    ObjectEncoding["HXSF"] = "hxsf";
    /**
        Specifies that objects are serialized using
        JavaScript Object Notation.
    **/
    ObjectEncoding["JSON"] = "json";
    /**
        Specifies the default format for the current target and runtime.

        Currently, the default on the Flash and AIR targets is AMF3, and
        the default on other targets is HXSF. If, in the future, a newer
        version of OpenFL introduces support for a new object encoding
        format, this may change. You can use this constant only if you're
        not concerned about interoperability with previous versions.
    **/
    ObjectEncoding["DEFAULT"] = "hxsf";
})(ObjectEncoding || (ObjectEncoding = {}));
var ObjectEncoding$1 = ObjectEncoding;

/**
    The CompressionAlgorithm class defines string constants for the names of
    compress and uncompress options. These constants are used as values of the
    `algorithm` parameter of the `ByteArray.compress()` and
    `ByteArray.uncompress()` methods.
**/
var CompressionAlgorithm;
(function (CompressionAlgorithm) {
    /**
        Defines the string to use for the deflate compression algorithm.
    **/
    CompressionAlgorithm["DEFLATE"] = "deflate";
    // GZIP;
    CompressionAlgorithm["LZMA"] = "lzma";
    /**
        Defines the string to use for the zlib compression algorithm.
    **/
    CompressionAlgorithm["ZLIB"] = "zlib";
})(CompressionAlgorithm || (CompressionAlgorithm = {}));
var CompressionAlgorithm$1 = CompressionAlgorithm;

/**
    The Endian class contains values that denote the byte order used to
    represent multibyte numbers. The byte order is either bigEndian (most
    significant byte first) or littleEndian (least significant byte first).

    OpenFL content can interface with a server by using the binary protocol of
    that server, directly. Some servers use the bigEndian byte order and some
    servers use the littleEndian byte order. Most servers on the Internet use
    the bigEndian byte order because "network byte order" is bigEndian. The
    littleEndian byte order is popular because the Intel x86 architecture uses
    it. Use the endian byte order that matches the protocol of the server that
    is sending or receiving data.
**/
var Endian;
(function (Endian) {
    /**
        Indicates the most significant byte of the multibyte number
        appears first in the sequence of bytes.

        The hexadecimal number 0x12345678 has 4 bytes (2 hexadecimal
        digits per byte). The most significant byte is 0x12. The
        least significant byte is 0x78. (For the equivalent decimal
        number, 305419896, the most significant digit is 3, and the
        least significant digit is 6).

        A stream using the bigEndian byte order (the most significant
        byte first) writes:

        ```
        12 34 56 78
        ```
    **/
    Endian["BIG_ENDIAN"] = "bigEndian";
    /**
        Indicates the least significant byte of the multibyte number
        appears first in the sequence of bytes.

        The hexadecimal number 0x12345678 has 4 bytes (2 hexadecimal
        digits per byte). The most significant byte is 0x12. The
        least significant byte is 0x78. (For the equivalent decimal
        number, 305419896, the most significant digit is 3, and the
        least significant digit is 6).

        A stream using the littleEndian byte order (the most
        significant byte first) writes:

        ```
        78 56 34 12
        ```
    **/
    Endian["LITTLE_ENDIAN"] = "littleEndian";
})(Endian || (Endian = {}));
var Endian$1 = Endian;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var common = createCommonjsModule(function (module, exports) {


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);
});
var common_1 = common.assign;
var common_2 = common.shrinkBuf;
var common_3 = common.setTyped;
var common_4 = common.Buf8;
var common_5 = common.Buf16;
var common_6 = common.Buf32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */



/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  common.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

var _tr_init_1  = _tr_init;
var _tr_stored_block_1 = _tr_stored_block;
var _tr_flush_block_1  = _tr_flush_block;
var _tr_tally_1 = _tr_tally;
var _tr_align_1 = _tr_align;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.







/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED$1               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN$1             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS$1      = 256;
/* number of literal bytes 0..255 */
var L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES$1       = 30;
/* number of distance codes */
var BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */
var MAX_BITS$1  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var MIN_LOOKAHEAD = (MAX_MATCH$1 + MIN_MATCH$1 + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = messages[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero$1(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  common.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  common.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH$1;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      common.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$1) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH$1) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH$1) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH$1 - 1)) ? s.strstart : MIN_MATCH$1 - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH$1) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH$1) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH$1);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero$1(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new common.Buf16(HEAP_SIZE$1 * 2);
  this.dyn_dtree  = new common.Buf16((2 * D_CODES$1 + 1) * 2);
  this.bl_tree    = new common.Buf16((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new common.Buf16(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new common.Buf16(2 * L_CODES$1 + 1);  /* heap used to build the Huffman trees */
  zero$1(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new common.Buf16(2 * L_CODES$1 + 1); //uch depth[2*L_CODES+1];
  zero$1(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$1;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED$1) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);

  s.window = new common.Buf8(s.w_size * 2);
  s.head = new common.Buf16(s.hash_size);
  s.prev = new common.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new common.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero$1(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero$1(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new common.Buf8(s.w_size);
    common.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2 = deflate;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

var deflate_1 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new common.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new common.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, common.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
var buf2binstring_1 = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
var binstring2buf = function (str) {
  var buf = new common.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
var buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2binstring: buf2binstring_1,
	binstring2buf: binstring2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH$1      = 0;
var Z_FINISH$1        = 4;

var Z_OK$1            = 0;
var Z_STREAM_END$1    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION$1 = -1;

var Z_DEFAULT_STRATEGY$1    = 0;

var Z_DEFLATED$1  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$1,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$1,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  var status = deflate_1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH$1 : Z_NO_FLUSH$1);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new common.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = deflate_1.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(common.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(common.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH$1) {
    status = deflate_1.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$1;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK$1);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$1) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1 = Deflate;
var deflate_2$1 = deflate$1;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;

var deflate_1$1 = {
	Deflate: Deflate_1,
	deflate: deflate_2$1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.



var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

var inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new common.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new common.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.







var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH$2        = 4;
var Z_BLOCK$1         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK$2            = 0;
var Z_STREAM_END$2    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR$1  = -2;
var Z_DATA_ERROR$1    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR$1     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED$2  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD$1 = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS$1 = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS$1;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new common.Buf16(320); /* temporary storage for code lengths */
  this.work = new common.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new common.Buf32(ENOUGH_LENS$1);
  state.distcode = state.distdyn = new common.Buf32(ENOUGH_DISTS$1);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$2;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$2) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new common.Buf32(512);
    distfix = new common.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS$1,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS$1, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new common.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    common.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    common.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      common.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new common.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE$1) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$2;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD$1;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED$2) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$1;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD$1;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE$1;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED$2) {
          strm.msg = 'unknown compression method';
          state.mode = BAD$1;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD$1;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              common.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE$1;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE$1;
        /* falls through */
      case TYPE$1:
        if (flush === Z_BLOCK$1 || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD$1;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD$1;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          common.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE$1;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD$1;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD$1;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD$1;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD$1;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD$1) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD$1;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD$1;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD$1;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE$1) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE$1;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$1;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD$1;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD$1;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD$1;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$2;
        break inf_leave;
      case BAD$1:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD$1 &&
                      (state.mode < CHECK || flush !== Z_FINISH$2))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE$1 ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$2) && ret === Z_OK$2) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$2;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$2;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$2;
}

var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2 = inflate;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

var inflate_1 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

var toString$1 = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = common.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  var status  = inflate_1.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== constants.Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== constants.Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? constants.Z_FINISH : constants.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new common.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1.inflate(strm, constants.Z_NO_FLUSH);    /* no bad return value */

    if (status === constants.Z_NEED_DICT && dictionary) {
      status = inflate_1.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === constants.Z_BUF_ERROR && allowBufError === true) {
      status = constants.Z_OK;
      allowBufError = false;
    }

    if (status !== constants.Z_STREAM_END && status !== constants.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === constants.Z_STREAM_END || (strm.avail_in === 0 && (_mode === constants.Z_FINISH || _mode === constants.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { common.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(common.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== constants.Z_STREAM_END);

  if (status === constants.Z_STREAM_END) {
    _mode = constants.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === constants.Z_FINISH) {
    status = inflate_1.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === constants.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === constants.Z_SYNC_FLUSH) {
    this.onEnd(constants.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === constants.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || messages[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1 = Inflate;
var inflate_2$1 = inflate$1;
var inflateRaw_1 = inflateRaw;
var ungzip  = inflate$1;

var inflate_1$1 = {
	Inflate: Inflate_1,
	inflate: inflate_2$1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip
};

var assign    = common.assign;





var pako = {};

assign(pako, deflate_1$1, inflate_1$1, constants);

var pako_1 = pako;

var pako$1 = {
	__proto__: null,
	'default': pako_1,
	__moduleExports: pako_1
};

/**
    The ByteArray class provides methods and properties to optimize reading,
    writing, and working with binary data.

    _Note:_ The ByteArray class is for advanced developers who need to
    access data on the byte level.

    In-memory data is a packed array (the most compact representation for
    the data type) of bytes, but an instance of the ByteArray class can be
    manipulated with the standard `[]`(array access) operators. It
    also can be read and written to as an in-memory file, using methods similar
    to those in the URLStream and Socket classes.

    On the Flash and AIR targets, the ByteArray type is a real class, but on
    other platforms, ByteArray is a Haxe abstract over a hidden `ByteArrayData`
    type. To check if an object is a ByteArray at runtime, import the ByteArray
    type, then compare with ByteArrayData, such as `Std.is (ba, ByteArrayData)`.

    In addition, all platforms support zlib compression and decompression, as
    well as additional formats for object serialization.

    Possible uses of the ByteArray class include the following:

    * Creating a custom protocol to connect to a server.
    * Writing your own URLEncoder/URLDecoder.
    * Writing your own AMF/Remoting packet.
    * Optimizing the size of your data by using data types.
    * Working with binary data loaded from a local file.
    * Supporting new binary file formats.
**/
let ByteArray = /** @class */ (() => {
    class ByteArray {
        /**
            Creates a ByteArray instance representing a packed array of bytes, so that
            you can use the methods and properties in this class to optimize your data
            storage and stream.
        **/
        constructor(length = 0) {
            this.__buffer = new ArrayBuffer(length);
            this.__view = new DataView(this.__buffer);
            this.__length = length;
            this.__littleEndian = (ByteArray.defaultEndian == Endian$1.LITTLE_ENDIAN);
            this.objectEncoding = ByteArray.defaultObjectEncoding;
            this.position = 0;
        }
        /**
            Clears the contents of the byte array and resets the `length`
            and `position` properties to 0. Calling this method explicitly
            frees up the memory used by the ByteArray instance.
        **/
        clear() {
            this.length = 0;
            this.position = 0;
        }
        /**
            Compresses the byte array. The entire byte array is compressed. For
            content running in Adobe AIR, you can specify a compression algorithm by
            passing a value(defined in the CompressionAlgorithm class) as the
            `algorithm` parameter. Flash Player supports only the default
            algorithm, zlib.
    
            After the call, the `length` property of the ByteArray is
            set to the new length. The `position` property is set to the
            end of the byte array.
    
            The zlib compressed data format is described at
            [http://www.ietf.org/rfc/rfc1950.txt](http://www.ietf.org/rfc/rfc1950.txt).
    
            The deflate compression algorithm is described at
            [http://www.ietf.org/rfc/rfc1951.txt](http://www.ietf.org/rfc/rfc1951.txt).
    
            The deflate compression algorithm is used in several compression
            formats, such as zlib, gzip, some zip implementations, and others. When
            data is compressed using one of those compression formats, in addition to
            storing the compressed version of the original data, the compression
            format data(for example, the .zip file) includes metadata information.
            Some examples of the types of metadata included in various file formats
            are file name, file modification date/time, original file size, optional
            comments, checksum data, and more.
    
            For example, when a ByteArray is compressed using the zlib algorithm,
            the resulting ByteArray is structured in a specific format. Certain bytes
            contain metadata about the compressed data, while other bytes contain the
            actual compressed version of the original ByteArray data. As defined by
            the zlib compressed data format specification, those bytes(that is, the
            portion containing the compressed version of the original data) are
            compressed using the deflate algorithm. Consequently those bytes are
            identical to the result of calling `compress(<ph
            outputclass="javascript">air.CompressionAlgorithm.DEFLATE)` on the
            original ByteArray. However, the result from `compress(<ph
            outputclass="javascript">air.CompressionAlgorithm.ZLIB)` includes
            the extra metadata, while the
            `compress(CompressionAlgorithm.DEFLATE)` result includes only
            the compressed version of the original ByteArray data and nothing
            else.
    
            In order to use the deflate format to compress a ByteArray instance's
            data in a specific format such as gzip or zip, you cannot simply call
            `compress(CompressionAlgorithm.DEFLATE)`. You must create a
            ByteArray structured according to the compression format's specification,
            including the appropriate metadata as well as the compressed data obtained
            using the deflate format. Likewise, in order to decode data compressed in
            a format such as gzip or zip, you can't simply call
            `uncompress(CompressionAlgorithm.DEFLATE)` on that data. First,
            you must separate the metadata from the compressed data, and you can then
            use the deflate format to decompress the compressed data.
    
        **/
        compress(algorithm = CompressionAlgorithm$1.ZLIB) {
            var buffer = null;
            if (this.__buffer.byteLength > this.__length) {
                buffer = new ArrayBuffer(this.__length);
                new Uint8Array(buffer).set(new Uint8Array(this.__buffer));
                this.__buffer = buffer;
                this.__view = new DataView(this.__buffer);
            }
            switch (algorithm) {
                case CompressionAlgorithm$1.DEFLATE:
                    buffer = undefined(this.__buffer);
                    break;
                case CompressionAlgorithm$1.LZMA:
                    // TODO
                    break;
                default:
                    buffer = undefined(this.__buffer);
                    break;
            }
            if (buffer != null) {
                this.__buffer = buffer;
                this.__view = new DataView(this.__buffer);
                this.__length = buffer.byteLength;
                this.position = this.__length;
            }
        }
        /**
            Compresses the byte array using the deflate compression algorithm. The
            entire byte array is compressed.
    
            After the call, the `length` property of the ByteArray is
            set to the new length. The `position` property is set to the
            end of the byte array.
    
            The deflate compression algorithm is described at
            [http://www.ietf.org/rfc/rfc1951.txt](http://www.ietf.org/rfc/rfc1951.txt).
    
            In order to use the deflate format to compress a ByteArray instance's
            data in a specific format such as gzip or zip, you cannot simply call
            `deflate()`. You must create a ByteArray structured according
            to the compression format's specification, including the appropriate
            metadata as well as the compressed data obtained using the deflate format.
            Likewise, in order to decode data compressed in a format such as gzip or
            zip, you can't simply call `inflate()` on that data. First, you
            must separate the metadata from the compressed data, and you can then use
            the deflate format to decompress the compressed data.
        **/
        deflate() {
            this.compress(CompressionAlgorithm$1.DEFLATE);
        }
        /**
            Converts an ArrayBuffer into a ByteArray.
    
            @param	buffer	An ArrayBuffer instance
            @returns	A new ByteArray
        **/
        static fromArrayBuffer(buffer) {
            if (buffer != null) {
                var byteArray = new ByteArray();
                byteArray.__buffer = buffer;
                byteArray.__length = buffer.byteLength;
                return byteArray;
            }
            else {
                return null;
            }
        }
        get(pos) {
            return this.__buffer[pos];
        }
        /**
            Decompresses the byte array using the deflate compression algorithm. The
            byte array must have been compressed using the same algorithm.
    
            After the call, the `length` property of the ByteArray is
            set to the new length. The `position` property is set to 0.
    
            The deflate compression algorithm is described at
            [http://www.ietf.org/rfc/rfc1951.txt](http://www.ietf.org/rfc/rfc1951.txt).
    
            In order to decode data compressed in a format that uses the deflate
            compression algorithm, such as data in gzip or zip format, it will not
            work to simply call `inflate()` on a ByteArray containing the
            compression formation data. First, you must separate the metadata that is
            included as part of the compressed data format from the actual compressed
            data. For more information, see the `compress()` method
            description.
    
            @throws IOError The data is not valid compressed data; it was not
                            compressed with the same compression algorithm used to
                            compress.
        **/
        inflate() {
            this.uncompress(CompressionAlgorithm$1.DEFLATE);
        }
        static loadFromFile(path) {
            // TODO
            return null;
        }
        /**
            Reads a Boolean value from the byte stream. A single byte is read, and
            `true` is returned if the byte is nonzero, `false`
            otherwise.
    
            @return Returns `true` if the byte is nonzero,
                    `false` otherwise.
            @throws EOFError There is not sufficient data available to read.
        **/
        readBoolean() {
            if (this.position < this.__length) {
                return (this.__buffer[this.position++] != 0);
            }
            else {
                throw new EOFError();
            }
        }
        /**
            Reads a signed byte from the byte stream.
    
            The returned value is in the range -128 to 127.
    
            @return An integer between -128 and 127.
            @throws EOFError There is not sufficient data available to read.
        **/
        readByte() {
            var value = this.readUnsignedByte();
            if ((value & 0x80) != 0) {
                return value - 0x100;
            }
            else {
                return value;
            }
        }
        /**
                Reads the number of data bytes, specified by the `length`
                parameter, from the byte stream. The bytes are read into the ByteArray
                object specified by the `bytes` parameter, and the bytes are
                written into the destination ByteArray starting at the position specified
                by `offset`.
    
                @param bytes  The ByteArray object to read data into.
                @param offset The offset(this.position) in `bytes` at which the
                              read data should be written.
                @param length The number of bytes to read. The default value of 0 causes
                              all available data to be read.
                @throws EOFError   There is not sufficient data available to read.
                @throws RangeError The value of the supplied offset and length, combined,
                                   is greater than the maximum for a uint.
            **/
        readBytes(bytes, offset = 0, length = 0) {
            if (length == 0)
                length = this.__length - this.position;
            if (this.position + length > this.__length) {
                throw new EOFError();
            }
            if (bytes.__length < offset + length) {
                bytes.__resize(offset + length);
            }
            if (bytes == this && offset > this.position) {
                var i = length;
                while (i > 0) {
                    i--;
                    this.__buffer[i + offset] = this.__buffer[i + this.position];
                }
            }
            for (let i = 0; i < length; i++) {
                bytes.__buffer[i + offset] = this.__buffer[i + this.position];
            }
            this.position += length;
        }
        /**
                Reads an IEEE 754 double-precision(64-bit) floating-point number from the
                byte stream.
    
                @return A double-precision(64-bit) floating-point number.
                @throws EOFError There is not sufficient data available to read.
            **/
        readDouble() {
            if (this.position + 8 > this.__length) {
                throw new EOFError();
            }
            this.position += 8;
            return this.__view.getFloat64(this.position - 8, this.__littleEndian);
        }
        /**
                Reads an IEEE 754 single-precision(32-bit) floating-point number from the
                byte stream.
    
                @return A single-precision(32-bit) floating-point number.
                @throws EOFError There is not sufficient data available to read.
            **/
        readFloat() {
            if (this.position + 4 > this.__length) {
                throw new EOFError();
            }
            this.position += 4;
            return this.__view.getFloat32(this.position - 4, this.__littleEndian);
        }
        /**
                Reads a signed 32-bit integer from the byte stream.
    
                The returned value is in the range -2147483648 to 2147483647.
    
                @return A 32-bit signed integer between -2147483648 and 2147483647.
                @throws EOFError There is not sufficient data available to read.
            **/
        readInt() {
            if (this.position + 4 > this.__length) {
                throw new EOFError();
            }
            this.position += 4;
            return this.__view.getInt32(this.position - 4, this.__littleEndian);
        }
        /**
            Reads a multibyte string of specified length from the byte stream using
            the specified character set.
    
            @param length  The number of bytes from the byte stream to read.
            @param charSet The string denoting the character set to use to interpret
                           the bytes. Possible character set strings include
                           `"shift-jis"`, `"cn-gb"`,
                           `"iso-8859-1"`, and others. For a complete list,
                           see <a href="../../charset-codes.html">Supported Character
                           Sets</a>.
    
                           **Note:** If the value for the `charSet`
                           parameter is not recognized by the current system, the
                           application uses the system's default code page as the
                           character set. For example, a value for the
                           `charSet` parameter, as in
                           `myTest.readMultiByte(22, "iso-8859-01")` that
                           uses `01` instead of `1` might work
                           on your development system, but not on another system. On
                           the other system, the application will use the system's
                           default code page.
            @return UTF-8 encoded string.
            @throws EOFError There is not sufficient data available to read.
        **/
        readMultiByte(length, charSet) {
            return this.readUTFBytes(length);
        }
        /**
                Reads an object from the byte array, encoded in AMF serialized format.
    
                @return The deserialized object.
                @throws EOFError There is not sufficient data available to read.
            **/
        readObject() {
            // TODO
            return null;
        }
        /**
            Reads a signed 16-bit integer from the byte stream.
    
            The returned value is in the range -32768 to 32767.
    
            @return A 16-bit signed integer between -32768 and 32767.
            @throws EOFError There is not sufficient data available to read.
        **/
        readShort() {
            if (this.position + 2 > this.__length) {
                throw new EOFError();
            }
            this.position += 2;
            return this.__view.getInt16(this.position - 2, this.__littleEndian);
        }
        /**
                Reads an unsigned byte from the byte stream.
    
                The returned value is in the range 0 to 255.
    
                @return A 32-bit unsigned integer between 0 and 255.
                @throws EOFError There is not sufficient data available to read.
            **/
        readUnsignedByte() {
            if (this.position < this.__length) {
                return this.__buffer[this.position++];
            }
            else {
                throw new EOFError();
            }
        }
        /**
                Reads an unsigned 32-bit integer from the byte stream.
    
                The returned value is in the range 0 to 4294967295.
    
                @return A 32-bit unsigned integer between 0 and 4294967295.
                @throws EOFError There is not sufficient data available to read.
            **/
        readUnsignedInt() {
            if (this.position + 4 > this.__length) {
                throw new EOFError();
            }
            this.position += 4;
            return this.__view.getUint32(this.position - 4, this.__littleEndian);
        }
        /**
                Reads an unsigned 16-bit integer from the byte stream.
    
                The returned value is in the range 0 to 65535.
    
                @return A 16-bit unsigned integer between 0 and 65535.
                @throws EOFError There is not sufficient data available to read.
            **/
        readUnsignedShort() {
            if (this.position + 2 > this.__length) {
                throw new EOFError();
            }
            this.position += 2;
            return this.__view.getUint16(this.position - 2, this.__littleEndian);
        }
        /**
                Reads a UTF-8 string from the byte stream. The string is assumed to be
                prefixed with an unsigned short indicating the length in bytes.
    
                @return UTF-8 encoded string.
                @throws EOFError There is not sufficient data available to read.
            **/
        readUTF() {
            var bytesCount = this.readUnsignedShort();
            return this.readUTFBytes(bytesCount);
        }
        /**
                Reads a sequence of UTF-8 bytes specified by the `length`
                parameter from the byte stream and returns a string.
    
                @param length An unsigned short indicating the length of the UTF-8 bytes.
                @return A string composed of the UTF-8 bytes of the specified length.
                @throws EOFError There is not sufficient data available to read.
            **/
        readUTFBytes(length) {
            if (this.position + length > this.__length) {
                throw new EOFError();
            }
            this.position += length;
            var s = "";
            var b = this.__buffer;
            var fcc = String.fromCharCode;
            var i = this.position - length;
            var max = this.position;
            // utf8-decode and utf16-encode
            while (i < max) {
                var c = b[i++];
                if (c < 0x80) {
                    if (c == 0)
                        break;
                    s += fcc(c);
                }
                else if (c < 0xE0)
                    s += fcc(((c & 0x3F) << 6) | (b[i++] & 0x7F));
                else if (c < 0xF0) {
                    var c2 = b[i++];
                    s += fcc(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));
                }
                else {
                    var c2 = b[i++];
                    var c3 = b[i++];
                    var u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);
                    // surrogate pair
                    s += fcc((u >> 10) + 0xD7C0);
                    s += fcc((u & 0x3FF) | 0xDC00);
                }
            }
            return s;
        }
        set(pos, v) {
            this.__buffer[pos] = v & 0xFF;
        }
        /**
                Converts the byte array to a string. If the data in the array begins with
                a Unicode byte order mark, the application will honor that mark when
                converting to a string. If `System.useCodePage` is set to
                `true`, the application will treat the data in the array as
                being in the current system code page when converting.
    
                @return The string representation of the byte array.
            **/
        toString() {
            var cachePosition = this.position;
            this.position = 0;
            var result = this.readUTFBytes(this.__length);
            this.position = cachePosition;
            return result;
        }
        /**
                Decompresses the byte array. For content running in Adobe AIR, you can
                specify a compression algorithm by passing a value(defined in the
                CompressionAlgorithm class) as the `algorithm` parameter. The
                byte array must have been compressed using the same algorithm. Flash
                Player supports only the default algorithm, zlib.
    
                After the call, the `length` property of the ByteArray is
                set to the new length. The `position` property is set to 0.
    
                The zlib compressed data format is described at
                [http://www.ietf.org/rfc/rfc1950.txt](http://www.ietf.org/rfc/rfc1950.txt).
    
                The deflate compression algorithm is described at
                [http://www.ietf.org/rfc/rfc1951.txt](http://www.ietf.org/rfc/rfc1951.txt).
    
                In order to decode data compressed in a format that uses the deflate
                compression algorithm, such as data in gzip or zip format, it will not
                work to call `uncompress(CompressionAlgorithm.DEFLATE)` on a
                ByteArray containing the compression formation data. First, you must
                separate the metadata that is included as part of the compressed data
                format from the actual compressed data. For more information, see the
                `compress()` method description.
    
                @throws IOError The data is not valid compressed data; it was not
                                compressed with the same compression algorithm used to
                                compress.
            **/
        uncompress(algorithm = CompressionAlgorithm$1.ZLIB) {
            var buffer = null;
            if (this.__buffer.byteLength > this.__length) {
                buffer = new ArrayBuffer(this.__length);
                new Uint8Array(buffer).set(new Uint8Array(this.__buffer));
                this.__buffer = buffer;
                this.__view = new DataView(this.__buffer);
            }
            switch (algorithm) {
                case CompressionAlgorithm$1.DEFLATE:
                    buffer = undefined(this.__buffer);
                    break;
                case CompressionAlgorithm$1.LZMA:
                    // TODO
                    break;
                default:
                    buffer = undefined(this.__buffer);
                    break;
            }
            if (buffer != null) {
                this.__buffer = buffer;
                this.__view = new DataView(this.__buffer);
                this.__length = buffer.byteLength;
            }
            this.position = 0;
        }
        /**
                Writes a Boolean value. A single byte is written according to the
                `value` parameter, either 1 if `true` or 0 if
                `false`.
    
                @param value A Boolean value determining which byte is written. If the
                             parameter is `true`, the method writes a 1; if
                             `false`, the method writes a 0.
            **/
        writeBoolean(value) {
            this.writeByte(value ? 1 : 0);
        }
        /**
            Writes a byte to the byte stream.
    
            The low 8 bits of the parameter are used. The high 24 bits are ignored.
    
    
            @param value A 32-bit integer. The low 8 bits are written to the byte
                         stream.
        **/
        writeByte(value) {
            this.__resize(this.position + 1);
            this.__view.setInt8(this.position++, value & 0xFF);
        }
        /**
                Writes a sequence of `length` bytes from the specified byte
                array, `bytes`, starting `offset`(zero-based index)
                bytes into the byte stream.
    
                If the `length` parameter is omitted, the default length of
                0 is used; the method writes the entire buffer starting at
                `offset`. If the `offset` parameter is also omitted,
                the entire buffer is written.
    
                If `offset` or `length` is out of range, they are
                clamped to the beginning and end of the `bytes` array.
    
                @param bytes  The ByteArray object.
                @param offset A zero-based index indicating the position into the array to
                              begin writing.
                @param length An unsigned integer indicating how far into the buffer to
                              write.
            **/
        writeBytes(bytes, offset = 0, length = 0) {
            if (bytes.__length == 0)
                return;
            if (length == 0)
                length = bytes.__length - offset;
            this.__resize(this.position + length);
            if (bytes == this && offset > this.position) {
                var i = length;
                while (i > 0) {
                    i--;
                    this.__buffer[i + offset] = this.__buffer[i + this.position];
                }
            }
            for (let i = 0; i < length; i++) {
                this.__buffer[i + offset] = bytes.__buffer[i + this.position];
            }
            this.position += length;
        }
        /**
                Writes an IEEE 754 double-precision(64-bit) floating-point number to the
                byte stream.
    
                @param value A double-precision(64-bit) floating-point number.
            **/
        writeDouble(value) {
            this.__resize(this.position + 8);
            this.__view.setFloat64(this.position, value, this.__littleEndian);
            this.position += 8;
        }
        /**
                Writes an IEEE 754 single-precision(32-bit) floating-point number to the
                byte stream.
    
                @param value A single-precision(32-bit) floating-point number.
            **/
        writeFloat(value) {
            this.__resize(this.position + 4);
            this.__view.setFloat32(this.position, value, this.__littleEndian);
            this.position += 4;
        }
        /**
                Writes a 32-bit signed integer to the byte stream.
    
                @param value An integer to write to the byte stream.
            **/
        writeInt(value) {
            this.__resize(this.position + 4);
            this.__view.setInt32(this.position, value, this.__littleEndian);
            this.position += 4;
        }
        /**
                Writes a multibyte string to the byte stream using the specified character
                set.
    
                @param value   The string value to be written.
                @param charSet The string denoting the character set to use. Possible
                               character set strings include `"shift-jis"`,
                               `"cn-gb"`, `"iso-8859-1"`, and
                               others. For a complete list, see <a
                               href="../../charset-codes.html">Supported Character
                               Sets</a>.
            **/
        writeMultiByte(value, charSet) {
            this.writeUTFBytes(value);
        }
        /**
            Writes an object into the byte array in AMF serialized format.
    
            @param object The object to serialize.
        **/
        writeObject(object) {
            // TODO
        }
        /**
            Writes a 16-bit integer to the byte stream. The low 16 bits of the
            parameter are used. The high 16 bits are ignored.
    
            @param value 32-bit integer, whose low 16 bits are written to the byte
                         stream.
        **/
        writeShort(value) {
            this.__resize(this.position + 2);
            this.__view.setInt16(this.position, value, this.__littleEndian);
            this.position += 2;
        }
        /**
                Writes a 32-bit unsigned integer to the byte stream.
    
                @param value An unsigned integer to write to the byte stream.
            **/
        writeUnsignedInt(value) {
            this.__resize(this.position + 2);
            this.__view.setUint16(this.position, value, this.__littleEndian);
            this.position += 2;
        }
        /**
            Writes a UTF-8 string to the byte stream. The length of the UTF-8 string
            in bytes is written first, as a 16-bit integer, followed by the bytes
            representing the characters of the string.
    
            @param value The string value to be written.
            @throws RangeError If the length is larger than 65535.
        **/
        writeUTF(value) {
            var bytes = this.__bytesOfString(value);
            this.writeShort(bytes.length);
            for (let value of bytes) {
                this.writeByte(value);
            }
        }
        /**
            Writes a UTF-8 string to the byte stream. Similar to the
            `writeUTF()` method, but `writeUTFBytes()` does not
            prefix the string with a 16-bit length word.
    
            @param value The string value to be written.
        **/
        writeUTFBytes(value) {
            var bytes = this.__bytesOfString(value);
            for (let value of bytes) {
                this.writeByte(value);
            }
        }
        __bytesOfString(value) {
            var a = new Array();
            // utf16-decode and utf8-encode
            var i = 0;
            while (i < value.length) {
                var c = value.charCodeAt(i++);
                // surrogate pair
                if (0xD800 <= c && c <= 0xDBFF)
                    c = (c - 0xD7C0 << 10) | (value.charCodeAt(i++) & 0x3FF);
                if (c <= 0x7F)
                    a.push(c);
                else if (c <= 0x7FF) {
                    a.push(0xC0 | (c >> 6));
                    a.push(0x80 | (c & 63));
                }
                else if (c <= 0xFFFF) {
                    a.push(0xE0 | (c >> 12));
                    a.push(0x80 | ((c >> 6) & 63));
                    a.push(0x80 | (c & 63));
                }
                else {
                    a.push(0xF0 | (c >> 18));
                    a.push(0x80 | ((c >> 12) & 63));
                    a.push(0x80 | ((c >> 6) & 63));
                    a.push(0x80 | (c & 63));
                }
            }
            return a;
        }
        __resize(size) {
            if (size > this.__length) {
                if (size > this.__buffer.byteLength) {
                    var buffer = new ArrayBuffer(((size + 1) * 3) >> 1);
                    if (this.__length > 0) {
                        new Uint8Array(buffer).set(new Uint8Array(this.__buffer));
                    }
                    this.__buffer = buffer;
                    this.__view = new DataView(this.__buffer);
                }
                this.__length = size;
            }
        }
        // Get & Set Methods
        /**
            The number of bytes of data available for reading from the current
            position in the byte array to the end of the array.
    
            Use the `bytesAvailable` property in conjunction with the
            read methods each time you access a ByteArray object to ensure that you
            are reading valid data.
        **/
        get bytesAvailable() {
            return this.__length - this.position;
        }
        /**
            Denotes the default endianness for the ByteArray class to use for a
            new ByteArray instance. When you create a new ByteArray instance, the
            endian value on that instance starts with the value of
            `defaultEndian`. The `defaultEndian`
            property is initialized to the default system endianness. This will
            most likely be `Endian.LITTLE_ENDIAN` on the majority platforms
            except for the Flash runtime.
    
            On Flash and AIR targets, this property cannot be changed and will
            always be set to `Endian.BIG_ENDIAN`.
        **/
        static get defaultEndian() {
            if (ByteArray.__defaultEndian == null) {
                var arrayBuffer = new ArrayBuffer(2);
                var uint8Array = new Uint8Array(arrayBuffer);
                var uint16array = new Uint16Array(arrayBuffer);
                uint8Array[0] = 0xAA;
                uint8Array[1] = 0xBB;
                if (uint16array[0] == 0xAABB) {
                    ByteArray.__defaultEndian = Endian$1.BIG_ENDIAN;
                }
                else {
                    ByteArray.__defaultEndian = Endian$1.LITTLE_ENDIAN;
                }
            }
            return ByteArray.__defaultEndian;
        }
        static set defaultEndian(value) {
            ByteArray.__defaultEndian = value;
        }
        /**
            Changes or reads the byte order for the data; either
            `Endian.BIG_ENDIAN` or `Endian.LITTLE_ENDIAN`.
        **/
        get endian() {
            return this.__littleEndian ? Endian$1.LITTLE_ENDIAN : Endian$1.BIG_ENDIAN;
        }
        set endian(value) {
            this.__littleEndian = (value == Endian$1.LITTLE_ENDIAN);
        }
        /**
            The length of the ByteArray object, in bytes.
    
            If the length is set to a value that is larger than the current length,
            the right side of the byte array is filled with zeros.
    
            If the length is set to a value that is smaller than the current
            length, the byte array is truncated.
        **/
        get length() {
            return this.__length;
        }
        set length(value) {
            if (value > 0) {
                this.__resize(value);
                if (value < this.position)
                    this.position = value;
            }
            this.__length = value;
        }
    }
    /**
        Denotes the default object encoding for the ByteArray class to use for a
        new ByteArray instance. When you create a new ByteArray instance, the
        encoding on that instance starts with the value of
        `defaultObjectEncoding`. The `defaultObjectEncoding`
        property is initialized to `ObjectEncoding.DEFAULT`. This value varies
        between platforms.

        When an object is written to or read from binary data, the
        `objectEncoding` value is used to determine whether the
        Haxe, JavaScript, ActionScript 3.0, ActionScript 2.0 or ActionScript 1.0
        format should be used. The value is a constant from the ObjectEncoding
        class.
    **/
    ByteArray.defaultObjectEncoding = ObjectEncoding$1.DEFAULT;
    ByteArray.__defaultEndian = null;
    ByteArray.__helper = new DataView(new ArrayBuffer(8));
    return ByteArray;
})();

/*
    Copyright (c) 2015, Adobe Systems Incorporated
    All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:
    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
    * Neither the name of Adobe Systems Incorporated nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**/
let AGALMiniAssembler = /** @class */ (() => {
    class AGALMiniAssembler {
        constructor(debugging = false) {
            this.debugEnabled = false;
            this.debugEnabled = debugging;
            if (!AGALMiniAssembler.initialized) {
                AGALMiniAssembler.init();
            }
        }
        get agalcode() { return this._agalcode; }
        get error() { return this._error; }
        assemble2(context3D, version, vertexSource, fragmentSource) {
            var agalVertex = this.assemble(AGALMiniAssembler.VERTEX, vertexSource, version);
            var agalFragment = this.assemble(AGALMiniAssembler.FRAGMENT, fragmentSource, version);
            var program = context3D.createProgram();
            program.upload(agalVertex, agalFragment);
            return program;
        }
        assemble(mode, source, version = 1, ignoreLimits = false) {
            var start = Lib$1.getTimer();
            this._agalcode = new ByteArray();
            this._error = "";
            var isFrag = false;
            if (mode == AGALMiniAssembler.FRAGMENT) {
                isFrag = true;
            }
            else if (mode != AGALMiniAssembler.VERTEX) {
                this._error = 'ERROR: mode needs to be "' + AGALMiniAssembler.FRAGMENT + '" or "' + AGALMiniAssembler.VERTEX + '" but is "' + mode + '".';
            }
            this._agalcode.endian = Endian$1.LITTLE_ENDIAN;
            this._agalcode.writeByte(0xa0); // tag version
            this._agalcode.writeUnsignedInt(version); // AGAL version, big endian, bit pattern will be 0x01000000
            this._agalcode.writeByte(0xa1); // tag program id
            this._agalcode.writeByte(isFrag ? 1 : 0); // vertex or fragment
            this.initregmap(version, ignoreLimits);
            var lines = source.replace(/\r/g, "\n").split("\n");
            var nops = 0;
            var lng = lines.length;
            var reg1 = /<.*>/g;
            var reg2 = /([\w\.\-\+]+)/gi;
            var reg3 = /^\w{3}/ig;
            var reg4 = /vc\[([vofi][acostdip]?[d]?)(\d*)?(\.[xyzw](\+\d{1,3})?)?\](\.[xyzw]{1,4})?|([vofi][acostdip]?[d]?)(\d*)?(\.[xyzw]{1,4})?/gi;
            var reg5 = /\[.*\]/ig;
            var reg6 = /^\b[A-Za-z]{1,3}/ig;
            var reg7 = /\d+/;
            var reg8 = /(\.[xyzw]{1,4})/;
            var reg9 = /[A-Za-z]{1,3}/ig;
            var reg10 = /(\.[xyzw]{1,1})/;
            var reg11 = /\+\d{1,3}/ig;
            var i = 0;
            while (i < lng && this._error == "") {
                var line = lines[i].trim();
                // remove comments
                var startcomment = line.indexOf("//");
                if (startcomment != -1) {
                    line = line.substr(0, startcomment);
                }
                // grab options
                var optsi = reg1.test(line) ? reg1.lastIndex : -1;
                var opts = null;
                if (optsi != -1) {
                    opts = this.match(line.substr(optsi), reg2);
                    line = line.substr(0, optsi);
                }
                // find opcode
                var opCode = null;
                var opFound = null;
                var result = reg3.exec(line);
                if (result != null) {
                    opCode = result[0];
                    opFound = AGALMiniAssembler.OPMAP[opCode];
                }
                if (opFound == null) {
                    if (line.length >= 3) {
                        console.warn("warning: bad line " + i + ": " + lines[i]);
                    }
                    i++;
                    continue;
                }
                // if debug is enabled, output the opcodes
                if (this.debugEnabled) {
                    console.info(opFound);
                }
                if (opFound == null) {
                    if (line.length >= 3) {
                        console.warn("warning: bad line " + i + ": " + lines[i]);
                    }
                    i++;
                    continue;
                }
                line = line.substr(line.indexOf(opFound.name) + opFound.name.length);
                if ((opFound.flags & AGALMiniAssembler.OP_VERSION2) != 0 && version < 2) {
                    this._error = "error: opcode requires version 2.";
                    break;
                }
                if ((opFound.flags & AGALMiniAssembler.OP_VERT_ONLY) != 0 && isFrag) {
                    this._error = "error: opcode is only allowed in vertex programs.";
                    break;
                }
                if ((opFound.flags & AGALMiniAssembler.OP_FRAG_ONLY) != 0 && !isFrag) {
                    this._error = "error: opcode is only allowed in fragment programs.";
                    break;
                }
                if (this.verbose) {
                    console.info("emit opcode=" + opFound);
                }
                this._agalcode.writeUnsignedInt(opFound.emitCode);
                nops++;
                if (nops > AGALMiniAssembler.MAX_OPCODES) {
                    this._error = "error: too many opcodes. maximum is " + AGALMiniAssembler.MAX_OPCODES + ".";
                    break;
                }
                // get operands, use regexp
                var regs = this.match(line, reg4);
                if (regs.length != opFound.numRegister) {
                    this._error = "error: wrong number of operands. found " + regs.length + " but expected " + opFound.numRegister + ".";
                    break;
                }
                var badreg = false;
                var pad = 64 + 64 + 32;
                var regLength = regs.length;
                for (let j = 0; j < regLength; j++) {
                    var isRelative = false;
                    var relreg = this.match(regs[j], reg5);
                    if (relreg.length > 0) {
                        regs[j] = regs[j].replace(relreg[0], "0");
                        if (this.verbose) {
                            console.info("IS REL");
                        }
                        isRelative = true;
                    }
                    var res = this.match(regs[j], reg6);
                    if (res.length == 0) {
                        this._error = "error: could not parse operand " + j + " (" + regs[j] + ").";
                        badreg = true;
                        break;
                    }
                    var regFound = AGALMiniAssembler.REGMAP[res[0]];
                    // if debug is enabled, output the registers
                    if (this.debugEnabled) {
                        console.info(regFound);
                    }
                    if (regFound == null) {
                        this._error = "error: could not find register name for operand " + j + " (" + regs[j] + ").";
                        badreg = true;
                        break;
                    }
                    if (isFrag) {
                        if ((regFound.flags & AGALMiniAssembler.REG_FRAG) == 0) {
                            this._error = "error: register operand " + j + " (" + regs[j] + ") only allowed in vertex programs.";
                            badreg = true;
                            break;
                        }
                        if (isRelative) {
                            this._error = "error: register operand " + j + " (" + regs[j] + ") relative adressing not allowed in fragment programs.";
                            badreg = true;
                            break;
                        }
                    }
                    else {
                        if ((regFound.flags & AGALMiniAssembler.REG_VERT) == 0) {
                            this._error = "error: register operand " + j + " (" + regs[j] + ") only allowed in fragment programs.";
                            badreg = true;
                            break;
                        }
                    }
                    regs[j] = regs[j].substr(regs[j].indexOf(regFound.name) + regFound.name.length);
                    // Log.info ("REGNUM: " + regs[j]);
                    var idxmatch = isRelative ? this.match(relreg[0], reg7) : this.match(regs[j], reg7);
                    var regidx = 0;
                    if (idxmatch.length > 0) {
                        regidx = parseInt(idxmatch[0]);
                    }
                    if (regFound.range < regidx) {
                        this._error = "error: register operand " + j + " (" + regs[j] + ") index exceeds limit of " + (regFound.range + 1) + ".";
                        badreg = true;
                        break;
                    }
                    var regmask = 0;
                    var maskmatch = this.match(regs[j], reg8);
                    var isDest = (j == 0 && (opFound.flags & AGALMiniAssembler.OP_NO_DEST) == 0);
                    var isSampler = (j == 2 && (opFound.flags & AGALMiniAssembler.OP_SPECIAL_TEX) != 0);
                    var reltype = 0;
                    var relsel = 0;
                    var reloffset = 0;
                    if (isDest && isRelative) {
                        this._error = "error: relative can not be destination";
                        badreg = true;
                        break;
                    }
                    if (maskmatch.length > 0) {
                        regmask = 0;
                        var cv = 0;
                        var maskLength = maskmatch[0].length;
                        var k = 1;
                        while (k < maskLength) {
                            cv = maskmatch[0].charCodeAt(k) - "x".charCodeAt(0);
                            if (cv > 2) {
                                cv = 3;
                            }
                            if (isDest) {
                                regmask |= 1 << cv;
                            }
                            else {
                                regmask |= cv << ((k - 1) << 1);
                            }
                            k++;
                        }
                        if (!isDest) {
                            while (k <= 4) {
                                regmask |= cv << ((k - 1) << 1); // repeat last
                                k++;
                            }
                        }
                    }
                    else {
                        regmask = isDest ? 0xf : 0xe4; // id swizzle or mask
                    }
                    if (isRelative) {
                        var relname = this.match(relreg[0], reg9);
                        var regFoundRel = AGALMiniAssembler.REGMAP[relname[0]];
                        if (regFoundRel == null) {
                            this._error = "error: bad index register";
                            badreg = true;
                            break;
                        }
                        reltype = regFoundRel.emitCode;
                        var selmatch = this.match(relreg[0], reg10);
                        if (selmatch.length == 0) {
                            this._error = "error: bad index register select";
                            badreg = true;
                            break;
                        }
                        relsel = selmatch[0].charCodeAt(1) - "x".charCodeAt(0);
                        if (relsel > 2) {
                            relsel = 3;
                        }
                        var relofs = this.match(relreg[0], reg11);
                        if (relofs.length > 0) {
                            reloffset = parseInt(relofs[0]);
                        }
                        if (reloffset < 0 || reloffset > 255) {
                            this._error = "error: index offset " + reloffset + " out of bounds. [0..255]";
                            badreg = true;
                            break;
                        }
                        if (this.verbose) {
                            console.info("RELATIVE: type=" + reltype + "==" + relname[0] + " sel=" + relsel + "==" + selmatch[0] + " idx=" + regidx + " offset="
                                + reloffset);
                        }
                    }
                    if (this.verbose) {
                        console.info("  emit argcode=" + regFound + "[" + regidx + "][" + regmask + "]");
                    }
                    if (isDest) {
                        this._agalcode.writeShort(regidx);
                        this._agalcode.writeByte(regmask);
                        this._agalcode.writeByte(regFound.emitCode);
                        pad -= 32;
                    }
                    else {
                        if (isSampler) {
                            if (this.verbose) {
                                console.info("  emit sampler");
                            }
                            var samplerbits = 5; // type 5
                            var optsLength = opts == null ? 0 : opts.length;
                            var bias = 0.0;
                            for (let k = 0; k < optsLength; k++) {
                                if (this.verbose) {
                                    console.info("    opt: " + opts[k]);
                                }
                                var optfound = AGALMiniAssembler.SAMPLEMAP[opts[k]];
                                if (optfound == null) {
                                    // todo check that it's a number...
                                    // Log.info ("Warning, unknown sampler option: " + opts[k]);
                                    bias = parseInt(opts[k]);
                                    if (this.verbose) {
                                        console.info("    bias: " + bias);
                                    }
                                }
                                else {
                                    if (optfound.flag != AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT) {
                                        samplerbits &= ~(0xf << optfound.flag);
                                    }
                                    samplerbits |= optfound.mask << optfound.flag;
                                }
                            }
                            this._agalcode.writeShort(regidx);
                            this._agalcode.writeByte(Math.floor(bias * 8.0));
                            this._agalcode.writeByte(0);
                            this._agalcode.writeUnsignedInt(samplerbits);
                            if (this.verbose) {
                                console.info("    bits: " + (samplerbits - 5));
                            }
                            pad -= 64;
                        }
                        else {
                            if (j == 0) {
                                this._agalcode.writeUnsignedInt(0);
                                pad -= 32;
                            }
                            this._agalcode.writeShort(regidx);
                            this._agalcode.writeByte(reloffset);
                            this._agalcode.writeByte(regmask);
                            this._agalcode.writeByte(regFound.emitCode);
                            this._agalcode.writeByte(reltype);
                            this._agalcode.writeShort(isRelative ? (relsel | (1 << 15)) : 0);
                            pad -= 64;
                        }
                    }
                }
                // pad unused regs
                var j = 0;
                while (j < pad) {
                    this._agalcode.writeByte(0);
                    j += 8;
                }
                if (badreg) {
                    break;
                }
                i++;
            }
            if (this._error != "") {
                this._error += "\n  at line " + i + " " + lines[i];
                this._agalcode.length = 0;
                console.info(this._error);
            }
            // Log.info the bytecode bytes if debugging is enabled
            if (this.debugEnabled) {
                var dbgLine = "generated bytecode:";
                var agalLength = this._agalcode.length;
                for (let index = 0; i < agalLength; index++) {
                    if (index % 16 == 0) {
                        dbgLine += "\n";
                    }
                    if (index % 4 == 0) {
                        dbgLine += " ";
                    }
                    var byteStr = (this._agalcode[index] & 0xFF).toString(16);
                    if (byteStr.length < 2) {
                        byteStr = "0" + byteStr;
                    }
                    dbgLine += byteStr;
                }
                console.info(dbgLine);
            }
            if (this.verbose) {
                console.info("AGALMiniAssembler.assemble time: " + ((Lib$1.getTimer() - start) / 1000) + "s");
            }
            return this._agalcode;
        }
        initregmap(version, ignorelimits) {
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.VA] = new Register(AGALMiniAssembler.VA, "vertex attribute", 0x0, ignorelimits ? 1024 : ((version == 1 || version == 2) ? 7 : 15), AGALMiniAssembler.REG_VERT | AGALMiniAssembler.REG_READ);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.VC] = new Register(AGALMiniAssembler.VC, "vertex constant", 0x1, ignorelimits ? 1024 : (version == 1 ? 127 : 249), AGALMiniAssembler.REG_VERT | AGALMiniAssembler.REG_READ);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.VT] = new Register(AGALMiniAssembler.VT, "vertex temporary", 0x2, ignorelimits ? 1024 : (version == 1 ? 7 : 25), AGALMiniAssembler.REG_VERT | AGALMiniAssembler.REG_WRITE | AGALMiniAssembler.REG_READ);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.VO] = new Register(AGALMiniAssembler.VO, "vertex output", 0x3, ignorelimits ? 1024 : 0, AGALMiniAssembler.REG_VERT | AGALMiniAssembler.REG_WRITE);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.VI] = new Register(AGALMiniAssembler.VI, "varying", 0x4, ignorelimits ? 1024 : (version == 1 ? 7 : 9), AGALMiniAssembler.REG_VERT | AGALMiniAssembler.REG_FRAG | AGALMiniAssembler.REG_READ | AGALMiniAssembler.REG_WRITE);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.FC] = new Register(AGALMiniAssembler.FC, "fragment constant", 0x1, ignorelimits ? 1024 : (version == 1 ? 27 : ((version == 2) ? 63 : 199)), AGALMiniAssembler.REG_FRAG | AGALMiniAssembler.REG_READ);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.FT] = new Register(AGALMiniAssembler.FT, "fragment temporary", 0x2, ignorelimits ? 1024 : (version == 1 ? 7 : 25), AGALMiniAssembler.REG_FRAG | AGALMiniAssembler.REG_WRITE | AGALMiniAssembler.REG_READ);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.FS] = new Register(AGALMiniAssembler.FS, "texture sampler", 0x5, ignorelimits ? 1024 : 7, AGALMiniAssembler.REG_FRAG | AGALMiniAssembler.REG_READ);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.FO] = new Register(AGALMiniAssembler.FO, "fragment output", 0x3, ignorelimits ? 1024 : (version == 1 ? 0 : 3), AGALMiniAssembler.REG_FRAG | AGALMiniAssembler.REG_WRITE);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.FD] = new Register(AGALMiniAssembler.FD, "fragment depth output", 0x6, ignorelimits ? 1024 : (version == 1 ? -1 : 0), AGALMiniAssembler.REG_FRAG | AGALMiniAssembler.REG_WRITE);
            AGALMiniAssembler.REGMAP[AGALMiniAssembler.IID] = new Register(AGALMiniAssembler.IID, "instance id", 0x7, ignorelimits ? 1024 : 0, AGALMiniAssembler.REG_VERT | AGALMiniAssembler.REG_READ);
            // aliases
            AGALMiniAssembler.REGMAP["op"] = AGALMiniAssembler.REGMAP[AGALMiniAssembler.VO];
            AGALMiniAssembler.REGMAP["i"] = AGALMiniAssembler.REGMAP[AGALMiniAssembler.VI];
            AGALMiniAssembler.REGMAP["v"] = AGALMiniAssembler.REGMAP[AGALMiniAssembler.VI];
            AGALMiniAssembler.REGMAP["oc"] = AGALMiniAssembler.REGMAP[AGALMiniAssembler.FO];
            AGALMiniAssembler.REGMAP["od"] = AGALMiniAssembler.REGMAP[AGALMiniAssembler.FD];
            AGALMiniAssembler.REGMAP["fi"] = AGALMiniAssembler.REGMAP[AGALMiniAssembler.VI];
        }
        static init() {
            AGALMiniAssembler.initialized = true;
            // Fill the dictionaries with opcodes and registers
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.MOV] = new OpCode(AGALMiniAssembler.MOV, 2, 0x00, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.ADD] = new OpCode(AGALMiniAssembler.ADD, 3, 0x01, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SUB] = new OpCode(AGALMiniAssembler.SUB, 3, 0x02, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.MUL] = new OpCode(AGALMiniAssembler.MUL, 3, 0x03, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.DIV] = new OpCode(AGALMiniAssembler.DIV, 3, 0x04, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.RCP] = new OpCode(AGALMiniAssembler.RCP, 2, 0x05, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.MIN] = new OpCode(AGALMiniAssembler.MIN, 3, 0x06, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.MAX] = new OpCode(AGALMiniAssembler.MAX, 3, 0x07, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.FRC] = new OpCode(AGALMiniAssembler.FRC, 2, 0x08, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SQT] = new OpCode(AGALMiniAssembler.SQT, 2, 0x09, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.RSQ] = new OpCode(AGALMiniAssembler.RSQ, 2, 0x0a, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.POW] = new OpCode(AGALMiniAssembler.POW, 3, 0x0b, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.LOG] = new OpCode(AGALMiniAssembler.LOG, 2, 0x0c, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.EXP] = new OpCode(AGALMiniAssembler.EXP, 2, 0x0d, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.NRM] = new OpCode(AGALMiniAssembler.NRM, 2, 0x0e, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SIN] = new OpCode(AGALMiniAssembler.SIN, 2, 0x0f, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.COS] = new OpCode(AGALMiniAssembler.COS, 2, 0x10, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.CRS] = new OpCode(AGALMiniAssembler.CRS, 3, 0x11, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.DP3] = new OpCode(AGALMiniAssembler.DP3, 3, 0x12, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.DP4] = new OpCode(AGALMiniAssembler.DP4, 3, 0x13, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.ABS] = new OpCode(AGALMiniAssembler.ABS, 2, 0x14, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.NEG] = new OpCode(AGALMiniAssembler.NEG, 2, 0x15, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SAT] = new OpCode(AGALMiniAssembler.SAT, 2, 0x16, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.M33] = new OpCode(AGALMiniAssembler.M33, 3, 0x17, AGALMiniAssembler.OP_SPECIAL_MATRIX);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.M44] = new OpCode(AGALMiniAssembler.M44, 3, 0x18, AGALMiniAssembler.OP_SPECIAL_MATRIX);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.M34] = new OpCode(AGALMiniAssembler.M34, 3, 0x19, AGALMiniAssembler.OP_SPECIAL_MATRIX);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.DDX] = new OpCode(AGALMiniAssembler.DDX, 2, 0x1a, AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_FRAG_ONLY);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.DDY] = new OpCode(AGALMiniAssembler.DDY, 2, 0x1b, AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_FRAG_ONLY);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.IFE] = new OpCode(AGALMiniAssembler.IFE, 2, 0x1c, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_INCNEST | AGALMiniAssembler.OP_SCALAR);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.INE] = new OpCode(AGALMiniAssembler.INE, 2, 0x1d, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_INCNEST | AGALMiniAssembler.OP_SCALAR);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.IFG] = new OpCode(AGALMiniAssembler.IFG, 2, 0x1e, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_INCNEST | AGALMiniAssembler.OP_SCALAR);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.IFL] = new OpCode(AGALMiniAssembler.IFL, 2, 0x1f, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_INCNEST | AGALMiniAssembler.OP_SCALAR);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.ELS] = new OpCode(AGALMiniAssembler.ELS, 0, 0x20, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_INCNEST | AGALMiniAssembler.OP_DECNEST | AGALMiniAssembler.OP_SCALAR);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.EIF] = new OpCode(AGALMiniAssembler.EIF, 0, 0x21, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_VERSION2 | AGALMiniAssembler.OP_DECNEST | AGALMiniAssembler.OP_SCALAR);
            // space
            // OPMAP[TED] = new OpCode (TED, 3, 0x26, OP_FRAG_ONLY | OP_SPECIAL_TEX | OP_VERSION2); //ted is not available in AGAL2
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.KIL] = new OpCode(AGALMiniAssembler.KIL, 1, 0x27, AGALMiniAssembler.OP_NO_DEST | AGALMiniAssembler.OP_FRAG_ONLY);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.TEX] = new OpCode(AGALMiniAssembler.TEX, 3, 0x28, AGALMiniAssembler.OP_FRAG_ONLY | AGALMiniAssembler.OP_SPECIAL_TEX);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SGE] = new OpCode(AGALMiniAssembler.SGE, 3, 0x29, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SLT] = new OpCode(AGALMiniAssembler.SLT, 3, 0x2a, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SGN] = new OpCode(AGALMiniAssembler.SGN, 2, 0x2b, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SEQ] = new OpCode(AGALMiniAssembler.SEQ, 3, 0x2c, 0);
            AGALMiniAssembler.OPMAP[AGALMiniAssembler.SNE] = new OpCode(AGALMiniAssembler.SNE, 3, 0x2d, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.RGBA] = new Sampler(AGALMiniAssembler.RGBA, AGALMiniAssembler.SAMPLER_TYPE_SHIFT, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.COMPRESSED] = new Sampler(AGALMiniAssembler.COMPRESSED, AGALMiniAssembler.SAMPLER_TYPE_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.COMPRESSEDALPHA] = new Sampler(AGALMiniAssembler.COMPRESSEDALPHA, AGALMiniAssembler.SAMPLER_TYPE_SHIFT, 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.DXT1] = new Sampler(AGALMiniAssembler.DXT1, AGALMiniAssembler.SAMPLER_TYPE_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.DXT5] = new Sampler(AGALMiniAssembler.DXT5, AGALMiniAssembler.SAMPLER_TYPE_SHIFT, 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.VIDEO] = new Sampler(AGALMiniAssembler.VIDEO, AGALMiniAssembler.SAMPLER_TYPE_SHIFT, 3);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.D2] = new Sampler(AGALMiniAssembler.D2, AGALMiniAssembler.SAMPLER_DIM_SHIFT, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.D3] = new Sampler(AGALMiniAssembler.D3, AGALMiniAssembler.SAMPLER_DIM_SHIFT, 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.CUBE] = new Sampler(AGALMiniAssembler.CUBE, AGALMiniAssembler.SAMPLER_DIM_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.MIPNEAREST] = new Sampler(AGALMiniAssembler.MIPNEAREST, AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.MIPLINEAR] = new Sampler(AGALMiniAssembler.MIPLINEAR, AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT, 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.MIPNONE] = new Sampler(AGALMiniAssembler.MIPNONE, AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.NOMIP] = new Sampler(AGALMiniAssembler.NOMIP, AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.NEAREST] = new Sampler(AGALMiniAssembler.NEAREST, AGALMiniAssembler.SAMPLER_FILTER_SHIFT, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.LINEAR] = new Sampler(AGALMiniAssembler.LINEAR, AGALMiniAssembler.SAMPLER_FILTER_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.ANISOTROPIC2X] = new Sampler(AGALMiniAssembler.ANISOTROPIC2X, AGALMiniAssembler.SAMPLER_FILTER_SHIFT, 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.ANISOTROPIC4X] = new Sampler(AGALMiniAssembler.ANISOTROPIC4X, AGALMiniAssembler.SAMPLER_FILTER_SHIFT, 3);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.ANISOTROPIC8X] = new Sampler(AGALMiniAssembler.ANISOTROPIC8X, AGALMiniAssembler.SAMPLER_FILTER_SHIFT, 4);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.ANISOTROPIC16X] = new Sampler(AGALMiniAssembler.ANISOTROPIC16X, AGALMiniAssembler.SAMPLER_FILTER_SHIFT, 5);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.CENTROID] = new Sampler(AGALMiniAssembler.CENTROID, AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT, 1 << 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.SINGLE] = new Sampler(AGALMiniAssembler.SINGLE, AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT, 1 << 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.IGNORESAMPLER] = new Sampler(AGALMiniAssembler.IGNORESAMPLER, AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT, 1 << 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.REPEAT] = new Sampler(AGALMiniAssembler.REPEAT, AGALMiniAssembler.SAMPLER_REPEAT_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.WRAP] = new Sampler(AGALMiniAssembler.WRAP, AGALMiniAssembler.SAMPLER_REPEAT_SHIFT, 1);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.CLAMP] = new Sampler(AGALMiniAssembler.CLAMP, AGALMiniAssembler.SAMPLER_REPEAT_SHIFT, 0);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.CLAMP_U_REPEAT_V] = new Sampler(AGALMiniAssembler.CLAMP_U_REPEAT_V, AGALMiniAssembler.SAMPLER_REPEAT_SHIFT, 2);
            AGALMiniAssembler.SAMPLEMAP[AGALMiniAssembler.REPEAT_U_CLAMP_V] = new Sampler(AGALMiniAssembler.REPEAT_U_CLAMP_V, AGALMiniAssembler.SAMPLER_REPEAT_SHIFT, 3);
        }
        match(value, reg) {
            var matches = [];
            var index = 0;
            var match;
            var result = null;
            while ((result = reg.exec(value)) != null) {
                match = result[0];
                matches.push(match);
                index = reg.lastIndex + match.length;
            }
            return matches;
        }
    }
    AGALMiniAssembler.OPMAP = new Map();
    AGALMiniAssembler.REGMAP = new Map();
    AGALMiniAssembler.SAMPLEMAP = new Map();
    AGALMiniAssembler.MAX_NESTING = 4;
    AGALMiniAssembler.MAX_OPCODES = 4096;
    AGALMiniAssembler.FRAGMENT = "fragment";
    AGALMiniAssembler.VERTEX = "vertex";
    // masks and shifts
    AGALMiniAssembler.SAMPLER_TYPE_SHIFT = 8;
    AGALMiniAssembler.SAMPLER_DIM_SHIFT = 12;
    AGALMiniAssembler.SAMPLER_SPECIAL_SHIFT = 16;
    AGALMiniAssembler.SAMPLER_REPEAT_SHIFT = 20;
    AGALMiniAssembler.SAMPLER_MIPMAP_SHIFT = 24;
    AGALMiniAssembler.SAMPLER_FILTER_SHIFT = 28;
    // regmap flags
    AGALMiniAssembler.REG_WRITE = 0x1;
    AGALMiniAssembler.REG_READ = 0x2;
    AGALMiniAssembler.REG_FRAG = 0x20;
    AGALMiniAssembler.REG_VERT = 0x40;
    // opmap flags
    AGALMiniAssembler.OP_SCALAR = 0x1;
    AGALMiniAssembler.OP_SPECIAL_TEX = 0x8;
    AGALMiniAssembler.OP_SPECIAL_MATRIX = 0x10;
    AGALMiniAssembler.OP_FRAG_ONLY = 0x20;
    AGALMiniAssembler.OP_VERT_ONLY = 0x40;
    AGALMiniAssembler.OP_NO_DEST = 0x80;
    AGALMiniAssembler.OP_VERSION2 = 0x100;
    AGALMiniAssembler.OP_INCNEST = 0x200;
    AGALMiniAssembler.OP_DECNEST = 0x400;
    // opcodes
    AGALMiniAssembler.MOV = "mov";
    AGALMiniAssembler.ADD = "add";
    AGALMiniAssembler.SUB = "sub";
    AGALMiniAssembler.MUL = "mul";
    AGALMiniAssembler.DIV = "div";
    AGALMiniAssembler.RCP = "rcp";
    AGALMiniAssembler.MIN = "min";
    AGALMiniAssembler.MAX = "max";
    AGALMiniAssembler.FRC = "frc";
    AGALMiniAssembler.SQT = "sqt";
    AGALMiniAssembler.RSQ = "rsq";
    AGALMiniAssembler.POW = "pow";
    AGALMiniAssembler.LOG = "log";
    AGALMiniAssembler.EXP = "exp";
    AGALMiniAssembler.NRM = "nrm";
    AGALMiniAssembler.SIN = "sin";
    AGALMiniAssembler.COS = "cos";
    AGALMiniAssembler.CRS = "crs";
    AGALMiniAssembler.DP3 = "dp3";
    AGALMiniAssembler.DP4 = "dp4";
    AGALMiniAssembler.ABS = "abs";
    AGALMiniAssembler.NEG = "neg";
    AGALMiniAssembler.SAT = "sat";
    AGALMiniAssembler.M33 = "m33";
    AGALMiniAssembler.M44 = "m44";
    AGALMiniAssembler.M34 = "m34";
    AGALMiniAssembler.DDX = "ddx";
    AGALMiniAssembler.DDY = "ddy";
    AGALMiniAssembler.IFE = "ife";
    AGALMiniAssembler.INE = "ine";
    AGALMiniAssembler.IFG = "ifg";
    AGALMiniAssembler.IFL = "ifl";
    AGALMiniAssembler.IEG = "ieg";
    AGALMiniAssembler.IEL = "iel";
    AGALMiniAssembler.ELS = "els";
    AGALMiniAssembler.EIF = "eif";
    AGALMiniAssembler.TED = "ted";
    AGALMiniAssembler.KIL = "kil";
    AGALMiniAssembler.TEX = "tex";
    AGALMiniAssembler.SGE = "sge";
    AGALMiniAssembler.SLT = "slt";
    AGALMiniAssembler.SGN = "sgn";
    AGALMiniAssembler.SEQ = "seq";
    AGALMiniAssembler.SNE = "sne";
    // registers
    AGALMiniAssembler.VA = "va";
    AGALMiniAssembler.VC = "vc";
    AGALMiniAssembler.VT = "vt";
    AGALMiniAssembler.VO = "vo";
    AGALMiniAssembler.VI = "vi";
    AGALMiniAssembler.FC = "fc";
    AGALMiniAssembler.FT = "ft";
    AGALMiniAssembler.FS = "fs";
    AGALMiniAssembler.FO = "fo";
    AGALMiniAssembler.FD = "fd";
    AGALMiniAssembler.IID = "iid";
    // samplers
    AGALMiniAssembler.D2 = "2d";
    AGALMiniAssembler.D3 = "3d";
    AGALMiniAssembler.CUBE = "cube";
    AGALMiniAssembler.MIPNEAREST = "mipnearest";
    AGALMiniAssembler.MIPLINEAR = "miplinear";
    AGALMiniAssembler.MIPNONE = "mipnone";
    AGALMiniAssembler.NOMIP = "nomip";
    AGALMiniAssembler.NEAREST = "nearest";
    AGALMiniAssembler.LINEAR = "linear";
    AGALMiniAssembler.ANISOTROPIC2X = "anisotropic2x"; // Introduced by Flash 14
    AGALMiniAssembler.ANISOTROPIC4X = "anisotropic4x"; // Introduced by Flash 14
    AGALMiniAssembler.ANISOTROPIC8X = "anisotropic8x"; // Introduced by Flash 14
    AGALMiniAssembler.ANISOTROPIC16X = "anisotropic16x"; // Introduced by Flash 14
    AGALMiniAssembler.CENTROID = "centroid";
    AGALMiniAssembler.SINGLE = "single";
    AGALMiniAssembler.IGNORESAMPLER = "ignoresampler";
    AGALMiniAssembler.REPEAT = "repeat";
    AGALMiniAssembler.WRAP = "wrap";
    AGALMiniAssembler.CLAMP = "clamp";
    AGALMiniAssembler.REPEAT_U_CLAMP_V = "repeat_u_clamp_v"; // Introduced by Flash 13
    AGALMiniAssembler.CLAMP_U_REPEAT_V = "clamp_u_repeat_v"; // Introduced by Flash 13
    AGALMiniAssembler.RGBA = "rgba";
    AGALMiniAssembler.COMPRESSED = "compressed";
    AGALMiniAssembler.COMPRESSEDALPHA = "compressedalpha";
    AGALMiniAssembler.DXT1 = "dxt1";
    AGALMiniAssembler.DXT5 = "dxt5";
    AGALMiniAssembler.VIDEO = "video";
    AGALMiniAssembler.initialized = false;
    return AGALMiniAssembler;
})();
class OpCode {
    constructor(name, numRegister, emitCode, flags) {
        this.name = name;
        this.numRegister = numRegister;
        this.emitCode = emitCode;
        this.flags = flags;
    }
    toString() {
        return "[OpCode name=\"" + this.name + "\", numRegister=" + this.numRegister + ", emitCode=" + this.emitCode + ", flags=" + this.flags + "]";
    }
}
class Register {
    constructor(name, longName, emitCode, range, flags) {
        this.name = name;
        this.longName = longName;
        this.emitCode = emitCode;
        this.range = range;
        this.flags = flags;
    }
    toString() {
        return "[Register name=\""
            + this.name
            + "\", longName=\""
            + this.longName
            + "\", emitCode="
            + this.emitCode
            + ", range="
            + this.range
            + ", flags="
            + this.flags
            + "]";
    }
}
class Sampler {
    constructor(name, flag, mask) {
        this.name = name;
        this.flag = flag;
        this.mask = mask;
    }
    toString() {
        return "[Sampler name=\"" + this.name + "\", flag=\"" + this.flag + "\", mask=" + this.mask + "]";
    }
}

/**
    The Context3D class provides a context for rendering geometrically defined graphics.
    A rendering context includes a drawing surface and its associated resources and
    this.__state. When possible, the rendering context uses the hardware graphics processing
    unit (GPU). Otherwise, the rendering context uses software. (If rendering through
    Context3D is not supported on a platform, the stage3Ds property of the Stage object
    contains an empty list.)

    The Context3D rendering context is a programmable pipeline that is very similar to
    OpenGL ES 2, but is abstracted so that it is compatible with a range of hardware and
    GPU interfaces. Although designed for 3D graphics, the rendering pipeline does not
    mandate that the rendering is three dimensional. Thus, you can create a 2D renderer
    by supplying the appropriate vertex and pixel fragment programs. In both the 3D and
    2D cases, the only geometric primitive supported is the triangle.

    Get an instance of the Context3D class by calling the requestContext3D() method of a
    Stage3D object. A limited number of Context3D objects can exist per stage; one for
    each Stage3D in the Stage.stage3Ds list. When the context is created, the Stage3D
    object dispatches a context3DCreate event. A rendering context can be destroyed and
    recreated at any time, such as when another application that uses the GPU gains
    focus. Your code should anticipate receiving multiple context3DCreate events.
    Position the rendering area on the stage using the x and y properties of the
    associated Stage3D instance.

    To render and display a scene (after getting a Context3D object), the following steps
    are typical:

    1. Configure the main display buffer attributes by calling `configureBackBuffer()`.
    2. Create and initialize your rendering resources, including:
       * Vertex and index buffers defining the scene geometry
       * Vertex and pixel programs (shaders) for rendering the scene
       * Textures
    3. Render a frame:
       * Set the render state as appropriate for an object or collection of objects in
       the scene.
       * Call the `drawTriangles()` method to render a set of triangles.
       * Change the rendering state for the next group of objects.
       * Call `drawTriangles()` to draw the triangles defining the objects.
       * Repeat until the scene is entirely rendered.
       * Call the `present()` method to display the rendered scene on the stage.

    The following limits apply to rendering:

    Resource limits:

    | Resource | Number allowed | Total memory |
    | --- | --- | --- |
    | Vertex buffers | 4096 | 256 MB |
    | Index buffers | 4096 | 128 MB |
    | Programs | 4096 | 16 MB |
    | Textures | 4096 | 128 MB |
    | Cube textures | 4096 | 256 MB |

    AGAL limits: 200 opcodes per program.

    Draw call limits: 32,768 `drawTriangles()` calls for each `present()` call.

    The following limits apply to textures:

    Texture limits for AIR 32 bit:

    | Texture | Maximum size | Total GPU memory |
    | --- | --- | --- |
    | Normal Texture (below Baseline extended) | 2048x2048 | 512 MB |
    | Normal Texture (Baseline extended and above) | 4096x4096 | 512 MB |
    | Rectangular Texture (below Baseline extended) | 2048x2048 | 512 MB |
    | Rectangular Texture (Baseline extended and above) | 4096x4096 | 512 MB |
    | Cube Texture | 1024x1024 | 256 MB |

    Texture limits for AIR 64 bit (Desktop):

    | Texture | Maximum size | Total GPU memory |
    | --- | --- | --- |
    | Normal Texture (below Baseline extended) | 2048x2048 | 512 MB |
    | Normal Texture (Baseline extended to Standard) | 4096x4096 | 512 MB |
    | Normal Texture (Standard extended and above) | 4096x4096 | 2048 MB |
    | Rectangular Texture (below Baseline extended) | 2048x2048 | 512 MB |
    | Rectangular Texture (Baseline extended to Standard) | 4096x4096 | 512 MB |
    | Rectangular Texture (Standard extended and above) | 4096x4096 | 2048 MB |
    | Cube Texture | 1024x1024 | 256 MB |

    512 MB is the absolute limit for textures, including the texture memory required
    for mipmaps. However, for Cube Textures, the memory limit is 256 MB.

    You cannot create Context3D objects with the Context3D constructor. It is
    constructed and available as a property of a Stage3D instance. The Context3D class
    can be used on both desktop and mobile platforms, both when running in Flash Player
    and AIR.
**/
let Context3D = /** @class */ (() => {
    class Context3D extends EventDispatcher {
        constructor(stage, contextState = null, stage3D = null) {
            super();
            this.__backBufferHeight = 0;
            this.__backBufferWidth = 0;
            this.__driverInfo = "OpenGL (Direct blitting)";
            this.__profile = Context3DProfile.STANDARD;
            this.__stage = stage;
            this.__contextState = contextState;
            this.__stage3D = stage3D;
            if (this.__contextState == null)
                this.__contextState = new Context3DState();
            this.__state = new Context3DState();
            // TODO: Dummy impl?
            this.__vertexConstants = new Float32Array(4 * 128);
            this.__fragmentConstants = new Float32Array(4 * 128);
            this.__programs = new Map();
            // this.__backend = new Context3DBackend(this);
            this.__bitmapDataPool = new BitmapDataPool(30, this);
            this.__quadIndexBufferElements = Math.floor(0xFFFF / 4);
            this.__quadIndexBufferCount = this.__quadIndexBufferElements * 6;
            // TODO: Dummy impl?
            var data = new Uint16Array(this.__quadIndexBufferCount);
            var index = 0;
            var vertex = 0;
            for (let i = 0; i < this.__quadIndexBufferElements; i++) {
                data[index] = vertex;
                data[index + 1] = vertex + 1;
                data[index + 2] = vertex + 2;
                data[index + 3] = vertex + 2;
                data[index + 4] = vertex + 1;
                data[index + 5] = vertex + 3;
                index += 6;
                vertex += 4;
            }
            this.__quadIndexBuffer = this.createIndexBuffer(this.__quadIndexBufferCount);
            this.__quadIndexBuffer.uploadFromTypedArray(data);
        }
        /**
            Clears the color, depth, and stencil buffers associated with this Context3D
            object and fills them with the specified values.
    
            Set the `mask` parameter to specify which buffers to clear. Use the constants
            defined in the Context3DClearMask class to set the `mask` parameter. Use the
            bitwise OR operator, "|", to add multiple buffers to the mask (or use
            Context3DClearMask.ALL). When rendering to the back buffer, the
            `configureBackBuffer()` method must be called before any `clear()` calls.
    
            **Note:** If you specify a parameter value outside the allowed range, Numeric
            parameter values are silently clamped to the range zero to one. Likewise, if
            stencil is greater than 0xff it is set to 0xff.
    
            @param	red	the red component of the color with which to clear the color buffer,
            in the range zero to one.
            @param	green	the green component of the color with which to clear the color
            buffer, in the range zero to one.
            @param	blue	the blue component of the color with which to clear the color
            buffer, in the range zero to one.
            @param	alpha	the alpha component of the color with which to clear the color
            buffer, in the range zero to one. The alpha component is not used for blending.
            It is written to the buffer alpha directly.
            @param	depth	the value with which to clear the depth buffer, in the range
            zero to one.
            @param	stencil	the 8-bit value with which to clear the stencil buffer, in a
            range of 0x00 to 0xff.
            @param	mask	specifies which buffers to clear.
            @throws	Error	Object Disposed: If this Context3D object has been disposed by a calling
            dispose() or because the underlying rendering hardware has been lost.
            @throws	Error	3768: The Stage3D API may not be used during background execution.
        **/
        clear(red = 0, green = 0, blue = 0, alpha = 1, depth = 1, stencil = 0, mask = Context3DClearMask.ALL) {
            // this.__backend.clear(red, green, blue, alpha, depth, stencil, mask);
        }
        /**
            Sets the viewport dimensions and other attributes of the rendering buffer.
    
            Rendering is double-buffered. The back buffer is swapped with the visible,
            front buffer when the `present()` method is called. The minimum size of the
            buffer is 32x32 pixels. The maximum size of the back buffer is limited by the
            device capabilities and can also be set by the user through the properties
            `maxBackBufferWidth` and `maxBackBufferHeight`. Configuring the buffer is a
            slow operation. Avoid changing the buffer size or attributes during normal
            rendering operations.
    
            @param	width	width in pixels of the buffer.
            @param	height	height in pixels of the buffer.
            @param	antiAlias	an integer value specifying the requested antialiasing
            quality. The value correlates to the number of subsamples used when
            antialiasing. Using more subsamples requires more calculations to be performed,
            although the relative performance impact depends on the specific rendering
            hardware. The type of antialiasing and whether antialiasing is performed at all is
            dependent on the device and rendering mode. Antialiasing is not supported at all by
            the software rendering context.
            | --- | --- |
            | 0 | No antialiasing |
            | 2 | Minimal antialiasing |
            | 4 | High-quality antialiasing |
            | 16 | Very high-quality antialiasing |
            @param	enableDepthAndStencil	`false` indicates no depth or stencil buffer is
            created, `true` creates a depth and a stencil buffer. For an AIR 3.2 or later
            application compiled with SWF version 15 or higher, if the `renderMode` element in
            the application descriptor file is `direct`, then the `depthAndStencil` element in
            the application descriptor file must have the same value as this argument. By
            default, the value of the `depthAndStencil` element is `false`.
            @param	wantsBestResolution	`true` indicates that if the device supports HiDPI
            screens it will attempt to allocate a larger back buffer than indicated with the
            `width` and `height` parameters. Since this add more pixels and potentially changes
            the result of shader operations this is turned off by default. Use
            `Stage.contentsScaleFactor` to determine by how much the native back buffer was
            scaled up.
            @param	wantsBestResolutionOnBrowserZoom	`true` indicates that the size of the
            back buffer should increase in proportion to the increase in the browser zoom
            factor. The setting of this value is persistent across multiple browser zooms.
            The default value of the parameter is `false`. Set `maxBackBufferWidth` and
            `maxBackBufferHeight` properties to limit the back buffer size increase. Use
            `backBufferWidth` and `backBufferHeight` to determine the current size of the
            back buffer.
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	Bad Input Size: The `width` or `height` parameter is either less
            than the minimum back buffer allowed size or greater than the maximum back buffer
            size allowed.
            @throws	Error	3709: The `depthAndStencil` flag in the application descriptor
            must match the `enableDepthAndStencil` Boolean passed to `configureBackBuffer()`
            on the Context3D object.
        **/
        configureBackBuffer(width, height, antiAlias, enableDepthAndStencil = true, wantsBestResolution = false, wantsBestResolutionOnBrowserZoom = false) {
            // this.__backend.configureBackBuffer(width, height, antiAlias, enableDepthAndStencil, wantsBestResolution, wantsBestResolutionOnBrowserZoom);
        }
        /**
            Creates a CubeTexture object.
    
            Use a CubeTexture object to upload cube texture bitmaps to the rendering context
            and to reference a cube texture during rendering. A cube texture consists of six
            equal-sized, square textures arranged in a cubic topology and are useful for
            describing environment maps.
    
            You cannot create CubeTexture objects with a CubeTexture constructor; use this
            method instead. After creating a CubeTexture object, upload the texture bitmap
            data using the CubeTexture `uploadFromBitmapData()`, `uploadFromByteArray()`, or
            `uploadCompressedTextureFromByteArray()` methods.
    
            @param size	The texture edge length in texels.
            @param format	The texel format, of the Context3DTextureFormat enumerated list.
            Texture compression lets you store texture images in compressed format directly on
            the GPU, which saves GPU memory and memory bandwidth. Typically, compressed
            textures are compressed offline and uploaded to the GPU in compressed form
            using the `Texture.uploadCompressedTextureFromByteArray` method. Flash Player 11.4
            and AIR 3.4 on desktop platforms added support for runtime texture compression,
            which may be useful in certain situations, such as when rendering dynamic
            textures from vector art. Note that this feature is not currently available on
            mobile platforms and an ArgumentError (Texture Format Mismatch) will be thrown
            instead. To use runtime texture compression, perform the following steps:
            1. Create the texture object by calling the `Context3D.createCubeTexture()`
            method, passing either `openfl.display3D.Context3DTextureFormat.COMPRESSED` or
            `openfl.display3D.Context3DTextureFormat.COMPRESSED_ALPHA` as the format
            parameter.
            2. Using the openfl.display3D.textures.Texture instance returned by
            `createCubeTexture()`, call either
            `openfl.display3D.textures.CubeTexture.uploadFromBitmapData()` or
            `openfl.display3D.textures.CubeTexture.uploadFromByteArray()` to upload and
            compress the texture in one step.
            @param optimizeForRenderToTexture	Set to true if the texture is likely to be
            used as a render target.
            @param streamingLevels	The MIP map level that must be loaded before the image
            is rendered. Texture streaming offers the ability to load and display the
            smallest mip levels first, progressively displaying higher quality images as the
            textures are loaded. End users can view lower-quality images in an application
            while the higher quality images load.
    
            By default, streamingLevels is 0, meaning that the highest quality image in the
            MIP map must be loaded before the image is rendered. This parameter was added in
            Flash Player 11.3 and AIR 3.3. Using the default value maintains the behavior of
            the previous versions of Flash Player and AIR.
    
            Set streamingLevels to a value between 1 and the number of images in the MIP map
            to enable texture streaming. For example, you have a MIP map that includes at the
            highest quality a main image at 64x64 pixels. Lower quality images in the MIP map
            are 32x32, 16x16, 8x8, 4x4, 2x2, and 1x1 pixels, for 7 images in total, or 7
            levels. Level 0 is the highest quality image. The maximum value of this property
            is log2(min(width,height)). Therefore, for a main image that is 64x64 pixels, the
            maximum value of streamingLevels is 7. Set this property to 3 to render the image
            after the 8x8 pixel image loads.
    
            **Note:** Setting this property to a value > 0 can impact memory usage and
            performance.
    
            @return	A new CubeTexture object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	Resource Limit Exceeded: if too many Texture objects are created
            or the amount of memory allocated to textures is exceeded.
            @throws	ArgumentError	Depth Texture Not Implemented: if you attempt to create
            a depth texture.
            @throws	ArgumentError	Texture Size Is Zero: if the size parameter is not greater
            than zero.
            @throws	ArgumentError	Texture Not Power Of Two: if the size parameter is not a
            power of two.
            @throws	ArgumentError	Texture Too Big: if the size parameter is greater than
            1024.
            @throws	Error	Texture Creation Failed: if the CubeTexture object could not be
            created by the rendering context (but information about the reason is not
            available).
            @throws	ArgumentError	Invalid streaming level: if streamingLevels is greater or
            equal to `log2(size)`.
        **/
        createCubeTexture(size, format, optimizeForRenderToTexture, streamingLevels = 0) {
            return new CubeTexture(this, size, format, optimizeForRenderToTexture, streamingLevels);
        }
        /**
            Creates an IndexBuffer3D object.
    
            Use an IndexBuffer3D object to upload a set of triangle indices to the rendering
            context and to reference that set of indices for rendering. Each index in the
            index buffer references a corresponding vertex in a vertex buffer. Each set of
            three indices identifies a triangle. Pass the IndexBuffer3D object to the
            `drawTriangles()` method to render one or more triangles defined in the index
            buffer.
    
            You cannot create IndexBuffer3D objects with the IndexBuffer3D class constructor;
            use this method instead. After creating a IndexBuffer3D object, upload the
            indices using the IndexBuffer3D `uploadFromVector()` or `uploadFromByteArray()`
            methods.
    
            @param	numIndices	the number of vertices to be stored in the buffer.
            @param	bufferUsage	the expected buffer usage. Use one of the constants defined
            in Context3DBufferUsage. The hardware driver can do appropriate optimization
            when you set it correctly. This parameter is only available after Flash 12/AIR 4.
            @return	A new IndexBuffer3D object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	Resource Limit Exceeded: if too many index buffers are created
            or the amount of memory allocated to index buffers is exceeded.
            @throws	Error	3768: The Stage3D API may not be used during background execution.
            @throws	ArgumentError	Buffer Too Big: when `numIndices` is greater than or equal
            to 0xf0000.
        **/
        createIndexBuffer(numIndices, bufferUsage = Context3DBufferUsage.STATIC_DRAW) {
            return new IndexBuffer3D(this, numIndices, bufferUsage);
        }
        /**
            Creates a Program3D object.
    
            Use a Program3D object to upload shader programs to the rendering context and
            to reference uploaded programs during rendering. A Program3D object stores
            two programs, a vertex program and a fragment program (also known as a pixel
            program). The programs are written in a binary shader assembly language.
    
            You cannot create Program3D objects with a Program3D constructor; use this method
            instead. After creating a Program3D object, upload the programs using the
            Program3D `upload()` method.
    
            @param	format	(Experimental) Set the format of this Program3D instance to AGAL
            (default) or to GLSL for use on GL-based renderers
            @return	A new Program3D object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	The number of programs exceeds 4096 or the total memory size
            exceeds 16MB (use dispose to free Program3D resources).
        **/
        createProgram(format = Context3DProgramFormat.AGAL) {
            return new Program3D(this, format);
        }
        /**
            Creates a Rectangle Texture object.
    
            Use a RectangleTexture object to upload texture bitmaps to the rendering context
            and to reference a texture during rendering.
    
            You cannot create RectangleTexture objects with a RectangleTexture constructor;
            use this method instead. After creating a RectangleTexture object, upload the
            texture bitmaps using the Texture `uploadFromBitmapData()` or
            `uploadFromByteArray()` methods.
    
            Note that 32-bit integer textures are stored in a packed BGRA format to match
            the OpenFL BitmapData format. Floating point textures use a conventional RGBA
            format.
    
            Rectangle textures are different from regular 2D textures in that their width and
            height do not have to be powers of two. Also, they do not contain mip maps.
            They are most useful for use in render to texture cases. If a rectangle texture
            is used with a sampler that uses mip map filtering or repeat wrapping the
            drawTriangles call will fail. Rectangle texture also do not allow streaming. The
            only texture formats supported by Rectangle textures are BGRA, BGR_PACKED,
            BGRA_PACKED. The compressed texture formats are not supported by Rectangle
            Textures.
    
            @param	width	The texture width in texels.
            @param	height	The texture height in texels.
            @param	format	The texel format, of the Context3DTextureFormat enumerated list.
            @param	optimizeForRenderToTexture	Set to true if the texture is likely to be
            used as a render target.
            @return	A new RectangleTexture object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling dispose() or because the underlying rendering hardware has been lost.
            @throws	Error	Resource Limit Exceeded: if too many Texture objects are created
            or the amount of memory allocated to textures is exceeded.
            @throws	ArgumentError	Texture Size Is Zero: if both the width or height
            parameters are not greater than zero.
            @throws	ArgumentError	Texture Too Big: if either the width or the height
            parameter is greater than 2048.
            @throws	Error	Texture Creation Failed: if the Texture object could not be
            created by the rendering context (but information about the reason is not
            available).
            @throws	Error	Requires Baseline Profile Or Above: if rectangular texture is
            created with baseline constrained profile.
        **/
        createRectangleTexture(width, height, format, optimizeForRenderToTexture) {
            return new RectangleTexture(this, width, height, format, optimizeForRenderToTexture);
        }
        /**
            Creates a Texture object.
    
            Use a Texture object to upload texture bitmaps to the rendering context and to
            reference a texture during rendering.
    
            You cannot create Texture objects with a Texture constructor; use this method
            instead. After creating a Texture object, upload the texture bitmaps using the
            Texture `uploadFromBitmapData()`, `uploadFromByteArray()`, or
            `uploadCompressedTextureFromByteArray()` methods.
    
            Note that 32-bit integer textures are stored in a packed BGRA format to match
            the OpenFL BitmapData format. Floating point textures use a conventional RGBA
            format.
    
            @param	width	The texture width in texels.
            @param	height	The texture height in texels.
            @param	format	The texel format, of the Context3DTextureFormat enumerated list.
            Texture compression lets you store texture images in compressed format directly
            on the GPU, which saves GPU memory and memory bandwidth. Typically, compressed
            textures are compressed offline and uploaded to the GPU in compressed form using
            the Texture.uploadCompressedTextureFromByteArray method. Flash Player 11.4 and
            AIR 3.4 on desktop platforms added support for runtime texture compression, which
            may be useful in certain situations, such as when rendering dynamic textures from
            vector art. Note that this feature is not currently available on mobile platforms
            and an ArgumentError (Texture Format Mismatch) will be thrown instead. To use
            runtime texture compression, perform the following steps:
            1. Create the texture object by calling the `Context3D.createTexture()` method,
            passing either `openfl.display3D.Context3DTextureFormat.COMPRESSED` or
            `openfl.display3D.Context3DTextureFormat.COMPRESSED_ALPHA` as the format
            parameter.
            2. Using the openfl.display3D.textures.Texture instance returned by
            `createTexture()`, call either
            `openfl.display3D.textures.Texture.uploadFromBitmapData()` or
            `openfl.display3D.textures.Texture.uploadFromByteArray()` to upload and compress
            the texture in one step.
            @param	optimizeForRenderToTexture	Set to true if the texture is likely to be
            used as a render target.
            @param	streamingLevels	The MIP map level that must be loaded before the image is
            rendered. Texture streaming offers the ability to load and display the smallest
            mip levels first, progressively displaying higher quality images as the textures
            are loaded. End users can view lower-quality images in an application while the
            higher quality images load.
    
            By default, streamingLevels is 0, meaning that the highest quality image in the
            MIP map must be loaded before the image is rendered. This parameter was added in
            Flash Player 11.3 and AIR 3.3. Using the default value maintains the behavior of
            the previous versions of Flash Player and AIR.
    
            Set `streamingLevels` to a value between 1 and the number of images in the MIP map
            to enable texture streaming. For example, you have a MIP map that includes at
            the highest quality a main image at 64x64 pixels. Lower quality images in the
            MIP map are 32x32, 16x16, 8x8, 4x4, 2x2, and 1x1 pixels, for 7 images in total,
            or 7 levels. Level 0 is the highest quality image. The maximum value of this
            property is log2(min(width,height)). Therefore, for a main image that is
            64x64 pixels, the maximum value of streamingLevels is 7. Set this property to
            3 to render the image after the 8x8 pixel image loads.
    
            **Note:** Setting this property to a value > 0 can impact memory usage and
            performance.
    
            @return	A new Texture object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a calling dispose() or because the underlying rendering hardware has been lost.
            @throws	Error	Resource Limit Exceeded: if too many Texture objects are created or the amount of memory allocated to textures is exceeded.
            @throws	ArgumentError	Depth Texture Not Implemented: if you attempt to create a depth texture.
            @throws	ArgumentError	Texture Size Is Zero: if both the width or height parameters are not greater than zero.
            @throws	ArgumentError	Texture Not Power Of Two: if both the width and height parameters are not a power of two.
            @throws	ArgumentError	Texture Too Big: if either the width or the height parameter is greater than 2048 for baseline and baseline constrained profile or if either the width or the height parameter is greater than 4096 for profile baseline extended and above.
            @throws	Error	Texture Creation Failed: if the Texture object could not be created by the rendering context (but information about the reason is not available).
            @throws	ArgumentError	Invalid streaming level: if streamingLevels is greater or equal to log2(min(width,height)).
        **/
        createTexture(width, height, format, optimizeForRenderToTexture, streamingLevels = 0) {
            return new Texture(this, width, height, format, optimizeForRenderToTexture, streamingLevels);
        }
        /**
            Creates a VertexBuffer3D object.
    
            Use a VertexBuffer3D object to upload a set of vertex data to the rendering
            context. A vertex buffer contains the data needed to render each point in the
            scene geometry. The data attributes associated with each vertex typically
            includes position, color, and texture coordinates and serve as the input to
            the vertex shader program. Identify the data values that correspond to one of
            the inputs of the vertex program using the `setVertexBufferAt()` method. You can
            specify up to sixty-four 32-bit values for each vertex.
    
            You cannot create VertexBuffer3D objects with a VertexBuffer3D constructor; use
            this method instead. After creating a VertexBuffer3D object, upload the vertex
            data using the VertexBuffer3D `uploadFromVector()` or `uploadFromByteArray()`
            methods.
    
            @param	numVertices	the number of vertices to be stored in the buffer. The
            maximum number of vertices in a single buffer is 65535.
            @param	data32PerVertex	the number of 32-bit(4-byte) data values associated
            with each vertex. The maximum number of 32-bit data elements per vertex is 64
            (or 256 bytes). Note that only eight attribute registers are accessible by a
            vertex shader program at any given time. Use `setVertextBufferAt()` to select
            attributes from within a vertex buffer.
            @param	bufferUsage	the expected buffer usage. Use one of the constants defined
            in Context3DBufferUsage. The hardware driver can do appropriate optimization when
            you set it correctly. This parameter is only available after Flash 12/AIR 4
            @return	A new VertexBuffer3D object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	Resource Limit Exceeded: if too many vertex buffer objects are
            created or the amount of memory alloted to vertex buffers is exceeded.
            @throws	ArgumentError	Buffer Too Big: when `numVertices` is greater than 0x10000
            or `data32PerVertex` is greater than 64.
            @throws	ArgumentError	Buffer Has Zero Size: when `numVertices` is zero or
            `data32PerVertex` is zero.
            @throws	ArgumentError	Buffer Creation Failed: if the VertexBuffer3D object
            could not be created by the rendering context (but additional information about
            the reason is not available).
            @throws	Error	3768: The Stage3D API may not be used during background execution.
        **/
        createVertexBuffer(numVertices, data32PerVertex, bufferUsage = Context3DBufferUsage.STATIC_DRAW) {
            return new VertexBuffer3D(this, numVertices, data32PerVertex, bufferUsage);
        }
        /**
            Creates a VideoTexture object.
    
            Use a VideoTexture object to obtain video frames as texture from NetStream object
            or Camera object and to upload the video frames to the rendering context.
    
            The VideoTexture object cannot be created with the VideoTexture constructor; use
            this method instead. After creating a VideoTexture object, attach NetStream
            object or Camera Object to get the video frames with the VideoTexture
            `attachNetStream()` or `attachCamera()` methods.
    
            Note that this method returns null if the system doesn't support this feature.
    
            VideoTexture does not contain mipmaps. If VideoTexture is used with a sampler
            that uses mip map filtering or repeat wrapping, the drawTriangles call will fail.
            VideoTexture can be treated as BGRA texture by the shaders. The attempt to
            instantiate the VideoTexture Object will fail if the Context3D was requested
            with sotfware rendering mode.
    
            A maximum of 4 VideoTexture objects are available per Context3D instance. On
            mobile the actual number of supported VideoTexture objects may be less than 4
            due to platform limitations.
    
            @return	A new VideoTexture object
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	Resource Limit Exceeded: if too many Texture objects are created
            or the amount of memory allocated to textures is exceeded.
            @throws	Error	Texture Creation Failed: if the Texture object could not be
            created by the rendering context (but information about the reason is not
            available).
        **/
        createVideoTexture() {
            if (Context3D.supportsVideoTexture) {
                return new VideoTexture(this);
            }
            else {
                throw new Error$1("Video textures are not currently supported");
            }
        }
        /**
            Frees all resources and internal storage associated with this Context3D.
    
            All index buffers, vertex buffers, textures, and programs that were created
            through this Context3D are disposed just as if calling `dispose()` on each of
            them individually. In addition, the Context3D itself is disposed freeing all
            temporary buffers and the back buffer. If you call `configureBackBuffer()`,
            `clear()`, `drawTriangles()`, `createCubeTexture()`, `createTexture()`,
            `createProgram()`, `createIndexBuffer()`, `createVertexBuffer()`, or
            `drawToBitmapData()` after calling `dispose()`, the runtime throws an exception.
    
            Warning: calling `dispose()` on a Context3D while there is still a event
            listener for `Events.CONTEXT3D_CREATE` set on the asociated Stage3D object the
            `dispose()` call will simulate a device loss. It will create a new Context3D on
            the Stage3D and issue the `Events.CONTEXT3D_CREATE` event again. If this is not
            desired remove the event listener from the Stage3D object before calling
            `dispose()` or set the `recreate` parameter to `false`.
    
            @param	recreate	Whether to allow this Stage3D object to create itself again
        **/
        dispose(recreate = true) {
            // this.__backend.dispose(recreate);
            this.__renderStage3DProgram = null;
            this.__frontBufferTexture = null;
            this.__present = false;
            this.__backBufferTexture = null;
            this.__fragmentConstants = null;
            this.__quadIndexBuffer = null;
            this.__stage = null;
            this.__vertexConstants = null;
        }
        /**
            Draws the current render buffer to a bitmap.
    
            The current contents of the back render buffer are copied to a BitmapData
            object. This is potentially a very slow operation that can take up to a second.
            Use with care. Note that this does not copy the front render buffer
            (the one shown on stage), but the buffer being drawn to. To capture the rendered
            image as it appears on the stage, call `drawToBitmapData()` immediately before you
            calling `present()`.
    
            Beginning with AIR 25, two new parameters have been introduced in the API
            `drawToBitmapData()`. This API now takes three parameters. The first one is the
            existing parameter `destination:BitmapData`. The second parameter is
            `srcRect:Rectangle`, which is target rectangle on Stage3D. The third parameter is
            `destPoint:Point`, which is the coordinate on the destination bitmap. The
            parameters `srcRect` and `destPoint` are optional and default to
            `(0,0,bitmapWidth,bitmapHeight)` and `(0,0)`, respectively.
    
            When the image is drawn, it is not scaled to fit the bitmap. Instead, the
            contents are clipped to the size of the destination bitmap.
    
            OpenFL BitmapData objects store colors already multiplied by the alpha component.
            For example, if the "pure" rgb color components of a pixel are (0x0A, 0x12, 0xBB)
            and the alpha component is 0x7F (.5), then the pixel is stored in the
            BitmapData object with the rgba values: (0x05, 0x09, 0x5D, 0x7F). You can set the
            blend factors so that the colors rendered to the buffer are multiplied by alpha
            or perform the operation in the fragment shader. The rendering context does not
            validate that the colors are stored in premultiplied format.
    
            @param	destination	The target BitmapData for this drawing operation
            @param	srcRect	The source rectangle in the current Stage3D context
            @param	destPoint A destination point to write to in the target BitmapData
            @throws	Error	Object Disposed: if this Context3D object has been disposed by
            a calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error	3768: The Stage3D API may not be used during background execution.
            @throws	Error	3802: If either one of the parameters `destPoint:Point` or
            `srcRect:Rectangle` is outside the bitmap/stage3D coordinate bound, or if
            non-numeric(NaN) values are passed as input.
        **/
        drawToBitmapData(destination, srcRect = null, destPoint = null) {
            // this.__backend.drawToBitmapData(destination, srcRect, destPoint);
        }
        /**
            Render the specified triangles using the current buffers and state of this
            Context3D object.
    
            For each triangle, the triangle vertices are processed by the vertex shader
            program and the triangle surface is processed by the pixel shader program. The
            output color from the pixel program for each pixel is drawn to the render
            target depending on the stencil operations, depth test, source and destination
            alpha, and the current blend mode. The render destination can be the main render
            buffer or a texture.
    
            If culling is enabled, (with the `setCulling()` method), then triangles can be
            discarded from the scene before the pixel program is run. If stencil and depth
            testing are enabled, then output pixels from the pixel program can be discarded
            without updating the render destination. In addition, the pixel program can
            decide not to output a color for a pixel.
    
            The rendered triangles are not displayed in the viewport until you call the
            `present()` method. After each `present()` call, the `clear()` method must be
            called before the first `drawTriangles()` call or rendering fails.
    
            When `enableErrorChecking` is `false`, this returns immediately, does
            not wait for results, and throws exceptions only if this Context3D instance has
            been disposed or there are too many draw calls. If the rendering context state
            is invalid rendering fails silently. When the `enableErrorChecking` property is
            `true`, this returns after the triangles are drawn and throws exceptions
            for any drawing errors or invalid context this.__state.
    
            @param	indexBuffer:IndexBuffer3D — a set of vertex indices referencing the
            vertices to render.
            @param	firstIndex:int (default = 0) — the index of the first vertex index
            selected to render. Default 0.
            @param	numTriangles:int (default = -1) — the number of triangles to render.
            Each triangle consumes three indices. Pass -1 to draw all triangles in the index
            buffer. Default -1.
            @throws	Error — Object Disposed: if this Context3D object has been disposed by
            a calling `dispose()` or because the underlying rendering hardware has been lost.
            @throws	Error — If this method is called too many times between calls to
            `present()`. The maximum number of calls is 32,768.
    
            The following errors are only thrown when `enableErrorChecking` property is true:
            @throws	Error	Need To Clear Before Draw: If the buffer has not been cleared
            since the last `present()` call.
            @throws	Error	If a valid Program3D object is not set.
            @throws	Error	No Valid Index Buffer Set: If an IndexBuffer3D object is not set.
            @throws	Error	Sanity Check On Parameters Failed: when the number of triangles
            to be drawn or the `firstIndex` exceed allowed values.
            @throws	RangeError — Not Enough Indices In This Buffer: when there aren't enough
            indices in the buffer to define the number of triangles to be drawn.
            @throws	Error — Sample Binds Texture Also Bound To Render: when the render target
            is a texture and that texture assigned to a texture input of the current fragment
            program.
            @throws	Error — Sample Binds Invalid Texture: an invalid texture is specified as
            the input to the current fragment program.
            @throws	Error — Sampler Format Does Not Match Texture Format: when the texture
            assigned as the input to the current fragment program has a different format than
            that specified for the sampler register. For example, a 2D texture is assigned to
            a cube texture sampler.
            @throws	Error — Sample Binds Undefined Texture: The current fragment program
            accesses a texture register that has not been set (using `setTextureAt()`).
            @throws	Error — Same Texture Needs Same Sampler Params: If a texture is used for
            more than one sampler register, all of the samplers must have the same settings.
            For example, you cannot set one sampler to clamp and another to wrap.
            @throws	Error — Texture Bound But Not Used: A texture is set as a shader input,
            but it is not used.
            @throws	Error — Stream Is Not Used: A vertex buffer is assigned to a vertex
            attribute input, but the vertex program does not reference the corresponding
            register.
            @throws	Error — Stream Is Invalid: a VertexBuffer3D object assigned to a vertex
            program input is not a valid object.
            @throws	RangeError — Stream Does Not Have Enough Vertices: A vertex buffer
            supplying data for drawing the specified triangles does not have enough data.
            @throws	RangeError — Stream Vertex Offset Out Of Bounds: The offset specified in
            a `setVertexBufferAt()` call is negative or past the end of the buffer.
            @throws	Error — Stream Read But Not Set: A vertex attribute used by the current
            vertex program is not set (using `setVertexBufferAt()`).
        **/
        drawTriangles(indexBuffer, firstIndex = 0, numTriangles = -1) {
            // this.__backend.drawTriangles(indexBuffer, firstIndex, numTriangles);
        }
        /**
            Displays the back rendering buffer.
    
            Calling the `present()` method makes the results of all rendering operations
            since the last `present()` call visible and starts a new rendering cycle.
            After calling `present`, you must call `clear()` before making another
            `drawTriangles()` call. Otherwise, this will alternately clear the
            render buffer to yellow and green or, if `enableErrorChecking` has been set to
            `true`, an exception is thrown.
    
            Calling `present()` also resets the render target, just like calling
            `setRenderToBackBuffer()`.
    
            @throws	Error	Need To Clear Before Draw: If the `clear()` has not been called
            since the previous call to `present()`. (Two consecutive `present()` calls are
            not allowed without calling `clear()` in between.)
            @throws	Error	3768: The Stage3D API may not be used during background execution.
        **/
        present() {
            // this.__backend.present();
        }
        /**
            Specifies the factors used to blend the output color of a drawing operation with
            the existing color.
    
            The output (source) color of the pixel shader program is combined with the
            existing (destination) color at that pixel according to the following formula:
    
            `result color = (source color * sourceFactor) + (destination color * destinationFactor)`
    
            The destination color is the current color in the render buffer for that pixel.
            Thus it is the result of the most recent `clear()` call and any intervening
            `drawTriangles()` calls.
    
            Use `setBlendFactors()` to set the factors used to multiply the source and
            destination colors before they are added together. The default blend factors
            are, `sourceFactor = Context3DBlendFactor.ONE`, and
            `destinationFactor = Context3DBlendFactor.ZERO`, which results in the source
            color overwriting the destination color (in other words, no blending of the
            two colors occurs). For normal alpha blending, use
            `sourceFactor = Context3DBlendFactor.SOURCE_ALPHA` and
            `destinationFactor = Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA`.
    
            Use the constants defined in the Context3DBlendFactor class to set the
            parameters of this function.
    
            @param	sourceFactor	The factor with which to multiply the source color.
            Defaults to `Context3DBlendFactor.ONE`.
            @param	destinationFactor	The factor with which to multiply the destination
            color. Defaults to `Context3DBlendFactor.ZERO`.
            @throws	Error — Invalid Enum: when `sourceFactor` or `destinationFactor` is
            not one of the recognized values, which are defined in the
            Context3DBlendFactor class.
        **/
        setBlendFactors(sourceFactor, destinationFactor) {
            this.setBlendFactorsSeparate(sourceFactor, destinationFactor, sourceFactor, destinationFactor);
        }
        setBlendFactorsSeparate(sourceRGBFactor, destinationRGBFactor, sourceAlphaFactor, destinationAlphaFactor) {
            this.__state.blendSourceRGBFactor = sourceRGBFactor;
            this.__state.blendDestinationRGBFactor = destinationRGBFactor;
            this.__state.blendSourceAlphaFactor = sourceAlphaFactor;
            this.__state.blendDestinationAlphaFactor = destinationAlphaFactor;
            // TODO: Better way to handle this?
            // this.__backend.resetGLBlendEquation();
        }
        /**
            Sets the mask used when writing colors to the render buffer.
    
            Only color components for which the corresponding color mask parameter is `true`
            are updated when a color is written to the render buffer. For example, if
            you call: `setColorMask(true, false, false, false)`, only the red component
            of a color is written to the buffer until you change the color mask again. The
            color mask does not affect the behavior of the `clear()` method.
    
            @param	red	set false to block changes to the red channel.
            @param	green	set false to block changes to the green channel.
            @param	blue	set false to block changes to the blue channel.
            @param	alpha	set false to block changes to the alpha channel.
        **/
        setColorMask(red, green, blue, alpha) {
            this.__state.colorMaskRed = red;
            this.__state.colorMaskGreen = green;
            this.__state.colorMaskBlue = blue;
            this.__state.colorMaskAlpha = alpha;
        }
        /**
            Sets triangle culling mode.
    
            Triangles may be excluded from the scene early in the rendering pipeline based
            on their orientation relative to the view plane. Specify vertex order
            consistently (clockwise or counter-clockwise) as seen from the outside of the
            model to cull correctly.
    
            @param	triangleFaceToCull	the culling mode. Use one of the constants defined
            in the Context3DTriangleFace class.
            @throws	Error	Invalid Enum Error: when triangleFaceToCull is not one of the
            values defined in the Context3DTriangleFace class.
        **/
        setCulling(triangleFaceToCull) {
            this.__state.culling = triangleFaceToCull;
        }
        /**
            Sets type of comparison used for depth testing.
    
            The depth of the source pixel output from the pixel shader program is compared
            to the current value in the depth buffer. If the comparison evaluates as `false`,
            then the source pixel is discarded. If `true`, then the source pixel is processed
            by the next step in the rendering pipeline, the stencil test. In addition, the
            depth buffer is updated with the depth of the source pixel, as long as the
            `depthMask` parameter is set to `true`.
    
            Sets the test used to compare depth values for source and destination pixels.
            The source pixel is composited with the destination pixel when the comparison is
            `true`. The comparison operator is applied as an infix operator between the
            source and destination pixel values, in that order.
    
            @param	depthMask	the destination depth value will be updated from the source
            pixel when `true`.
            @param	passCompareMode	the depth comparison test operation. One of the values
            of Context3DCompareMode.
        **/
        setDepthTest(depthMask, passCompareMode) {
            this.__state.depthMask = depthMask;
            this.__state.depthCompareMode = passCompareMode;
        }
        /**
            Sets vertex and fragment shader programs to use for subsequent rendering.
    
            @param	program	the Program3D object representing the vertex and fragment
            programs to use.
        **/
        setProgram(program) {
            this.__state.program = program;
            this.__state.shader = null; // TODO: Merge this logic
            if (program != null) {
                for (let i = 0; i < program.__samplerStates.length; i++) {
                    if (this.__state.samplerStates[i] == null) {
                        this.__state.samplerStates[i] = program.__samplerStates[i].clone();
                    }
                    else {
                        this.__state.samplerStates[i].copyFrom(program.__samplerStates[i]);
                    }
                }
            }
        }
        /**
            Set constants for use by shader programs using values stored in a ByteArray.
    
            Sets constants that can be accessed from the vertex or fragment program.
    
            @param	programType	one of Context3DProgramType.
            @param	firstRegister	the index of the first shader program constant to set.
            @param	numRegisters	the number of registers to set. Every register is read
            as four float values.
            @param	data	the source ByteArray object
            @param	byteArrayOffset	an offset into the ByteArray for reading
            @throws	TypeError	kNullPointerError when data is null.
            @throws	RangeError	kConstantRegisterOutOfBounds when attempting to set more than
            the maximum number of shader constants.
            @throws	RangeError	kBadInputSize if `byteArrayOffset` is greater than or equal to
            the length of data or no. of elements in `data - byteArrayOffset` is less than
            `numRegisters*16`
        **/
        setProgramConstantsFromByteArray(programType, firstRegister, numRegisters, data, byteArrayOffset) {
            if (numRegisters == 0 || this.__state.program == null)
                return;
            if (this.__state.program != null && this.__state.program.__format == Context3DProgramFormat.GLSL) ;
            else {
                // TODO: Cleanup?
                if (numRegisters == -1) {
                    numRegisters = ((data.length >> 2) - byteArrayOffset);
                }
                var isVertex = (programType == Context3DProgramType.VERTEX);
                var dest = isVertex ? this.__vertexConstants : this.__fragmentConstants;
                var floatData = new Float32Array(data.__buffer, 0, data.length);
                var outOffset = firstRegister * 4;
                var inOffset = Math.floor(byteArrayOffset / 4);
                for (let i = 0; i < (numRegisters * 4); i++) {
                    dest[outOffset + i] = floatData[inOffset + i];
                }
                if (this.__state.program != null) {
                    this.__state.program.__markDirty(isVertex, firstRegister, numRegisters);
                }
            }
        }
        /**
            Sets constants for use by shader programs using values stored in a Matrix3D.
    
            Use this to pass a matrix to a shader program. The sets 4
            constant registers used by the vertex or fragment program. The matrix is
            assigned to registers row by row. The first constant register is assigned the
            top row of the matrix. You can set 128 registers for a vertex program and 28
            for a fragment program.
    
            @param	programType	The type of shader program, either
            `Context3DProgramType.VERTEX` or `Context3DProgramType.FRAGMENT`.
            @param	firstRegister	the index of the first constant register to set. Since
            a Matrix3D has 16 values, four registers are set.
            @param	matrix	the matrix containing the constant values.
            @param	transposedMatrix	if `true` the matrix entries are copied to registers
            in transposed order. The default value is `false`.
            @throws	TypeError	Null Pointer Error: when matrix is `null`.
            @throws	RangeError	Constant Register Out Of Bounds: when attempting to set more
            than the maximum number of shader constant registers.
        **/
        setProgramConstantsFromMatrix(programType, firstRegister, matrix, transposedMatrix = false) {
            if (this.__state.program != null && this.__state.program.__format == Context3DProgramFormat.GLSL) ;
            else {
                var isVertex = (programType == Context3DProgramType.VERTEX);
                var dest = isVertex ? this.__vertexConstants : this.__fragmentConstants;
                var source = matrix.rawData;
                var i = firstRegister * 4;
                if (transposedMatrix) {
                    dest[i++] = source[0];
                    dest[i++] = source[4];
                    dest[i++] = source[8];
                    dest[i++] = source[12];
                    dest[i++] = source[1];
                    dest[i++] = source[5];
                    dest[i++] = source[9];
                    dest[i++] = source[13];
                    dest[i++] = source[2];
                    dest[i++] = source[6];
                    dest[i++] = source[10];
                    dest[i++] = source[14];
                    dest[i++] = source[3];
                    dest[i++] = source[7];
                    dest[i++] = source[11];
                    dest[i++] = source[15];
                }
                else {
                    dest[i++] = source[0];
                    dest[i++] = source[1];
                    dest[i++] = source[2];
                    dest[i++] = source[3];
                    dest[i++] = source[4];
                    dest[i++] = source[5];
                    dest[i++] = source[6];
                    dest[i++] = source[7];
                    dest[i++] = source[8];
                    dest[i++] = source[9];
                    dest[i++] = source[10];
                    dest[i++] = source[11];
                    dest[i++] = source[12];
                    dest[i++] = source[13];
                    dest[i++] = source[14];
                    dest[i++] = source[15];
                }
                if (this.__state.program != null) {
                    this.__state.program.__markDirty(isVertex, firstRegister, 4);
                }
            }
        }
        /**
            Sets the constant inputs for the shader programs.
    
            Sets an array of constants to be accessed by a vertex or fragment shader
            program. Constants set in Program3D are accessed within the shader programs as
            constant registers. Each constant register is comprised of 4 floating point
            values (x, y, z, w). Therefore every register requires 4 entries in the data
            Vector. The number of registers that you can set for vertex program and
            fragment program depends on the Context3DProfile.
    
            @param	programType	The type of shader program, either
            `Context3DProgramType.VERTEX` or `Context3DProgramType.FRAGMENT`.
            @param	firstRegister	the index of the first constant register to set.
            @param	data	the floating point constant values. There must be at least
            `numRegisters` 4 elements in data.
            @param	numRegisters	the number of constants to set. Specify -1, the default
            value, to set enough registers to use all of the available data.
            @throws	TypeError	Null Pointer Error: when data is `null`.
            @throws	RangeError	Constant Register Out Of Bounds: when attempting to set more
            than the maximum number of shader constant registers.
            @throws	RangeError	Bad Input Size: When the number of elements in data is less
            than `numRegisters*4`
        **/
        setProgramConstantsFromVector(programType, firstRegister, data, numRegisters = -1) {
            if (numRegisters == 0)
                return;
            if (this.__state.program != null && this.__state.program.__format == Context3DProgramFormat.GLSL) ;
            else {
                if (numRegisters == -1) {
                    numRegisters = (data.length >> 2);
                }
                var isVertex = (programType == Context3DProgramType.VERTEX);
                var dest = isVertex ? this.__vertexConstants : this.__fragmentConstants;
                var source = data;
                var sourceIndex = 0;
                var destIndex = firstRegister * 4;
                for (let i = 0; i < numRegisters; i++) {
                    dest[destIndex++] = source[sourceIndex++];
                    dest[destIndex++] = source[sourceIndex++];
                    dest[destIndex++] = source[sourceIndex++];
                    dest[destIndex++] = source[sourceIndex++];
                }
                if (this.__state.program != null) {
                    this.__state.program.__markDirty(isVertex, firstRegister, numRegisters);
                }
            }
        }
        /**
            Sets the back rendering buffer as the render target. Subsequent calls to
            `drawTriangles()` and `clear()` methods result in updates to the back buffer.
            Use this method to resume normal rendering after using the
            `setRenderToTexture()` method.
        **/
        setRenderToBackBuffer() {
            this.__state.renderToTexture = null;
        }
        /**
            Sets the specified texture as the rendering target.
    
            Subsequent calls to `drawTriangles()` and `clear()` methods update the
            specified texture instead of the back buffer. Mip maps are created
            automatically. Use the `setRenderToBackBuffer()` to resume normal rendering to
            the back buffer.
    
            No clear is needed before drawing. If there is no clear operation, the render
            content will be retained. depth buffer and stencil buffer will also not be
            cleared. But it is forced to clear when first drawing. Calling `present()`
            resets the target to the back buffer.
    
            @param	texture	the target texture to render into. Set to `null` to resume
            rendering to the back buffer (`setRenderToBackBuffer()` and `present` also reset
            the target to the back buffer).
            @param	enableDepthAndStencil	if `true`, depth and stencil testing are
            available. If `false`, all depth and stencil state is ignored for subsequent
            drawing operations.
            @param	antiAlias	the antialiasing quality. Use 0 to disable antialiasing;
            higher values improve antialiasing quality, but require more calculations. The
            value is currently ignored by mobile platform and software rendering context.
            @param	surfaceSelector	specifies which element of the texture to update.
            Texture objects have one surface, so you must specify 0, the default value.
            CubeTexture objects have six surfaces, so you can specify an integer from 0
            through 5.
            @param	colorOutputIndex	The output color register. Must be 0 for constrained
            or baseline mode. Otherwise specifies the output color register.
            @throws	ArgumentError	for a mismatched surfaceSelector parameter. The value
            must be 0 for 2D textures and 0..5 for cube maps.
            @throws	ArgumentError	texture is not derived from the TextureBase class
            (either Texture or CubeTexture classes).
            @throws	ArgumentError	colorOutputIndex must be an integer is from 0 through 3.
            @throws	ArgumentError	this call requires a Context3D that is created with the
            standard profile or above.
        **/
        setRenderToTexture(texture, enableDepthAndStencil = false, antiAlias = 0, surfaceSelector = 0) {
            this.__state.renderToTexture = texture;
            this.__state.renderToTextureDepthStencil = enableDepthAndStencil;
            this.__state.renderToTextureAntiAlias = antiAlias;
            this.__state.renderToTextureSurfaceSelector = surfaceSelector;
        }
        /**
            Manuallytexture sampler this.__state.
    
            Texture sampling state is typically set at the time setProgram is called.
            However, you cantexture sampler state with this function. If you do not
            want the program to change sampler state, set the `ignoresamnpler` bit in AGAL
            and use this function.
    
            @param	sampler	sampler The sampler register to use. Maps to the sampler register
            in AGAL.
            @param	wrap	Wrapping mode. Defined in Context3DWrapMode. The default is repeat.
            @param	filter	Texture filtering mode. Defined in Context3DTextureFilter. The
            default is nearest.
            @param	mipfilter	Mip map filter. Defined in Context3DMipFilter. The default
            is none.
            @throws	Error	sampler out of range
            @throws	Error	wrap, filter, mipfilter bad enum
            @throws	Error	Object Disposed: if this Context3D object has been disposed by a
            calling `dispose()` or because the underlying rendering hardware has been lost.
        **/
        setSamplerStateAt(sampler, wrap, filter, mipfilter) {
            // if (sampler < 0 || sampler > Context3D.MAX_SAMPLERS) {
            // 	throw new Error ("sampler out of range");
            // }
            if (this.__state.samplerStates[sampler] == null) {
                this.__state.samplerStates[sampler] = new SamplerState();
            }
            var state = this.__state.samplerStates[sampler];
            state.wrap = wrap;
            state.filter = filter;
            state.mipfilter = mipfilter;
        }
        /**
            Sets a scissor rectangle, which is type of drawing mask. The renderer only draws
            to the area inside the scissor rectangle. Scissoring does not affect clear
            operations.
    
            Pass `null` to turn off scissoring.
    
            @param	rectangle	The rectangle in which to draw. Specify the rectangle
            position and dimensions in pixels. The coordinate system origin is the top left
            corner of the viewport, with positive values increasing down and to the right
            (the same as the normal OpenFL display coordinate system).
        **/
        setScissorRectangle(rectangle) {
            if (rectangle != null) {
                this.__state.scissorEnabled = true;
                this.__state.scissorRectangle.copyFrom(rectangle);
            }
            else {
                this.__state.scissorEnabled = false;
            }
        }
        /**
            Sets stencil mode and operation.
    
            An 8-bit stencil reference value can be associated with each draw call. During
            rendering, the reference value can be tested against values stored previously
            in the frame buffer. The result of the test can control the draw action and
            whether or how the stored stencil value is updated. In addition, depth testing
            controls whether stencil testing is performed. A failed depth test can also be
            used to control the action taken on the stencil buffer.
    
            In the pixel processing pipeline, depth testing is performed first. If the depth
            test fails, a stencil buffer update action can be taken, but no further evaluation
            of the stencil buffer value can be made. If the depth test passes, then the
            stencil test is performed. Alternate actions can be taken depending on the outcome
            of the stencil test.
    
            The stencil reference value is set using `setStencilReferenceValue()`.
    
            @param	triangleFace	the triangle orientations allowed to contribute to the
            stencil operation. One of Context3DTriangleFace.
            @param	compareMode	the test operator used to compare the current stencil
            reference value and the destination pixel stencil value. Destination pixel color
            and depth update is performed when the comparison is true. The stencil actions
            are performed as requested in the following action parameters. The comparison
            operator is applied as an infix operator between the current and destination
            reference values, in that order (in pseudocode:
            `if stencilReference OPERATOR stencilBuffer then pass`). Use one of the constants
            defined in the Context3DCompareMode class.
            @param	actionOnBothPass	action to be taken when both depth and stencil
            comparisons pass. Use one of the constants defined in the Context3DStencilAction
            class.
            @param	actionOnDepthFail	action to be taken when depth comparison fails. Use
            one of the constants defined in the Context3DStencilAction class.
            @param	actionOnDepthPassStencilFail	action to be taken when depth comparison
            passes and the stencil comparison fails. Use one of the constants defined in the
            Context3DStencilAction class.
            @throws	Error	Invalid Enum Error: when `triangleFace` is not one of the values
            defined in the Context3DTriangleFace class.
            @throws	Error	Invalid Enum Error: when `compareMode` is not one of the values
            defined in the Context3DCompareMode class.
            @throws	Error	Invalid Enum Error: when `actionOnBothPass`, `actionOnDepthFail`,
            or `actionOnDepthPassStencilFail` is not one of the values defined in the
            Context3DStencilAction class.
        **/
        setStencilActions(triangleFace = Context3DTriangleFace.FRONT_AND_BACK, compareMode = Context3DCompareMode.ALWAYS, actionOnBothPass = Context3DStencilAction.KEEP, actionOnDepthFail = Context3DStencilAction.KEEP, actionOnDepthPassStencilFail = Context3DStencilAction.KEEP) {
            this.__state.stencilTriangleFace = triangleFace;
            this.__state.stencilCompareMode = compareMode;
            this.__state.stencilPass = actionOnBothPass;
            this.__state.stencilDepthFail = actionOnDepthFail;
            this.__state.stencilFail = actionOnDepthPassStencilFail;
        }
        /**
            Sets the stencil comparison value used for stencil tests.
    
            Only the lower 8 bits of the reference value are used. The stencil buffer value
            is also 8 bits in length. Use the `readMask` and `writeMask` to use the stencil
            buffer as a bit field.
    
            @param	referenceValue	an 8-bit reference value used in reference value
            comparison tests.
            @param	readMask	an 8-bit mask for applied to both the current stencil
            buffer value and the reference value before the comparison.
            @param	writeMask	an 8-bit mask applied to the reference value before updating
            the stencil buffer.
        **/
        setStencilReferenceValue(referenceValue, readMask = 0xFF, writeMask = 0xFF) {
            this.__state.stencilReferenceValue = referenceValue;
            this.__state.stencilReadMask = readMask;
            this.__state.stencilWriteMask = writeMask;
        }
        /**
            Specifies the texture to use for a texture input register of a fragment program.
    
            A fragment program can read information from up to eight texture objects. Use
            this to assign a Texture or CubeTexture object to one of the sampler
            registers used by the fragment program.
    
            **Note:** if you change the active fragment program (with setProgram) to a
            shader that uses fewer textures, set the unused registers to `null`:
    
            ``haxe
            setTextureAt(7, null);
            ```
    
            @param	sampler	the sampler register index, a value from 0 through 7.
            @param	texture	the texture object to make available, either a Texture or a
            CubeTexture instance.
        **/
        setTextureAt(sampler, texture) {
            // if (sampler < 0 || sampler > Context3D.MAX_SAMPLERS) {
            // 	throw new Error ("sampler out of range");
            // }
            this.__state.textures[sampler] = texture;
        }
        /**
            Specifies which vertex data components correspond to a single vertex shader
            program input.
    
            Use the setVertexBufferAt method to identify which components of the data
            defined for each vertex in a VertexBuffer3D buffer belong to which inputs to the
            vertex program. The developer of the vertex program determines how much data is
            needed per vertex. That data is mapped from 1 or more VertexBuffer3D stream(s) to
            the attribute registers of the vertex shader program.
    
            The smallest unit of data consumed by the vertex shader is a 32-bit data.
            Offsets into the vertex stream are specified in multiples of 32-bits.
    
            As an example, a programmer might define each vertex with the following data:
    
            ```
            position:  x    float32
                       y    float32
                       z    float32
            color:     r    unsigned byte
                       g    unsigned byte
                       b    unsigned byte
                       a    unsigned byte
            ```
    
            Assuming the vertex was defined in a VertexBuffer3D object named buffer, it
            would be assigned to a vertex shader with the following code:
    
            ```haxe
            setVertexBufferAt(0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3);   // attribute #0 will contain the position information
            setVertexBufferAt(1, buffer, 3, Context3DVertexBufferFormat.BYTES_4);    // attribute #1 will contain the color information
            ```
    
            @param	index	the index of the attribute register in the vertex shader (0
            through 7).
            @param	buffer	the buffer that contains the source vertex data to be fed to the
            vertex shader.
            @param	bufferOffset	an offset from the start of the data for a single vertex
            at which to start reading this attribute. In the example above, the position data
            has an offset of 0 because it is the first attribute; color has an offset of 3
            because the color attribute follows the three 32-bit position values. The offset
            is specified in units of 32 bits.
            @param	format	a value from the Context3DVertexBufferFormat class specifying
            the data type of this attribute.
            @throws	Error	Invalid Enum: when format is not one of the values defined in
            the Context3DVertexBufferFormat class.
            @throws	RangeError	Attribute Register Out Of Bounds: when the index parameter
            is outside the range from 0 through 7. (A maximum of eight vertex attribute
            registers can be used by a shader.)
        **/
        setVertexBufferAt(index, buffer, bufferOffset = 0, format = Context3DVertexBufferFormat.FLOAT_4) {
            // TODO: Don't flush immediately?
            // this.__backend.setVertexBufferAt(index, buffer, bufferOffset, format);
        }
        __renderStage3D(stage3D) {
            // Assume this is the primary Context3D
            var context = stage3D.context3D;
            if (context != null
                && context != this
                && context.__frontBufferTexture != null
                && stage3D.visible
                && this.backBufferHeight > 0
                && this.backBufferWidth > 0) {
                // if (!stage.renderer.cleared) stage.renderer.clear ();
                if (this.__renderStage3DProgram == null) {
                    var vertexAssembler = new AGALMiniAssembler();
                    vertexAssembler.assemble(Context3DProgramType.VERTEX, "m44 op, va0, vc0\n" + "mov v0, va1");
                    var fragmentAssembler = new AGALMiniAssembler();
                    fragmentAssembler.assemble(Context3DProgramType.FRAGMENT, "tex ft1, v0, fs0 <2d,nearest,nomip>\n" + "mov oc, ft1");
                    this.__renderStage3DProgram = this.createProgram();
                    this.__renderStage3DProgram.upload(vertexAssembler.agalcode, fragmentAssembler.agalcode);
                }
                this.setProgram(this.__renderStage3DProgram);
                this.setBlendFactors(Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO);
                this.setColorMask(true, true, true, true);
                this.setCulling(Context3DTriangleFace.NONE);
                this.setDepthTest(false, Context3DCompareMode.ALWAYS);
                this.setStencilActions();
                this.setStencilReferenceValue(0, 0, 0);
                this.setScissorRectangle(null);
                this.setTextureAt(0, context.__frontBufferTexture);
                this.setVertexBufferAt(0, stage3D.__renderData.vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
                this.setVertexBufferAt(1, stage3D.__renderData.vertexBuffer, 3, Context3DVertexBufferFormat.FLOAT_2);
                this.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, stage3D.__renderTransform, true);
                this.drawTriangles(stage3D.__renderData.indexBuffer);
                this.__present = true;
            }
        }
        // Get & Set Methods
        /**
            Indicates if Context3D supports video texture.
        **/
        static get supportsVideoTexture() {
            return Context3D.__supportsVideoTexture;
        }
        /**
            Specifies the height of the back buffer, which can be changed by a successful
            call to the `configureBackBuffer()` method. The height may be modified when the
            browser zoom factor changes if the `wantsBestResolutionOnBrowserZoom` parameter
            is set to `true` in the last successful call to the `configureBackBuffer()`
            method. The change in height can be detected by registering an event listener
            for the browser zoom change event.
        **/
        get backBufferHeight() {
            return this.__backBufferHeight;
        }
        /**
            Specifies the width of the back buffer, which can be changed by a successful
            call to the `configureBackBuffer()` method. The width may be modified when the
            browser zoom factor changes if the `wantsBestResolutionOnBrowserZoom` parameter
            is set to `true` in the last successful call to the `configureBackBuffer()`
            method. The change in width can be detected by registering an event listener
            for the browser zoom change event.
        **/
        get backBufferWidth() {
            return this.__backBufferWidth;
        }
        /**
            The type of graphics library driver used by this rendering context. Indicates
            whether the rendering is using software, a DirectX driver, or an OpenGL driver.
            Also indicates whether hardware rendering failed. If hardware rendering fails,
            Flash Player uses software rendering for Stage3D and `driverInfo` contains one
            of the following values:
    
            * "Software Hw_disabled=userDisabled" - The Enable hardware acceleration
            checkbox in the Adobe Flash Player Settings UI is not selected.
            * "Software Hw_disabled=oldDriver" - There are known problems with the
            hardware graphics driver. Updating the graphics driver may fix this problem.
            * "Software Hw_disabled=unavailable" - Known problems with the hardware
            graphics driver or hardware graphics initialization failure.
            * "Software Hw_disabled=explicit" - The content explicitly requested software
            rendering through requestContext3D.
            * "Software Hw_disabled=domainMemory" - The content uses domainMemory, which
            requires a license when used with Stage3D hardware rendering. Visit
            adobe.com/go/fpl.
        **/
        get driverInfo() {
            return this.__driverInfo;
        }
        /**
            Specifies whether errors encountered by the renderer are reported to the
            application.
    
            When `enableErrorChecking` is `true`, the `clear()`, and `drawTriangles()`
            methods are synchronous and can throw errors. When `enableErrorChecking`
            is `false`, the default, the `clear()`, and `drawTriangles()` methods are
            asynchronous and errors are not reported. Enabling error checking reduces
            rendering performance. You should only enable error checking when debugging.
        **/
        get enableErrorChecking() {
            return this.__enableErrorChecking;
        }
        set enableErrorChecking(value) {
            this.__enableErrorChecking = value;
        }
        /**
            Specifies the maximum height of the back buffer. The inital value is the system
            limit in the platform. The property can be set to a value smaller than or equal
            to, but not greater than, the system limit. The property can be set to a value
            greater than or equal to, but not smaller than, the minimum limit. The minimum
            limit is a constant value, 32, when the back buffer is not configured. The
            minimum limit will be the value of the `height` parameter in the last successful
            call to the `configureBackBuffer()` method after the back buffer is configured.
        **/
        get maxBackBufferHeight() {
            return this.__maxBackBufferHeight;
        }
        /**
            Specifies the maximum width of the back buffer. The inital value is the system
            limit in the platform. The property can be set to a value smaller than or equal
            to, but not greater than, the system limit. The property can be set to a value
            greater than or equal to, but not smaller than, the minimum limit. The minimum
            limit is a constant value, 32, when the back buffer is not configured. The
            minimum limit will be the value of the width parameter in the last successful
            call to the `configureBackBuffer()` method after the back buffer is configured.
        **/
        get maxBackBufferWidth() {
            return this.__maxBackBufferWidth;
        }
        /**
            The feature-support profile in use by this Context3D object.
        **/
        get profile() {
            return this.__profile;
        }
        /**
            Returns the total GPU memory allocated by Stage3D data structures of an
            application.
    
            Whenever a GPU resource object is created, memory utilized is stored in
            Context3D. This memory includes index buffers, vertex buffers,
            textures (excluding video texture), and programs that were created through this
            Context3D.
    
            API totalGPUMemory returns the total memory consumed by the above resources to
            the user. Default value returned is 0. The total GPU memory returned is in bytes.
            The information is only provided in Direct mode on mobile, and in Direct and
            GPU modes on desktop. (On desktop, using `<renderMode>gpu</renderMode>` will
            fall back to `<renderMode>direct</renderMode>`)
    
            This API can be used when the SWF version is 32 or later.
        **/
        get totalGPUMemory() {
            // return this.__backend.getTotalGPUMemory();
            return 0;
        }
    }
    Context3D.__supportsBGRA = null;
    Context3D.__supportsVideoTexture = true;
    return Context3D;
})();

var openfl$y;
(function (openfl) {
    var display3D;
    (function (display3D) {
        /**
            Defines the values to use for specifying the Context3D render mode.
        **/
        let Context3DRenderMode;
        (function (Context3DRenderMode) {
            /**
                Automatically choose rendering engine.
    
                A hardware-accelerated rendering engine is used if available on the current
                device. Availability of hardware acceleration is influenced by the device
                capabilites, the wmode when running under Flash Player, and the render mode when
                running under AIR.
            **/
            Context3DRenderMode["AUTO"] = "auto";
            /**
                Use software 3D rendering.
    
                Software rendering is not available on mobile devices.
            **/
            Context3DRenderMode["SOFTWARE"] = "software";
        })(Context3DRenderMode = display3D.Context3DRenderMode || (display3D.Context3DRenderMode = {}));
    })(display3D = openfl.display3D || (openfl.display3D = {}));
})(openfl$y || (openfl$y = {}));
var Context3DRenderMode = openfl$y.display3D.Context3DRenderMode;

/**
    The Stage class represents the main drawing area.
    For SWF content running in the browser (in Flash<sup>஼/sup> Player), the
    Stage represents the entire area where Flash content is shown. For content
    running in AIR on desktop operating systems, each NativeWindow object has
    a corresponding Stage object.

    The Stage object is not globally accessible. You need to access it through
    the `stage` property of a DisplayObject instance.

    The Stage class has several ancestor classes נDisplayObjectContainer,
    InteractiveObject, DisplayObject, and EventDispatcher נfrom which it
    inherits properties and methods. Many of these properties and methods are
    either inapplicable to Stage objects, or require security checks when
    called on a Stage object. The properties and methods that require security
    checks are documented as part of the Stage class.

    In addition, the following inherited properties are inapplicable to Stage
    objects. If you try to set them, an IllegalOperationError is thrown. These
    properties may always be read, but since they cannot be set, they will
    always contain default values.

    * `accessibilityProperties`
    * `alpha`
    * `blendMode`
    * `cacheAsBitmap`
    * `contextMenu`
    * `filters`
    * `focusRect`
    * `loaderInfo`
    * `mask`
    * `mouseEnabled`
    * `name`
    * `opaqueBackground`
    * `rotation`
    * `scale9Grid`
    * `scaleX`
    * `scaleY`
    * `scrollRect`
    * `tabEnabled`
    * `tabIndex`
    * `transform`
    * `visible`
    * `x`
    * `y`

    Some events that you might expect to be a part of the Stage class, such as
    `enterFrame`, `exitFrame`, `frameConstructed`, and `render`, cannot be
    Stage events because a reference to the Stage object cannot be guaranteed
    to exist in every situation where these events are used. Because these
    events cannot be dispatched by the Stage object, they are instead
    dispatched by every DisplayObject instance, which means that you can add
    an event listener to any DisplayObject instance to listen for these
    events. These events, which are part of the DisplayObject class, are
    called broadcast events to differentiate them from events that target a
    specific DisplayObject instance. Two other broadcast events, `activate`
    and `deactivate`, belong to DisplayObject's superclass, EventDispatcher.
    The `activate` and `deactivate` events behave similarly to the
    DisplayObject broadcast events, except that these two events are
    dispatched not only by all DisplayObject instances, but also by all
    EventDispatcher instances and instances of other EventDispatcher
    subclasses. For more information on broadcast events, see the
    DisplayObject class.

    @event fullScreen             Dispatched when the Stage object enters, or
                                  leaves, full-screen mode. A change in
                                  full-screen mode can be initiated through
                                  ActionScript, or the user invoking a
                                  keyboard shortcut, or if the current focus
                                  leaves the full-screen window.
    @event mouseLeave             Dispatched by the Stage object when the
                                  pointer moves out of the stage area. If the
                                  mouse button is pressed, the event is not
                                  dispatched.
    @event orientationChange      Dispatched by the Stage object when the
                                  stage orientation changes.
                                  Orientation changes can occur when the user
                                  rotates the device, opens a slide-out
                                  keyboard, or when the `setAspectRatio()` is
                                  called.

                                  **Note:** If the `autoOrients` property is
                                  `false`, then the stage orientation does not
                                  change when a device is rotated. Thus,
                                  StageOrientationEvents are only dispatched
                                  for device rotation when `autoOrients` is
                                  `true`.
    @event orientationChanging    Dispatched by the Stage object when the
                                  stage orientation begins changing.
                                  **Important:** orientationChanging events
                                  are not dispatched on Android devices.

                                  **Note:** If the `autoOrients` property is
                                  `false`, then the stage orientation does not
                                  change when a device is rotated. Thus,
                                  StageOrientationEvents are only dispatched
                                  for device rotation when `autoOrients` is
                                  `true`.
    @event resize                 Dispatched when the `scaleMode` property of
                                  the Stage object is set to
                                  `StageScaleMode.NO_SCALE` and the SWF file
                                  is resized.
    @event stageVideoAvailability Dispatched by the Stage object when the
                                  state of the stageVideos property changes.
**/
class Stage3D extends EventDispatcher {
    constructor(stage) {
        super();
        this.__stage = stage;
        this.__height = 0;
        this.__projectionTransform = new Matrix3D();
        this.__renderTransform = new Matrix3D();
        this.__width = 0;
        this.__x = 0;
        this.__y = 0;
        this.visible = true;
        this.__renderData = new DisplayObjectRenderData();
        if (stage.stageWidth > 0 && stage.stageHeight > 0) {
            this.__resize(stage.stageWidth, stage.stageHeight);
        }
    }
    /**
        Request the creation of a Context3D object for this Stage3D instance.

        Before calling this function, add an event listener for the `context3DCreate`
        event. If you do not, the runtime throws an exception.

        **Important note on device loss:**
        GPU device loss occurs when the GPU hardware becomes unavailable to the application.
        The Context3D object is disposed when the GPU device is lost. GPU device loss can
        happen for various reasons, such as, when a mobile device runs out of battery power
        or a Windows device goes to a "lock screen." When the GPU becomes available again,
        the runtime creates a new Context3D instance and dispatches another
        `context3DCreate` event. Your application must reload all assets and reset the
        rendering context state whenever device loss occurs.

        Design your application logic to handle the possibility of device loss and context
        regeneration. Do not remove the `context3DCreate` event listener. Do not perform
        actions in response to the event that should not be repeated in the application.
        For example, do not add anonymous functions to handle timer events because they
        would be duplicated after device loss. To test your application's handling of
        device loss, you can simulate device loss by calling the `dispose()` method of the
        Context3D object.

        The following example illustrates how to request a Context3d rendering context:

        ```haxe
        if( stage.stage3Ds.length > 0 )
        {
            var stage3D:Stage3D = stage.stage3Ds[0];
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, myContext3DHandler );
            stage3D.requestContext3D( );
        }

        function myContext3DHandler ( event : Event ) : void
        {
            var targetStage3D : Stage3D = cast event.target;
            InitAll3DResources( targetStage3D.context3D );
            StartRendering( targetStage3D.context3D );
        }
        ```

        @param	context3DRenderMode	The type of rendering context to request. The default
        is `Context3DRenderMode.AUTO` for which the runtime will create a
        hardware-accelerated context if possible and fall back to software otherwise. Use
        `Context3DRenderMode.SOFTWARE` to request a software rendering context. Software
        rendering is not available on mobile devices. Software rendering is available only
        for `Context3DProfile.BASELINE` and `Context3DProfile.BASELINE_CONSTRAINED`.
        @param	profile	(AIR 3.4 and higher) Specifies the extent to which Flash Player
        supports lower-level GPUs. The default is `Context3DProfile.BASELINE`, which
        returns a Context3D instance similar to that used in previous releases. To get
        details of all available profiles, see openfl.display3D.Context3DProfile.
        @event	context3DCreate	Dispatched when the requested rendering context is
        successfully completed.
        @event	error	Dispatched when the requested rendering context cannot be created.
        @throws	Error	if no listeners for the `context3DCreate` event have been added to
        this Stage3D object.
        @throws	ArgumentError	if this method is called again with a different
        `context3DRenderMode` before the previous call has completed.
    **/
    requestContext3D(context3DRenderMode = Context3DRenderMode.AUTO, profile = Context3DProfile.BASELINE) {
        if (this.__contextLost) {
            this.__contextRequested = true;
            return;
        }
        if (this.__context3D != null) {
            this.__contextRequested = true;
            setTimeout(this.__dispatchCreate, 1);
        }
        else if (!this.__contextRequested) {
            this.__contextRequested = true;
            setTimeout(this.__createContext, 1);
        }
    }
    /**
        Request the creation of a Context3D object for this Stage3D instance.

        Before calling this function, add an event listener for the `context3DCreate`
        event. If you do not, the runtime throws an exception.

        **Important note on device loss:**
        GPU device loss occurs when the GPU hardware becomes unavailable to the
        application. The Context3D object is disposed when the GPU device is lost. GPU
        device loss can happen for various reasons, such as, when a mobile device runs out
        of battery power or a Windows device goes to a "lock screen." When the GPU becomes
        available again, the runtime creates a new Context3D instance and dispatches
        another `context3DCreate` event. Your application must reload all assets and reset
        the rendering context state whenever device loss occurs.

        Design your application logic to handle the possibility of device loss and context
        regeneration. Do not remove the `context3DCreate` event listener. Do not perform
        actions in response to the event that should not be repeated in the application.
        For example, do not add anonymous functions to handle timer events because they
        would be duplicated after device loss. To test your application's handling of
        device loss, you can simulate device loss by calling the `dispose()` method of the
        Context3D object.

        The following example illustrates how to request a Context3d rendering context:

        ```haxe
        if( stage.stage3Ds.length > 0 )
        {
            var stage3D:Stage3D = stage.stage3Ds[0];
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, myContext3DHandler );
            stage3D.requestContext3DMatchingProfiles(Vector.<string>([Context3DProfile.BASELINE, Context3DProfile.BASELINE_EXTENDED]));
        }

        function myContext3DHandler ( event : Event ) : void
        {
            var targetStage3D : Stage3D = cast event.target;
            if(targetStage3D.context3D.profile.localeCompare(Context3DProfile.BASELINE) == 0)
            {
                InitAll3DResources( targetStage3D.context3D );
            }
            StartRendering( targetStage3D.context3D );
        }
        ```

        @param	profiles	(AIR 3.4 and higher) a profile arrays that developer want to
        use in their flash program. When developer pass profile array to
        `Stage3D.requestContext3DMatchingProfiles`, he will get a Context3D based on the
        high level profile in that array according to their hardware capability. The
        `rendermode` is set to AUTO, so the parameter is omitted.
        @event	context3DCreate	Dispatched when the requested rendering context is
        successfully completed.
        @event	error	Dispatched when the requested rendering context cannot be created.
        If the hardware is not available, it will not create a software context3d.
        @throws	Error	if no listeners for the context3DCreate event have been added to
        this Stage3D object.
        @throws	ArgumentError	if this method is called before the previous call has
        completed.
        @throws	ArgumentError	if the item in array is not openfl.display3D.Context3DProfile.
    **/
    requestContext3DMatchingProfiles(profiles) {
        this.requestContext3D();
    }
    __createContext() {
        if (this.__stage.context3D != null) {
            // #if openfl_share_context
            // context3D = __stage.context3D;
            // #else
            this.__context3D = new Context3D(this.__stage, this.__stage.context3D.__contextState, this);
            this.__dispatchCreate();
        }
        else {
            this.__dispatchError();
        }
    }
    __dispatchError() {
        this.__contextRequested = false;
        this.dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, "Context3D not available"));
    }
    __dispatchCreate() {
        if (this.__contextRequested) {
            this.__contextRequested = false;
            this.dispatchEvent(new Event(Event.CONTEXT3D_CREATE));
        }
    }
    __lostContext() {
        this.__contextLost = true;
        if (this.__context3D != null) {
            this.__context3D.dispose();
            this.__contextRequested = true;
        }
    }
    __resize(width, height) {
        if (width != this.__width || height != this.__height) {
            if (this.__renderData.canvas != null) {
                this.__renderData.canvas.width = width;
                this.__renderData.canvas.height = height;
            }
            this.__projectionTransform.copyRawDataFrom(Vector.ofArray([
                2.0 / (width > 0 ? width : 1), 0.0, 0.0, 0.0, 0.0, -2.0 / (height > 0 ? height : 1), 0.0, 0.0, 0.0, 0.0, -2.0 / 2000, 0.0, -1.0, 1.0, 0.0, 1.0
            ]));
            this.__renderTransform.identity();
            this.__renderTransform.appendTranslation(this.__x, this.__y, 0);
            this.__renderTransform.append(this.__projectionTransform);
            this.__width = width;
            this.__height = height;
        }
    }
    __restoreContext() {
        this.__contextLost = false;
        this.__createContext();
    }
    // Get & Set Methods
    /**
        The Context3D object associated with this Stage3D instance.

        This property is initially `null`. To create the Context3D instance for this
        Stage3D object, add an event listener for the `context3DCreate` event and then call
        the `requestContext3D` method. The listener is called once the Context3D object has
        been created.
    **/
    get context3D() {
        return this.__context3D;
    }
    /**
        The horizontal coordinate of the Stage3D display on the stage, in pixels.

        This property defaults to zero.
    **/
    get x() {
        return this.__x;
    }
    set x(value) {
        if (this.__x != value) {
            this.__x = value;
            this.__renderTransform.identity();
            this.__renderTransform.appendTranslation(this.__x, this.__y, 0);
            this.__renderTransform.append(this.__projectionTransform);
        }
    }
    /**
        The vertical coordinate of the Stage3D display on the stage, in pixels.

        This property defaults to zero.
    **/
    get y() {
        return this.__y;
    }
    set y(value) {
        if (this.__y == value) {
            this.__y = value;
            this.__renderTransform.identity();
            this.__renderTransform.appendTranslation(this.__x, this.__y, 0);
            this.__renderTransform.append(this.__projectionTransform);
        }
    }
}

var openfl$z;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The StageAlign class provides constant values to use for the
            `Stage.align` property.
        **/
        let StageAlign;
        (function (StageAlign) {
            /**
                Specifies that the Stage is aligned at the bottom.
            **/
            StageAlign["BOTTOM"] = "bottom";
            /**
                Specifies that the Stage is aligned on the left.
            **/
            StageAlign["BOTTOM_LEFT"] = "bottomLeft";
            /**
                Specifies that the Stage is aligned to the right.
            **/
            StageAlign["BOTTOM_RIGHT"] = "bottomRight";
            /**
                Specifies that the Stage is aligned on the left.
            **/
            StageAlign["LEFT"] = "left";
            /**
                Specifies that the Stage is aligned to the right.
            **/
            StageAlign["RIGHT"] = "right";
            /**
                Specifies that the Stage is aligned at the top.
            **/
            StageAlign["TOP"] = "top";
            /**
                Specifies that the Stage is aligned on the left.
            **/
            StageAlign["TOP_LEFT"] = "topLeft";
            /**
                Specifies that the Stage is aligned to the right.
            **/
            StageAlign["TOP_RIGHT"] = "topRight";
        })(StageAlign = display.StageAlign || (display.StageAlign = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$z || (openfl$z = {}));
var StageAlign = openfl$z.display.StageAlign;

var openfl$A;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The StageDisplayState class provides values for the
            `Stage.displayState` property.
        **/
        let StageDisplayState;
        (function (StageDisplayState) {
            /**
                Specifies that the Stage is in full-screen mode.
            **/
            StageDisplayState["FULL_SCREEN"] = "fullScreen";
            /**
                Specifies that the Stage is in full-screen mode with keyboard interactivity enabled.
            **/
            StageDisplayState["FULL_SCREEN_INTERACTIVE"] = "fullScreenInteractive";
            /**
                Specifies that the Stage is in normal mode.
            **/
            StageDisplayState["NORMAL"] = "normal";
        })(StageDisplayState = display.StageDisplayState || (display.StageDisplayState = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$A || (openfl$A = {}));
var StageDisplayState = openfl$A.display.StageDisplayState;

var openfl$B;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The StageQuality class provides values for the `Stage.quality`
            property.
        **/
        let StageQuality;
        (function (StageQuality) {
            /**
                Specifies very high rendering quality: graphics are anti-aliased using a 4
                x 4 pixel grid and bitmaps are always smoothed.
            **/
            StageQuality["BEST"] = "best";
            /**
                Specifies high rendering quality: graphics are anti-aliased using a 4 x 4
                pixel grid, and bitmaps are smoothed if the movie is static.
            **/
            StageQuality["HIGH"] = "high";
            /**
                Specifies low rendering quality: graphics are not anti-aliased, and
                bitmaps are not smoothed.
            **/
            StageQuality["LOW"] = "low";
            /**
                Specifies medium rendering quality: graphics are anti-aliased using a 2 x
                2 pixel grid, but bitmaps are not smoothed. This setting is suitable for
                movies that do not contain text.
            **/
            StageQuality["MEDIUM"] = "medium";
        })(StageQuality = display.StageQuality || (display.StageQuality = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$B || (openfl$B = {}));
var StageQuality = openfl$B.display.StageQuality;

var openfl$C;
(function (openfl) {
    var display;
    (function (display) {
        /**
            The StageScaleMode class provides values for the
            `Stage.scaleMode` property.
        **/
        let StageScaleMode;
        (function (StageScaleMode) {
            /**
                Specifies that the entire application be visible in the specified area without
                trying to preserve the original aspect ratio. Distortion can occur.
            **/
            StageScaleMode["EXACT_FIT"] = "exactFit";
            /**
                Specifies that the entire application fill the specified area, without
                distortion but possibly with some cropping, while maintaining the original
                aspect ratio of the application.
            **/
            StageScaleMode["NO_BORDER"] = "noBorder";
            /**
                Specifies that the size of the application be fixed, so that it remains
                unchanged even as the size of the player window changes. Cropping might occur
                if the player window is smaller than the content.
            **/
            StageScaleMode["NO_SCALE"] = "noScale";
            /**
                Specifies that the entire application be visible in the specified area without
                distortion while maintaining the original aspect ratio of the application.
                Borders can appear on two sides of the application.
            **/
            StageScaleMode["SHOW_ALL"] = "showAll";
        })(StageScaleMode = display.StageScaleMode || (display.StageScaleMode = {}));
    })(display = openfl.display || (openfl.display = {}));
})(openfl$C || (openfl$C = {}));
var StageScaleMode = openfl$C.display.StageScaleMode;

/**
    The IllegalOperationError exception is thrown when a method is not
    implemented or the implementation doesn't cover the current usage.

    Examples of illegal operation error exceptions include:

    * A base class, such as DisplayObjectContainer, provides more
    functionality than a Stage can support(such as masks)
    * Certain accessibility methods are called when the player is compiled
    without accessibility support
    * The mms.cfg setting prohibits a FileReference action
    * ActionScript tries to run a `FileReference.browse()` call
    when a browse dialog box is already open
    * ActionScript tries to use an unsupported protocol for a FileReference
    object(such as FTP)
    * Authoring-only features are invoked from a run-time
    player
    * An attempt is made to set the name of a Timeline-placed
    object
**/
class IllegalOperationError extends Error$1 {
    /**
        Creates a new IllegalOperationError object.

        @param message A string associated with the error object.
    **/
    constructor(message = "") {
        super(message, 0);
        this.name = "IllegalOperationError";
    }
}

/**
    An UncaughtErrorEvent object is dispatched by an instance of the
    UncaughtErrorEvents class when an uncaught error occurs. An uncaught error
    happens when an error is thrown outside of any `try..catch` blocks or when
    an ErrorEvent object is dispatched with no registered listeners. The
    uncaught error event functionality is often described as a "global error
    handler."
    The UncaughtErrorEvents object that dispatches the event is associated
    with either a LoaderInfo object or a Loader object. Use the following
    properties to access an UncaughtErrorEvents instance:

    * `LoaderInfo.uncaughtErrorEvents`: to detect uncaught errors in code
    defined in the same SWF.
    * `Loader.uncaughtErrorEvents`: to detect uncaught errors in code defined
    in the SWF loaded by a Loader object.

    When an `uncaughtError` event happens, even if the event is handled,
    execution does not continue in the call stack that caused the error. If
    the error is a synchronous error, any code remaining in the where
    the error happened is not executed. Consequently, it is likely that when
    an uncaught error event happens, your application is in an unstable state.
    Since there can be many causes for an uncaught error, it is impossible to
    predict what functionality is available. For example, your application may
    be able to execute network operations or file operations. However, those
    operations aren't necessarily available.

    When one SWF loads another, `uncaughtError` events bubble down and up
    again through the LoaderInfo heirarchy. For example, suppose A.swf loads
    B.swf using a Loader instance. If an uncaught error occurs in B.swf, an
    `uncaughtError` event is dispatched to LoaderInfo and Loader objects in
    the following sequence:

    1. (Capture phase) A.swf's LoaderInfo
    2. (Capture phase) Loader in A.swf
    3. (Target phase) B.swf's LoaderInfo
    4. (Bubble phase) Loader in A.swf
    5. (Bubble phase) A.swf's LoaderInfo

    A Loader object's `uncaughtErrorEvents` property never dispatches an
    `uncaughtErrorEvent` in the target phase. It only dispatches the event in
    the capture and bubbling phases.

    As with other event bubbling, calling `stopPropagation()` or
    `stopImmediatePropagation()` stops the event from being dispatched to any
    other listeners, with one important difference. A Loader object's
    UncaughtErrorEvents object is treated as a pair with the loaded SWF's
    `LoaderInfo.uncaughtErrorEvents` object for event propagation purposes. If
    a listener registered with one of those objects calls the
    `stopPropagation()` method, events are still dispatched to other listeners
    registered with that UncaughtErrorEvents object _and_ to listeners
    registered with its partner UncaughtErrorEvents object before event
    propagation ends. The `stopImmediatePropagation()` method still prevents
    events from being dispatched to all additional listeners.

    When content is running in a debugger version of the runtime, such as the
    debugger version of Flash Player or the AIR Debug Launcher (ADL), an
    uncaught error dialog appears when an uncaught error happens. For those
    runtime versions, the error dialog appears even when a listener is
    registered for the `uncaughtError` event. To prevent the dialog from
    appearing in that situation, call the UncaughtErrorEvent object's
    `preventDefault()` method.

    If the content loaded by a Loader object is an AVM1 (ActionScript 2) SWF
    file, uncaught errors in the AVM1 SWF file do not result in an
    `uncaughtError` event. In addition, JavaScript errors in HTML content
    loaded in an HTMLLoader object (including a Flex HTML control) do not
    result in an `uncaughtError` event.

**/
let UncaughtErrorEvent = /** @class */ (() => {
    class UncaughtErrorEvent extends ErrorEvent {
        /**
            Creates an UncaughtErrorEvent object that contains information about
            an `uncaughtError` event.
    
            @param type       The type of the event.
            @param bubbles    Determines whether the Event object participates in
                              the bubbling stage of the event flow. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through
                              the inherited `cancelable` property.
            @param error_in   The object associated with the error that was not
                              caught or handled (an Error or ErrorEvent object
                              under normal circumstances).
        **/
        constructor(type, bubbles = true, cancelable = true, error = null) {
            super(type, bubbles, cancelable);
            this.__error = error;
        }
        clone() {
            var event = new UncaughtErrorEvent(this.__type, this.__bubbles, this.__cancelable, this.__error);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("UncaughtErrorEvent", "type", "bubbles", "cancelable", "error");
        }
        __init() {
            super.__init();
            this.__error = null;
        }
        // Get & Set Methods
        /**
            The error object associated with the uncaught error. Typically, this
            object's data type is one of the following:
            * An Error instance (or one of its subclasses), if the uncaught error
            is a synchronous error created by a `throw` statement, such as an
            error that could have been caught using a `try..catch` block
            * An ErrorEvent instance (or one of its subclasses), if the uncaught
            error is an asynchronous error that dispatches an error event when the
            error happens
    
            However, the `error` property can potentially be an object of any data
            type. ActionScript does not require a `throw` statement to be used
            only with Error objects. For example, the following code is legal both
            at compile time and run time:
    
            ```haxe
            throw new Sprite();
            ```
    
            If that `throw` statement is not caught by a `try..catch` block, the
            `throw` statement triggers an `uncaughtError` event. In that case, the
            `error` property of the UncaughtErrorEvent object that's dispatched is
            the Sprite object that's constructed in the `throw` statement.
    
            Consequently, in your `uncaughtError` listener, you should check the
            data type of the `error` property. The following example demonstrates
            this check:
    
            ```haxe
            function uncaughtErrorHandler(event:UncaughtErrorEvent):Void {
                var message:String;
                if (Std.is(event.error, Error)) {
                    message = cast(event.error, Error).message;
                } else if (Std.is(event.error, ErrorEvent)) {
                    message = cast(event.error, ErrorEvent).text;
                } else {
                    message = String(event.error);
                }
            }
            ```
    
            If the `error` property contains an Error instance (or Error
            subclass), the available error information varies depending on the
            version of the runtime in which the content is running. The following
            functionality is only available when content is running in a debugger
            version of the runtime, such as the debugger version of Flash Player
            or the AIR Debug Launcher (ADL):
    
            * `Error.getStackTrace()` to get the call stack that led to the error.
            In non-debugger runtime versions, this method returns `null`. Note
            that call stack information is never available when the `error`
            property is an ErrorEvent instance.
            * Complete `Error.message` text. In non-debugger runtime versions,
            this property contains a short version of the error message, which is
            often a combination of the `Error.errorID` and `Error.name`
            properties.
    
            All other properties and methods of the Error class are available in
            all runtime versions.
        **/
        get error() {
            return this.__error;
        }
    }
    /**
        Defines the value of the `type` property of an `uncaughtError` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `true` |
        | `cancelable` | `true`; cancelling the event prevents the uncaught error dialog from appearing in debugger runtime versions |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `error` | The uncaught error. |
        | `target` | The LoaderInfo object associated with the SWF where the error happened. |
        | `text` | Text error message. |
    **/
    UncaughtErrorEvent.UNCAUGHT_ERROR = "uncaughtError";
    UncaughtErrorEvent.__pool = new ObjectPool(() => new UncaughtErrorEvent(null), (event) => event.__init());
    return UncaughtErrorEvent;
})();

/**
    The methods of the Mouse class are used to hide and show the mouse pointer,
    or to set the pointer to a specific style. The Mouse class is a top-level
    class whose properties and methods you can access without using a
    constructor. <ph outputclass="flashonly">The pointer is visible by default,
    but you can hide it and implement a custom pointer.
**/
let Mouse = /** @class */ (() => {
    class Mouse {
        /**
            Hides the pointer. The pointer is visible by default.
    
            **Note:** You need to call `Mouse.hide()` only once,
            regardless of the number of previous calls to
            `Mouse.show()`.
    
        **/
        static hide() {
            Mouse.__hidden = true;
            // TODO
            // for (window in Application.current.windows)
            // {
            // 	window.cursor = null;
            // }
        }
        /**
            Registers a native cursor under the given name, with the given data.
    
            @param name   The name to use as a reference to the native cursor
                          instance.
            @param cursor The properties for the native cursor, such as icon
                          bitmap, specified as a MouseCursorData instance.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10_2) public static registerCursor (name:String, cursor:openfl.ui.MouseCursorData):Void;
        /**
            Displays the pointer. The pointer is visible by default.
    
            **Note:** You need to call `Mouse.show()` only once,
            regardless of the number of previous calls to
            `Mouse.hide()`.
    
        **/
        static show() {
            Mouse.__hidden = false;
            var cacheCursor = Mouse.__cursor;
            Mouse.__cursor = null;
            Mouse.__setCursor(cacheCursor);
        }
        static __setCursor(value) {
            // TODO
            // var limeCursor: LimeMouseCursor = null;
            // switch (value)
            // {
            // 	case MouseCursor.ARROW:
            // 		limeCursor = ARROW;
            // 	case MouseCursor.BUTTON:
            // 		limeCursor = POINTER;
            // 	case MouseCursor.HAND:
            // 		limeCursor = MOVE;
            // 	case MouseCursor.IBEAM:
            // 		limeCursor = TEXT;
            // 	case MouseCursor.__CROSSHAIR:
            // 		limeCursor = CROSSHAIR;
            // 	case MouseCursor.__CUSTOM:
            // 		limeCursor = CUSTOM;
            // 	case MouseCursor.__RESIZE_NESW:
            // 		limeCursor = RESIZE_NESW;
            // 	case MouseCursor.__RESIZE_NS:
            // 		limeCursor = RESIZE_NS;
            // 	case MouseCursor.__RESIZE_NWSE:
            // 		limeCursor = RESIZE_NWSE;
            // 	case MouseCursor.__RESIZE_WE:
            // 		limeCursor = RESIZE_WE;
            // 	case MouseCursor.__WAIT:
            // 		limeCursor = WAIT;
            // 	case MouseCursor.__WAIT_ARROW:
            // 		limeCursor = WAIT_ARROW;
            // 	default:
            // }
            // if (limeCursor != null && !Mouse.__hidden)
            // {
            // 	for (window in Application.current.windows)
            // 	{
            // 		window.cursor = limeCursor;
            // 	}
            // }
        }
        static __setStageCursor(stage, cursor) {
            // TODO
            // var limeCursor: LimeMouseCursor = null;
            // switch (value)
            // {
            // 	case MouseCursor.ARROW:
            // 		limeCursor = ARROW;
            // 	case MouseCursor.BUTTON:
            // 		limeCursor = POINTER;
            // 	case MouseCursor.HAND:
            // 		limeCursor = MOVE;
            // 	case MouseCursor.IBEAM:
            // 		limeCursor = TEXT;
            // 	case MouseCursor.__CROSSHAIR:
            // 		limeCursor = CROSSHAIR;
            // 	case MouseCursor.__CUSTOM:
            // 		limeCursor = CUSTOM;
            // 	case MouseCursor.__RESIZE_NESW:
            // 		limeCursor = RESIZE_NESW;
            // 	case MouseCursor.__RESIZE_NS:
            // 		limeCursor = RESIZE_NS;
            // 	case MouseCursor.__RESIZE_NWSE:
            // 		limeCursor = RESIZE_NWSE;
            // 	case MouseCursor.__RESIZE_WE:
            // 		limeCursor = RESIZE_WE;
            // 	case MouseCursor.__WAIT:
            // 		limeCursor = WAIT;
            // 	case MouseCursor.__WAIT_ARROW:
            // 		limeCursor = WAIT_ARROW;
            // 	default:
            // }
            // if (limeCursor != null && !Mouse.__hidden)
            // {
            // 	// TODO
            // 	//stage.window.cursor = limeCursor;
            // }
        }
        /**
            Unregisters the native cursor with the given name.
    
            @param name The name referring to the native cursor instance.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash11) public static unregisterCursor (name:String):Void;
        // Get & Set Methods
        /**
            Sets or returns the type of cursor, or, for a native cursor, the
            cursor name.
            The default value is `openfl.ui.MouseCursor.AUTO`.
    
            To set values for this property, use the following string values:
    
            | String value | Description |
            | --- | --- |
            | `openfl.ui.MouseCursor.AUTO` | Mouse cursor will change automatically based on the object under the mouse. |
            | `openfl.ui.MouseCursor.ARROW` | Mouse cursor will be an arrow. |
            | `openfl.ui.MouseCursor.BUTTON` | Mouse cursor will be a button clicking hand. |
            | `openfl.ui.MouseCursor.HAND` | Mouse cursor will be a dragging hand. |
            | `openfl.ui.MouseCursor.IBEAM` | Mouse cursor will be an I-beam. |
    
            **Note:** For Flash Player 10.2 or AIR 2.6 and later versions, this
            property sets or gets the cursor name when you are using a native
            cursor. A native cursor name defined using `Mouse.registerCursor()`
            overwrites currently predefined cursor types (such as
            `openfl.ui.MouseCursor.IBEAM`).
    
            @throws ArgumentError If set to any value which is not a member of
                                  `openfl.ui.MouseCursor`, or is not a string
                                  specified using the `Mouse.registerCursor()`
                                  method.
        **/
        static get cursor() {
            return Mouse.__cursor;
        }
        static set cursor(value) {
            if (value == null)
                value = MouseCursor$1.AUTO;
            Mouse.__setCursor(value);
            Mouse.__cursor = value;
        }
    }
    /**
        Indicates whether the computer or device displays a persistent cursor.

        The `supportsCursor` property is `true` on most desktop computers and
        `false` on most mobile devices.

        **Note:** Mouse events can be dispatched whether or not this property
        is `true`. However, mouse events may behave differently depending on
        the physical characteristics of the pointing device.
    **/
    Mouse.supportsCursor = true;
    /**
        Indicates whether the current configuration supports native cursors.
    **/
    Mouse.supportsNativeCursor = false;
    Mouse.__cursor = MouseCursor$1.AUTO;
    return Mouse;
})();

/**
    The Stage class represents the main drawing area.

    For SWF content running in the browser(in Flash<sup>®</sup> Player),
    the Stage represents the entire area where Flash content is shown. For
    content running in AIR on desktop operating systems, each NativeWindow
    object has a corresponding Stage object.

    The Stage object is not globally accessible. You need to access it
    through the `stage` property of a DisplayObject instance.

    The Stage class has several ancestor classes  -  DisplayObjectContainer,
    InteractiveObject, DisplayObject, and EventDispatcher  -  from which it
    inherits properties and methods. Many of these properties and methods are
    either inapplicable to Stage objects, or require security checks when
    called on a Stage object. The properties and methods that require security
    checks are documented as part of the Stage class.

    In addition, the following inherited properties are inapplicable to
    Stage objects. If you try to set them, an IllegalOperationError is thrown.
    These properties may always be read, but since they cannot be set, they
    will always contain default values.


    * `accessibilityProperties`
    * `alpha`
    * `blendMode`
    * `cacheAsBitmap`
    * `contextMenu`
    * `filters`
    * `focusRect`
    * `loaderInfo`
    * `mask`
    * `mouseEnabled`
    * `name`
    * `opaqueBackground`
    * `rotation`
    * `scale9Grid`
    * `scaleX`
    * `scaleY`
    * `scrollRect`
    * `tabEnabled`
    * `tabIndex`
    * `transform`
    * `visible`
    * `x`
    * `y`


    Some events that you might expect to be a part of the Stage class, such
    as `enterFrame`, `exitFrame`,
    `frameConstructed`, and `render`, cannot be Stage
    events because a reference to the Stage object cannot be guaranteed to
    exist in every situation where these events are used. Because these events
    cannot be dispatched by the Stage object, they are instead dispatched by
    every DisplayObject instance, which means that you can add an event
    listener to any DisplayObject instance to listen for these events. These
    events, which are part of the DisplayObject class, are called broadcast
    events to differentiate them from events that target a specific
    DisplayObject instance. Two other broadcast events, `activate`
    and `deactivate`, belong to DisplayObject's superclass,
    EventDispatcher. The `activate` and `deactivate`
    events behave similarly to the DisplayObject broadcast events, except that
    these two events are dispatched not only by all DisplayObject instances,
    but also by all EventDispatcher instances and instances of other
    EventDispatcher subclasses. For more information on broadcast events, see
    the DisplayObject class.

    @event fullScreen             Dispatched when the Stage object enters, or
                                  leaves, full-screen mode. A change in
                                  full-screen mode can be initiated through
                                  ActionScript, or the user invoking a keyboard
                                  shortcut, or if the current focus leaves the
                                  full-screen window.
    @event mouseLeave             Dispatched by the Stage object when the
                                  pointer moves out of the stage area. If the
                                  mouse button is pressed, the event is not
                                  dispatched.
    @event orientationChange      Dispatched by the Stage object when the stage
                                  orientation changes.

                                  Orientation changes can occur when the
                                  user rotates the device, opens a slide-out
                                  keyboard, or when the
                                  `setAspectRatio()` is called.

                                  **Note:** If the
                                  `autoOrients` property is
                                  `false`, then the stage
                                  orientation does not change when a device is
                                  rotated. Thus, StageOrientationEvents are
                                  only dispatched for device rotation when
                                  `autoOrients` is
                                  `true`.
    @event orientationChanging    Dispatched by the Stage object when the stage
                                  orientation begins changing.

                                  **Important:** orientationChanging
                                  events are not dispatched on Android
                                  devices.

                                  **Note:** If the
                                  `autoOrients` property is
                                  `false`, then the stage
                                  orientation does not change when a device is
                                  rotated. Thus, StageOrientationEvents are
                                  only dispatched for device rotation when
                                  `autoOrients` is
                                  `true`.
    @event resize                 Dispatched when the `scaleMode`
                                  property of the Stage object is set to
                                  `StageScaleMode.NO_SCALE` and the
                                  SWF file is resized.
    @event stageVideoAvailability Dispatched by the Stage object when the state
                                  of the stageVideos property changes.
**/
class Stage extends DisplayObjectContainer {
    constructor(width = 0, height = 0, color = null, documentClass = null, windowAttributes = null) {
        // 	#if hxtelemetry
        // Telemetry.__initialize();
        // 	#end
        super();
        this.name = null;
        this.__color = 0xFFFFFFFF;
        this.__colorSplit = [0xFF, 0xFF, 0xFF];
        this.__colorString = "#FFFFFF";
        this.__contentsScaleFactor = 1;
        this.__currentTabOrderIndex = 0;
        this.__deltaTime = 0;
        this.__displayState = StageDisplayState.NORMAL;
        this.__mouseX = 0;
        this.__mouseY = 0;
        this.__lastClickTime = 0;
        this.__logicalWidth = 0;
        this.__logicalHeight = 0;
        this.__displayMatrix = new Matrix();
        this.__displayRect = new Rectangle();
        this.__renderDirty = true;
        this.__stage3Ds = new Vector();
        for (let i = 0; i < 4; i++) {
            this.__stage3Ds.push(new Stage3D(this));
        }
        this.__stage = this;
        this.align = StageAlign.TOP_LEFT;
        this.__allowsFullScreen = true;
        this.__allowsFullScreenInteractive = true;
        this.__quality = StageQuality.HIGH;
        this.__scaleMode = StageScaleMode.NO_SCALE;
        this.showDefaultContextMenu = true;
        this.softKeyboardRect = new Rectangle();
        this.stageFocusRect = true;
        this.__clearBeforeRender = true;
        this.__forceRender = false;
        this.__stack = [];
        this.__rollOutStack = [];
        this.__mouseOutStack = [];
        this.__touchData = new Map();
        // __backend = new StageBackend(this, width, height, color, documentClass, windowAttributes);
    }
    /**
        Calling the `invalidate()` method signals Flash runtimes to
        alert display objects on the next opportunity it has to render the display
        list(for example, when the playhead advances to a new frame). After you
        call the `invalidate()` method, when the display list is next
        rendered, the Flash runtime sends a `render` event to each
        display object that has registered to listen for the `render`
        event. You must call the `invalidate()` method each time you
        want the Flash runtime to send `render` events.

        The `render` event gives you an opportunity to make changes
        to the display list immediately before it is actually rendered. This lets
        you defer updates to the display list until the latest opportunity. This
        can increase performance by eliminating unnecessary screen updates.

        The `render` event is dispatched only to display objects
        that are in the same security domain as the code that calls the
        `stage.invalidate()` method, or to display objects from a
        security domain that has been granted permission via the
        `Security.allowDomain()` method.

    **/
    invalidate() {
        this.__invalidated = true;
        // TODO: Should this not mark as dirty?
        this.__renderDirty = true;
    }
    // /** @hidden */ @:dox(hide) public isFocusInaccessible ():Bool;
    localToGlobal(pos) {
        return pos.clone();
    }
    __broadcastEvent(event) {
        if (DisplayObject.__broadcastEvents.has(event.type)) {
            var dispatchers = DisplayObject.__broadcastEvents.get(event.type);
            for (let dispatcher of dispatchers) {
                // TODO: Way to resolve dispatching occurring if object not on stage
                // and there are multiple stage objects running in HTML5?
                if (dispatcher.stage == this || dispatcher.stage == null) {
                    // #if!openfl_disable_handle_error
                    try {
                        dispatcher.__dispatch(event);
                    }
                    catch (e) {
                        this.__handleError(e);
                    }
                    // #else
                    // dispatcher.__dispatch(event);
                    // #end
                }
            }
        }
    }
    __dispatchEvent(event) {
        // #if!openfl_disable_handle_error
        try {
            // #end
            return super.__dispatchEvent(event);
            // #if!openfl_disable_handle_error
        }
        catch (e) {
            this.__handleError(e);
            return false;
        }
        // #end
    }
    __dispatchPendingMouseEvent() {
        if (this.__pendingMouseEvent) {
            this.__onMouse(MouseEvent.MOUSE_MOVE, this.__pendingMouseX, this.__pendingMouseY, 0);
            this.__pendingMouseEvent = false;
        }
    }
    __dispatchStack(event, stack) {
        // #if!openfl_disable_handle_error
        try {
            // #end
            var target;
            var length = stack.length;
            if (length == 0) {
                event.__eventPhase = EventPhase$1.AT_TARGET;
                target = event.target;
                target.__dispatch(event);
            }
            else {
                event.__eventPhase = EventPhase$1.CAPTURING_PHASE;
                event.__target = stack[stack.length - 1];
                for (let i = 0; i < length - 1; i++) {
                    stack[i].__dispatch(event);
                    if (Event.__isCanceled) {
                        return;
                    }
                }
                event.__eventPhase = EventPhase$1.AT_TARGET;
                target = event.target;
                target.__dispatch(event);
                if (Event.__isCanceled) {
                    return;
                }
                if (event.bubbles) {
                    event.__eventPhase = EventPhase$1.BUBBLING_PHASE;
                    var i = length - 2;
                    while (i >= 0) {
                        stack[i].__dispatch(event);
                        if (Event.__isCanceled) {
                            return;
                        }
                        i--;
                    }
                }
            }
            // #if!openfl_disable_handle_error
        }
        catch (e) {
            this.__handleError(e);
        }
        // #end
    }
    __dispatchTarget(target, event) {
        // #if!openfl_disable_handle_error
        try {
            return target.__dispatchEvent(event);
        }
        catch (e) {
            this.__handleError(e);
            return false;
        }
        // #else
        // return (<internal.DisplayObject><any>target).__dispatchEvent(event);
        // #end
    }
    __drag(mouse) {
        var parent = this.__dragObject.parent;
        if (parent != null) {
            parent.__getWorldTransform().__transformInversePoint(mouse);
        }
        var x = mouse.x + this.__dragOffsetX;
        var y = mouse.y + this.__dragOffsetY;
        if (this.__dragBounds != null) {
            if (x < this.__dragBounds.x) {
                x = this.__dragBounds.x;
            }
            else if (x > this.__dragBounds.right) {
                x = this.__dragBounds.right;
            }
            if (y < this.__dragBounds.y) {
                y = this.__dragBounds.y;
            }
            else if (y > this.__dragBounds.bottom) {
                y = this.__dragBounds.bottom;
            }
        }
        this.__dragObject.x = x;
        this.__dragObject.y = y;
    }
    __getInteractive(stack) {
        if (stack != null) {
            stack.push(this);
        }
        return true;
    }
    __globalToLocal(global, local) {
        if (global != local) {
            local.copyFrom(global);
        }
        return local;
    }
    __handleError(e) {
        var event = new UncaughtErrorEvent(UncaughtErrorEvent.UNCAUGHT_ERROR, true, true, e);
        try {
            Lib$1.current.__loaderInfo.uncaughtErrorEvents.dispatchEvent(event);
        }
        catch (e) { }
        if (!event.__preventDefault) {
            // try
            // {
            // 	var exc = @: privateAccess haxe.CallStack.lastException;
            // 	if (exc != null && Reflect.hasField(exc, "stack") && exc.stack != null && exc.stack != "")
            // 	{
            // 		untyped __js__("console.log")(exc.stack);
            // 		e.stack = exc.stack;
            // 	}
            // 	else
            // 	{
            // 		var msg = CallStack.toString(CallStack.callStack());
            // 		untyped __js__("console.log")(msg);
            // 	}
            // }
            // catch (e2: Dynamic) { }
            // untyped __js__("throw e");
            throw e;
        }
    }
    __onKey(event) {
        this.__dispatchPendingMouseEvent();
        MouseEvent.__altKey = event.altKey;
        // #if!openfl_doc_gen
        MouseEvent.__commandKey = event.commandKey;
        // #end
        MouseEvent.__ctrlKey = event.ctrlKey;
        MouseEvent.__shiftKey = event.shiftKey;
        var preventDefault = false;
        var stack = new Array();
        if (this.__focus == null) {
            this.__getInteractive(stack);
        }
        else {
            this.__focus.__getInteractive(stack);
        }
        if (stack.length > 0) {
            // Flash Player events are not cancelable, should we make only some events (like APP_CONTROL_BACK) cancelable?
            stack.reverse();
            this.__dispatchStack(event, stack);
            if (event.__preventDefault) {
                preventDefault = true;
            }
            else {
                if (event.type == KeyboardEvent.KEY_DOWN && event.keyCode == Keyboard.TAB) {
                    var tabStack = new Array();
                    this.__tabTest(tabStack);
                    var nextIndex = -1;
                    var nextObject = null;
                    var nextOffset = event.shiftKey ? -1 : 1;
                    if (tabStack.length > 1) {
                        tabStack.sort((a, b) => a.tabIndex - b.tabIndex);
                        if (tabStack[tabStack.length - 1].tabIndex == -1) {
                            // all tabIndices are equal to -1
                            if (this.focus != null)
                                nextIndex = 0;
                            else
                                nextIndex = this.__currentTabOrderIndex;
                        }
                        else {
                            var i = 0;
                            while (i < tabStack.length) {
                                if (tabStack[i].tabIndex > -1) {
                                    if (i > 0)
                                        tabStack.splice(0, i);
                                    break;
                                }
                                i++;
                            }
                            if (this.focus != null) {
                                var index = tabStack.indexOf(this.focus);
                                if (index < 0)
                                    nextIndex = 0;
                                else
                                    nextIndex = index + nextOffset;
                            }
                            else {
                                nextIndex = this.__currentTabOrderIndex;
                            }
                        }
                    }
                    else if (tabStack.length == 1) {
                        nextObject = tabStack[0];
                        if (this.focus == nextObject)
                            nextObject = null;
                    }
                    if (tabStack.length == 1 || tabStack.length == 0 && this.focus != null) {
                        nextIndex = 0;
                    }
                    else if (tabStack.length > 1) {
                        if (nextIndex < 0)
                            nextIndex += tabStack.length;
                        nextIndex %= tabStack.length;
                        nextObject = tabStack[nextIndex];
                        if (nextObject == this.focus) {
                            nextIndex += nextOffset;
                            if (nextIndex < 0)
                                nextIndex += tabStack.length;
                            nextIndex %= tabStack.length;
                            nextObject = tabStack[nextIndex];
                        }
                    }
                    var focusEvent = null;
                    if (focus != null) {
                        focusEvent = new FocusEvent(FocusEvent.KEY_FOCUS_CHANGE, true, true, nextObject, event.shiftKey, 0);
                        stack = [];
                        focus.__getInteractive(stack);
                        stack.reverse();
                        this.__dispatchStack(focusEvent, stack);
                    }
                    if (focusEvent == null || !focusEvent.isDefaultPrevented()) {
                        this.__currentTabOrderIndex = nextIndex;
                        if (nextObject != null)
                            this.focus = nextObject;
                        // TODO: handle border around focus
                    }
                }
                // TODO: handle arrow keys changing the focus
            }
        }
        return preventDefault;
    }
    __onMouse(type, x, y, button) {
        if (button > 2)
            return;
        var targetPoint = Point.__pool.get();
        targetPoint.setTo(x, y);
        this.__displayMatrix.__transformInversePoint(targetPoint);
        this.__mouseX = targetPoint.x;
        this.__mouseY = targetPoint.y;
        var stack = [];
        var target = null;
        if (this.__hitTest(this.__mouseX, this.__mouseY, true, stack, true, this)) {
            target = stack[stack.length - 1];
        }
        else {
            target = this;
            stack = [this];
        }
        if (target == null)
            target = this;
        var clickType = null;
        var event = null;
        switch (type) {
            case MouseEvent.MOUSE_DOWN:
                if (target.__allowMouseFocus()) {
                    if (focus != null) {
                        var focusEvent = new FocusEvent(FocusEvent.MOUSE_FOCUS_CHANGE, true, true, target, false, 0);
                        this.__dispatchStack(focusEvent, stack);
                        if (!focusEvent.isDefaultPrevented()) {
                            this.focus = target;
                        }
                    }
                    else {
                        this.focus = target;
                    }
                }
                else {
                    this.focus = null;
                }
                this.__mouseDownLeft = target;
                MouseEvent.__buttonDown = true;
                break;
            case MouseEvent.MIDDLE_MOUSE_DOWN:
                this.__mouseDownMiddle = target;
                break;
            case MouseEvent.RIGHT_MOUSE_DOWN:
                this.__mouseDownRight = target;
                break;
            case MouseEvent.MOUSE_UP:
                if (this.__mouseDownLeft != null) {
                    MouseEvent.__buttonDown = false;
                    if (this.__mouseDownLeft == target) {
                        clickType = MouseEvent.CLICK;
                    }
                    else {
                        // event = null;
                        // #if openfl_pool_events
                        // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(MouseEvent.RELEASE_OUTSIDE, this.__mouseX, this.__mouseY, new Point(this.__mouseX, this.__mouseY), this);
                        // #else
                        event = MouseEvent.__create(MouseEvent.RELEASE_OUTSIDE, 1, this.__mouseX, this.__mouseY, new Point(this.__mouseX, this.__mouseY), this);
                        // #end
                        this.__mouseDownLeft.dispatchEvent(event);
                        // #if openfl_pool_events
                        // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
                        // #end
                    }
                    this.__mouseDownLeft = null;
                }
                break;
            case MouseEvent.MIDDLE_MOUSE_UP:
                if (this.__mouseDownMiddle == target) {
                    clickType = MouseEvent.MIDDLE_CLICK;
                }
                this.__mouseDownMiddle = null;
                break;
            case MouseEvent.RIGHT_MOUSE_UP:
                if (this.__mouseDownRight == target) {
                    clickType = MouseEvent.RIGHT_CLICK;
                }
                this.__mouseDownRight = null;
                break;
        }
        var localPoint = Point.__pool.get();
        event = null;
        // #if openfl_pool_events
        // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(type, this.__mouseX, this.__mouseY, (<internal.DisplayObject><any>target).__globalToLocal(targetPoint, localPoint), target);
        // #else
        event = MouseEvent.__create(type, button, this.__mouseX, this.__mouseY, target.__globalToLocal(targetPoint, localPoint), target);
        // #end
        this.__dispatchStack(event, stack);
        // #if openfl_pool_events
        // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
        // #end
        if (clickType != null) {
            // #if openfl_pool_events
            // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(clickType, this.__mouseX, this.__mouseY, (<internal.DisplayObject><any>target).__globalToLocal(targetPoint, localPoint), target);
            // #else
            event = MouseEvent.__create(clickType, button, this.__mouseX, this.__mouseY, target.__globalToLocal(targetPoint, localPoint), target);
            // #end
            this.__dispatchStack(event, stack);
            // #if openfl_pool_events
            // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
            // #end
            if (type == MouseEvent.MOUSE_UP && target.doubleClickEnabled) {
                var currentTime = Lib$1.getTimer();
                if (currentTime - this.__lastClickTime < 500) {
                    // #if openfl_pool_events
                    // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(MouseEvent.DOUBLE_CLICK, __mouseX, __mouseY, (<internal.DisplayObject><any>target).__globalToLocal(targetPoint, localPoint), target);
                    // #else
                    event = MouseEvent.__create(MouseEvent.DOUBLE_CLICK, button, this.__mouseX, this.__mouseY, target.__globalToLocal(targetPoint, localPoint), target);
                    // #end
                    this.__dispatchStack(event, stack);
                    // #if openfl_pool_events
                    // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
                    // #end
                    this.__lastClickTime = 0;
                }
                else {
                    this.__lastClickTime = currentTime;
                }
            }
        }
        if (Mouse.__cursor == MouseCursor$1.AUTO && !Mouse.__hidden) {
            var cursor = null;
            if (this.__mouseDownLeft != null) {
                cursor = this.__mouseDownLeft.__getCursor();
            }
            else {
                for (let target of stack) {
                    cursor = target.__getCursor();
                    if (cursor != null) {
                        Mouse.__setStageCursor(this, cursor);
                    }
                }
            }
            if (cursor == null) {
                Mouse.__setStageCursor(this, MouseCursor$1.ARROW);
            }
        }
        event = null;
        if (target != this.__mouseOverTarget) {
            if (this.__mouseOverTarget != null) {
                // #if openfl_pool_events
                // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(MouseEvent.MOUSE_OUT, this.__mouseX, this.__mouseY, (<internal.DisplayObject><any>this.__mouseOverTarget).__globalToLocal(targetPoint, localPoint),
                // this.__mouseOverTarget as InteractiveObject);
                // #else
                event = MouseEvent.__create(MouseEvent.MOUSE_OUT, button, this.__mouseX, this.__mouseY, this.__mouseOverTarget.__globalToLocal(targetPoint, localPoint), this.__mouseOverTarget);
                // #end
                this.__dispatchStack(event, this.__mouseOutStack);
                // #if openfl_pool_events
                // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
                // #end
            }
        }
        var item, i = 0;
        while (i < this.__rollOutStack.length) {
            item = this.__rollOutStack[i];
            if (stack.indexOf(item) == -1) {
                var index = this.__rollOutStack.indexOf(item);
                if (index > -1)
                    this.__rollOutStack.splice(index, 1);
                // #if openfl_pool_events
                // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(MouseEvent.ROLL_OUT, __mouseX, __mouseY, __mouseOver(<internal.DisplayObject><any>target).__globalToLocal(targetPoint, localPoint),
                // 	__mouseOverTarget as InteractiveObject);
                // #else
                event = MouseEvent.__create(MouseEvent.ROLL_OUT, button, this.__mouseX, this.__mouseY, this.__mouseOverTarget.__globalToLocal(targetPoint, localPoint), this.__mouseOverTarget);
                // #end
                event.__bubbles = false;
                this.__dispatchTarget(item, event);
                // #if openfl_pool_events
                // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
                // #end
            }
            else {
                i++;
            }
        }
        for (item in stack) {
            if (this.__rollOutStack.indexOf(item) == -1 && this.__mouseOverTarget != null) {
                if (item.hasEventListener(MouseEvent.ROLL_OVER)) {
                    // // #if openfl_pool_events
                    // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(MouseEvent.ROLL_OVER, this.__mouseX, this.__mouseY, (<internal.DisplayObject><any>this.__mouseOverTarget).__globalToLocal(targetPoint, localPoint),
                    // 	item as InteractiveObject);
                    // #else
                    event = MouseEvent.__create(MouseEvent.ROLL_OVER, button, this.__mouseX, this.__mouseY, this.__mouseOverTarget.__globalToLocal(targetPoint, localPoint), item);
                    // #end
                    event.__bubbles = false;
                    this.__dispatchTarget(item, event);
                    // #if openfl_pool_events
                    // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
                    // #end
                }
                if (item.hasEventListener(MouseEvent.ROLL_OUT) || item.hasEventListener(MouseEvent.ROLL_OVER)) {
                    this.__rollOutStack.push(item);
                }
            }
        }
        if (target != this.__mouseOverTarget) {
            if (target != null) {
                // #if openfl_pool_events
                // event = (<internal.MouseEvent><any>MouseEvent).__pool.get(MouseEvent.MOUSE_OVER, __mouseX, __mouseY, (<internal.DisplayObject><any>target).__globalToLocal(targetPoint, localPoint), cast target);
                // #else
                event = MouseEvent.__create(MouseEvent.MOUSE_OVER, button, this.__mouseX, this.__mouseY, target.__globalToLocal(targetPoint, localPoint), target);
                // #end
                this.__dispatchStack(event, stack);
                // #if openfl_pool_events
                // (<internal.MouseEvent><any>MouseEvent).__pool.release(event);
                // #end
            }
            this.__mouseOverTarget = target;
            this.__mouseOutStack = stack;
        }
        if (this.__dragObject != null) {
            this.__drag(targetPoint);
            var dropTarget = null;
            if (this.__mouseOverTarget == this.__dragObject) {
                var cacheMouseEnabled = this.__dragObject.mouseEnabled;
                var cacheMouseChildren = this.__dragObject.mouseChildren;
                this.__dragObject.mouseEnabled = false;
                this.__dragObject.mouseChildren = false;
                var stack = [];
                if (this.__hitTest(this.__mouseX, this.__mouseY, true, stack, true, this)) {
                    dropTarget = stack[stack.length - 1];
                }
                this.__dragObject.mouseEnabled = cacheMouseEnabled;
                this.__dragObject.mouseChildren = cacheMouseChildren;
            }
            else if (this.__mouseOverTarget != this) {
                dropTarget = this.__mouseOverTarget;
            }
            this.__dragObject.__dropTarget = dropTarget;
        }
        Point.__pool.release(targetPoint);
        Point.__pool.release(localPoint);
    }
    __onMouseWheel(deltaX, deltaY) {
        // TODO: Support delta modes
        var x = this.__mouseX;
        var y = this.__mouseY;
        var stack = [];
        var target = null;
        if (this.__hitTest(this.__mouseX, this.__mouseY, true, stack, true, this)) {
            target = stack[stack.length - 1];
        }
        else {
            target = this;
            stack = [this];
        }
        if (target == null)
            target = this;
        var targetPoint = Point.__pool.get();
        targetPoint.setTo(x, y);
        this.__displayMatrix.__transformInversePoint(targetPoint);
        var delta = Math.round(deltaY);
        var event = MouseEvent.__create(MouseEvent.MOUSE_WHEEL, 0, this.__mouseX, this.__mouseY, target.__globalToLocal(targetPoint, targetPoint), target, delta);
        event.__cancelable = true;
        this.__dispatchStack(event, stack);
        Point.__pool.release(targetPoint);
        return event.isDefaultPrevented();
    }
    __onTouch(type, id, x, y, pressure, isPrimaryTouchPoint) {
        var targetPoint = Point.__pool.get();
        targetPoint.setTo(x, y);
        this.__displayMatrix.__transformInversePoint(targetPoint);
        var touchX = targetPoint.x;
        var touchY = targetPoint.y;
        var stack = [];
        var target = null;
        if (this.__hitTest(touchX, touchY, false, stack, true, this)) {
            target = stack[stack.length - 1];
        }
        else {
            target = this;
            stack = [this];
        }
        if (target == null)
            target = this;
        var touchData = null;
        if (this.__touchData.has(id)) {
            touchData = this.__touchData.get(id);
        }
        else {
            touchData = TouchData.__pool.get();
            touchData.reset();
            this.__touchData.set(id, touchData);
        }
        var touchType = null;
        var releaseTouchData = false;
        switch (type) {
            case TouchEvent.TOUCH_BEGIN:
                touchData.touchDownTarget = target;
                break;
            case TouchEvent.TOUCH_END:
                if (touchData.touchDownTarget == target) {
                    touchType = TouchEvent.TOUCH_TAP;
                }
                touchData.touchDownTarget = null;
                releaseTouchData = true;
                break;
        }
        var localPoint = Point.__pool.get();
        var touchEvent = TouchEvent.__create(type, null, touchX, touchY, target.__globalToLocal(targetPoint, localPoint), target);
        touchEvent.touchPointID = id;
        touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
        touchEvent.pressure = pressure;
        this.__dispatchStack(touchEvent, stack);
        if (touchType != null) {
            touchEvent = TouchEvent.__create(touchType, null, touchX, touchY, target.__globalToLocal(targetPoint, localPoint), target);
            touchEvent.touchPointID = id;
            touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
            touchEvent.pressure = pressure;
            this.__dispatchStack(touchEvent, stack);
        }
        var touchOverTarget = touchData.touchOverTarget;
        if (target != touchOverTarget && touchOverTarget != null) {
            touchEvent = TouchEvent.__create(TouchEvent.TOUCH_OUT, null, touchX, touchY, touchOverTarget.__globalToLocal(targetPoint, localPoint), touchOverTarget);
            touchEvent.touchPointID = id;
            touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
            touchEvent.pressure = pressure;
            this.__dispatchTarget(touchOverTarget, touchEvent);
        }
        var touchOutStack = touchData.rollOutStack;
        var item, i = 0;
        while (i < touchOutStack.length) {
            item = touchOutStack[i];
            if (stack.indexOf(item) == -1) {
                var index = touchOutStack.indexOf(item);
                if (index > -1)
                    touchOutStack.splice(index, 1);
                touchEvent = TouchEvent.__create(TouchEvent.TOUCH_ROLL_OUT, null, touchX, touchY, touchOverTarget.__globalToLocal(targetPoint, localPoint), touchOverTarget);
                touchEvent.touchPointID = id;
                touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
                touchEvent.__bubbles = false;
                touchEvent.pressure = pressure;
                this.__dispatchTarget(item, touchEvent);
            }
            else {
                i++;
            }
        }
        for (item in stack) {
            if (touchOutStack.indexOf(item) == -1) {
                if (item.hasEventListener(TouchEvent.TOUCH_ROLL_OVER)) {
                    touchEvent = TouchEvent.__create(TouchEvent.TOUCH_ROLL_OVER, null, touchX, touchY, touchOverTarget.__globalToLocal(targetPoint, localPoint), item);
                    touchEvent.touchPointID = id;
                    touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
                    touchEvent.__bubbles = false;
                    touchEvent.pressure = pressure;
                    this.__dispatchTarget(item, touchEvent);
                }
                if (item.hasEventListener(TouchEvent.TOUCH_ROLL_OUT)) {
                    touchOutStack.push(item);
                }
            }
        }
        if (target != touchOverTarget) {
            if (target != null) {
                touchEvent = TouchEvent.__create(TouchEvent.TOUCH_OVER, null, touchX, touchY, target.__globalToLocal(targetPoint, localPoint), target);
                touchEvent.touchPointID = id;
                touchEvent.isPrimaryTouchPoint = isPrimaryTouchPoint;
                touchEvent.__bubbles = true;
                touchEvent.pressure = pressure;
                this.__dispatchTarget(target, touchEvent);
            }
            touchData.touchOverTarget = target;
        }
        Point.__pool.release(targetPoint);
        Point.__pool.release(localPoint);
        if (releaseTouchData) {
            this.__touchData.delete(id);
            touchData.reset();
            TouchData.__pool.release(touchData);
        }
    }
    __render() {
        if (this.__rendering)
            return;
        this.__rendering = true;
        // #if hxtelemetry
        // Telemetry.__advanceFrame();
        // #end
        // #if gl_stats
        // Context3DStats.resetDrawCalls();
        // #end
        var event = null;
        // #if openfl_pool_events
        // event = (<internal.Event><any>Event).__pool.get(Event.ENTER_FRAME);
        // this.__broadcastEvent(event);
        // (<internal.Event><any>Event).__pool.release(event);
        // event = (<internal.Event><any>Event).__pool.get(Event.FRAME_CONSTRUCTED);
        // this.__broadcastEvent(event);
        // (<internal.Event><any>Event).__pool.release(event);
        // event = (<internal.Event><any>Event).__pool.get(Event.EXIT_FRAME);
        // this.__broadcastEvent(event);
        // (<internal.Event><any>Event).__pool.release(event);
        // #else
        this.__broadcastEvent(new Event(Event.ENTER_FRAME));
        this.__broadcastEvent(new Event(Event.FRAME_CONSTRUCTED));
        this.__broadcastEvent(new Event(Event.EXIT_FRAME));
        // #end
        this.__renderable = true;
        if (this.__renderer != null) {
            this.__renderer.__enterFrame(this, this.__deltaTime);
        }
        this.__deltaTime = 0;
        var shouldRender = (this.__renderer != null && (this.__renderDirty || this.__forceRender));
        var shouldUpdate = shouldRender || this.__transformDirty;
        if (this.__invalidated && shouldRender) {
            this.__invalidated = false;
            // #if openfl_pool_events
            // event = (<internal.Event><any>Event).__pool.get(Event.RENDER);
            // #else
            event = new Event(Event.RENDER);
            // #end
            this.__broadcastEvent(event);
            // #if openfl_pool_events
            // (<internal.Event><any>Event).__pool.release(event);
            // #end
        }
        // #if hxtelemetry
        // var stack = Telemetry.__unwindStack();
        // Telemetry.__startTiming(TelemetryCommandName.RENDER);
        // #end
        if (DisplayObject.__supportDOM) {
            if (shouldUpdate || this.__wasDirty) {
                // If we were dirty last time, we need at least one more
                // update in order to clear "changed" properties
                this.__update(false, true);
                this.__wasDirty = shouldUpdate;
            }
        }
        else if (shouldUpdate) {
            this.__update(false, true);
        }
        // #if(lime || openfl_html5)
        if (this.__renderer != null) {
            if (this.__context3D != null) {
                for (let stage3D of this.__stage3Ds) {
                    this.__context3D.__renderStage3D(stage3D);
                }
                // #if!openfl_disable_display_render
                if (this.__context3D.__present)
                    shouldRender = true;
                // #end
            }
            if (shouldRender) {
                if (this.__context3D == null) {
                    this.__renderer.__clear();
                }
                this.__renderer.__render(this);
            }
            else if (this.__context3D == null) ;
            if (this.__context3D != null) {
                if (!this.__context3D.__present) ;
                else {
                    if (!this.__renderer.__cleared) {
                        this.__renderer.__clear();
                    }
                    this.__context3D.__present = false;
                    this.__context3D.__cleared = false;
                }
                this.__context3D.__bitmapDataPool.cleanup();
            }
            this.__renderer.__cleared = false;
            // TODO: Run once for multi-stage application
            BitmapData.__pool.cleanup();
        }
        // #end
        // #if hxtelemetry
        // Telemetry.__endTiming(TelemetryCommandName.RENDER);
        // Telemetry.__rewindStack(stack);
        // #end
        this.__rendering = false;
    }
    __resize() {
        var cacheWidth = this.__stageWidth;
        var cacheHeight = this.__stageHeight;
        var windowWidth = 0; //__backend.getWindowWidth();
        var windowHeight = 0; //__backend.getWindowHeight();
        // #if openfl_html5
        this.__logicalWidth = windowWidth;
        this.__logicalHeight = windowHeight;
        // #end
        this.__displayMatrix.identity();
        if (this.__fullScreenSourceRect != null && !false /*__backend.getWindowFullscreen()*/) {
            this.__stageWidth = Math.round(this.__fullScreenSourceRect.width);
            this.__stageHeight = Math.round(this.__fullScreenSourceRect.height);
            var displayScaleX = windowWidth / this.__stageWidth;
            var displayScaleY = windowHeight / this.__stageHeight;
            this.__displayMatrix.translate(-this.__fullScreenSourceRect.x, -this.__fullScreenSourceRect.y);
            this.__displayMatrix.scale(displayScaleX, displayScaleY);
            this.__displayRect.setTo(this.__fullScreenSourceRect.left, this.__fullScreenSourceRect.right, this.__fullScreenSourceRect.top, this.__fullScreenSourceRect.bottom);
        }
        else {
            if (this.__logicalWidth == 0 && this.__logicalHeight == 0) {
                this.__stageWidth = windowWidth;
                this.__stageHeight = windowHeight;
            }
            else {
                this.__stageWidth = this.__logicalWidth;
                this.__stageHeight = this.__logicalHeight;
                var scaleX = windowWidth / this.__stageWidth;
                var scaleY = windowHeight / this.__stageHeight;
                var targetScale = Math.min(scaleX, scaleY);
                var offsetX = Math.round((windowWidth - (this.__stageWidth * targetScale)) / 2);
                var offsetY = Math.round((windowHeight - (this.__stageHeight * targetScale)) / 2);
                this.__displayMatrix.scale(targetScale, targetScale);
                this.__displayMatrix.translate(offsetX, offsetY);
            }
            this.__displayRect.setTo(0, 0, this.__stageWidth, this.__stageHeight);
        }
        if (this.__context3D != null) {
            this.__context3D.configureBackBuffer(windowWidth, windowHeight, 0, true, true, true);
        }
        for (let stage3D of this.__stage3Ds) {
            stage3D.__resize(windowWidth, windowHeight);
        }
        if (this.__renderer != null) {
            this.__renderer.__resize(windowWidth, windowHeight);
        }
        if (this.__stageWidth != cacheWidth || this.__stageHeight != cacheHeight) {
            this.__renderDirty = true;
            this.__setTransformDirty();
            var event = null;
            // #if openfl_pool_events
            // event = (<internal.Event><any>Event).__pool.get(Event.RESIZE);
            // #else
            event = new Event(Event.RESIZE);
            // #end
            this.__dispatchEvent(event);
            // #if openfl_pool_events
            // (<internal.Event><any>Event).__pool.release(event);
            // #end
        }
    }
    __setLogicalSize(width, height) {
        this.__logicalWidth = width;
        this.__logicalHeight = height;
        this.__resize();
    }
    __startDrag(sprite, lockCenter, bounds) {
        if (bounds == null) {
            this.__dragBounds = null;
        }
        else {
            this.__dragBounds = new Rectangle();
            var right = bounds.right;
            var bottom = bounds.bottom;
            this.__dragBounds.x = right < bounds.x ? right : bounds.x;
            this.__dragBounds.y = bottom < bounds.y ? bottom : bounds.y;
            this.__dragBounds.width = Math.abs(bounds.width);
            this.__dragBounds.height = Math.abs(bounds.height);
        }
        this.__dragObject = sprite;
        if (this.__dragObject != null) {
            if (lockCenter) {
                this.__dragOffsetX = 0;
                this.__dragOffsetY = 0;
            }
            else {
                var mouse = Point.__pool.get();
                mouse.setTo(this.mouseX, this.mouseY);
                var parent = this.__dragObject.parent;
                if (parent != null) {
                    parent.__getWorldTransform().__transformInversePoint(mouse);
                }
                this.__dragOffsetX = this.__dragObject.x - mouse.x;
                this.__dragOffsetY = this.__dragObject.y - mouse.y;
                Point.__pool.release(mouse);
            }
        }
    }
    __stopDrag(sprite) {
        this.__dragBounds = null;
        this.__dragObject = null;
    }
    // Get & Set Methods
    /**
        Specifies whether this stage allows the use of the full screen mode
    **/
    get allowsFullScreen() {
        return this.__allowsFullScreen;
    }
    /**
        Specifies whether this stage allows the use of the full screen with text input mode
    **/
    get allowsFullScreenInteractive() {
        return this.__allowsFullScreenInteractive;
    }
    /**
        The window background color.
    **/
    get color() {
        return this.__color;
    }
    set color(value) {
        if (value == null) {
            this.__transparent = true;
            value = 0x000000;
        }
        else {
            this.__transparent = false;
        }
        if (this.__color != value) {
            var r = (value & 0xFF0000) >>> 16;
            var g = (value & 0x00FF00) >>> 8;
            var b = (value & 0x0000FF);
            this.__colorSplit[0] = r / 0xFF;
            this.__colorSplit[1] = g / 0xFF;
            this.__colorSplit[2] = b / 0xFF;
            this.__colorString = "#" + (value & 0xFFFFFF).toString(16);
            this.__renderDirty = true;
            this.__color = (0xFF << 24) | (value & 0xFFFFFF);
        }
    }
    /**
        Specifies the effective pixel scaling factor of the stage. This
        value is 1 on standard screens and HiDPI (Retina display)
        screens. When the stage is rendered on HiDPI screens the pixel
        resolution is doubled; even if the stage scaling mode is set to
        `StageScaleMode.NO_SCALE`. `Stage.stageWidth` and `Stage.stageHeight`
        continue to be reported in classic pixel units.
    **/
    get contentsScaleFactor() {
        return this.__contentsScaleFactor;
    }
    /**
        **BETA**

        The current Context3D the default display renderer.

        This property is supported only when using hardware rendering.
    **/
    get context3D() {
        return this.__context3D;
    }
    /**
        A value from the StageDisplayState class that specifies which display
        state to use. The following are valid values:

        * `StageDisplayState.FULL_SCREEN` Sets AIR application or
        Flash runtime to expand the stage over the user's entire screen, with
        keyboard input disabled.
        * `StageDisplayState.FULL_SCREEN_INTERACTIVE` Sets the AIR
        application to expand the stage over the user's entire screen, with
        keyboard input allowed.(Not available for content running in Flash
        Player.)
        * `StageDisplayState.NORMAL` Sets the Flash runtime back to
        the standard stage display mode.


        The scaling behavior of the movie in full-screen mode is determined by
        the `scaleMode` setting(set using the
        `Stage.scaleMode` property or the SWF file's `embed`
        tag settings in the HTML file). If the `scaleMode` property is
        set to `noScale` while the application transitions to
        full-screen mode, the Stage `width` and `height`
        properties are updated, and the Stage dispatches a `resize`
        event. If any other scale mode is set, the stage and its contents are
        scaled to fill the new screen dimensions. The Stage object retains its
        original `width` and `height` values and does not
        dispatch a `resize` event.

        The following restrictions apply to SWF files that play within an HTML
        page(not those using the stand-alone Flash Player or not running in the
        AIR runtime):


        * To enable full-screen mode, add the `allowFullScreen`
        parameter to the `object` and `embed` tags in the
        HTML page that includes the SWF file, with `allowFullScreen`
        set to `"true"`, as shown in the following example:
        * Full-screen mode is initiated in response to a mouse click or key
        press by the user; the movie cannot change `Stage.displayState`
        without user input. Flash runtimes restrict keyboard input in full-screen
        mode. Acceptable keys include keyboard shortcuts that terminate
        full-screen mode and non-printing keys such as arrows, space, Shift, and
        Tab keys. Keyboard shortcuts that terminate full-screen mode are: Escape
        (Windows, Linux, and Mac), Control+W(Windows), Command+W(Mac), and
        Alt+F4.

        A Flash runtime dialog box appears over the movie when users enter
        full-screen mode to inform the users they are in full-screen mode and that
        they can press the Escape key to end full-screen mode.

        * Starting with Flash Player 9.0.115.0, full-screen works the same in
        windowless mode as it does in window mode. If you set the Window Mode
        (`wmode` in the HTML) to Opaque Windowless
        (`opaque`) or Transparent Windowless
        (`transparent`), full-screen can be initiated, but the
        full-screen window will always be opaque.

        These restrictions are _not_ present for SWF content running in
        the stand-alone Flash Player or in AIR. AIR supports an interactive
        full-screen mode which allows keyboard input.

        For AIR content running in full-screen mode, the system screen saver
        and power saving options are disabled while video content is playing and
        until either the video stops or full-screen mode is exited.

        On Linux, setting `displayState` to
        `StageDisplayState.FULL_SCREEN` or
        `StageDisplayState.FULL_SCREEN_INTERACTIVE` is an asynchronous
        operation.

        @throws SecurityError Calling the `displayState` property of a
                              Stage object throws an exception for any caller that
                              is not in the same security sandbox as the Stage
                              owner(the main SWF file). To avoid this, the Stage
                              owner can grant permission to the domain of the
                              caller by calling the
                              `Security.allowDomain()` method or the
                              `Security.allowInsecureDomain()` method.
                              For more information, see the "Security" chapter in
                              the _ActionScript 3.0 Developer's Guide_.
                              Trying to set the `displayState` property
                              while the settings dialog is displayed, without a
                              user response, or if the `param` or
                              `embed` HTML tag's
                              `allowFullScreen` attribute is not set to
                              `true` throws a security error.
    **/
    get displayState() {
        return this.__displayState;
    }
    set displayState(value) {
        // __backend.setDisplayState(value);
        this.__displayState = value;
    }
    /**
        The interactive object with keyboard focus; or `null` if focus
        is not set or if the focused object belongs to a security sandbox to which
        the calling object does not have access.

        @throws Error Throws an error if focus cannot be set to the target.
    **/
    get focus() {
        return this.__focus;
    }
    set focus(value) {
        if (value != this.__focus) {
            var oldFocus = this.__focus;
            this.__focus = value;
            this.__cacheFocus = value;
            if (oldFocus != null) {
                var event = new FocusEvent(FocusEvent.FOCUS_OUT, true, false, value, false, 0);
                var stack = new Array();
                oldFocus.__getInteractive(stack);
                stack.reverse();
                this.__dispatchStack(event, stack);
            }
            if (value != null) {
                var event = new FocusEvent(FocusEvent.FOCUS_IN, true, false, oldFocus, false, 0);
                var stack = new Array();
                value.__getInteractive(stack);
                stack.reverse();
                this.__dispatchStack(event, stack);
            }
        }
    }
    /**
        Gets and sets the frame rate of the stage. The frame rate is defined as
        frames per second. By default the rate is set to the frame rate of the
        first SWF file loaded. Valid range for the frame rate is from 0.01 to 1000
        frames per second.

        **Note:** An application might not be able to follow high frame rate
        settings, either because the target platform is not fast enough or the
        player is synchronized to the vertical blank timing of the display device
        (usually 60 Hz on LCD devices). In some cases, a target platform might
        also choose to lower the maximum frame rate if it anticipates high CPU
        usage.

        For content running in Adobe AIR, setting the `frameRate`
        property of one Stage object changes the frame rate for all Stage objects
        (used by different NativeWindow objects).

        @throws SecurityError Calling the `frameRate` property of a
                              Stage object throws an exception for any caller that
                              is not in the same security sandbox as the Stage
                              owner(the main SWF file). To avoid this, the Stage
                              owner can grant permission to the domain of the
                              caller by calling the
                              `Security.allowDomain()` method or the
                              `Security.allowInsecureDomain()` method.
                              For more information, see the "Security" chapter in
                              the _ActionScript 3.0 Developer's Guide_.
    **/
    get frameRate() {
        // return __backend.getFrameRate();
        return 0;
    }
    set frameRate(value) {
        // __backend.setFrameRate(value);
    }
    /**
        Returns the height of the monitor that will be used when going to full
        screen size, if that state is entered immediately. If the user has
        multiple monitors, the monitor that's used is the monitor that most of
        the stage is on at the time.
        **Note**: If the user has the opportunity to move the browser from one
        monitor to another between retrieving the value and going to full
        screen size, the value could be incorrect. If you retrieve the value
        in an event handler that sets `Stage.displayState` to
        `StageDisplayState.FULL_SCREEN`, the value will be correct.

        This is the pixel height of the monitor and is the same as the stage
        height would be if `Stage.align` is set to `StageAlign.TOP_LEFT` and
        `Stage.scaleMode` is set to `StageScaleMode.NO_SCALE`.
    **/
    get fullScreenHeight() {
        // return __backend.getFullScreenHeight();
        return 0;
    }
    /**
        Sets the Flash runtime to scale a specific region of the stage to
        full-screen mode. If available, the Flash runtime scales in hardware,
        which uses the graphics and video card on a user's computer, and
        generally displays content more quickly than software scaling.
        When this property is set to a valid rectangle and the `displayState`
        property is set to full-screen mode, the Flash runtime scales the
        specified area. The actual Stage size in pixels within ActionScript
        does not change. The Flash runtime enforces a minimum limit for the
        size of the rectangle to accommodate the standard "Press Esc to exit
        full-screen mode" message. This limit is usually around 260 by 30
        pixels but can vary on platform and Flash runtime version.

        This property can only be set when the Flash runtime is not in
        full-screen mode. To use this property correctly, set this property
        first, then set the `displayState` property to full-screen mode, as
        shown in the code examples.

        To enable scaling, set the `fullScreenSourceRect` property to a
        rectangle object:

        ```haxe
        // valid, will enable hardware scaling
        stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
        ```

        To disable scaling, set `fullScreenSourceRect=null`.

        ```haxe
        stage.fullScreenSourceRect = null;
        ```

        The end user also can select within Flash Player Display Settings to
        turn off hardware scaling, which is enabled by default. For more
        information, see <a href="http://www.adobe.com/go/display_settings"
        scope="external">www.adobe.com/go/display_settings</a>.
    **/
    get fullScreenSourceRect() {
        return this.__fullScreenSourceRect == null ? null : this.__fullScreenSourceRect.clone();
    }
    set fullScreenSourceRect(value) {
        if (value == null) {
            if (this.__fullScreenSourceRect != null) {
                this.__fullScreenSourceRect = null;
                this.__resize();
            }
        }
        else if (!value.equals(this.__fullScreenSourceRect)) {
            this.__fullScreenSourceRect = value.clone();
            this.__resize();
        }
    }
    /**
        Returns the width of the monitor that will be used when going to full
        screen size, if that state is entered immediately. If the user has
        multiple monitors, the monitor that's used is the monitor that most of
        the stage is on at the time.
        **Note**: If the user has the opportunity to move the browser from one
        monitor to another between retrieving the value and going to full
        screen size, the value could be incorrect. If you retrieve the value
        in an event handler that sets `Stage.displayState` to
        `StageDisplayState.FULL_SCREEN`, the value will be correct.

        This is the pixel width of the monitor and is the same as the stage
        width would be if `Stage.align` is set to `StageAlign.TOP_LEFT` and
        `Stage.scaleMode` is set to `StageScaleMode.NO_SCALE`.
    **/
    get fullScreenWidth() {
        // return __backend.getFullScreenWidth();
        return 0;
    }
    set height(value) {
    }
    get mouseX() {
        return this.__mouseX;
    }
    get mouseY() {
        return this.__mouseY;
    }
    /**
        A value from the StageQuality class that specifies which rendering quality
        is used. The following are valid values:

        * `StageQuality.LOW` - Low rendering quality. Graphics are
        not anti-aliased, and bitmaps are not smoothed, but runtimes still use
        mip-mapping.
        * `StageQuality.MEDIUM` - Medium rendering quality.
        Graphics are anti-aliased using a 2 x 2 pixel grid, bitmap smoothing is
        dependent on the `Bitmap.smoothing` setting. Runtimes use
        mip-mapping. This setting is suitable for movies that do not contain
        text.
        * `StageQuality.HIGH` - High rendering quality. Graphics
        are anti-aliased using a 4 x 4 pixel grid, and bitmap smoothing is
        dependent on the `Bitmap.smoothing` setting. Runtimes use
        mip-mapping. This is the default rendering quality setting that Flash
        Player uses.
        * `StageQuality.BEST` - Very high rendering quality.
        Graphics are anti-aliased using a 4 x 4 pixel grid. If
        `Bitmap.smoothing` is `true` the runtime uses a high
        quality downscale algorithm that produces fewer artifacts(however, using
        `StageQuality.BEST` with `Bitmap.smoothing` set to
        `true` slows performance significantly and is not a recommended
        setting).


        Higher quality settings produce better rendering of scaled bitmaps.
        However, higher quality settings are computationally more expensive. In
        particular, when rendering scaled video, using higher quality settings can
        reduce the frame rate.

        In the desktop profile of Adobe AIR, `quality` can be set to
        `StageQuality.BEST` or `StageQuality.HIGH`(and the
        default value is `StageQuality.HIGH`). Attempting to set it to
        another value has no effect(and the property remains unchanged). In the
        moble profile of AIR, all four quality settings are available. The default
        value on mobile devices is `StageQuality.MEDIUM`.

        For content running in Adobe AIR, setting the `quality`
        property of one Stage object changes the rendering quality for all Stage
        objects(used by different NativeWindow objects).
        **_Note:_** The operating system draws the device fonts, which are
        therefore unaffected by the `quality` property.

        @throws SecurityError Calling the `quality` property of a Stage
                              object throws an exception for any caller that is
                              not in the same security sandbox as the Stage owner
                             (the main SWF file). To avoid this, the Stage owner
                              can grant permission to the domain of the caller by
                              calling the `Security.allowDomain()`
                              method or the
                              `Security.allowInsecureDomain()` method.
                              For more information, see the "Security" chapter in
                              the _ActionScript 3.0 Developer's Guide_.
    **/
    get quality() {
        return this.__quality;
    }
    set quality(value) {
        this.__quality = value;
        if (this.__renderer != null) {
            this.__renderer.__allowSmoothing = (this.quality != StageQuality.LOW);
        }
    }
    set rotation(value) { }
    /**
        A value from the StageScaleMode class that specifies which scale mode to
        use. The following are valid values:

        * `StageScaleMode.EXACT_FIT` - The entire application is
        visible in the specified area without trying to preserve the original
        aspect ratio. Distortion can occur, and the application may appear
        stretched or compressed.
        * `StageScaleMode.SHOW_ALL` - The entire application is
        visible in the specified area without distortion while maintaining the
        original aspect ratio of the application. Borders can appear on two sides
        of the application.
        * `StageScaleMode.NO_BORDER` - The entire application fills
        the specified area, without distortion but possibly with some cropping,
        while maintaining the original aspect ratio of the application.
        * `StageScaleMode.NO_SCALE` - The entire application is
        fixed, so that it remains unchanged even as the size of the player window
        changes. Cropping might occur if the player window is smaller than the
        content.


        @throws SecurityError Calling the `scaleMode` property of a
                              Stage object throws an exception for any caller that
                              is not in the same security sandbox as the Stage
                              owner(the main SWF file). To avoid this, the Stage
                              owner can grant permission to the domain of the
                              caller by calling the
                              `Security.allowDomain()` method or the
                              `Security.allowInsecureDomain()` method.
                              For more information, see the "Security" chapter in
                              the _ActionScript 3.0 Developer's Guide_.
    **/
    get scaleMode() {
        return this.__scaleMode;
    }
    set scaleMode(value) {
        // TODO
        this.__scaleMode = value;
    }
    set scaleX(value) { }
    set scaleY(value) { }
    /**
        A list of Stage3D objects available for displaying 3-dimensional content.

        You can use only a limited number of Stage3D objects at a time. The number of
        available Stage3D objects depends on the platform and on the available hardware.

        A Stage3D object draws in front of a StageVideo object and behind the OpenFL
        display list.
    **/
    get stage3Ds() {
        return this.__stage3Ds;
    }
    /**
        The current height, in pixels, of the Stage.

        If the value of the `Stage.scaleMode` property is set to
        `StageScaleMode.NO_SCALE` when the user resizes the window, the
        Stage content maintains its size while the `stageHeight`
        property changes to reflect the new height size of the screen area
        occupied by the SWF file.(In the other scale modes, the
        `stageHeight` property always reflects the original height of
        the SWF file.) You can add an event listener for the `resize`
        event and then use the `stageHeight` property of the Stage
        class to determine the actual pixel dimension of the resized Flash runtime
        window. The event listener allows you to control how the screen content
        adjusts when the user resizes the window.

        Air for TV devices have slightly different behavior than desktop
        devices when you set the `stageHeight` property. If the
        `Stage.scaleMode` property is set to
        `StageScaleMode.NO_SCALE` and you set the
        `stageHeight` property, the stage height does not change until
        the next frame of the SWF.

        **Note:** In an HTML page hosting the SWF file, both the
        `object` and `embed` tags' `height`
        attributes must be set to a percentage(such as `100%`), not
        pixels. If the settings are generated by JavaScript code, the
        `height` parameter of the `AC_FL_RunContent() `
        method must be set to a percentage, too. This percentage is applied to the
        `stageHeight` value.

        @throws SecurityError Calling the `stageHeight` property of a
                              Stage object throws an exception for any caller that
                              is not in the same security sandbox as the Stage
                              owner(the main SWF file). To avoid this, the Stage
                              owner can grant permission to the domain of the
                              caller by calling the
                              `Security.allowDomain()` method or the
                              `Security.allowInsecureDomain()` method.
                              For more information, see the "Security" chapter in
                              the _ActionScript 3.0 Developer's Guide_.
    **/
    get stageHeight() {
        return this.__stageHeight;
    }
    /**
        Specifies the current width, in pixels, of the Stage.

        If the value of the `Stage.scaleMode` property is set to
        `StageScaleMode.NO_SCALE` when the user resizes the window, the
        Stage content maintains its defined size while the `stageWidth`
        property changes to reflect the new width size of the screen area occupied
        by the SWF file.(In the other scale modes, the `stageWidth`
        property always reflects the original width of the SWF file.) You can add
        an event listener for the `resize` event and then use the
        `stageWidth` property of the Stage class to determine the
        actual pixel dimension of the resized Flash runtime window. The event
        listener allows you to control how the screen content adjusts when the
        user resizes the window.

        Air for TV devices have slightly different behavior than desktop
        devices when you set the `stageWidth` property. If the
        `Stage.scaleMode` property is set to
        `StageScaleMode.NO_SCALE` and you set the
        `stageWidth` property, the stage width does not change until
        the next frame of the SWF.

        **Note:** In an HTML page hosting the SWF file, both the
        `object` and `embed` tags' `width`
        attributes must be set to a percentage(such as `100%`), not
        pixels. If the settings are generated by JavaScript code, the
        `width` parameter of the `AC_FL_RunContent() `
        method must be set to a percentage, too. This percentage is applied to the
        `stageWidth` value.

        @throws SecurityError Calling the `stageWidth` property of a
                              Stage object throws an exception for any caller that
                              is not in the same security sandbox as the Stage
                              owner (the main SWF file). To avoid this, the Stage
                              owner can grant permission to the domain of the
                              caller by calling the
                              `Security.allowDomain()` method or the
                              `Security.allowInsecureDomain()` method.
                              For more information, see the "Security" chapter in
                              the _ActionScript 3.0 Developer's Guide_.
    **/
    get stageWidth() {
        return this.__stageWidth;
    }
    get tabEnabled() {
        return false;
    }
    set tabEnabled(value) {
        throw new IllegalOperationError("Error: The Stage class does not implement this property or method.");
    }
    get tabIndex() {
        return -1;
    }
    set tabIndex(value) {
        throw new IllegalOperationError("Error: The Stage class does not implement this property or method.");
    }
    set transform(value) { }
    set width(value) { }
    set x(value) { }
    set y(value) { }
}

/**
    The TileContainer type is a special kind of Tile that can hold
    other tiles within it.

    Tile and TileContainer objects can be rendered by adding them to
    a Tilemap instance.
**/
class TileContainer extends Tile {
    constructor(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, originX = 0, originY = 0) {
        super(-1, x, y, scaleX, scaleY, rotation, originX, originY);
        this.__tiles = new Array();
        this.__length = 0;
    }
    /**
        Adds a Tile instance to this TileContainer instance. The tile is
        added to the front (top) of all other tiles in this TileContainer
        instance. (To add a tile to a specific index position, use the `addTileAt()`
        method.)

        @param tile The Tile instance to add to this TileContainer instance.
        @return The Tile instance that you pass in the `tile` parameter.
    **/
    addTile(tile) {
        if (tile == null)
            return null;
        if (tile.parent == this) {
            var index = this.__tiles.indexOf(tile);
            if (index > -1)
                this.__tiles.splice(index, 1);
            this.__length--;
        }
        this.__tiles[this.numTiles] = tile;
        tile.__parent = this;
        this.__length++;
        this.__setRenderDirty();
        return tile;
    }
    /**
        Adds a Tile instance to this TileContainer instance. The tile is added
        at the index position specified. An index of 0 represents the back (bottom)
        of the rendered list for this TileContainer object.

        For example, the following example shows three tiles, labeled
        a, b, and c, at index positions 0, 2, and 1, respectively:

        ![b over c over a](/images/DisplayObjectContainer_layers.jpg)

        @param tile The Tile instance to add to this TileContainer instance.
        @param index The index position to which the tile is added. If you
                        specify a currently occupied index position, the tile object
                        that exists at that position and all higher positions are
                        moved up one position in the tile list.
        @return The Tile instance that you pass in the `tile` parameter.
    **/
    addTileAt(tile, index) {
        if (tile == null)
            return null;
        if (tile.parent == this) {
            var i = this.__tiles.indexOf(tile);
            if (i > -1)
                this.__tiles.splice(i, 1);
            this.__length--;
        }
        this.__tiles.splice(index, 0, tile);
        tile.__parent = this;
        this.__length++;
        this.__setRenderDirty();
        return tile;
    }
    /**
        Adds an Array of Tile instances to this TileContainer instance. The tiles
        are added to the front (top) of all other tiles in this TileContainer
        instance.

        @param tiles The Tile instances to add to this TileContainer instance.
        @return The Tile Array that you pass in the `tiles` parameter.
    **/
    addTiles(tiles) {
        for (let tile of tiles) {
            this.addTile(tile);
        }
        return tiles;
    }
    clone() {
        var group = new TileContainer();
        for (let tile of this.__tiles) {
            group.addTile(tile.clone());
        }
        return group;
    }
    /**
        Determines whether the specified tile is contained within the
        TileContainer instance. The search includes the entire tile list including
        this TileContainer instance. Grandchildren, great-grandchildren, and so on
        each return `true`.

        @param	tile	The tile object to test.
        @return	`true` if the `tile` object is contained within the TileContainer;
        otherwise `false`.
    **/
    contains(tile) {
        return (this.__tiles.indexOf(tile) > -1);
    }
    /**
        Override from tile. A single tile, just has his rectangle.
        A container must get a rectangle that contains all other rectangles.

        @param targetCoordinateSpace The tile that works as a coordinate system.
        @return Rectangle The bounding box. If no box found, this will return {0,0,0,0} rectangle instead of null.
    **/
    getBounds(targetCoordinateSpace) {
        var result = new Rectangle();
        var rect = null;
        for (let tile of this.__tiles) {
            // TODO: Generate less Rectangle objects? Could be done with __getBounds but need a initial rectangle and the stack of transformations
            rect = tile.getBounds(targetCoordinateSpace);
            result.__expand(rect.x, rect.y, rect.width, rect.height);
        }
        return result;
    }
    /**
        Returns the tile instance that exists at the specified index.

        @param index The index position of the tile object.
        @return The tile object at the specified index position.
    **/
    getTileAt(index) {
        if (index >= 0 && index < this.numTiles) {
            return this.__tiles[index];
        }
        return null;
    }
    /**
        Returns the index position of a contained Tile instance.

        @param child The Tile instance to identify.
        @return The index position of the tile object to identify.
    **/
    getTileIndex(tile) {
        for (let i = 0; i < this.__tiles.length; i++) {
            if (this.__tiles[i] == tile)
                return i;
        }
        return -1;
    }
    /**
        Removes the specified Tile instance from the tile list of the TileContainer
        instance. The index positions of any tile objects above the tile in the
        TileContainer are decreased by 1.

        @param	tile	The Tile instance to remove.
        @return	The Tile instance that you pass in the `tile` parameter.
    **/
    removeTile(tile) {
        if (tile != null && tile.parent == this) {
            tile.__parent = null;
            var index = this.__tiles.indexOf(tile);
            if (index > -1)
                this.__tiles.splice(index, 1);
            this.__length--;
            this.__setRenderDirty();
        }
        return tile;
    }
    /**
        Removes a Tile from the specified `index` position in the tile list of the
        TileContainer. The index positions of any tile objects above the tile in
        the TileContainer are decreased by 1.

        @param	index	The index of the Tile to remove.
        @return	The Tile instance that was removed.
    **/
    removeTileAt(index) {
        if (index >= 0 && index < this.numTiles) {
            return this.removeTile(this.__tiles[index]);
        }
        return null;
    }
    /**
        Removes all Tile instances from the tile list of the TileContainer instance.

        @param	beginIndex	The beginning position.
        @param	endIndex	The ending position.
    **/
    removeTiles(beginIndex = 0, endIndex = 0x7fffffff) {
        if (beginIndex < 0)
            beginIndex = 0;
        if (endIndex > this.__tiles.length - 1)
            endIndex = this.__tiles.length - 1;
        var removed = this.__tiles.splice(beginIndex, endIndex - beginIndex + 1);
        for (let tile of removed) {
            tile.__parent = null;
        }
        this.__length = this.__tiles.length;
        this.__setRenderDirty();
    }
    /**
        Changes the position of an existing tile in the tile container.
        This affects the layering of tile objects. For example, the following
        example shows three tile objects, labeled a, b, and c, at index
        positions 0, 1, and 2, respectively:

        ![c over b over a](/images/DisplayObjectContainerSetChildIndex1.jpg)

        When you use the `setTileIndex()` method and specify an
        index position that is already occupied, the only positions that change
        are those in between the tile object's former and new position. All
        others will stay the same. If a tile is moved to an index LOWER than its
        current index, all tiles in between will INCREASE by 1 for their index
        reference. If a tile is moved to an index HIGHER than its current index,
        all tiles in between will DECREASE by 1 for their index reference. For
        example, if the tile container in the previous example is named
        `container`, you can swap the position of the tile objects
        labeled a and b by calling the following code:

        ```haxe
        container.setTileIndex(container.getTileAt(1), 0);
        ```

        This code results in the following arrangement of objects:

        ![c over a over b](/images/DisplayObjectContainerSetChildIndex2.jpg)

        @param	tile	The Tile instance for which you want to change the index
        number.
        @param	index	The resulting index number for the `tile` object.
    **/
    setTileIndex(tile, index) {
        if (index >= 0 && index <= this.numTiles && tile.parent == this) {
            var i = this.__tiles.indexOf(tile);
            if (i != index) {
                if (i > -1)
                    this.__tiles.splice(i, 1);
                this.__tiles.splice(index, 0, tile);
            }
            this.__setRenderDirty();
        }
    }
    /**
        Sorts the z-order (front-to-back order) of all the tile objects in this
        container based on a comparison function.

        A comparison should take two arguments to compare. Given the elements
        A and B, the result of `compareFunction` can have a negative, 0, or positive value:

        * A negative return value specifies that A appears before B in the sorted sequence.
        * A return value of 0 specifies that A and B have the same sort order.
        * A positive return value specifies that A appears after B in the sorted sequence.

        The sort operation is not guaranteed to be stable, which means that the
        order of equal elements may not be retained.

        @param	compareFunction	A comparison to use when sorting.
    **/
    sortTiles(compareFunction) {
        this.__tiles.sort(compareFunction);
        this.__setRenderDirty();
    }
    /**
    Swaps the z-order (front-to-back order) of the two specified tile
    objects. All other tile objects in the tile container remain in
    the same index positions.

    @param	child1	The first tile object.
    @param	child2	The second tile object.
    **/
    swapTiles(tile1, tile2) {
        if (tile1.parent == this && tile2.parent == this) {
            var index1 = this.__tiles.indexOf(tile1);
            var index2 = this.__tiles.indexOf(tile2);
            this.__tiles[index1] = tile2;
            this.__tiles[index2] = tile1;
            this.__setRenderDirty();
        }
    }
    /**
    Swaps the z-order (front-to-back order) of the tile objects at the two
    specified index positions in the tile list. All other tile objects in
    the tile container remain in the same index positions.

    @param	index1	The index position of the first tile object.
    @param	index2	The index position of the second tile object.
    **/
    swapTilesAt(index1, index2) {
        var swap = this.__tiles[index1];
        this.__tiles[index1] = this.__tiles[index2];
        this.__tiles[index2] = swap;
        swap = null;
        this.__setRenderDirty();
    }
    // Get & Set Methods
    /**
        Returns the number of tiles of this object.
    **/
    get numTiles() {
        return this.__length;
    }
    get height() {
        var result = Rectangle.__pool.get();
        var rect = null;
        for (let tile of this.__tiles) {
            // TODO: Generate less Rectangle objects? Could be done with __getBounds but need a initial rectangle and the stack of transformations
            rect = tile.getBounds(this);
            result.__expand(rect.x, rect.y, rect.width, rect.height);
        }
        this.__getBounds(result, this.matrix);
        var h = result.height;
        Rectangle.__pool.release(result);
        return h;
    }
    set height(value) {
        var result = Rectangle.__pool.get();
        var rect = null;
        for (let tile of this.__tiles) {
            // TODO: Generate less Rectangle objects? Could be done with __getBounds but need a initial rectangle and the stack of transformations
            rect = tile.getBounds(this);
            result.__expand(rect.x, rect.y, rect.width, rect.height);
        }
        if (result.height != 0) {
            this.scaleY = value / result.height;
        }
        Rectangle.__pool.release(result);
    }
    get width() {
        var result = Rectangle.__pool.get();
        var rect = null;
        for (let tile of this.__tiles) {
            // TODO: Generate less Rectangle objects? Could be done with __getBounds but need a initial rectangle and the stack of transformations
            rect = tile.getBounds(this);
            result.__expand(rect.x, rect.y, rect.width, rect.height);
        }
        this.__getBounds(result, this.matrix);
        var w = result.width;
        Rectangle.__pool.release(result);
        return w;
    }
    set width(value) {
        var result = Rectangle.__pool.get();
        var rect = null;
        for (let tile of this.__tiles) {
            // TODO: Generate less Rectangle objects? Could be done with __getBounds but need a initial rectangle and the stack of transformations
            rect = tile.getBounds(this);
            result.__expand(rect.x, rect.y, rect.width, rect.height);
        }
        if (result.width != 0) {
            this.scaleX = value / result.width;
        }
        Rectangle.__pool.release(result);
    }
}

/**
    The Tilemap class represents a "quad batch", or series of objects that are
    rendered from the same bitmap. The Tilemap class is designed to encourage
    the use of a single Tileset reference for best performance, but it is possible
    to use unique Tileset references for each Tile or TileContainer within a
    Tilemap.

    On software renderered platforms, the Tilemap class uses a rendering method
    similar to BitmapData `copyPixels`, so it will perform fastest if tile objects
    do not use rotation or scale.

    On hardware rendered platforms, the Tilemap class uses a rendering method
    that is fast even with transforms, and allows support for additional features,
    such as custom `shader` references, and color transform. Using multiple Shader
    or Tileset references will require a new draw call each time there is a change.

    **Note:** The Tilemap class is not a subclass of the InteractiveObject
    class, so it cannot dispatch mouse events. However, you can use the
    `addEventListener()` method of the display object container that
    contains the Tilemap object.
**/
class Tilemap extends DisplayObject {
    /**
        Creates a new Tilemap object.

        @param	width	The width of the tilemap in pixels.
        @param	height	The height of the tilemap in pixels.
        @param	tileset	A Tileset being referenced.
        @param	smoothing	Whether or not the tilemap is smoothed when scaled. For example, the following examples
        show the same tilemap scaled by a factor of 3, with `smoothing` set to `false` (left) and `true` (right):

        ![A bitmap without smoothing.](/images/bitmap_smoothing_off.jpg) ![A bitmap with smoothing.](/images/bitmap_smoothing_on.jpg)
    **/
    constructor(width, height, tileset = null, smoothing = true) {
        super();
        this.__tileset = tileset;
        this.smoothing = smoothing;
        this.tileAlphaEnabled = true;
        this.tileBlendModeEnabled = true;
        this.tileColorTransformEnabled = true;
        this.__group = new TileContainer();
        this.__group.tileset = tileset;
        this.__width = width;
        this.__height = height;
        this.__type = DisplayObjectType$1.TILEMAP;
    }
    /**
        Adds a Tile instance to this Tilemap instance. The tile is
        added to the front (top) of all other tiles in this Tilemap
        instance. (To add a tile to a specific index position, use the `addTileAt()`
        method.)

        @param tile The Tile instance to add to this Tilemap instance.
        @return The Tile instance that you pass in the `tile` parameter.
    **/
    addTile(tile) {
        return this.__group.addTile(tile);
    }
    /**
        Adds a Tile instance to this Tilemap instance. The tile is added
        at the index position specified. An index of 0 represents the back (bottom)
        of the rendered list for this Tilemap object.

        For example, the following example shows three tiles, labeled
        a, b, and c, at index positions 0, 2, and 1, respectively:

        ![b over c over a](/images/DisplayObjectContainer_layers.jpg)

        @param tile The Tile instance to add to this Tilemap instance.
        @param index The index position to which the tile is added. If you
                     specify a currently occupied index position, the tile object
                     that exists at that position and all higher positions are
                     moved up one position in the tile list.
        @return The Tile instance that you pass in the `tile` parameter.
    **/
    addTileAt(tile, index) {
        return this.__group.addTileAt(tile, index);
    }
    /**
        Adds an Array of Tile instances to this Tilemap instance. The tiles
        are added to the front (top) of all other tiles in this Tilemap
        instance.

        @param tiles The Tile instances to add to this Tilemap instance.
        @return The Tile Array that you pass in the `tiles` parameter.
    **/
    addTiles(tiles) {
        return this.__group.addTiles(tiles);
    }
    /**
        Determines whether the specified tile is contained within the
        Tilemap instance. The search includes the entire tile list including
        this Tilemap instance. Grandchildren, great-grandchildren, and so on
        each return `true`.

        @param	tile	The tile object to test.
        @return	`true` if the `tile` object is contained within the Tilemap;
        otherwise `false`.
    **/
    contains(tile) {
        return this.__group.contains(tile);
    }
    /**
        Returns the tile instance that exists at the specified index.

        @param index The index position of the tile object.
        @return The tile object at the specified index position.
    **/
    getTileAt(index) {
        return this.__group.getTileAt(index);
    }
    /**
        Returns the index position of a contained Tile instance.

        @param child The Tile instance to identify.
        @return The index position of the tile object to identify.
    **/
    getTileIndex(tile) {
        return this.__group.getTileIndex(tile);
    }
    /**
        Returns a TileContainer with each of the tiles contained within this
        Tilemap.

        @return	A new TileContainer with the same Tile references as this Tilemap
    **/
    getTiles() {
        return this.__group.clone();
    }
    /**
        Removes the specified Tile instance from the tile list of the Tilemap
        instance. The index positions of any tile objects above the tile in the
        Tilemap are decreased by 1.

        @param	tile	The Tile instance to remove.
        @return	The Tile instance that you pass in the `tile` parameter.
    **/
    removeTile(tile) {
        return this.__group.removeTile(tile);
    }
    /**
        Removes a Tile from the specified `index` position in the tile list of the
        Tilemap. The index positions of any tile objects above the tile in
        the Tilemap are decreased by 1.

        @param	index	The index of the Tile to remove.
        @return	The Tile instance that was removed.
    **/
    removeTileAt(index) {
        return this.__group.removeTileAt(index);
    }
    /**
        Removes all Tile instances from the tile list of the ITileContainer instance.

        @param	beginIndex	The beginning position.
        @param	endIndex	The ending position.
    **/
    removeTiles(beginIndex = 0, endIndex = 0x7fffffff) {
        return this.__group.removeTiles(beginIndex, endIndex);
    }
    /**
        Changes the position of an existing tile in the tile container.
        This affects the layering of tile objects. For example, the following
        example shows three tile objects, labeled a, b, and c, at index
        positions 0, 1, and 2, respectively:

        ![c over b over a](/images/DisplayObjectContainerSetChildIndex1.jpg)

        When you use the `setTileIndex()` method and specify an
        index position that is already occupied, the only positions that change
        are those in between the tile object's former and new position. All
        others will stay the same. If a tile is moved to an index LOWER than its
        current index, all tiles in between will INCREASE by 1 for their index
        reference. If a tile is moved to an index HIGHER than its current index,
        all tiles in between will DECREASE by 1 for their index reference. For
        example, if the tile container in the previous example is named
        `container`, you can swap the position of the tile objects
        labeled a and b by calling the following code:

        ```haxe
        container.setTileIndex(container.getTileAt(1), 0);
        ```

        This code results in the following arrangement of objects:

        ![c over a over b](/images/DisplayObjectContainerSetChildIndex2.jpg)

        @param	tile	The Tile instance for which you want to change the index
        number.
        @param	index	The resulting index number for the `tile` object.
    **/
    setTileIndex(tile, index) {
        this.__group.setTileIndex(tile, index);
    }
    /**
        Sets all the Tile instances of this Tilemap instance.

        @param	beginIndex	The beginning position.
        @param	endIndex	The ending position.
    **/
    setTiles(group) {
        for (var tile of this.__group.__tiles) {
            this.removeTile(tile);
        }
        for (tile of group.__tiles) {
            this.addTile(tile);
        }
    }
    /**
        Sorts the z-order (front-to-back order) of all the tile objects in this
        container based on a comparison function.

        A comparison should take two arguments to compare. Given the elements
        A and B, the result of `compareFunction` can have a negative, 0, or positive value:

        * A negative return value specifies that A appears before B in the sorted sequence.
        * A return value of 0 specifies that A and B have the same sort order.
        * A positive return value specifies that A appears after B in the sorted sequence.

        The sort operation is not guaranteed to be stable, which means that the
        order of equal elements may not be retained.

        @param	compareFunction	A comparison to use when sorting.
    **/
    sortTiles(compareFunction) {
        this.__group.sortTiles(compareFunction);
    }
    /**
        Swaps the z-order (front-to-back order) of the two specified tile
        objects. All other tile objects in the tile container remain in
        the same index positions.

        @param	child1	The first tile object.
        @param	child2	The second tile object.
    **/
    swapTiles(tile1, tile2) {
        this.__group.swapTiles(tile1, tile2);
    }
    /**
        Swaps the z-order (front-to-back order) of the tile objects at the two
        specified index positions in the tile list. All other tile objects in
        the tile container remain in the same index positions.

        @param	index1	The index position of the first tile object.
        @param	index2	The index position of the second tile object.
    **/
    swapTilesAt(index1, index2) {
        this.__group.swapTilesAt(index1, index2);
    }
    __getBounds(rect, matrix) {
        var bounds = Rectangle.__pool.get();
        bounds.setTo(0, 0, this.__width, this.__height);
        bounds.__transform(bounds, matrix);
        rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
        Rectangle.__pool.release(bounds);
    }
    __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        if (!hitObject.visible || this.__isMask)
            return false;
        if (this.mask != null && !this.mask.__hitTestMask(x, y))
            return false;
        this.__getRenderTransform();
        var px = this.__renderTransform.__transformInverseX(x, y);
        var py = this.__renderTransform.__transformInverseY(x, y);
        if (px > 0 && py > 0 && px <= this.__width && py <= this.__height) {
            if (stack != null && !interactiveOnly) {
                stack.push(hitObject);
            }
            return true;
        }
        return false;
    }
    // Get & Set Methods
    get height() {
        return this.__height * Math.abs(this.__scaleY);
    }
    set height(value) {
        this.__height = Math.round(value);
        this.__localBoundsDirty = true;
    }
    /**
        Returns the number of tiles of this object.
    **/
    get numTiles() {
        return this.__group.__length;
    }
    /**
        Optionally define a default Tileset to be used for all contained tiles. Tile
        instances that do not have their `tileset` property defined will use this value.

        If a Tile object does not have a Tileset set, either using this property or using
        the Tile `tileset` property, it will not be rendered.
    **/
    get tileset() {
        return this.__tileset;
    }
    set tileset(value) {
        if (value != this.__tileset) {
            this.__tileset = value;
            this.__group.tileset = value;
            this.__group.__dirty = true;
            this.__setRenderDirty();
        }
    }
    get width() {
        return this.__width * Math.abs(this.__scaleX);
    }
    set width(value) {
        this.__width = Math.round(value);
        this.__localBoundsDirty = true;
    }
}

/**
    The Tile class is the base class for all objects that can be contained in a
    ITileContainer object. Use the Tilemap or TileContainer class to arrange the tile
    objects in the tile list. Tilemap or TileContainer objects can contain tile'
    objects, while other the Tile class is a "leaf" node that have only parents and
    siblings, no children.

    The Tile class supports basic functionality like the _x_ and _y_ position of an
    tile, as well as more advanced properties of a tile such as its transformation
    matrix.

    Tile objects render from a Tileset using either an `id` or a `rect` value, to
    reference either an existing rectangle within the Tileset, or a custom rectangle.

    Tile objects cannot be rendered on their own. In order to display a Tile object,
    it should be contained within a Tilemap instance.
**/
class Tile {
    constructor(id = 0, x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, originX = 0, originY = 0) {
        this.__id = id;
        this.__matrix = new Matrix();
        if (x != 0)
            this.x = x;
        if (y != 0)
            this.y = y;
        if (scaleX != 1)
            this.scaleX = scaleX;
        if (scaleY != 1)
            this.scaleY = scaleY;
        if (rotation != 0)
            this.rotation = rotation;
        this.__dirty = true;
        this.__length = 0;
        this.__originX = originX;
        this.__originY = originY;
        this.__alpha = 1;
        this.__blendMode = null;
        this.__visible = true;
    }
    /**
        Duplicates an instance of a Tile subclass.

        @return A new Tile object that is identical to the original.
    **/
    clone() {
        var tile = new Tile(this.__id);
        tile.__alpha = this.__alpha;
        tile.__blendMode = this.__blendMode;
        tile.__originX = this.__originX;
        tile.__originY = this.__originY;
        if (this.__rect != null)
            tile.__rect = this.__rect.clone();
        tile.matrix = this.__matrix.clone();
        tile.__shader = this.__shader;
        tile.tileset = this.__tileset;
        if (this.__colorTransform != null) {
            tile.__colorTransform = this.__colorTransform.__clone();
        }
        return tile;
    }
    /**
        Gets you the bounding box of the Tile.
        It will find a tileset to know the original rect
        Then it will apply all the transformations from his parent.

        @param targetCoordinateSpace The tile that works as a coordinate system.
        @return Rectangle The bounding box. If no box found, this will return {0,0,0,0} rectangle instead of null.
    **/
    getBounds(targetCoordinateSpace) {
        var result = new Rectangle();
        this.__findTileRect(result);
        // Copied from DisplayObject. Create the translation matrix.
        var matrix = Matrix.__pool.get();
        if (targetCoordinateSpace != null && targetCoordinateSpace != this) {
            matrix.copyFrom(this.__getWorldTransform()); // ? Is this correct?
            var targetMatrix = Matrix.__pool.get();
            targetMatrix.copyFrom(targetCoordinateSpace.__getWorldTransform());
            targetMatrix.invert();
            matrix.concat(targetMatrix);
            Matrix.__pool.release(targetMatrix);
        }
        else {
            matrix.identity();
        }
        this.__getBounds(result, matrix);
        Matrix.__pool.release(matrix);
        return result;
    }
    __getBounds(result, matrix) {
        result.__transform(result, matrix);
    }
    /**
        Evaluates the bounding box of the tile to see if it overlaps or
        intersects with the bounding box of the `obj` tile.
        Both tiles must be under the same Tilemap for this to work.

        @param obj The tile to test against.
        @return `true` if the bounding boxes of the tiles
                intersect; `false` if not.
    **/
    hitTestTile(obj) {
        if (obj != null && obj.parent != null && parent != null) {
            var currentBounds = this.getBounds(this);
            var targetBounds = obj.getBounds(this);
            return currentBounds.intersects(targetBounds);
        }
        return false;
    }
    /**
        Calling the `invalidate()` method signals to have the current tile
        redrawn the next time the tile object is eligible to be rendered.

        Invalidation is handled automatically, but in some cases it is
        necessary to trigger it manually, such as changing the parameters
        of a Shader instance attached to this tile.
    **/
    invalidate() {
        this.__setRenderDirty();
    }
    __findTileRect(result) {
        if (this.tileset == null) {
            if (parent != null) {
                var parentTileset = parent.__findTileset();
                if (parentTileset == null) {
                    result.setTo(0, 0, 0, 0);
                }
                else {
                    var rect = parentTileset.getRect(this.id);
                    if (rect == null) {
                        result.setTo(0, 0, 0, 0);
                    }
                    else {
                        result.copyFrom(rect);
                    }
                }
            }
            else {
                result.setTo(0, 0, 0, 0);
            }
        }
        else {
            result.copyFrom(this.tileset.getRect(this.id));
        }
        result.x = 0;
        result.y = 0;
    }
    __findTileset() {
        // TODO: Avoid Std.is
        if (this.tileset != null)
            return this.tileset;
        if (this.parent instanceof Tilemap)
            return this.parent.tileset;
        if (this.parent == null)
            return null;
        return this.parent.__findTileset();
    }
    /**
        Climbs all the way up to get a transformation matrix
        adds his own matrix and then returns it.
        @return Matrix The final transformation matrix from stage to this point.
    **/
    __getWorldTransform() {
        var retval = this.matrix.clone();
        if (parent != null) {
            retval.concat(this.parent.__getWorldTransform());
        }
        return retval;
    }
    __setRenderDirty() {
        if (!this.__dirty) {
            this.__dirty = true;
            if (parent != null) {
                parent.__setRenderDirty();
            }
        }
    }
    // Get & Set Methods
    /**
        Indicates the alpha transparency value of the object specified. Valid
        values are 0 (fully transparent) to 1 (fully opaque). The default value is 1.
        Tile objects with `alpha` set to 0 _are_ active, even though they are invisible.
    **/
    get alpha() {
        return this.__alpha;
    }
    set alpha(value) {
        if (value != this.__alpha) {
            this.__alpha = value;
            this.__setRenderDirty();
        }
    }
    /**
        A value from the BlendMode class that specifies which blend mode to use.

        This property is supported only when using hardware rendering or the Flash target.
    **/
    get blendMode() {
        return this.__blendMode;
    }
    set blendMode(value) {
        if (value != this.__blendMode) {
            this.__blendMode = value;
            this.__setRenderDirty();
        }
    }
    /**
        A ColorTransform object containing values that universally adjust the
        colors in the display object.

        This property is supported only when using hardware rendering.
    **/
    get colorTransform() {
        return this.__colorTransform;
    }
    set colorTransform(value) {
        if (value != this.__colorTransform) {
            this.__colorTransform = value;
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the height of the tile, in pixels. The height is
        calculated based on the bounds of the tile after local transformations.
        When you set the `height` property, the `scaleY` property
        is adjusted accordingly.
        If a tile has a height of zero, no change is applied
    **/
    get height() {
        var result = Rectangle.__pool.get();
        this.__findTileRect(result);
        this.__getBounds(result, this.matrix);
        var h = result.height;
        Rectangle.__pool.release(result);
        return h;
    }
    set height(value) {
        var result = Rectangle.__pool.get();
        this.__findTileRect(result);
        if (result.height != 0) {
            this.scaleY = value / result.height;
        }
        Rectangle.__pool.release(result);
    }
    /**
        The ID of the tile to draw from the Tileset
    **/
    get id() {
        return this.__id;
    }
    set id(value) {
        if (value != this.__id) {
            this.__id = value;
            this.__setRenderDirty();
        }
    }
    /**
        A Matrix object containing values that alter the scaling, rotation, and
        translation of the tile object.

        If the `matrix` property is set to a value (not `null`), the `x`, `y`,
        `scaleX`, `scaleY` and the `rotation` values will be overwritten.
    **/
    get matrix() {
        return this.__matrix;
    }
    set matrix(value) {
        if (value != this.__matrix) {
            this.__rotation = null;
            this.__scaleX = null;
            this.__scaleY = null;
            this.__matrix = value;
            this.__setRenderDirty();
        }
    }
    /**
        Modifies the origin x coordinate for this tile, which is the center value
        used when determining position, scale and rotation.
    **/
    get originX() {
        return this.__originX;
    }
    set originX(value) {
        if (value != this.__originX) {
            this.__originX = value;
            this.__setRenderDirty();
        }
    }
    /**
        Modifies the origin y coordinate for this tile, which is the center value
        used when determining position, scale and rotation.
    **/
    get originY() {
        return this.__originY;
    }
    set originY(value) {
        if (value != this.__originY) {
            this.__originY = value;
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the ITileContainer object that contains this display
        object. Use the `parent` property to specify a relative path to
        tile objects that are above the current tile object in the tile
        list hierarchy.
    **/
    get parent() {
        return this.__parent;
    }
    /**
        The custom rectangle to draw from the Tileset
    **/
    get rect() {
        return this.__rect;
    }
    set rect(value) {
        if (value != this.__rect) {
            this.__rect = value;
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the rotation of the Tile instance, in degrees, from its
        original orientation. Values from 0 to 180 represent clockwise rotation;
        values from 0 to -180 represent counterclockwise rotation. Values outside
        this range are added to or subtracted from 360 to obtain a value within
        the range. For example, the statement `tile.rotation = 450`
        is the same as ` tile.rotation = 90`.
    **/
    get rotation() {
        if (this.__rotation == null) {
            if (this.__matrix.b == 0 && this.__matrix.c == 0) {
                this.__rotation = 0;
                this.__rotationSine = 0;
                this.__rotationCosine = 1;
            }
            else {
                var radians = Math.atan2(this.__matrix.d, this.__matrix.c) - (Math.PI / 2);
                this.__rotation = radians * (180 / Math.PI);
                this.__rotationSine = Math.sin(radians);
                this.__rotationCosine = Math.cos(radians);
            }
        }
        return this.__rotation;
    }
    set rotation(value) {
        if (value != this.__rotation) {
            this.__rotation = value;
            var radians = value * (Math.PI / 180);
            this.__rotationSine = Math.sin(radians);
            this.__rotationCosine = Math.cos(radians);
            var __scaleX = this.scaleX;
            var __scaleY = this.scaleY;
            this.__matrix.a = this.__rotationCosine * __scaleX;
            this.__matrix.b = this.__rotationSine * __scaleX;
            this.__matrix.c = -this.__rotationSine * __scaleY;
            this.__matrix.d = this.__rotationCosine * __scaleY;
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the horizontal scale (percentage) of the object as applied from
        the origin point. The default origin point is (0,0). 1.0
        equals 100% scale.

        Scaling the local coordinate system changes the `x` and
        `y` property values, which are defined in whole pixels.
    **/
    get scaleX() {
        if (this.__scaleX == null) {
            if (this.matrix.b == 0) {
                this.__scaleX = this.__matrix.a;
            }
            else {
                this.__scaleX = Math.sqrt(this.__matrix.a * this.__matrix.a + this.__matrix.b * this.__matrix.b);
            }
        }
        return this.__scaleX;
    }
    set scaleX(value) {
        if (value != this.__scaleX) {
            this.__scaleX = value;
            if (this.__matrix.b == 0) {
                this.__matrix.a = value;
            }
            else {
                var rotation = this.rotation;
                var a = this.__rotationCosine * value;
                var b = this.__rotationSine * value;
                this.__matrix.a = a;
                this.__matrix.b = b;
            }
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the vertical scale (percentage) of an object as applied from the
        origin point of the object. The default origin point is (0,0).
        1.0 is 100% scale.

        Scaling the local coordinate system changes the `x` and
        `y` property values, which are defined in whole pixels.
    **/
    get scaleY() {
        if (this.__scaleY == null) {
            if (this.__matrix.c == 0) {
                this.__scaleY = this.matrix.d;
            }
            else {
                this.__scaleY = Math.sqrt(this.__matrix.c * this.__matrix.c + this.__matrix.d * this.__matrix.d);
            }
        }
        return this.__scaleY;
    }
    set scaleY(value) {
        if (value != this.__scaleY) {
            this.__scaleY = value;
            if (this.__matrix.c == 0) {
                this.__matrix.d = value;
            }
            else {
                var rotation = this.rotation;
                var c = -this.__rotationSine * value;
                var d = this.__rotationCosine * value;
                this.__matrix.c = c;
                this.__matrix.d = d;
            }
            this.__setRenderDirty();
        }
    }
    /**
        Uses a custom Shader instance when rendering this tile.

        This property is only supported when using hardware rendering.
    **/
    get shader() {
        return this.__shader;
    }
    set shader(value) {
        if (value != this.__shader) {
            this.__shader = value;
            this.__setRenderDirty();
        }
    }
    /**
        The Tileset that this Tile is rendered from.

        If `null`, this Tile will use the Tileset value of its parent.
    **/
    get tileset() {
        return this.__tileset;
    }
    set tileset(value) {
        if (value != this.__tileset) {
            this.__tileset = value;
            this.__setRenderDirty();
        }
    }
    /**
        Whether or not the tile object is visible.
    **/
    get visible() {
        return this.__visible;
    }
    set visible(value) {
        if (value != this.__visible) {
            this.__visible = value;
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the width of the tile, in pixels. The width is
        calculated based on the bounds of the tile after local transformations.
        When you set the `width` property, the `scaleX` property
        is adjusted accordingly.
        If a tile has a width of zero, no change is applied
    **/
    get width() {
        // TODO how does pooling work with flash target?
        var result = Rectangle.__pool.get();
        this.__findTileRect(result);
        this.__getBounds(result, this.matrix);
        var w = result.width;
        Rectangle.__pool.release(result);
        return w;
    }
    set width(value) {
        var result = Rectangle.__pool.get();
        this.__findTileRect(result);
        if (result.width != 0) {
            this.scaleX = value / result.width;
        }
        Rectangle.__pool.release(result);
    }
    /**
        Indicates the _x_ coordinate of the Tile instance relative
        to the local coordinates of the parent ITileContainer. If the
        object is inside a TileContainer that has transformations, it is
        in the local coordinate system of the enclosing TileContainer.
        Thus, for a TileContainer rotated 90° counterclockwise, the
        TileContainer's children inherit a coordinate system that is
        rotated 90° counterclockwise. The object's coordinates refer to the
        registration point position.
    **/
    get x() {
        return this.__matrix.tx;
    }
    set x(value) {
        if (value != this.__matrix.tx) {
            this.__matrix.tx = value;
            this.__setRenderDirty();
        }
    }
    /**
        Indicates the _y_ coordinate of the Tile instance relative
        to the local coordinates of the parent ITileContainer. If the
        object is inside a TileContainer that has transformations, it is
        in the local coordinate system of the enclosing TileContainer.
        Thus, for a TileContainer rotated 90° counterclockwise, the
        TileContainer's children inherit a coordinate system that is
        rotated 90° counterclockwise. The object's coordinates refer to the
        registration point position.
    **/
    get y() {
        return this.__matrix.ty;
    }
    set y(value) {
        if (value != this.__matrix.ty) {
            this.__matrix.ty = value;
            this.__setRenderDirty();
        }
    }
}

/**
    The Tileset class lets you specify logical rectangles within a larger
    BitmapData object, to be rendered using a Tilemap instance.

    The `Tileset()` constructor allows you to create a Tileset
    object that contains a reference to a BitmapData object. After you create a
    Tileset object, use the `addRect()` method to specify rectangles to be used
    for tile rendering.
**/
class Tileset {
    /**
        Creates a new Tileset instance.

        @param	bitmapData	A BitmapData object to reference
        @param	rects	An optional array of rectangles to define with the referenced BitmapData
    **/
    constructor(bitmapData, rects = null) {
        // TODO: Add support for adding uniform tile rectangles (margin, spacing, width, height)
        this.__bitmapData = bitmapData;
        this.rectData = new Vector();
        this.__data = new Array();
        if (rects != null) {
            for (let rect of rects) {
                this.addRect(rect);
            }
        }
    }
    /**
        Adds a new rectangle to this Tilemap object.

        @param	rect	A Rectangle represented a part of the referenced BitmapData object
        @returns	The assigned ID value for this new rectangle
    **/
    addRect(rect) {
        if (rect == null)
            return -1;
        this.rectData.push(rect.x);
        this.rectData.push(rect.y);
        this.rectData.push(rect.width);
        this.rectData.push(rect.height);
        var tileData = new TileData(rect);
        tileData.__update(this.__bitmapData);
        this.__data.push(tileData);
        return this.__data.length - 1;
    }
    /**
        Duplicates an instance of a Tileset subclass.

        @return A new Tileset object that is identical to the original.
    **/
    clone() {
        var tileset = new Tileset(this.__bitmapData, null);
        var rect = Rectangle.__pool.get();
        for (let tileData of this.__data) {
            rect.setTo(tileData.x, tileData.y, tileData.width, tileData.height);
            tileset.addRect(rect);
        }
        Rectangle.__pool.release(rect);
        return tileset;
    }
    /**
        Returns whether the current Tileset already has a rectangle
        defined that matches the dimensions of a specific rectangle
        object.

        @param	rect	A Rectangle object to compare against
        @returns	Whether the Tileset already contains the value of this rectangle
    **/
    hasRect(rect) {
        for (let tileData of this.__data) {
            if (rect.x == tileData.x && rect.y == tileData.y && rect.width == tileData.width && rect.height == tileData.height) {
                return true;
            }
        }
        return false;
    }
    /**
        Get the rectangle value associated with a specific tile ID.

        If the ID is invalid, then a `null` value will be returned.

        @param	id	A tile ID
        @return	A new Rectangle containing the tile source rectangle, or `null` if the
        tile ID does not exist in this Tileset
    **/
    getRect(id) {
        if (id < this.__data.length && id >= 0) {
            return new Rectangle(this.__data[id].x, this.__data[id].y, this.__data[id].width, this.__data[id].height);
        }
        return null;
    }
    /**
        Gets the tile ID associated with a specified rectangle
        value, if it is defined in the Tileset. This will return
        `null` if the rectangle value is not defined in the Tileset.

        @param	rect	A Rectangle object to compare against
        @returns	The defined tile ID, or `null` if the rectangle
        value is not present in this Tileset
    **/
    getRectID(rect) {
        var tileData;
        for (let i = 0; i < this.__data.length; i++) {
            tileData = this.__data[i];
            if (rect.x == tileData.x && rect.y == tileData.y && rect.width == tileData.width && rect.height == tileData.height) {
                return i;
            }
        }
        return null;
    }
    // Get & Set Methods
    /**
        The BitmapData object being referenced.
    **/
    get bitmapData() {
        return this.__bitmapData;
    }
    set bitmapData(value) {
        this.__bitmapData = value;
        for (let data of this.__data) {
            data.__update(this.__bitmapData);
        }
    }
    /**
        Returns the number of rectangles defined in this Tileset.
    **/
    get numRects() {
        return this.__data.length;
    }
}
class TileData {
    constructor(rect = null) {
        if (rect != null) {
            this.x = Math.round(rect.x);
            this.y = Math.round(rect.y);
            this.width = Math.round(rect.width);
            this.height = Math.round(rect.height);
        }
    }
    __update(bitmapData) {
        if (bitmapData != null) {
            var bitmapWidth = bitmapData.width;
            var bitmapHeight = bitmapData.height;
            // #if(openfl_power_of_two && !flash)
            // var newWidth = 1;
            // var newHeight = 1;
            // while (newWidth < bitmapWidth)
            // {
            // 	newWidth <<= 1;
            // }
            // while (newHeight < bitmapHeight)
            // {
            // 	newHeight <<= 1;
            // }
            // bitmapWidth = newWidth;
            // bitmapHeight = newHeight;
            // #end
            this.__uvX = this.x / bitmapWidth;
            this.__uvY = this.y / bitmapHeight;
            this.__uvWidth = (this.x + this.width) / bitmapWidth;
            this.__uvHeight = (this.y + this.height) / bitmapHeight;
        }
    }
}

class SecurityError extends Error$1 {
    constructor(message = "") {
        super(message, 0);
        this.name = "SecurityError";
    }
}

/**
    The Accelerometer class dispatches AccelerometerEvent objects when
    acceleration updates are obtained from the Accelerometer sensor installed
    on the device.
**/
let AccelerometerEvent = /** @class */ (() => {
    class AccelerometerEvent extends Event {
        /**
            Creates an AccelerometerEvent object that contains information about
            acceleration along three dimensional axis. Event objects are passed as
            parameters to event listeners.
    
            @param type          The type of the event. Event listeners can access
                                 this information through the inherited
                                 `type` property. There is only one type of
                                 update event: `AccelerometerEvent.UPDATE`.
            @param bubbles       Determines whether the Event object bubbles. Event
                                 listeners can access this information through the
                                 inherited `bubbles` property.
            @param cancelable    Determines whether the Event object can be canceled.
                                 Event listeners can access this information through
                                 the inherited `cancelable` property.
            @param timestamp     The timestamp of the Accelerometer update.
            @param accelerationX The acceleration value in Gs(9.8m/sec/sec) along the
                                 x-axis.
            @param accelerationY The acceleration value in Gs(9.8m/sec/sec) along the
                                 y-axis.
            @param accelerationZ The acceleration value in Gs(9.8m/sec/sec) along the
                                 z-axis.
        **/
        constructor(type, bubbles = false, cancelable = false, timestamp = 0, accelerationX = 0, accelerationY = 0, accelerationZ = 0) {
            super(type, bubbles, cancelable);
            this.timestamp = timestamp;
            this.accelerationX = accelerationX;
            this.accelerationY = accelerationY;
            this.accelerationZ = accelerationZ;
        }
        clone() {
            var event = new AccelerometerEvent(this.__type, this.__bubbles, this.__cancelable, this.timestamp, this.accelerationX, this.accelerationY, this.accelerationZ);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("AccelerometerEvent", "type", "bubbles", "cancelable", "timestamp", "accelerationX", "accelerationY", "accelerationZ");
        }
        __init() {
            super.__init();
            this.timestamp = 0;
            this.accelerationX = 0;
            this.accelerationY = 0;
            this.accelerationZ = 0;
        }
    }
    /**
        Defines the value of the `type` property of a `AccelerometerEvent`
        event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `timestamp` | The timestamp of the Accelerometer update. |
        | `accelerationX` | The acceleration value in Gs (9.8m/sec/sec) along the x-axis. |
        | `accelerationY` | The acceleration value in Gs (9.8m/sec/sec) along the y-axis. |
        | `accelerationZ` | The acceleration value in Gs (9.8m/sec/sec) along the z-axis. |
    **/
    AccelerometerEvent.UPDATE = "update";
    AccelerometerEvent.__pool = new ObjectPool(() => new AccelerometerEvent(null), (event) => event.__init());
    return AccelerometerEvent;
})();

/**
    A Camera or Microphone object dispatches an ActivityEvent object whenever
    a camera or microphone reports that it has become active or inactive.
    There is only one type of activity event: `ActivityEvent.ACTIVITY`.

**/
let ActivityEvent = /** @class */ (() => {
    class ActivityEvent extends Event {
        /**
            Creates an event object that contains information about activity
            events. Event objects are passed as parameters to Event listeners.
    
            @param type       The type of the event. Event listeners can access
                              this information through the inherited `type`
                              property. There is only one type of activity event:
                              `ActivityEvent.ACTIVITY`.
            @param bubbles    Determines whether the Event object participates in
                              the bubbling phase of the event flow. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through
                              the inherited `cancelable` property.
            @param activating Indicates whether the device is activating (`true`)
                              or deactivating (`false`). Event listeners can
                              access this information through the `activating`
                              property.
        **/
        constructor(type, bubbles = false, cancelable = false, activating = false) {
            super(type, bubbles, cancelable);
            this.activating = activating;
        }
        clone() {
            var event = new ActivityEvent(this.__type, this.__bubbles, this.__cancelable, this.activating);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("ActivityEvent", "type", "bubbles", "cancelable", "activating");
        }
        __init() {
            super.__init();
            this.activating = false;
        }
    }
    /**
        The `ActivityEvent.ACTIVITY` constant defines the value of the `type`
        property of an `activity` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `activating` | `true` if the device is activating or `false` if it is deactivating. |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object beginning or ending a session, such as a Camera or Microphone object. |
    **/
    ActivityEvent.ACTIVITY = "activity";
    ActivityEvent.__pool = new ObjectPool(() => new ActivityEvent(null), (event) => event.__init());
    return ActivityEvent;
})();

/**
    An object dispatches an AsyncErrorEvent when an exception is thrown from
    native asynchronous code, which could be from, for example,
    LocalConnection, NetConnection, SharedObject, or NetStream. There is only
    one type of asynchronous error event: `AsyncErrorEvent.ASYNC_ERROR`.

**/
let AsyncErrorEvent = /** @class */ (() => {
    class AsyncErrorEvent extends ErrorEvent {
        /**
            Creates an AsyncErrorEvent object that contains information about
            asyncError events. AsyncErrorEvent objects are passed as parameters to
            event listeners.
    
            @param type       The type of the event. Event listeners can access
                              this information through the inherited `type`
                              property. There is only one type of error event:
                              `ErrorEvent.ERROR`.
            @param bubbles    Determines whether the Event object bubbles. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through
                              the inherited `cancelable` property.
            @param text       Text to be displayed as an error message. Event
                              listeners can access this information through the
                              `text` property.
            @param error      The exception that occurred. If error is non-null,
                              the event's `errorId` property is set from the
                              error's `errorId` property.
        **/
        constructor(type, bubbles = false, cancelable = false, text = "", error = null) {
            super(type, bubbles, cancelable);
            this.text = text;
            this.error = error;
        }
        clone() {
            var event = new AsyncErrorEvent(this.__type, this.__bubbles, this.__cancelable, this.text, this.error);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("AsyncErrorEvent", "type", "bubbles", "cancelable", "text", "error");
        }
        __init() {
            super.__init();
            this.text = "";
            this.error = null;
        }
    }
    /**
        The `AsyncErrorEvent.ASYNC_ERROR` constant defines the value of the
        `type` property of an `asyncError` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The object dispatching the event. |
        | `error` | The error that triggered the event. |
    **/
    AsyncErrorEvent.ASYNC_ERROR = "asyncError";
    AsyncErrorEvent.__pool = new ObjectPool(() => new AsyncErrorEvent(null), (event) => event.__init());
    return AsyncErrorEvent;
})();

/**
    An object dispatches a DataEvent object when raw data has completed
    loading. There are two types of data event:
    * `DataEvent.DATA`: dispatched for data sent or received.
    * `DataEvent.UPLOAD_COMPLETE_DATA`: dispatched when data is sent and the
    server has responded.

**/
let DataEvent = /** @class */ (() => {
    class DataEvent extends TextEvent {
        /**
            Creates an event object that contains information about data events.
            Event objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access
                              this information through the inherited `type`
                              property. There is only one type of data event:
                              `DataEvent.DATA`.
            @param bubbles    Determines whether the Event object participates in
                              the bubbling phase of the event flow. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through
                              the inherited `cancelable` property.
            @param data       The raw data loaded into Flash Player or Adobe AIR.
                              Event listeners can access this information through
                              the `data` property.
        **/
        constructor(type, bubbles = false, cancelable = false, data = "") {
            super(type, bubbles, cancelable);
            this.data = data;
        }
        clone() {
            var event = new DataEvent(this.__type, this.__bubbles, this.__cancelable, this.data);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("DataEvent", "type", "bubbles", "cancelable", "data");
        }
        __init() {
            super.__init();
            this.data = "";
        }
    }
    /**
        Defines the value of the `type` property of a `data` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `data` | The raw data loaded into Flash Player or Adobe AIR. |
        | `target` | The XMLSocket object receiving data. |
    **/
    DataEvent.DATA = "data";
    /**
        Defines the value of the `type` property of an `uploadCompleteData`
        event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `data` | The raw data returned from the server after a successful file upload. |
        | `target` | The FileReference object receiving data after a successful upload. |
    **/
    DataEvent.UPLOAD_COMPLETE_DATA = "uploadCompleteData";
    DataEvent.__pool = new ObjectPool(() => new DataEvent(null), (event) => event.__init());
    return DataEvent;
})();

/**
    The Stage object dispatches a FullScreenEvent object whenever the Stage
    enters or leaves full-screen display mode. There is only one type of
    `fullScreen` event: `FullScreenEvent.FULL_SCREEN`.

**/
let FullScreenEvent = /** @class */ (() => {
    class FullScreenEvent extends ActivityEvent {
        /**
            Creates an event object that contains information about `fullScreen`
            events. Event objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access
                              this information through the inherited `type`
                              property. There is only one type of `fullScreen`
                              event: `FullScreenEvent.FULL_SCREEN`.
            @param bubbles    Determines whether the Event object participates in
                              the bubbling phase of the event flow. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through
                              the inherited `cancelable` property.
            @param fullScreen Indicates whether the device is activating (`true`)
                              or deactivating (`false`). Event listeners can
                              access this information through the `activating`
                              property.
        **/
        constructor(type, bubbles = false, cancelable = false, fullScreen = false, interactive = false) {
            // TODO: What is the "activating" value supposed to be?
            super(type, bubbles, cancelable);
            this.fullScreen = fullScreen;
            this.interactive = interactive;
        }
        clone() {
            var event = new FullScreenEvent(this.__type, this.__bubbles, this.__cancelable, this.fullScreen, this.interactive);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("FullscreenEvent", "type", "bubbles", "cancelable", "fullscreen", "interactive");
        }
        __init() {
            super.__init();
            this.fullScreen = false;
            this.interactive = false;
        }
    }
    /**
        The `FullScreenEvent.FULL_SCREEN` constant defines the value of the
        `type` property of a `fullScreen` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `fullScreen` | `true` if the display state is full screen or `false` if it is normal. |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Stage object. |
    **/
    FullScreenEvent.FULL_SCREEN = "fullScreen";
    /**
        The `FULL_SCREEN_INTERACTIVE_ACCEPTED:String` constant defines the value of the
        type property of a `fullScreenInteractiveAccepted` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `fullScreen` | `true` if the display state is full screen or `false` if it is normal. |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Stage object. |
    **/
    FullScreenEvent.FULL_SCREEN_INTERACTIVE_ACCEPTED = "fullScreenInteractiveAccepted";
    FullScreenEvent.__pool = new ObjectPool(() => new FullScreenEvent(null), (event) => event.__init());
    return FullScreenEvent;
})();

/**
    The GameInputEvent class represents an event that is dispatched when a game input device has either been added or removed from the application platform. A game input device also dispatches events when it is turned on or off.
**/
let GameInputEvent = /** @class */ (() => {
    class GameInputEvent extends Event {
        constructor(type, bubbles = true, cancelable = false, device = null) {
            super(type, bubbles, cancelable);
            this.__device = device;
        }
        clone() {
            var event = new GameInputEvent(this.__type, this.__bubbles, this.__cancelable, this.__device);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("GameInputEvent", "type", "bubbles", "cancelable", "device");
        }
        __init() {
            super.__init();
            this.__device = null;
        }
        // Get & Set Methods
        /**
            Returns a reference to the device that was added or removed. When a device is added, use this property to get a reference to the new device, instead of enumerating all of the devices to find the new one.
        **/
        get device() {
            return this.__device;
        }
    }
    /**
        Indicates that a compatible device has been connected or turned on.
    **/
    GameInputEvent.DEVICE_ADDED = "deviceAdded";
    /**
        Indicates that one of the enumerated devices has been disconnected or turned off.
    **/
    GameInputEvent.DEVICE_REMOVED = "deviceRemoved";
    /**
        Dispatched when a game input device is connected but is not usable.
    **/
    GameInputEvent.DEVICE_UNUSABLE = "deviceUnusable";
    GameInputEvent.__pool = new ObjectPool(() => new GameInputEvent(null), (event) => event.__init());
    return GameInputEvent;
})();

/**
    The application dispatches HTTPStatusEvent objects when a network request
    returns an HTTP status code.

    HTTPStatusEvent objects are always sent before error or completion
    events. An HTTPStatusEvent object does not necessarily indicate an error
    condition; it simply reflects the HTTP status code(if any) that is
    provided by the networking stack. Some Flash Player environments may be
    unable to detect HTTP status codes; a status code of 0 is always reported
    in these cases.

    In Flash Player, there is only one type of HTTPStatus event:
    `httpStatus`. In the AIR runtime, a FileReference, URLLoader, or
    URLStream can register to listen for an `httpResponseStatus`,
    which includes `responseURL` and `responseHeaders`
    properties. These properties are undefined in a `httpStatus`
    event.
**/
let HTTPStatusEvent = /** @class */ (() => {
    class HTTPStatusEvent extends Event {
        /**
            Creates an Event object that contains specific information about HTTP
            status events. Event objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access this
                              information through the inherited `type`
                              property. There is only one type of HTTPStatus event:
                              `HTTPStatusEvent.HTTP_STATUS`.
            @param bubbles    Determines whether the Event object participates in the
                              bubbling stage of the event flow. Event listeners can
                              access this information through the inherited
                              `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through the
                              inherited `cancelable` property.
            @param status     Numeric status. Event listeners can access this
                              information through the `status` property.
        **/
        constructor(type, bubbles = false, cancelable = false, status = 0, redirected = false) {
            super(type, bubbles, cancelable);
            this.__status = status;
            this.redirected = redirected;
        }
        clone() {
            var event = new HTTPStatusEvent(this.__type, this.__bubbles, this.__cancelable, this.__status, this.redirected);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("HTTPStatusEvent", "type", "bubbles", "cancelable", "status", "redirected");
        }
        __init() {
            super.__init();
            this.__status = 0;
            this.redirected = false;
        }
        // Get & Set Methods
        /**
            The HTTP status code returned by the server. For example, a value of 404
            indicates that the server has not found a match for the requested URI.
            HTTP status codes can be found in sections 10.4 and 10.5 of the HTTP
            specification at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
    
    
            If Flash Player or AIR cannot get a status code from the server, or if
            it cannot communicate with the server, the default value of 0 is passed to
            your code. A value of 0 can be generated in any player(for example, if a
            malformed URL is requested), and a value of 0 is always generated by the
            Flash Player plug-in when it is run in the following browsers, which do
            not pass HTTP status codes to the player: Netscape, Mozilla, Safari,
            Opera, and Internet Explorer for the Macintosh.
        **/
        get status() {
            return this.__status;
        }
    }
    /**
        Unlike the `httpStatus` event, the `httpResponseStatus` event is
        delivered before any response data. Also, the `httpResponseStatus`
        event includes values for the `responseHeaders` and `responseURL`
        properties (which are undefined for an `httpStatus` event. Note that
        the `httpResponseStatus` event (if any) will be sent before (and in
        addition to) any `complete` or `error` event.
        The `HTTPStatusEvent.HTTP_RESPONSE_STATUS` constant defines the value
        of the `type` property of a `httpResponseStatus` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `responseURL` | The URL from which the response was returned. |
        | `responseHeaders` | The response headers that the response returned, as an array of URLRequestHeader objects. |
        | `status` | The HTTP status code returned by the server. |
        | `target` | The network object receiving an HTTP status code. |
    **/
    HTTPStatusEvent.HTTP_RESPONSE_STATUS = "httpResponseStatus";
    /**
        The `HTTPStatusEvent.HTTP_STATUS` constant defines the value of the
        `type` property of a `httpStatus` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `status` | The HTTP status code returned by the server. |
        | `target` | The network object receiving an HTTP status code.  |
    **/
    HTTPStatusEvent.HTTP_STATUS = "httpStatus";
    HTTPStatusEvent.__pool = new ObjectPool(() => new HTTPStatusEvent(null), (event) => event.__init());
    return HTTPStatusEvent;
})();

/**
    A NetConnection, NetStream, or SharedObject object dispatches
    NetStatusEvent objects when a it reports its status. There is only one
    type of status event: `NetStatusEvent.NET_STATUS`.

**/
let NetStatusEvent = /** @class */ (() => {
    class NetStatusEvent extends Event {
        /**
            Creates an Event object that contains information about `netStatus`
            events. Event objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access
                              this information through the inherited `type`
                              property. There is only one type of status event:
                              `NetStatusEvent.NET_STATUS`.
            @param bubbles    Determines whether the Event object participates in
                              the bubbling stage of the event flow. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through
                              the inherited `cancelable` property.
            @param info       An object containing properties that describe the
                              object's status. Event listeners can access this
                              object through the `info` property.
        **/
        constructor(type, bubbles = false, cancelable = false, info = null) {
            super(type, bubbles, cancelable);
            this.info = info;
        }
        clone() {
            var event = new NetStatusEvent(this.__type, this.__bubbles, this.__cancelable, this.info);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("NetStatusEvent", "type", "bubbles", "cancelable", "info");
        }
        __init() {
            super.__init();
            this.info = null;
        }
    }
    /**
        Defines the value of the `type` property of a `netStatus` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `info` | An object with properties that describe the object's status or error condition. |
        | `target` | The NetConnection or NetStream object reporting its status. |
    **/
    NetStatusEvent.NET_STATUS = "netStatus";
    NetStatusEvent.__pool = new ObjectPool(() => new NetStatusEvent(null), (event) => event.__init());
    return NetStatusEvent;
})();

/**
    Dispatched when a Sound object requests new audio data or when a
    Microphone object has new audio data to provide.
    This event has two uses:

    * To provide dynamically generated audio data for a Sound object
    * To get audio data for a Microphone object

    **Dynamically generating audio using the Sound object** Use the
    `sampleData` event to play dynamically generated audio. In this
    environment, the Sound object doesn't actually contain sound data.
    Instead, it acts as a socket for sound data that is being streamed to it
    through the use of the you assign as the handler for the
    `sampleData` event.

    In your function, you use the `ByteArray.writeFloat()` method to write to
    the event's `data`) property, which contains the sampled data you want to
    play.

    If a Sound object has not loaded an MP3 file, when you call its `play()`
    method the object starts dispatching `sampleData` events, requesting sound
    samples. The Sound object continues to send events as the sound plays back
    until you stop providing data, or until the `stop()` method of the
    SoundChannel object is called.

    Thes latency of the event varies from platform to platform, and it could
    change in future versions of Flash Player or AIR. Don't depend on a
    specific latency. Instead calculate it using
    `((SampleDataEvent.position/44.1) - SoundChannelObject.position)`.

    Provide between 2048 and 8192 samples to the `data` property of the
    SampleDataEvent object. For best performance, provide as many samples as
    possible. The fewer samples you provide, the more likely it is that clicks
    and pops will occur during playback. This behavior can differ on various
    platforms and can occur in various situations - for example, when resizing
    the browser. You might write code that works on one platform when you
    provide only 2048 samples, but that same code might not work as well when
    run on a different platform. If you require the lowest latency possible,
    consider making the amount of data user-selectable.

    If you provide fewer than 2048 samples, tha Sound object plays the
    remaining samples and then stops the sound as if the end of a sound file
    was reached, generating a `complete` event.

    You can use the `extract()` method of a Sound object to extract its sound
    data, which you can then write to the dynamic stream for playback.

    When you use the `sampleData` event with a Sound object, the only Sound
    methods that are enabled are `extract()` and `play()`. Calling any other
    methods or properties results in an "invalid call" exception. All methods
    and properties of the SoundChannel object are still enabled.

    **Capturing Microphone audio** Use the `sampleData` event to capture audio
    data from a microphone. When you add an event listener for the
    `sampleData` event, the Microphone dispatches the event as audio samples
    become available.

    In the event handler function, use the `ByteArray.readFloat()` method to
    read the event's `data`) property, which contains the sampled data. The
    event will contain multiple samples, so you should use a `while` loop to
    read the available data:

    ```haxe
    var soundBytes = new ByteArray();
    while(event.data.bytesAvailable) {
        var sample = event.data.readFloat();
        soundBytes.writeFloat(sample);
    }
    ```
**/
let SampleDataEvent = /** @class */ (() => {
    class SampleDataEvent extends Event {
        /**
            Creates an event object that contains information about audio data
            events. Event objects are passed as parameters to event listeners.
    
            @param type        The type of the event. This value
                               is:`Event.SAMPLE_DATA`.
            @param bubbles     Determines whether the Event object participates in
                               the bubbling stage of the event flow.
            @param cancelable  Determines whether the Event object can be
                               canceled.
            @param theposition The position of the data in the audio stream.
            @param thedata     A byte array of data.
        **/
        constructor(type, bubbles = false, cancelable = false) {
            super(type, bubbles, cancelable);
            this.data = new ByteArray();
            this.data.endian = Endian$1.LITTLE_ENDIAN;
            this.position = 0.0;
        }
        clone() {
            var event = new SampleDataEvent(this.__type, this.__bubbles, this.__cancelable);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("SampleDataEvent", "type", "bubbles", "cancelable");
        }
        __init() {
            super.__init();
            this.data = new ByteArray();
            this.data.endian = Endian$1.LITTLE_ENDIAN;
            this.position = 0.0;
        }
    }
    /**
        Defines the value of the `type` property of a `SampleDataEvent` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `position` | The point from which audio data is provided. |
    **/
    SampleDataEvent.SAMPLE_DATA = "sampleData";
    SampleDataEvent.__pool = new ObjectPool(() => new SampleDataEvent(null), (event) => event.__init());
    return SampleDataEvent;
})();

/**
    An object dispatches a SecurityErrorEvent object to report the occurrence
    of a security error. Security errors reported through this class are
    generally from asynchronous operations, such as loading data, in which
    security violations may not manifest immediately. Your event listener can
    access the object's `text` property to determine what operation
    was attempted and any URLs that were involved. If there are no event
    listeners, the debugger version of Flash Player or the AIR Debug Launcher
    (ADL) application automatically displays an error message that contains the
    contents of the `text` property. There is one type of security
    error event: `SecurityErrorEvent.SECURITY_ERROR`.

    Security error events are the final events dispatched for any target
    object. This means that any other events, including generic error events,
    are not dispatched for a target object that experiences a security
    error.
**/
let SecurityErrorEvent = /** @class */ (() => {
    class SecurityErrorEvent extends ErrorEvent {
        /**
            Creates an Event object that contains information about security error
            events. Event objects are passed as parameters to event listeners.
    
            @param type       The type of the event. Event listeners can access this
                              information through the inherited `type`
                              property. There is only one type of error event:
                              `SecurityErrorEvent.SECURITY_ERROR`.
            @param bubbles    Determines whether the Event object participates in the
                              bubbling stage of the event flow. Event listeners can
                              access this information through the inherited
                              `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through the
                              inherited `cancelable` property.
            @param text       Text to be displayed as an error message. Event
                              listeners can access this information through the
                              `text` property.
            @param id         A reference number to associate with the specific error.
        **/
        constructor(type, bubbles = false, cancelable = false, text = "", id = 0) {
            super(type, bubbles, cancelable, text, id);
        }
        clone() {
            var event = new SecurityErrorEvent(this.__type, this.__bubbles, this.__cancelable, this.text, this.__errorID);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("SecurityErrorEvent", "type", "bubbles", "cancelable", "text", "errorID");
        }
    }
    /**
        The `SecurityErrorEvent.SECURITY_ERROR` constant defines the value of
        the `type` property of a `securityError` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The network object reporting the security error. |
        | `text` | Text to be displayed as an error message. |
    **/
    SecurityErrorEvent.SECURITY_ERROR = "securityError";
    SecurityErrorEvent.__pool = new ObjectPool(() => new SecurityErrorEvent(null), (event) => event.__init());
    return SecurityErrorEvent;
})();

/**
    A Timer object dispatches a TimerEvent objects whenever the Timer object
    reaches the interval specified by the `Timer.delay` property.
**/
let TimerEvent = /** @class */ (() => {
    class TimerEvent extends Event {
        /**
            Creates an Event object with specific information relevant to
            `timer` events. Event objects are passed as parameters to event
            listeners.
    
            @param type       The type of the event. Event listeners can access this
                              information through the inherited `type`
                              property.
            @param bubbles    Determines whether the Event object bubbles. Event
                              listeners can access this information through the
                              inherited `bubbles` property.
            @param cancelable Determines whether the Event object can be canceled.
                              Event listeners can access this information through the
                              inherited `cancelable` property.
        **/
        constructor(type, bubbles = false, cancelable = false) {
            super(type, bubbles, cancelable);
        }
        clone() {
            var event = new TimerEvent(this.__type, this.__bubbles, this.__cancelable);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("TimerEvent", "type", "bubbles", "cancelable");
        }
        /**
            Instructs Flash Player or the AIR runtime to render after processing of
            this event completes, if the display list has been modified.
    
        **/
        updateAfterEvent() { }
    }
    /**
        Defines the value of the `type` property of a `timer` event object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Timer object that has reached its interval. |
    **/
    TimerEvent.TIMER = "timer";
    /**
        Defines the value of the `type` property of a `timerComplete` event
        object.
        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `currentTarget` | The object that is actively processing the Event object with an event listener. |
        | `target` | The Timer object that has completed its requests. |
    **/
    TimerEvent.TIMER_COMPLETE = "timerComplete";
    TimerEvent.__pool = new ObjectPool(() => new TimerEvent(null), (event) => event.__init());
    return TimerEvent;
})();

/**
    Almost exactly StageVideoEvent.
**/
let VideoTextureEvent = /** @class */ (() => {
    class VideoTextureEvent extends Event {
        constructor(type, bubbles = false, cancelable = false, status = null, colorSpace = null) {
            super(type, bubbles, cancelable);
            this.__status = status;
            this.__colorSpace = colorSpace;
        }
        clone() {
            var event = new VideoTextureEvent(this.__type, this.__bubbles, this.__cancelable, this.__status, this.__colorSpace);
            event.__target = this.__target;
            event.__currentTarget = this.__currentTarget;
            event.__eventPhase = this.__eventPhase;
            return event;
        }
        toString() {
            return this.formatToString("VideoTextureEvent", "type", "bubbles", "cancelable", "status", "colorSpace");
        }
        __init() {
            super.__init();
            this.__status = null;
            this.__colorSpace = null;
        }
        // Get & Set Methods
        /**
            The color space used by the video being displayed in the VideoTexture object.
        **/
        get colorSpace() {
            return this.__colorSpace;
        }
        /**
            The status of the VideoTexture object.
        **/
        get status() {
            return this.__status;
        }
    }
    /**
        The `VideoTextureEvent.RENDER_STATE` constant defines the value of the `type`
        property of a `renderState` event object.

        This event has the following properties:

        | Property | Value |
        | --- | --- |
        | `bubbles` | `false` |
        | `cancelable` | `false`; there is no default behavior to cancel. |
        | `colorSpace` | The available color spaces for displaying the video. |
        | `currentTarget` | The object that is actively processing the StageVideoEvent object with an event listener. |
        | `status` | Indicates whether the video is being rendered (decoded and displayed) by hardware or software, or not at all. |
        | `target` | The VideoTexture object that changed state. |
    **/
    VideoTextureEvent.RENDER_STATE = "renderState";
    VideoTextureEvent.__pool = new ObjectPool(() => new VideoTextureEvent(null), (event) => event.__init());
    return VideoTextureEvent;
})();

/**
    The ExternalInterface class is an application programming interface that
    enables straightforward communication between ActionScript and the SWF
    container– for example, an HTML page with JavaScript or a desktop
    application that uses Flash Player to display a SWF file.

    Using the ExternalInterface class, you can call an ActionScript function
    in the Flash runtime, using JavaScript in the HTML page. The ActionScript
    function can return a value, and JavaScript receives it immediately as the
    return value of the call.

    This functionality replaces the `fscommand()` method.

    Use the ExternalInterface class in the following combinations of browser
    and operating system:

    The ExternalInterface class requires the user's web browser to support
    either ActiveX<sup>®</sup> or the NPRuntime API that is exposed by some
    browsers for plug-in scripting. Even if a browser and operating system
    combination are not listed above, they should support the ExternalInterface
    class if they support the NPRuntime API. See
    [http://www.mozilla.org/projects/plugins/npruntime.html](http://www.mozilla.org/projects/plugins/npruntime.html)..

    **Note:** When embedding SWF files within an HTML page, make sure
    that the `id` attribute is set and the `id` and
    `name` attributes of the `object` and
    `embed` tags do not include the following characters:
    `. - + * / \`

    **Note for Flash Player applications:** Flash Player version
    9.0.115.0 and later allows the `.`(period) character within the
    `id` and `name` attributes.

    **Note for Flash Player applications:** In Flash Player 10 and later
    running in a browser, using this class programmatically to open a pop-up
    window may not be successful. Various browsers(and browser configurations)
    may block pop-up windows at any time; it is not possible to guarantee any
    pop-up window will appear. However, for the best chance of success, use
    this class to open a pop-up window only in code that executes as a direct
    result of a user action(for example, in an event handler for a mouse click
    or key-press event.)

    From ActionScript, you can do the following on the HTML page:

    * Call any JavaScript function.
    * Pass any number of arguments, with any names.
    * Pass various data types(Boolean, Number, String, and so on).
    * Receive a return value from the JavaScript function.



    From JavaScript on the HTML page, you can:

    * Call an ActionScript function.
    * Pass arguments using standard call notation.
    * Return a value to the JavaScript function.



    **Note for Flash Player applications:** Flash Player does not
    currently support SWF files embedded within HTML forms.

    **Note for AIR applications:** In Adobe AIR, the ExternalInterface
    class can be used to communicate between JavaScript in an HTML page loaded
    in the HTMLLoader control and ActionScript in SWF content embedded in that
    HTML page.
**/
let ExternalInterface = /** @class */ (() => {
    class ExternalInterface {
        /**
            Registers an ActionScript method as callable from the container. After a
            successful invocation of `addCallBack()`, the registered
            function in the player can be called by JavaScript or ActiveX code in the
            container.
        
            **Note:** For _local_ content running in a browser, calls to
            the `ExternalInterface.addCallback()` method work only if the
            SWF file and the containing web page are in the local-trusted security
            sandbox. For more information, see the Flash Player Developer Center
            Topic: [Security](http://www.adobe.com/go/devnet_security_en).
        
            @param functionName The name by which the container can invoke the
                                function.
            @param closure      The closure to invoke. This could be a
                                free-standing function, or it could be a method
                                closure referencing a method of an object instance. By
                                passing a method closure, you can direct the callback
                                at a method of a particular object instance.
        
                                **Note:** Repeating `addCallback()`
                                on an existing callback with a
                                `null` closure value removes the
                                callback.
            @throws Error         The container does not support incoming calls.
                                  Incoming calls are supported only in Internet
                                  Explorer for Windows and browsers that use the
                                  NPRuntime API such as Mozilla 1.7.5 and later or
                                  Firefox 1.0 and later.
            @throws SecurityError A callback with the specified name has already been
                                  added by ActionScript in a sandbox to which you do
                                  not have access; you cannot overwrite that callback.
                                  To work around this problem, rewrite the
                                  ActionScript that originally called the
                                  `addCallback()` method so that it also
                                  calls the `Security.allowDomain()`
                                  method.
            @throws SecurityError The containing environment belongs to a security
                                  sandbox to which the calling code does not have
                                  access. To fix this problem, follow these steps:
        
                                   1. In the `object` tag for the SWF
                                  file in the containing HTML page, set the following
                                  parameter:
        
                                  `<param name="allowScriptAccess"
                                  value="always" />`
        
                                   2. In the SWF file, add the following
                                  ActionScript:
        
        
                                  `openfl.system.Security.allowDomain(_sourceDomain_)`
        **/
        static addCallback(functionName, closure) {
            // ExternalInterfaceBackend.addCallback(functionName, closure);
        }
        /**
            Calls a exposed by the SWF container, passing zero or more
            arguments. If the is not available, the call returns
            `null`; otherwise it returns the value provided by the
            function. Recursion is _not_ permitted on Opera or Netscape browsers;
            on these browsers a recursive call produces a `null` response.
            (Recursion is supported on Internet Explorer and Firefox browsers.)
        
            If the container is an HTML page, this method invokes a JavaScript
            function in a `script` element.
        
            If the container is another ActiveX container, this method dispatches
            the FlashCall ActiveX event with the specified name, and the container
            processes the event.
        
            If the container is hosting the Netscape plug-in, you can either write
            custom support for the new NPRuntime interface or embed an HTML control
            and embed the player within the HTML control. If you embed an HTML
            control, you can communicate with the player through a JavaScript
            interface to the native container application.
        
            **Note:** For _local_ content running in a browser, calls to
            the `ExternalInterface.call()` method are permitted only if the
            SWF file and the containing web page(if there is one) are in the
            local-trusted security sandbox. Also, you can prevent a SWF file from
            using this method by setting the `allowNetworking` parameter of
            the `object` and `embed` tags in the HTML page that
            contains the SWF content. For more information, see the Flash Player
            Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).
        
            **Note for Flash Player applications:** In Flash Player 10 and Flash
            Player 9 Update 5, some web browsers restrict this method if a pop-up
            blocker is enabled. In this scenario, you can only call this method
            successfully in response to a user event(for example, in an event handler
            for a mouse click or keypress event).
        
            @param functionName The alphanumeric name of the to call in the
                                container. Using a non-alphanumeric name
                                causes a runtime error(error 2155). You can use a
                                `try..catch` block to handle the error.
            @return The response received from the container. If the call failed–
                    for example, if there is no such in the container, the
                    interface is not available, a recursion occurred(with a Netscape
                    or Opera browser), or there is a security issue–
                    `null` is returned and an error is thrown.
            @throws Error         The container does not support outgoing calls.
                                  Outgoing calls are supported only in Internet
                                  Explorer for Windows and browsers that use the
                                  NPRuntime API such as Mozilla 1.7.5 and later or
                                  Firefox 1.0 and later.
            @throws SecurityError The containing environment belongs to a security
                                  sandbox to which the calling code does not have
                                  access. To fix this problem, follow these steps:
        
                                   1. In the `object` tag for the SWF
                                  file in the containing HTML page, set the following
                                  parameter:
        
                                  `<param name="allowScriptAccess"
                                  value="always" />`
        
                                   2. In the SWF file, add the following
                                  ActionScript:
        
        
                                  `openfl.system.Security.allowDomain(_sourceDomain_)`
        **/
        static call(functionName, ...parameters) {
            // return ExternalInterfaceBackend.call(functionName, p1, p2, p3, p4, p5);
        }
    }
    /**
        Indicates whether this player is in a container that offers an external
        interface. If the external interface is available, this property is
        `true`; otherwise, it is `false`.

        **Note:** When using the External API with HTML, always check that
        the HTML has finished loading before you attempt to call any JavaScript
        methods.
    **/
    ExternalInterface.available = true;
    /**
        Indicates whether the external interface should attempt to pass
        ActionScript exceptions to the current browser and JavaScript exceptions
        to the player. You must explicitly set this property to `true`
        to catch JavaScript exceptions in ActionScript and to catch ActionScript
        exceptions in JavaScript.
    **/
    ExternalInterface.marshallExceptions = false;
    return ExternalInterface;
})();

/**
    The BitmapFilter class is the base class for all image filter effects.

    The BevelFilter, BlurFilter, ColorMatrixFilter, ConvolutionFilter,
    DisplacementMapFilter, DropShadowFilter, GlowFilter, GradientBevelFilter,
    and GradientGlowFilter classes all extend the BitmapFilter class. You can
    apply these filter effects to any display object.

    You can neither directly instantiate nor extend BitmapFilter.
**/
class BitmapFilter {
    constructor() {
        this.__bottomExtension = 0;
        this.__leftExtension = 0;
        this.__needSecondBitmapData = true;
        this.__numShaderPasses = 0;
        this.__preserveObject = false;
        this.__rightExtension = 0;
        this.__shaderBlendMode = BlendMode.NORMAL;
        this.__topExtension = 0;
        this.__smooth = true;
    }
    /**
        Returns a BitmapFilter object that is an exact copy of the original
        BitmapFilter object.

        @return A BitmapFilter object.
    **/
    clone() {
        return new BitmapFilter();
    }
    __applyFilter(bitmapData, sourceBitmapData, sourceRect, destPoint) {
        return sourceBitmapData;
    }
    __initShader(renderer, pass, sourceBitmapData) {
        // return renderer.__defaultShader;
        return null;
    }
}

/**
    The BitmapFilterQuality class contains values to set the rendering quality
    of a BitmapFilter object.
**/
var BitmapFilterQuality;
(function (BitmapFilterQuality) {
    /**
        Defines the high quality filter setting.
    **/
    BitmapFilterQuality[BitmapFilterQuality["HIGH"] = 3] = "HIGH";
    /**
        Defines the medium quality filter setting.
    **/
    BitmapFilterQuality[BitmapFilterQuality["MEDIUM"] = 2] = "MEDIUM";
    /**
        Defines the low quality filter setting.
    **/
    BitmapFilterQuality[BitmapFilterQuality["LOW"] = 1] = "LOW";
})(BitmapFilterQuality || (BitmapFilterQuality = {}));
var BitmapFilterQuality$1 = BitmapFilterQuality;

class BitmapFilterShader extends Shader {
    constructor(code = null) {
        super(code);
        this.glVertexHeader = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;

		varying vec2 openfl_TextureCoordv;

		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;
	`;
        this.glVertexBody = `
		openfl_TextureCoordv = openfl_TextureCoord;

		gl_Position = openfl_Matrix * openfl_Position;
	`;
        this.glVertexSource = `
		#pragma header

		void main(void)
		{
			#pragma body
		}
	`;
        this.glFragmentHeader = `
		varying vec2 openfl_TextureCoordv;

		uniform sampler2D openfl_Texture;
		uniform vec2 openfl_TextureSize;
	`;
        this.glFragmentBody = `
		gl_FragColor = texture2D (openfl_Texture, openfl_TextureCoordv);
	`;
        this.glFragmentSource = `
		#pragma header

		void main(void)
		{
			#pragma body

		}
	`;
    }
}

/**
    The BitmapFilterType class contains values to set the type of a
    BitmapFilter.
**/
var BitmapFilterType;
(function (BitmapFilterType) {
    /**
        Defines the setting that applies a filter to the entire area of an object.
    **/
    BitmapFilterType[BitmapFilterType["FULL"] = 0] = "FULL";
    /**
        Defines the setting that applies a filter to the inner area of an object.
    **/
    BitmapFilterType[BitmapFilterType["INNER"] = 1] = "INNER";
    /**
        Defines the setting that applies a filter to the outer area of an object.
    **/
    BitmapFilterType[BitmapFilterType["OUTER"] = 2] = "OUTER";
})(BitmapFilterType || (BitmapFilterType = {}));
var BitmapFilterType$1 = BitmapFilterType;

// import openfl._internal.backend.lime_standalone.ImageDataUtil;
class BlurShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;

		varying vec2 vBlurCoords[7];

		void main(void) {

			vec4 sum = vec4(0.0);
			sum += texture2D(openfl_Texture, vBlurCoords[0]) * 0.00443;
			sum += texture2D(openfl_Texture, vBlurCoords[1]) * 0.05399;
			sum += texture2D(openfl_Texture, vBlurCoords[2]) * 0.24197;
			sum += texture2D(openfl_Texture, vBlurCoords[3]) * 0.39894;
			sum += texture2D(openfl_Texture, vBlurCoords[4]) * 0.24197;
			sum += texture2D(openfl_Texture, vBlurCoords[5]) * 0.05399;
			sum += texture2D(openfl_Texture, vBlurCoords[6]) * 0.00443;

			gl_FragColor = sum;

		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;

		uniform mat4 openfl_Matrix;

		uniform vec2 uRadius;
		varying vec2 vBlurCoords[7];
		uniform vec2 uTextureSize;

		void main(void) {

			gl_Position = openfl_Matrix * openfl_Position;

			vec2 r = uRadius / uTextureSize;
			vBlurCoords[0] = openfl_TextureCoord - r;
			vBlurCoords[1] = openfl_TextureCoord - r * 0.75;
			vBlurCoords[2] = openfl_TextureCoord - r * 0.5;
			vBlurCoords[3] = openfl_TextureCoord;
			vBlurCoords[4] = openfl_TextureCoord + r * 0.5;
			vBlurCoords[5] = openfl_TextureCoord + r * 0.75;
			vBlurCoords[6] = openfl_TextureCoord + r;

		}
	`;
        this.data.uRadius.value = [0, 0];
    }
    __update() {
        this.data.uTextureSize.value = [this.__texture.input.width, this.__texture.input.height];
        super.__update();
    }
}
/**
    The BlurFilter class lets you apply a blur visual effect to display
    objects. A blur effect softens the details of an image. You can produce
    blurs that range from a softly unfocused look to a Gaussian blur, a hazy
    appearance like viewing an image through semi-opaque glass. When the
    `quality` property of this filter is set to low, the result is a
    softly unfocused look. When the `quality` property is set to
    high, it approximates a Gaussian blur filter. You can apply the filter to
    any display object(that is, objects that inherit from the DisplayObject
    class), such as MovieClip, SimpleButton, TextField, and Video objects, as
    well as to BitmapData objects.

    To create a new filter, use the constructor `new
    BlurFilter()`. The use of filters depends on the object to which you
    apply the filter:


    * To apply filters to movie clips, text fields, buttons, and video, use
    the `filters` property(inherited from DisplayObject). Setting
    the `filters` property of an object does not modify the object,
    and you can remove the filter by clearing the `filters`
    property.
    * To apply filters to BitmapData objects, use the
    `BitmapData.applyFilter()` method. Calling
    `applyFilter()` on a BitmapData object takes the source
    BitmapData object and the filter object and generates a filtered image as a
    result.


    If you apply a filter to a display object, the
    `cacheAsBitmap` property of the display object is set to
    `true`. If you remove all filters, the original value of
    `cacheAsBitmap` is restored.

    This filter supports Stage scaling. However, it does not support general
    scaling, rotation, and skewing. If the object itself is scaled
    (`scaleX` and `scaleY` are not set to 100%), the
    filter effect is not scaled. It is scaled only when the user zooms in on
    the Stage.

    A filter is not applied if the resulting image exceeds the maximum
    dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in
    width or height, and the total number of pixels cannot exceed 16,777,215
    pixels.(So, if an image is 8,191 pixels wide, it can only be 2,048 pixels
    high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the
    limitation is 2,880 pixels in height and 2,880 pixels in width. If, for
    example, you zoom in on a large movie clip with a filter applied, the
    filter is turned off if the resulting image exceeds the maximum
    dimensions.
**/
let BlurFilter = /** @class */ (() => {
    class BlurFilter extends BitmapFilter {
        /**
            Initializes the filter with the specified parameters. The default values
            create a soft, unfocused image.
    
            @param blurX   The amount to blur horizontally. Valid values are from 0 to
                           255.0(floating-point value).
            @param blurY   The amount to blur vertically. Valid values are from 0 to
                           255.0(floating-point value).
            @param quality The number of times to apply the filter. You can specify
                           the quality using the BitmapFilterQuality constants:
    
    
                          * `openfl.filters.BitmapFilterQuality.LOW`
    
                          * `openfl.filters.BitmapFilterQuality.MEDIUM`
    
                          * `openfl.filters.BitmapFilterQuality.HIGH`
    
    
                           High quality approximates a Gaussian blur. For most
                           applications, these three values are sufficient. Although
                           you can use additional numeric values up to 15 to achieve
                           different effects, be aware that higher values are rendered
                           more slowly.
        **/
        constructor(blurX = 4, blurY = 4, quality = 1) {
            super();
            this.blurX = blurX;
            this.blurY = blurY;
            this.quality = quality;
            this.__needSecondBitmapData = true;
            this.__preserveObject = false;
            this.__renderDirty = true;
        }
        publicclone() {
            return new BlurFilter(this.__blurX, this.__blurY, this.__quality);
        }
        __applyFilter(bitmapData, sourceBitmapData, sourceRect, destPoint) {
            // var time = Timer.stamp();
            // var finalImage = ImageDataUtil.gaussianBlur(bitmapData.limeImage, sourceBitmapData.limeImage, sourceRect.__toLimeRectangle(),
            // 	destPoint.__toLimeVector2(), __blurX, __blurY, __quality);
            // var elapsed = Timer.stamp() - time;
            // // trace("blurX: " + __blurX + " blurY: " + __blurY + " quality: " + __quality + " elapsed: " + elapsed * 1000 + "ms");
            // if (finalImage == bitmapData.limeImage) return bitmapData;
            return sourceBitmapData;
        }
        __initShader(renderer, pass, sourceBitmapData) {
            var uRadius = BlurFilter.__blurShader.data.uRadius;
            if (pass < this.__horizontalPasses) {
                var scale = Math.pow(0.5, pass >> 1);
                uRadius.value[0] = this.blurX * scale;
                uRadius.value[1] = 0;
            }
            else {
                var scale = Math.pow(0.5, (pass - this.__horizontalPasses) >> 1);
                uRadius.value[0] = 0;
                uRadius.value[1] = this.blurY * scale;
            }
            return BlurFilter.__blurShader;
        }
        // Get & Set Methods
        /**
            The amount of horizontal blur. Valid values are from 0 to 255(floating
            point). The default value is 4. Values that are a power of 2(such as 2,
            4, 8, 16 and 32) are optimized to render more quickly than other values.
        **/
        get blurX() {
            return this.__blurX;
        }
        set blurX(value) {
            if (value != this.__blurX) {
                this.__blurX = value;
                this.__renderDirty = true;
                this.__leftExtension = (value > 0 ? Math.ceil(value) : 0);
                this.__rightExtension = this.__leftExtension;
            }
        }
        /**
            The amount of vertical blur. Valid values are from 0 to 255(floating
            point). The default value is 4. Values that are a power of 2(such as 2,
            4, 8, 16 and 32) are optimized to render more quickly than other values.
        **/
        get blurY() {
            return this.__blurY;
        }
        set blurY(value) {
            if (value != this.__blurY) {
                this.__blurY = value;
                this.__renderDirty = true;
                this.__topExtension = (value > 0 ? Math.ceil(value) : 0);
                this.__bottomExtension = this.__topExtension;
            }
        }
        /**
            The number of times to perform the blur. The default value is
            `BitmapFilterQuality.LOW`, which is equivalent to applying the
            filter once. The value `BitmapFilterQuality.MEDIUM` applies the
            filter twice; the value `BitmapFilterQuality.HIGH` applies it
            three times and approximates a Gaussian blur. Filters with lower values
            are rendered more quickly.
    
            For most applications, a `quality` value of low, medium, or
            high is sufficient. Although you can use additional numeric values up to
            15 to increase the number of times the blur is applied, higher values are
            rendered more slowly. Instead of increasing the value of
            `quality`, you can often get a similar effect, and with faster
            rendering, by simply increasing the values of the `blurX` and
            `blurY` properties.
    
            You can use the following BitmapFilterQuality constants to specify
            values of the `quality` property:
    
            * `BitmapFilterQuality.LOW`
            * `BitmapFilterQuality.MEDIUM`
            * `BitmapFilterQuality.HIGH`
        **/
        get quality() {
            return this.__quality;
        }
        set quality(value) {
            // TODO: Quality effect with fewer passes?
            this.__horizontalPasses = (this.__blurX <= 0) ? 0 : Math.round(this.__blurX * (value / 4)) + 1;
            this.__verticalPasses = (this.__blurY <= 0) ? 0 : Math.round(this.__blurY * (value / 4)) + 1;
            this.__numShaderPasses = this.__horizontalPasses + this.__verticalPasses;
            if (value != this.__quality)
                this.__renderDirty = true;
            this.__quality = value;
        }
    }
    BlurFilter.__blurShader = new BlurShader();
    return BlurFilter;
})();

// import openfl._internal.backend.lime_standalone.ImageCanvasUtil;
// import openfl._internal.backend.lime_standalone.RGBA;
class ColorMatrixShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		varying vec2 openfl_TextureCoordv;
		uniform sampler2D openfl_Texture;

		uniform mat4 uMultipliers;
		uniform vec4 uOffsets;

		void main(void) {

			vec4 color = texture2D(openfl_Texture, openfl_TextureCoordv);

			if (color.a == 0.0)
			{

				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);

			} else
			{

				color = vec4(color.rgb / color.a, color.a);
				color = uOffsets + color * uMultipliers;

				gl_FragColor = vec4(color.rgb * color.a, color.a);

			}

		}
	`;
        this.data.uMultipliers.value = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        this.data.uOffsets.value = [0, 0, 0, 0];
    }
    init(matrix) {
        var multipliers = this.data.uMultipliers.value;
        var offsets = this.data.uOffsets.value;
        multipliers[0] = matrix[0];
        multipliers[1] = matrix[1];
        multipliers[2] = matrix[2];
        multipliers[3] = matrix[3];
        multipliers[4] = matrix[5];
        multipliers[5] = matrix[6];
        multipliers[6] = matrix[7];
        multipliers[7] = matrix[8];
        multipliers[8] = matrix[10];
        multipliers[9] = matrix[11];
        multipliers[10] = matrix[12];
        multipliers[11] = matrix[13];
        multipliers[12] = matrix[15];
        multipliers[13] = matrix[16];
        multipliers[14] = matrix[17];
        multipliers[15] = matrix[18];
        offsets[0] = matrix[4] / 255.0;
        offsets[1] = matrix[9] / 255.0;
        offsets[2] = matrix[14] / 255.0;
        offsets[3] = matrix[19] / 255.0;
    }
}
/**
    The ColorMatrixFilter class lets you apply a 4 x 5 matrix transformation
    on the RGBA color and alpha values of every pixel in the input image to
    produce a result with a new set of RGBA color and alpha values. It allows
    saturation changes, hue rotation, luminance to alpha, and various other
    effects. You can apply the filter to any display object (that is, objects
    that inherit from the DisplayObject class), such as MovieClip,
    SimpleButton, TextField, and Video objects, as well as to BitmapData
    objects.
    **Note:** For RGBA values, the most significant byte represents the red
    channel value, followed by green, blue, and then alpha.

    To create a new color matrix filter, use the syntax `new
    ColorMatrixFilter()`. The use of filters depends on the object to which
    you apply the filter:

    * To apply filters to movie clips, text fields, buttons, and video, use
    the `filters` property (inherited from DisplayObject). Setting the
    `filters` property of an object does not modify the object, and you can
    remove the filter by clearing the `filters` property.
    * To apply filters to BitmapData objects, use the
    `BitmapData.applyFilter()` method. Calling `applyFilter()` on a BitmapData
    object takes the source BitmapData object and the filter object and
    generates a filtered image as a result.

    If you apply a filter to a display object, the `cacheAsBitmap` property of
    the display object is set to `true`. If you remove all filters, the
    original value of `cacheAsBitmap` is restored.

    A filter is not applied if the resulting image exceeds the maximum
    dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in
    width or height, and the total number of pixels cannot exceed 16,777,215
    pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels
    high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the
    limitation is 2,880 pixels in height and 2,880 pixels in width. For
    example, if you zoom in on a large movie clip with a filter applied, the
    filter is turned off if the resulting image reaches the maximum
    dimensions.
**/
let ColorMatrixFilter = /** @class */ (() => {
    class ColorMatrixFilter extends BitmapFilter {
        /**
            Initializes a new ColorMatrixFilter instance with the specified
            parameters.
        **/
        constructor(matrix = null) {
            super();
            this.matrix = matrix;
            this.__numShaderPasses = 1;
            this.__needSecondBitmapData = false;
        }
        publicclone() {
            return new ColorMatrixFilter(this.__matrix);
        }
        __applyFilter(destBitmapData, sourceBitmapData, sourceRect, destPoint) {
            // var sourceImage = sourceBitmapData.limeImage;
            // var image = destBitmapData.limeImage;
            // // ImageCanvasUtil.convertToData(sourceImage);
            // // ImageCanvasUtil.convertToData(image);
            // var sourceData = sourceImage.data;
            // var destData = image.data;
            // var offsetX = Math.round(destPoint.x - sourceRect.x);
            // var offsetY = Math.round(destPoint.y - sourceRect.y);
            // var sourceStride = sourceBitmapData.width * 4;
            // var destStride = destBitmapData.width * 4;
            // var sourceFormat = sourceImage.buffer.format;
            // var destFormat = image.buffer.format;
            // var sourcePremultiplied = sourceImage.buffer.premultiplied;
            // var destPremultiplied = image.buffer.premultiplied;
            // var sourcePixel: RGBA, destPixel: RGBA = 0;
            // var sourceOffset: number, destOffset: number;
            // for (let row = Math.round(sourceRect.y); row < Math.round(sourceRect.height); row++)
            // {
            // 	for (let column = Math.round(sourceRect.x); column < Math.round(sourceRect.width); column++)
            // 	{
            // 		sourceOffset = (row * sourceStride) + (column * 4);
            // 		destOffset = ((row + offsetX) * destStride) + ((column + offsetY) * 4);
            // 		sourcePixel.readUInt8(sourceData, sourceOffset, sourceFormat, sourcePremultiplied);
            // 		if (sourcePixel.a == 0)
            // 		{
            // 			destPixel = 0;
            // 		}
            // 		else
            // 		{
            // 			destPixel.r = Math.round(Math.max(0,
            // 				Math.min((this.__matrix[0] * sourcePixel.r) + (this.__matrix[1] * sourcePixel.g) + (this.__matrix[2] * sourcePixel.b)
            // 					+ (this.__matrix[3] * sourcePixel.a) + __matrix[4],
            // 					255)));
            // 			destPixel.g = Math.round(Math.max(0,
            // 				Math.min((this.__matrix[5] * sourcePixel.r) + (this.__matrix[6] * sourcePixel.g) + (this.__matrix[7] * sourcePixel.b)
            // 					+ (this.__matrix[8] * sourcePixel.a) + __matrix[9],
            // 					255)));
            // 			destPixel.b = Math.round(Math.max(0,
            // 				Math.min((this.__matrix[10] * sourcePixel.r) + (this.__matrix[11] * sourcePixel.g) + (this.__matrix[12] * sourcePixel.b)
            // 					+ (this.__matrix[13] * sourcePixel.a) + __matrix[14],
            // 					255)));
            // 			destPixel.a = Math.round(Math.max(0,
            // 				Math.min((this.__matrix[15] * sourcePixel.r) + (this.__matrix[16] * sourcePixel.g) + (this.__matrix[17] * sourcePixel.b)
            // 					+ (this.__matrix[18] * sourcePixel.a) + __matrix[19],
            // 					255)));
            // 		}
            // 		destPixel.writeUInt8(destData, destOffset, destFormat, destPremultiplied);
            // 	}
            // }
            // destBitmapData.limeImage.dirty = true;
            return destBitmapData;
        }
        __initShader(renderer, pass, sourceBitmapData) {
            ColorMatrixFilter.__colorMatrixShader.init(this.matrix);
            return ColorMatrixFilter.__colorMatrixShader;
        }
        // Get & Set Methods
        /**
            An array of 20 items for 4 x 5 color transform. The `matrix` property
            cannot be changed by directly modifying its value (for example,
            `myFilter.matrix[2] = 1;`). Instead, you must get a reference to the
            array, make the change to the reference, and reset the value.
            The color matrix filter separates each source pixel into its red,
            green, blue, and alpha components as srcR, srcG, srcB, srcA. To
            calculate the result of each of the four channels, the value of each
            pixel in the image is multiplied by the values in the transformation
            matrix. An offset, between -255 and 255, can optionally be added to
            each result (the fifth item in each row of the matrix). The filter
            combines each color component back into a single pixel and writes out
            the result. In the following formula, a[0] through a[19] correspond to
            entries 0 through 19 in the 20-item array that is passed to the
            `matrix` property:
    
            ```
            redResult   = (a[0]  * srcR) + (a[1]  * srcG) + (a[2]  * srcB) + (a[3]  * srcA) + a[4]
            greenResult = (a[5]  * srcR) + (a[6]  * srcG) + (a[7]  * srcB) + (a[8]  * srcA) + a[9]
            blueResult  = (a[10] * srcR) + (a[11] * srcG) + (a[12] * srcB) + (a[13] * srcA) + a[14]
            alphaResult = (a[15] * srcR) + (a[16] * srcG) + (a[17] * srcB) + (a[18] * srcA) + a[19]
            ```
    
            For each color value in the array, a value of 1 is equal to 100% of
            that channel being sent to the output, preserving the value of the
            color channel.
    
            The calculations are performed on unmultiplied color values. If the
            input graphic consists of premultiplied color values, those values are
            automatically converted into unmultiplied color values for this
            operation.
    
            Two optimized modes are available:
    
            **Alpha only.** When you pass to the filter a matrix that adjusts only
            the alpha component, as shown here, the filter optimizes its
            performance:
    
            ```
            1 0 0 0 0
            0 1 0 0 0
            0 0 1 0 0
            0 0 0 N 0  (where N is between 0.0 and 1.0)
            ```
    
            **Faster version**. Available only with SSE/AltiVec
            accelerator-enabled processors, such as Intel<sup>®</sup>
            Pentium<sup>®</sup> 3 and later and Apple<sup>®</sup> G4 and later.
            The accelerator is used when the multiplier terms are in the range
            -15.99 to 15.99 and the adder terms a[4], a[9], a[14], and a[19] are
            in the range -8000 to 8000.
    
            @throws TypeError The Array is `null` when being set
        **/
        get matrix() {
            return this.__matrix;
        }
        set matrix(value) {
            if (value == null) {
                value = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
            }
            this.__matrix = value;
        }
    }
    ColorMatrixFilter.__colorMatrixShader = new ColorMatrixShader();
    return ColorMatrixFilter;
})();

class ConvolutionShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		varying vec2 vBlurCoords[9];

		uniform sampler2D openfl_Texture;

		uniform float uBias;
		uniform mat3 uConvoMatrix;
		uniform float uDivisor;
		uniform bool uPreserveAlpha;

		void main(void) {

			vec4 tc = texture2D(openfl_Texture, vBlurCoords[4]);
			vec4 c = vec4(0.0);

			c += texture2D(openfl_Texture, vBlurCoords[0]) * uConvoMatrix[0][0];
			c += texture2D(openfl_Texture, vBlurCoords[1]) * uConvoMatrix[0][1];
			c += texture2D(openfl_Texture, vBlurCoords[2]) * uConvoMatrix[0][2];

			c += texture2D(openfl_Texture, vBlurCoords[3]) * uConvoMatrix[1][0];
			c += tc * uConvoMatrix[1][1];
			c += texture2D(openfl_Texture, vBlurCoords[5]) * uConvoMatrix[1][2];

			c += texture2D(openfl_Texture, vBlurCoords[6]) * uConvoMatrix[2][0];
			c += texture2D(openfl_Texture, vBlurCoords[7]) * uConvoMatrix[2][1];
			c += texture2D(openfl_Texture, vBlurCoords[8]) * uConvoMatrix[2][2];

			if (uDivisor > 0.0)
			{

				c /= vec4(uDivisor, uDivisor, uDivisor, uDivisor);

			}

			c += vec4(uBias, uBias, uBias, uBias);

			if (uPreserveAlpha)
			{

				c.a = tc.a;

			}

			gl_FragColor = c;

		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;

		varying vec2 vBlurCoords[9];

		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;

		void main(void) {

			vec2 r = vec2(1.0, 1.0) / openfl_TextureSize;
			vec2 t = openfl_TextureCoord;

			vBlurCoords[0] = t + r * vec2(-1.0, -1.0);
			vBlurCoords[1] = t + r * vec2(0.0, -1.0);
			vBlurCoords[2] = t + r * vec2(1.0, -1.0);

			vBlurCoords[3] = t + r * vec2(-1.0, 0.0);
			vBlurCoords[4] = t;
			vBlurCoords[5] = t + r * vec2(1.0, 0.0);

			vBlurCoords[6] = t + r * vec2(-1.0, 1.0);
			vBlurCoords[7] = t + r * vec2(0.0, 1.0);
			vBlurCoords[8] = t + r * vec2(1.0, 1.0);

			gl_Position = openfl_Matrix * openfl_Position;

		}
	`;
        this.data.uDivisor.value = [1];
        this.data.uBias.value = [0];
        this.data.uPreserveAlpha.value = [true];
    }
}
/**
    The ConvolutionFilter class applies a matrix convolution filter effect. A
    convolution combines pixels in the input image with neighboring pixels to
    produce an image. A wide variety of image effects can be achieved through
    convolutions, including blurring, edge detection, sharpening, embossing,
    and beveling. You can apply the filter to any display object (that is,
    objects that inherit from the DisplayObject class), such as MovieClip,
    SimpleButton, TextField, and Video objects, as well as to BitmapData
    objects.
    To create a convolution filter, use the syntax `new ConvolutionFilter()`.
    The use of filters depends on the object to which you apply the filter:

    * To apply filters to movie clips, text fields, buttons, and video, use
    the `filters` property (inherited from DisplayObject). Setting the
    `filters` property of an object does not modify the object, and you can
    remove the filter by clearing the `filters` property.
    * To apply filters to BitmapData objects, use the
    `BitmapData.applyFilter()` method. Calling `applyFilter()` on a BitmapData
    object takes the source BitmapData object and the filter object and
    generates a filtered image as a result.

    If you apply a filter to a display object, the value of the
    `cacheAsBitmap` property of the object is set to `true`. If you clear all
    filters, the original value of `cacheAsBitmap` is restored.

    A filter is not applied if the resulting image exceeds the maximum
    dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in
    width or height, and the total number of pixels cannot exceed 16,777,215
    pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels
    high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the
    limitation is 2,880 pixels in height and 2,880 pixels in width. For
    example, if you zoom in on a large movie clip with a filter applied, the
    filter is turned off if the resulting image exceeds maximum dimensions.
**/
let ConvolutionFilter = /** @class */ (() => {
    class ConvolutionFilter extends BitmapFilter {
        /**
            Initializes a ConvolutionFilter instance with the specified
            parameters.
    
            @param matrixX       The _x_ dimension of the matrix (the number of
                                 columns in the matrix). The default value is 0.
            @param matrixY       The _y_ dimension of the matrix (the number of
                                 rows in the matrix). The default value is 0.
            @param divisor       The divisor used during matrix transformation.
                                 The default value is 1. A divisor that is the sum
                                 of all the matrix values evens out the overall
                                 color intensity of the result. A value of 0 is
                                 ignored and the default is used instead.
            @param bias          The bias to add to the result of the matrix
                                 transformation. The default value is 0.
            @param preserveAlpha A value of `false` indicates that the alpha value
                                 is not preserved and that the convolution applies
                                 to all channels, including the alpha channel. A
                                 value of `true` indicates that the convolution
                                 applies only to the color channels. The default
                                 value is `true`.
            @param clamp         For pixels that are off the source image, a value
                                 of `true` indicates that the input image is
                                 extended along each of its borders as necessary
                                 by duplicating the color values at the given edge
                                 of the input image. A value of `false` indicates
                                 that another color should be used, as specified
                                 in the `color` and `alpha` properties. The
                                 default is `true`.
            @param color         The hexadecimal color to substitute for pixels
                                 that are off the source image.
            @param alpha         The alpha of the substitute color.
        **/
        constructor(matrixX = 0, matrixY = 0, matrix = null, divisor = 1.0, bias = 0.0, preserveAlpha = true, clamp = true, color = 0, alpha = 0.0) {
            super();
            this.matrixX = matrixX;
            this.matrixY = matrixY;
            this.__matrix = matrix;
            this.divisor = divisor;
            this.bias = bias;
            this.preserveAlpha = preserveAlpha;
            this.clamp = clamp;
            this.color = color;
            this.alpha = alpha;
            this.__numShaderPasses = 1;
        }
        clone() {
            return new ConvolutionFilter(this.matrixX, this.matrixY, this.__matrix, this.divisor, this.bias, this.preserveAlpha, this.clamp, this.color, this.alpha);
        }
        __initShader(renderer, pass, sourceBitmapData) {
            var data = ConvolutionFilter.__convolutionShader.data;
            data.uConvoMatrix.value = this.matrix;
            data.uDivisor.value[0] = this.divisor;
            data.uBias.value[0] = this.bias;
            data.uPreserveAlpha.value[0] = this.preserveAlpha;
            return ConvolutionFilter.__convolutionShader;
        }
        // Get & Set Methods
        /**
            An array of values used for matrix transformation. The number of items
            in the array must equal `matrixX * matrixY`.
            A matrix convolution is based on an _n_ x _m_ matrix, which describes
            how a given pixel value in the input image is combined with its
            neighboring pixel values to produce a resulting pixel value. Each
            result pixel is determined by applying the matrix to the corresponding
            source pixel and its neighboring pixels.
    
            For a 3 x 3 matrix convolution, the following formula is used for each
            independent color channel:
    
            ```
            dst (x, y) = ((src (x-1, y-1) * a0 + src(x, y-1) * a1....
                           src(x, y+1) * a7 + src (x+1,y+1) * a8) / divisor) + bias
            ```
    
            Certain filter specifications perform faster when run by a processor
            that offers SSE (Streaming SIMD Extensions). The following are
            criteria for faster convolution operations:
    
            * The filter must be a 3x3 filter.
            * All the filter terms must be integers between -127 and +127.
            * The sum of all the filter terms must not have an absolute value
            greater than 127.
            * If any filter term is negative, the divisor must be between 2.00001
            and 256.
            * If all filter terms are positive, the divisor must be between 1.1
            and 256.
            * The bias must be an integer.
    
            **Note:** If you create a ConvolutionFilter instance using the
            constructor without parameters, the order you assign values to matrix
            properties affects the behavior of the filter. In the following case,
            the matrix array is assigned while the `matrixX` and `matrixY`
            properties are still set to `0` (the default value):
    
            ```haxe
            public myfilter = new ConvolutionFilter();
            myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
            myfilter.matrixX = 3;
            myfilter.matrixY = 3;
            ```
    
            In the following case, the matrix array is assigned while the
            `matrixX` and `matrixY` properties are set to `3`:
    
            ```haxe
            public myfilter = new ConvolutionFilter();
            myfilter.matrixX = 3;
            myfilter.matrixY = 3;
            myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
            ```
    
            @throws TypeError The Array is null when being set
        **/
        get matrix() {
            return this.__matrix;
        }
        set matrix(v) {
            if (v == null) {
                v = [0, 0, 0, 0, 1, 0, 0, 0, 0];
            }
            if (v.length != 9) {
                throw "Only a 3x3 matrix is supported";
            }
            this.__matrix = v;
        }
    }
    ConvolutionFilter.__convolutionShader = new ConvolutionShader();
    return ConvolutionFilter;
})();

class InvertAlphaShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		varying vec2 vTexCoord;

		void main(void) {
			vec4 texel = texture2D(openfl_Texture, vTexCoord);
			gl_FragColor = vec4(texel.rgb, 1.0 - texel.a);
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;
		uniform mat4 openfl_Matrix;
		varying vec2 vTexCoord;

		void main(void) {
			gl_Position = openfl_Matrix * openfl_Position;
			vTexCoord = openfl_TextureCoord;
		}
	`;
    }
}
class BlurAlphaShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		uniform vec4 uColor;
		uniform float uStrength;
		varying vec2 vTexCoord;
		varying vec2 vBlurCoords[6];

		void main(void)
		{
			vec4 texel = texture2D(openfl_Texture, vTexCoord);

			vec3 contributions = vec3(0.00443, 0.05399, 0.24197);
			vec3 top = vec3(
				texture2D(openfl_Texture, vBlurCoords[0]).a,
				texture2D(openfl_Texture, vBlurCoords[1]).a,
				texture2D(openfl_Texture, vBlurCoords[2]).a
			);
			vec3 bottom = vec3(
				texture2D(openfl_Texture, vBlurCoords[3]).a,
				texture2D(openfl_Texture, vBlurCoords[4]).a,
				texture2D(openfl_Texture, vBlurCoords[5]).a
			);

			float a = texel.a * 0.39894;
			a += dot(top, contributions.xyz);
			a += dot(bottom, contributions.zyx);

			gl_FragColor = uColor * clamp(a * uStrength, 0.0, 1.0);
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;

		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;

		uniform vec2 uRadius;
		varying vec2 vTexCoord;
		varying vec2 vBlurCoords[6];

		void main(void) {

			gl_Position = openfl_Matrix * openfl_Position;
			vTexCoord = openfl_TextureCoord;

			vec3 offset = vec3(0.5, 0.75, 1.0);
			vec2 r = uRadius / openfl_TextureSize;
			vBlurCoords[0] = openfl_TextureCoord - r * offset.z;
			vBlurCoords[1] = openfl_TextureCoord - r * offset.y;
			vBlurCoords[2] = openfl_TextureCoord - r * offset.x;
			vBlurCoords[3] = openfl_TextureCoord + r * offset.x;
			vBlurCoords[4] = openfl_TextureCoord + r * offset.y;
			vBlurCoords[5] = openfl_TextureCoord + r * offset.z;
		}
	`;
        this.data.uRadius.value = [0, 0];
        this.data.uColor.value = [0, 0, 0, 0];
        this.data.uStrength.value = [1];
    }
}
class CombineShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		uniform sampler2D sourceBitmap;
		varying vec4 textureCoords;

		void main(void) {
			vec4 src = texture2D(sourceBitmap, textureCoords.xy);
			vec4 glow = texture2D(openfl_Texture, textureCoords.zw);

			gl_FragColor = src + glow * (1.0 - src.a);
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;
		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;
		uniform vec2 offset;
		varying vec4 textureCoords;

		void main(void) {
			gl_Position = openfl_Matrix * openfl_Position;
			textureCoords = vec4(openfl_TextureCoord, openfl_TextureCoord - offset / openfl_TextureSize);
		}
	`;
        this.data.offset.value = [0, 0];
    }
}
class InnerCombineShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		uniform sampler2D sourceBitmap;
		varying vec4 textureCoords;

		void main(void) {
			vec4 src = texture2D(sourceBitmap, textureCoords.xy);
			vec4 glow = texture2D(openfl_Texture, textureCoords.zw);

			gl_FragColor = vec4((src.rgb * (1.0 - glow.a)) + (glow.rgb * src.a), src.a);
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;
		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;
		uniform vec2 offset;
		varying vec4 textureCoords;

		void main(void) {
			gl_Position = openfl_Matrix * openfl_Position;
			textureCoords = vec4(openfl_TextureCoord, openfl_TextureCoord - offset / openfl_TextureSize);
		}
	`;
        this.data.offset.value = [0, 0];
    }
}
class CombineKnockoutShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		uniform sampler2D sourceBitmap;
		varying vec4 textureCoords;

		void main(void) {
			vec4 src = texture2D(sourceBitmap, textureCoords.xy);
			vec4 glow = texture2D(openfl_Texture, textureCoords.zw);

			gl_FragColor = glow * (1.0 - src.a);
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;
		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;
		uniform vec2 offset;
		varying vec4 textureCoords;

		void main(void) {
			gl_Position = openfl_Matrix * openfl_Position;
			textureCoords = vec4(openfl_TextureCoord, openfl_TextureCoord - offset / openfl_TextureSize);
		}
	`;
        this.data.offset.value = [0, 0];
    }
}
class InnerCombineKnockoutShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		uniform sampler2D sourceBitmap;
		varying vec4 textureCoords;

		void main(void) {
			vec4 src = texture2D(sourceBitmap, textureCoords.xy);
			vec4 glow = texture2D(openfl_Texture, textureCoords.zw);

			gl_FragColor = glow * src.a;
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;
		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;
		uniform vec2 offset;
		varying vec4 textureCoords;

		void main(void) {
			gl_Position = openfl_Matrix * openfl_Position;
			textureCoords = vec4(openfl_TextureCoord, openfl_TextureCoord - offset / openfl_TextureSize);
		}
	`;
        this.data.offset.value = [0, 0];
    }
}
/**
    The GlowFilter class lets you apply a glow effect to display objects. You
    have several options for the style of the glow, including inner or outer
    glow and knockout mode. The glow filter is similar to the drop shadow
    filter with the `distance` and `angle` properties of
    the drop shadow filter set to 0. You can apply the filter to any display
    object(that is, objects that inherit from the DisplayObject class), such
    as MovieClip, SimpleButton, TextField, and Video objects, as well as to
    BitmapData objects.

    The use of filters depends on the object to which you apply the
    filter:


    * To apply filters to display objects, use the `filters`
    property(inherited from DisplayObject). Setting the `filters`
    property of an object does not modify the object, and you can remove the
    filter by clearing the `filters` property.
    * To apply filters to BitmapData objects, use the
    `BitmapData.applyFilter()` method. Calling
    `applyFilter()` on a BitmapData object takes the source
    BitmapData object and the filter object and generates a filtered image as a
    result.


    If you apply a filter to a display object, the
    `cacheAsBitmap` property of the display object is set to
    `true`. If you clear all filters, the original value of
    `cacheAsBitmap` is restored.

    This filter supports Stage scaling. However, it does not support general
    scaling, rotation, and skewing. If the object itself is scaled(if
    `scaleX` and `scaleY` are set to a value other than
    1.0), the filter is not scaled. It is scaled only when the user zooms in on
    the Stage.

    A filter is not applied if the resulting image exceeds the maximum
    dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in
    width or height, and the total number of pixels cannot exceed 16,777,215
    pixels.(So, if an image is 8,191 pixels wide, it can only be 2,048 pixels
    high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the
    limitation is 2,880 pixels in height and 2,880 pixels in width. For
    example, if you zoom in on a large movie clip with a filter applied, the
    filter is turned off if the resulting image exceeds the maximum
    dimensions.
**/
let GlowFilter = /** @class */ (() => {
    class GlowFilter extends BitmapFilter {
        /**
            Initializes a new GlowFilter instance with the specified parameters.
    
            @param color    The color of the glow, in the hexadecimal format
                            0x_RRGGBB_. The default value is 0xFF0000.
            @param alpha    The alpha transparency value for the color. Valid values
                            are 0 to 1. For example, .25 sets a transparency value of
                            25%.
            @param blurX    The amount of horizontal blur. Valid values are 0 to 255
                           (floating point). Values that are a power of 2(such as 2,
                            4, 8, 16 and 32) are optimized to render more quickly than
                            other values.
            @param blurY    The amount of vertical blur. Valid values are 0 to 255
                           (floating point). Values that are a power of 2(such as 2,
                            4, 8, 16 and 32) are optimized to render more quickly than
                            other values.
            @param strength The strength of the imprint or spread. The higher the
                            value, the more color is imprinted and the stronger the
                            contrast between the glow and the background. Valid values
                            are 0 to 255.
            @param quality  The number of times to apply the filter. Use the
                            BitmapFilterQuality constants:
    
                             * `BitmapFilterQuality.LOW`
                             * `BitmapFilterQuality.MEDIUM`
                             * `BitmapFilterQuality.HIGH`
    
    
                            For more information, see the description of the
                            `quality` property.
            @param inner    Specifies whether the glow is an inner glow. The value
                            ` true` specifies an inner glow. The value
                            `false` specifies an outer glow(a glow around
                            the outer edges of the object).
            @param knockout Specifies whether the object has a knockout effect. The
                            value `true` makes the object's fill
                            transparent and reveals the background color of the
                            document.
        **/
        constructor(color = 0xFF0000, alpha = 1, blurX = 6, blurY = 6, strength = 2, quality = 1, inner = false, knockout = false) {
            super();
            this.__color = color;
            this.__alpha = alpha;
            this.__blurX = blurX;
            this.__blurY = blurY;
            this.__strength = strength;
            this.__inner = inner;
            this.__knockout = knockout;
            this.__quality = quality;
            this.__updateSize();
            this.__needSecondBitmapData = true;
            this.__preserveObject = true;
            this.__renderDirty = true;
        }
        clone() {
            return new GlowFilter(this.__color, this.__alpha, this.__blurX, this.__blurY, this.__strength, this.__quality, this.__inner, this.__knockout);
        }
        __applyFilter(bitmapData, sourceBitmapData, sourceRect, destPoint) {
            // // TODO: Support knockout, inner
            // var r = (__color >> 16) & 0xFF;
            // var g = (__color >> 8) & 0xFF;
            // var b = __color & 0xFF;
            // if (__inner || __knockout)
            // {
            // 	sourceBitmapData.limeImage.colorTransform(sourceBitmapData.limeImage.rect, new ColorTransform(1, 1, 1, 0, 0, 0, 0, -255).__toLimeColorMatrix());
            // 	sourceBitmapData.limeImage.dirty = true;
            // 	sourceBitmapData.limeImage.version++;
            // 	bitmapData = sourceBitmapData.clone();
            // 	return bitmapData;
            // }
            // var finalImage = ImageDataUtil.gaussianBlur(bitmapData.limeImage, sourceBitmapData.limeImage, sourceRect.__toLimeRectangle(),
            // 	destPoint.__toLimeVector2(), __blurX, __blurY, __quality, __strength);
            // finalImage.colorTransform(finalImage.rect, new ColorTransform(0, 0, 0, __alpha, r, g, b, 0).__toLimeColorMatrix());
            // if (finalImage == bitmapData.limeImage) return bitmapData;
            return sourceBitmapData;
        }
        __initShader(renderer, pass, sourceBitmapData) {
            // First pass of inner glow is invert alpha
            if (this.__inner && pass == 0) {
                return GlowFilter.__invertAlphaShader;
            }
            var blurPass = pass - (this.__inner ? 1 : 0);
            var numBlurPasses = this.__horizontalPasses + this.__verticalPasses;
            if (blurPass < numBlurPasses) {
                var shader = GlowFilter.__blurAlphaShader;
                var uRadius = shader.data.uRadius;
                var uColor = shader.data.uColor;
                var uStrength = shader.data.uStrength;
                if (blurPass < this.__horizontalPasses) {
                    var scale = Math.pow(0.5, blurPass >> 1) * 0.5;
                    uRadius.value[0] = this.blurX * scale;
                    uRadius.value[1] = 0;
                }
                else {
                    var scale = Math.pow(0.5, (blurPass - this.__horizontalPasses) >> 1) * 0.5;
                    uRadius.value[0] = 0;
                    uRadius.value[1] = this.blurY * scale;
                }
                uColor.value[0] = ((this.color >> 16) & 0xFF) / 255;
                uColor.value[1] = ((this.color >> 8) & 0xFF) / 255;
                uColor.value[2] = (this.color & 0xFF) / 255;
                uColor.value[3] = this.alpha;
                uStrength.value[0] = blurPass == (numBlurPasses - 1) ? this.__strength : 1.0;
                return shader;
            }
            if (this.__inner) {
                if (this.__knockout) {
                    var shader = GlowFilter.__innerCombineKnockoutShader;
                    shader.data.sourceBitmap.input = sourceBitmapData;
                    shader.data.offset.value[0] = 0.0;
                    shader.data.offset.value[1] = 0.0;
                    return shader;
                }
                var shader = GlowFilter.__innerCombineShader;
                shader.data.sourceBitmap.input = sourceBitmapData;
                shader.data.offset.value[0] = 0.0;
                shader.data.offset.value[1] = 0.0;
                return shader;
            }
            else {
                if (this.__knockout) {
                    var shader = GlowFilter.__combineKnockoutShader;
                    shader.data.sourceBitmap.input = sourceBitmapData;
                    shader.data.offset.value[0] = 0.0;
                    shader.data.offset.value[1] = 0.0;
                    return shader;
                }
                var shader = GlowFilter.__combineShader;
                shader.data.sourceBitmap.input = sourceBitmapData;
                shader.data.offset.value[0] = 0.0;
                shader.data.offset.value[1] = 0.0;
                return shader;
            }
        }
        __updateSize() {
            this.__leftExtension = (this.__blurX > 0 ? Math.ceil(this.__blurX * 1.5) : 0);
            this.__rightExtension = this.__leftExtension;
            this.__topExtension = (this.__blurY > 0 ? Math.ceil(this.__blurY * 1.5) : 0);
            this.__bottomExtension = this.__topExtension;
            this.__calculateNumShaderPasses();
        }
        __calculateNumShaderPasses() {
            this.__horizontalPasses = (this.__blurX <= 0) ? 0 : Math.round(this.__blurX * (this.__quality / 4)) + 1;
            this.__verticalPasses = (this.__blurY <= 0) ? 0 : Math.round(this.__blurY * (this.__quality / 4)) + 1;
            this.__numShaderPasses = this.__horizontalPasses + this.__verticalPasses + (this.__inner ? 2 : 1);
        }
        // Get & Set Methods
        /**
            The alpha transparency value for the color. Valid values are 0 to 1. For
            example, .25 sets a transparency value of 25%. The default value is 1.
        **/
        get alpha() {
            return this.__alpha;
        }
        set alpha(value) {
            if (value != this.__alpha)
                this.__renderDirty = true;
            this.__alpha = value;
        }
        /**
            The amount of horizontal blur. Valid values are 0 to 255(floating point).
            The default value is 6. Values that are a power of 2(such as 2, 4, 8, 16,
            and 32) are optimized to render more quickly than other values.
        **/
        get blurX() {
            return this.__blurX;
        }
        set blurX(value) {
            if (value != this.__blurX) {
                this.__blurX = value;
                this.__renderDirty = true;
                this.__updateSize();
            }
        }
        /**
            The amount of vertical blur. Valid values are 0 to 255(floating point).
            The default value is 6. Values that are a power of 2(such as 2, 4, 8, 16,
            and 32) are optimized to render more quickly than other values.
        **/
        get blurY() {
            return this.__blurY;
        }
        set blurY(value) {
            if (value != this.__blurY) {
                this.__blurY = value;
                this.__renderDirty = true;
                this.__updateSize();
            }
        }
        /**
            The color of the glow. Valid values are in the hexadecimal format
            0x_RRGGBB_. The default value is 0xFF0000.
        **/
        get color() {
            return this.__color;
        }
        set color(value) {
            if (value != this.__color)
                this.__renderDirty = true;
            this.__color = value;
        }
        /**
            Specifies whether the glow is an inner glow. The value `true`
            indicates an inner glow. The default is `false`, an outer glow
            (a glow around the outer edges of the object).
        **/
        get inner() {
            return this.__inner;
        }
        set inner(value) {
            if (value != this.__inner) {
                this.__renderDirty = true;
                this.__calculateNumShaderPasses();
            }
            this.__inner = value;
        }
        /**
            Specifies whether the object has a knockout effect. A value of
            `true` makes the object's fill transparent and reveals the
            background color of the document. The default value is `false`
            (no knockout effect).
        **/
        get knockout() {
            return this.__knockout;
        }
        set knockout(value) {
            if (value != this.__knockout) {
                this.__renderDirty = true;
                this.__calculateNumShaderPasses();
            }
            this.__knockout = value;
        }
        /**
            The number of times to apply the filter. The default value is
            `BitmapFilterQuality.LOW`, which is equivalent to applying the
            filter once. The value `BitmapFilterQuality.MEDIUM` applies the
            filter twice; the value `BitmapFilterQuality.HIGH` applies it
            three times. Filters with lower values are rendered more quickly.
    
            For most applications, a `quality` value of low, medium, or
            high is sufficient. Although you can use additional numeric values up to
            15 to achieve different effects, higher values are rendered more slowly.
            Instead of increasing the value of `quality`, you can often get
            a similar effect, and with faster rendering, by simply increasing the
            values of the `blurX` and `blurY` properties.
        **/
        get quality() {
            return this.__quality;
        }
        set quality(value) {
            if (value != this.__quality) {
                this.__renderDirty = true;
                this.__calculateNumShaderPasses();
            }
            this.__quality = value;
        }
        /**
            The strength of the imprint or spread. The higher the value, the more
            color is imprinted and the stronger the contrast between the glow and the
            background. Valid values are 0 to 255. The default is 2.
        **/
        get strength() {
            return this.__strength;
        }
        set strength(value) {
            if (value != this.__strength)
                this.__renderDirty = true;
            this.__strength = value;
        }
    }
    GlowFilter.__invertAlphaShader = new InvertAlphaShader();
    GlowFilter.__blurAlphaShader = new BlurAlphaShader();
    GlowFilter.__combineShader = new CombineShader();
    GlowFilter.__innerCombineShader = new InnerCombineShader();
    GlowFilter.__combineKnockoutShader = new CombineKnockoutShader();
    GlowFilter.__innerCombineKnockoutShader = new InnerCombineKnockoutShader();
    return GlowFilter;
})();

// import openfl._internal.backend.lime_standalone.ImageDataUtil;
class HideShader extends BitmapFilterShader {
    constructor() {
        super();
        this.glFragmentSource = `
		uniform sampler2D openfl_Texture;
		uniform sampler2D sourceBitmap;
		varying vec4 textureCoords;

		void main(void) {
			gl_FragColor = texture2D(openfl_Texture, textureCoords.zw);
		}
	`;
        this.glVertexSource = `
		attribute vec4 openfl_Position;
		attribute vec2 openfl_TextureCoord;
		uniform mat4 openfl_Matrix;
		uniform vec2 openfl_TextureSize;
		uniform vec2 offset;
		varying vec4 textureCoords;

		void main(void) {
			gl_Position = openfl_Matrix * openfl_Position;
			textureCoords = vec4(openfl_TextureCoord, openfl_TextureCoord - offset / openfl_TextureSize);
		}
	`;
        this.data.offset.value = [0, 0];
    }
}
/**
    The DropShadowFilter class lets you add a drop shadow to display objects.
    The shadow algorithm is based on the same box filter that the blur filter
    uses. You have several options for the style of the drop shadow, including
    inner or outer shadow and knockout mode. You can apply the filter to any
    display object(that is, objects that inherit from the DisplayObject
    class), such as MovieClip, SimpleButton, TextField, and Video objects, as
    well as to BitmapData objects.

    The use of filters depends on the object to which you apply the
    filter:


    * To apply filters to display objects use the `filters`
    property(inherited from DisplayObject). Setting the `filters`
    property of an object does not modify the object, and you can remove the
    filter by clearing the `filters` property.
    * To apply filters to BitmapData objects, use the
    `BitmapData.applyFilter()` method. Calling
    `applyFilter()` on a BitmapData object takes the source
    BitmapData object and the filter object and generates a filtered image as a
    result.


    If you apply a filter to a display object, the value of the
    `cacheAsBitmap` property of the display object is set to
    `true`. If you clear all filters, the original value of
    `cacheAsBitmap` is restored.

    This filter supports Stage scaling. However, it does not support general
    scaling, rotation, and skewing. If the object itself is scaled(if
    `scaleX` and `scaleY` are set to a value other than
    1.0), the filter is not scaled. It is scaled only when the user zooms in on
    the Stage.

    A filter is not applied if the resulting image exceeds the maximum
    dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in
    width or height, and the total number of pixels cannot exceed 16,777,215
    pixels.(So, if an image is 8,191 pixels wide, it can only be 2,048 pixels
    high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the
    limitation is 2,880 pixels in height and 2,880 pixels in width. If, for
    example, you zoom in on a large movie clip with a filter applied, the
    filter is turned off if the resulting image exceeds the maximum
    dimensions.
**/
let DropShadowFilter = /** @class */ (() => {
    class DropShadowFilter extends BitmapFilter {
        /**
            Creates a new DropShadowFilter instance with the specified parameters.
    
            @param distance   Offset distance for the shadow, in pixels.
            @param angle      Angle of the shadow, 0 to 360 degrees(floating point).
            @param color      Color of the shadow, in hexadecimal format
                              _0xRRGGBB_. The default value is 0x000000.
            @param alpha      Alpha transparency value for the shadow color. Valid
                              values are 0.0 to 1.0. For example, .25 sets a
                              transparency value of 25%.
            @param blurX      Amount of horizontal blur. Valid values are 0 to 255.0
                             (floating point).
            @param blurY      Amount of vertical blur. Valid values are 0 to 255.0
                             (floating point).
            @param strength   The strength of the imprint or spread. The higher the
                              value, the more color is imprinted and the stronger the
                              contrast between the shadow and the background. Valid
                              values are 0 to 255.0.
            @param quality    The number of times to apply the filter. Use the
                              BitmapFilterQuality constants:
    
                               * `BitmapFilterQuality.LOW`
                               * `BitmapFilterQuality.MEDIUM`
                               * `BitmapFilterQuality.HIGH`
    
    
                              For more information about these values, see the
                              `quality` property description.
            @param inner      Indicates whether or not the shadow is an inner shadow.
                              A value of `true` specifies an inner shadow.
                              A value of `false` specifies an outer shadow
                             (a shadow around the outer edges of the object).
            @param knockout   Applies a knockout effect(`true`), which
                              effectively makes the object's fill transparent and
                              reveals the background color of the document.
            @param hideObject Indicates whether or not the object is hidden. A value
                              of `true` indicates that the object itself is
                              not drawn; only the shadow is visible.
        **/
        constructor(distance = 4, angle = 45, color = 0, alpha = 1, blurX = 4, blurY = 4, strength = 1, quality = 1, inner = false, knockout = false, hideObject = false) {
            super();
            this.__offsetX = 0;
            this.__offsetY = 0;
            this.__distance = distance;
            this.__angle = angle;
            this.__color = color;
            this.__alpha = alpha;
            this.__blurX = blurX;
            this.__blurY = blurY;
            this.__strength = strength;
            this.__quality = quality;
            this.__inner = inner;
            this.__knockout = knockout;
            this.__hideObject = hideObject;
            this.__updateSize();
            this.__needSecondBitmapData = true;
            this.__preserveObject = true;
            this.__renderDirty = true;
        }
        clone() {
            return new DropShadowFilter(this.__distance, this.__angle, this.__color, this.__alpha, this.__blurX, this.__blurY, this.__strength, this.__quality, this.__inner, this.__knockout, this.__hideObject);
        }
        __applyFilter(bitmapData, sourceBitmapData, sourceRect, destPoint) {
            // TODO: Support knockout, inner
            // var r = (this.__color >> 16) & 0xFF;
            // var g = (this.__color >> 8) & 0xFF;
            // var b = this.__color & 0xFF;
            // var point = new Point(destPoint.x + this.__offsetX, destPoint.y + this.__offsetY);
            // var finalImage = ImageDataUtil.gaussianBlur(bitmapData.limeImage, sourceBitmapData.limeImage, sourceRect.__toLimeRectangle(), point.__toLimeVector2(),
            // 	this.__blurX, this.__blurY, this.__quality, this.__strength);
            // finalImage.colorTransform(finalImage.rect, new ColorTransform(0, 0, 0, this.__alpha, r, g, b, 0).__toLimeColorMatrix());
            // if (finalImage == bitmapData.limeImage) return bitmapData;
            return sourceBitmapData;
        }
        __initShader(renderer, pass, sourceBitmapData) {
            // Drop shadow is glow with an offset
            if (this.__inner && pass == 0) {
                return GlowFilter.__invertAlphaShader;
            }
            var blurPass = pass - (this.__inner ? 1 : 0);
            var numBlurPasses = this.__horizontalPasses + this.__verticalPasses;
            var shader = null;
            if (blurPass < numBlurPasses) {
                var shader = GlowFilter.__blurAlphaShader;
                var uRadius = shader.data.uRadius;
                var uColor = shader.data.uColor;
                var uStrength = shader.data.uStrength;
                if (blurPass < this.__horizontalPasses) {
                    var scale = Math.pow(0.5, blurPass >> 1) * 0.5;
                    uRadius.value[0] = this.blurX * scale;
                    uRadius.value[1] = 0;
                }
                else {
                    var scale = Math.pow(0.5, (blurPass - this.__horizontalPasses) >> 1) * 0.5;
                    uRadius.value[0] = 0;
                    uRadius.value[1] = this.blurY * scale;
                }
                uColor.value[0] = ((this.color >> 16) & 0xFF) / 255;
                uColor.value[1] = ((this.color >> 8) & 0xFF) / 255;
                uColor.value[2] = (this.color & 0xFF) / 255;
                uColor.value[3] = this.alpha;
                uStrength.value[0] = blurPass == (numBlurPasses - 1) ? this.__strength : 1.0;
                return shader;
            }
            if (this.__inner) {
                if (this.__knockout || this.__hideObject) {
                    var shader = GlowFilter.__innerCombineKnockoutShader;
                    shader.data.sourceBitmap.input = sourceBitmapData;
                    shader.data.offset.value[0] = this.__offsetX;
                    shader.data.offset.value[1] = this.__offsetY;
                    return shader;
                }
                var shader = GlowFilter.__innerCombineShader;
                shader.data.sourceBitmap.input = sourceBitmapData;
                shader.data.offset.value[0] = this.__offsetX;
                shader.data.offset.value[1] = this.__offsetY;
                return shader;
            }
            else {
                if (this.__knockout) {
                    var shader = GlowFilter.__combineKnockoutShader;
                    shader.data.sourceBitmap.input = sourceBitmapData;
                    shader.data.offset.value[0] = this.__offsetX;
                    shader.data.offset.value[1] = this.__offsetY;
                    return shader;
                }
                else if (this.__hideObject) {
                    var shader = DropShadowFilter.__hideShader;
                    shader.data.sourceBitmap.input = sourceBitmapData;
                    shader.data.offset.value[0] = this.__offsetX;
                    shader.data.offset.value[1] = this.__offsetY;
                    return shader;
                }
                var shader = GlowFilter.__combineShader;
                shader.data.sourceBitmap.input = sourceBitmapData;
                shader.data.offset.value[0] = this.__offsetX;
                shader.data.offset.value[1] = this.__offsetY;
                return shader;
            }
        }
        __updateSize() {
            this.__offsetX = Math.floor(this.__distance * Math.cos(this.__angle * Math.PI / 180));
            this.__offsetY = Math.floor(this.__distance * Math.sin(this.__angle * Math.PI / 180));
            this.__topExtension = Math.ceil((this.__offsetY < 0 ? -this.__offsetY : 0) + this.__blurY);
            this.__bottomExtension = Math.ceil((this.__offsetY > 0 ? this.__offsetY : 0) + this.__blurY);
            this.__leftExtension = Math.ceil((this.__offsetX < 0 ? -this.__offsetX : 0) + this.__blurX);
            this.__rightExtension = Math.ceil((this.__offsetX > 0 ? this.__offsetX : 0) + this.__blurX);
            this.__calculateNumShaderPasses();
        }
        __calculateNumShaderPasses() {
            this.__horizontalPasses = Math.round(this.__blurX * (this.__quality / 4)) + 1;
            this.__verticalPasses = Math.round(this.__blurY * (this.__quality / 4)) + 1;
            this.__numShaderPasses = this.__horizontalPasses + this.__verticalPasses + (this.__inner ? 2 : 1);
        }
        // Get & Set Methods
        /**
            The alpha transparency value for the shadow color. Valid values are 0.0 to
            1.0. For example, .25 sets a transparency value of 25%. The default value
            is 1.0.
        **/
        get alpha() {
            return this.__alpha;
        }
        set alpha(value) {
            if (value != this.__alpha)
                this.__renderDirty = true;
            this.__alpha = value;
        }
        /**
            The angle of the shadow. Valid values are 0 to 360 degrees(floating
            point). The default value is 45.
        **/
        get angle() {
            return this.__angle;
        }
        set angle(value) {
            if (value != this.__angle) {
                this.__angle = value;
                this.__renderDirty = true;
                this.__updateSize();
            }
        }
        /**
            The amount of horizontal blur. Valid values are 0 to 255.0(floating
            point). The default value is 4.0.
        **/
        get blurX() {
            return this.__blurX;
        }
        set blurX(value) {
            if (value != this.__blurX) {
                this.__blurX = value;
                this.__renderDirty = true;
                this.__updateSize();
            }
        }
        /**
            The amount of vertical blur. Valid values are 0 to 255.0(floating point).
            The default value is 4.0.
        **/
        get blurY() {
            return this.__blurY;
        }
        set blurY(value) {
            if (value != this.__blurY) {
                this.__blurY = value;
                this.__renderDirty = true;
                this.__updateSize();
            }
        }
        /**
            The color of the shadow. Valid values are in hexadecimal format
            _0xRRGGBB_. The default value is 0x000000.
        **/
        get color() {
            return this.__color;
        }
        set color(value) {
            if (value != this.__color)
                this.__renderDirty = true;
            this.__color = value;
        }
        /**
            The offset distance for the shadow, in pixels. The default value is 4.0
            (floating point).
        **/
        get distance() {
            return this.__distance;
        }
        set distance(value) {
            if (value != this.__distance) {
                this.__distance = value;
                this.__renderDirty = true;
                this.__updateSize();
            }
        }
        /**
            Indicates whether or not the object is hidden. The value `true`
            indicates that the object itself is not drawn; only the shadow is visible.
            The default is `false`(the object is shown).
        **/
        get hideObject() {
            return this.__hideObject;
        }
        set hideObject(value) {
            if (value != this.__hideObject) {
                this.__renderDirty = true;
            }
            this.__hideObject = value;
        }
        /**
            Indicates whether or not the shadow is an inner shadow. The value
            `true` indicates an inner shadow. The default is
            `false`, an outer shadow(a shadow around the outer edges of
            the object).
        **/
        get inner() {
            return this.__inner;
        }
        set inner(value) {
            if (value != this.__inner)
                this.__renderDirty = true;
            this.__inner = value;
        }
        /**
            Applies a knockout effect(`true`), which effectively makes the
            object's fill transparent and reveals the background color of the
            document. The default is `false`(no knockout).
        **/
        get knockout() {
            return this.__knockout;
        }
        set knockout(value) {
            if (value != this.__knockout)
                this.__renderDirty = true;
            this.__knockout = value;
        }
        /**
            The number of times to apply the filter. The default value is
            `BitmapFilterQuality.LOW`, which is equivalent to applying the
            filter once. The value `BitmapFilterQuality.MEDIUM` applies the
            filter twice; the value `BitmapFilterQuality.HIGH` applies it
            three times. Filters with lower values are rendered more quickly.
    
            For most applications, a quality value of low, medium, or high is
            sufficient. Although you can use additional numeric values up to 15 to
            achieve different effects, higher values are rendered more slowly. Instead
            of increasing the value of `quality`, you can often get a
            similar effect, and with faster rendering, by simply increasing the values
            of the `blurX` and `blurY` properties.
        **/
        get quality() {
            return this.__quality;
        }
        set quality(value) {
            if (value != this.__quality)
                this.__renderDirty = true;
            this.__quality = value;
        }
        /**
            The strength of the imprint or spread. The higher the value, the more
            color is imprinted and the stronger the contrast between the shadow and
            the background. Valid values are from 0 to 255.0. The default is 1.0.
        **/
        get strength() {
            return this.__strength;
        }
        set strength(value) {
            if (value != this.__strength)
                this.__renderDirty = true;
            this.__strength = value;
        }
    }
    DropShadowFilter.__hideShader = new HideShader();
    return DropShadowFilter;
})();

/**
    The ShaderFilter class applies a filter by executing a shader on the
    object being filtered. The filtered object is used as an input to the
    shader, and the shader output becomes the filter result.
    To create a new filter, use the constructor `new ShaderFilter()`. The use
    of filters depends on the object to which you apply the filter:

    * To apply filters to movie clips, text fields, buttons, and video, use
    the `filters` property (inherited from DisplayObject). Setting the
    `filters` property of an object does not modify the object, and you can
    remove the filter by clearing the `filters` property.
    * To apply filters to BitmapData objects, use the
    `BitmapData.applyFilter()` method. Calling `applyFilter()` on a BitmapData
    object takes the source BitmapData object and the filter object and
    generates a filtered image as a result.

    If you apply a filter to a display object, the value of the
    `cacheAsBitmap` property of the object is set to true. If you remove all
    filters, the original value of `cacheAsBitmap` is restored.

    This filter supports stage scaling. However, it does not support general
    scaling, rotation, and skewing. If the object itself is scaled (if the
    `scaleX` and `scaleY` properties are not set to 100%), the filter is not
    scaled. It is scaled only when the user zooms in on the stage.

    A filter is not applied if the resulting image exceeds the maximum
    dimensions. In AIR 1.5 and Flash Player 10, the maximum is 8,191 pixels in
    width or height, and the total number of pixels cannot exceed 16,777,215
    pixels. (So, if an image is 8,191 pixels wide, it can only be 2,048 pixels
    high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the
    limitation is 2,880 pixels in height and 2,880 pixels in width. If, for
    example, you zoom in on a large movie clip with a filter applied, the
    filter is turned off if the resulting image exceeds the maximum
    dimensions.

    To specify the Shader instance to use with the filter, pass the Shader
    instance as an argument to the `ShaderFilter()` constructor, or set it as
    the value of the `shader` property.

    To allow the shader output to extend beyond the bounds of the filtered
    object, use the `leftExtension`, `rightExtension`, `topExtension`, and
    `bottomExtension` properties.
**/
class ShaderFilter extends BitmapFilter {
    /**
        Creates a new shader filter.

        @param shader The Shader to use for this filter. For details and
                        limitations that the shader must conform to, see the
                        description for the `shader` property.
    **/
    constructor(shader) {
        super();
        this.shader = shader;
        this.__numShaderPasses = 1;
    }
    clone() {
        var filter = new ShaderFilter(this.shader);
        filter.bottomExtension = this.bottomExtension;
        filter.leftExtension = this.leftExtension;
        filter.rightExtension = this.rightExtension;
        filter.topExtension = this.topExtension;
        return filter;
    }
    invalidate() {
        this.__renderDirty = true;
    }
    __initShader(renderer, pass, sourceBitmapData) {
        this.__shaderBlendMode = this.blendMode;
        return this.shader;
    }
}

/**
    The `PerspectiveProjection` class provides an easy way to assign or modify the perspective
    transformations of a display object and all of its children. For more complex or custom
    perspective transformations, use the `Matrix3D` class. While the `PerspectiveProjection` class
    provides basic three-dimensional presentation properties, the `Matrix3D` class provides more
    detailed control over the three-dimensional presentation of display objects.

    Projection is a way of representing a three-dimensional object in a two-dimensional space,
    like a cube projected onto a computer screen. Perspective projection uses a viewing frustum
    (a rectangular pyramid) to model and project a three-dimensional world and its objects on the screen.
    The viewing frustum becomes increasingly wider as it moves further from the origin of the viewpoint.
    The origin of the viewpoint could be a camera or the eyes of an observer facing the screen.
    The projected perspective produces the illusion of three dimensions with depth and distance,
    where the objects closer to the screen appear larger than the objects farther from the screen.

    ![Frustum viewing area](/images/frustum.jpg)

    A default `PerspectiveProjection` object is a framework defined for perspective transformation of
    the root object, based on the field of view and aspect ratio (dimensions) of the stage.
    The projection center, the vanishing point, is set to the center of the stage, which means the
    three-dimensional display objects disappear toward the center of the stage as they move
    back in the z axis. The default viewpoint is at point (0,0) looking down the positive z axis.
    The y-axis points down toward the bottom of the screen. You can gain access to the root display
    object's perspective projection settings and change the field of view and projection center
    properties of the perspectiveProjection property through the root object's `DisplayObject.transform`
    property.

    You can also set a different perspective projection setting for a display object through the parent's
    perspective projection. First, create a `PerspectiveProjection` object and set its `fieldOfView` and
    projectionCenter properties. Next, assign the `PerspectiveProjection` object to the parent display
    object using the `DisplayObject.transform` property. The specified projection matrix and transformation
    will then apply to all the display object's three-dimensional children.
**/
let PerspectiveProjection = /** @class */ (() => {
    class PerspectiveProjection {
        /**
            Creates an instance of a PerspectiveProjection object.
        **/
        constructor() {
            this.__fieldOfView = 0;
            this.focalLength = 0;
            this.matrix3D = new Matrix3D();
            this.projectionCenter = new Point(Lib$1.current.stage.stageWidth / 2, Lib$1.current.stage.stageHeight / 2);
        }
        /**
            Returns the underlying Matrix3D object of the display object.
    
            A display object, like the root object, can have a `PerspectiveProjection` object without needing a `Matrix3D`
            property defined for its transformations. In fact, use either a `PerspectiveProjection` or a `Matrix3D` object
            to specify the perspective transformation. If when using the `PerspectiveProjection` object, a `Matrix3D`
            object was needed, the `toMatrix3D()` method can retrieve the underlying `Matrix3D` object of the display object.
            For example, the `toMatrix3D()` method can be used with the `Utils3D.projectVectors()` method.
            @return The underlying `Matrix3D` object.
        **/
        toMatrix3D() {
            if (this.projectionCenter == null)
                return null;
            var _mp = this.matrix3D.rawData;
            _mp[0] = this.focalLength;
            _mp[5] = this.focalLength;
            _mp[11] = 1.0;
            _mp[15] = 0;
            // matrix3D.rawData = [357.0370178222656,0,0,0,0,357.0370178222656,0,0,0,0,1,1,0,0,0,0];
            return this.matrix3D;
        }
        // Getters & Setters
        /**
            Specifies an angle, as a degree between 0 and 180, for the field of view in three dimensions.
            This value determines how strong the perspective transformation and distortion apply to a
            three-dimensional display object with a non-zero z-coordinate.
    
            A degree close to 0 means that the screen's two-dimensional x- and y-coordinates are roughly
            the same as the three-dimensional x-, y-, and z-coordinates with little or no distortion.
            In other words, for a small angle, a display object moving down the z axis appears to stay
            near the same size and moves little.
    
            A value close to 180 degrees results in a fisheye lens effect: positions with a z value smaller
            than 0 are magnified, while positions with a z value larger than 0 are minimized. With a
            large angle, a display object moving down the z axis appears to change size quickly and moves
            a great distance. If the field of view is set to 0 or 180, nothing is seen on the screen.
        **/
        get fieldOfView() {
            return this.__fieldOfView;
        }
        set fieldOfView(fieldOfView) {
            this.__fieldOfView = fieldOfView * PerspectiveProjection.TO_RADIAN;
            this.focalLength = 250.0 * (1.0 / Math.tan(this.__fieldOfView * 0.5));
        }
    }
    PerspectiveProjection.TO_RADIAN = 0.01745329251994329577; // Math.PI / 180
    return PerspectiveProjection;
})();

/**
    The Utils3D class contains static methods that simplify the implementation of
    certain three-dimensional matrix operations.
**/
class Utils3D {
    /**
        Interpolates the orientation of an object toward a position. The `pointTowards()`
        method combines the functionality of the `Matrix3D.pointAt()` and
        `Matrix3D.interpolateTo()` methods.

        The `pointTowards()` method allows for in-place modification to the orientation.
        It decomposes the Matrix3D of the display object and replaces the rotation
        elements by ones that make a percent turn toward the position of the target. The
        object can make an incremental turn toward the target while still moving in its
        own direction. The consecutive calls to the `pointTowards()` followed by a
        translation method can produce the animation of an object chasing or following a
        moving target. First point the object a percent point toward the target, then
        incrementally move the object along an axis.

        @param	percent	A Number between 0 and 1 that incrementally turns the object
        toward the target.
        @param	mat	The Matrix3D property of the object that is transformed.
        @param	pos	The world-relative position of the target object. World-relative
        defines the transformation of the object relative to the world space and
        coordinates, where all objects are positioned.
        @param	at	The object-relative vector that defines where the display object is
        pointing. Object-relative defines the transformation of the object relative to the
        object space, the object's own frame of reference and coordinate system. Default
        value is (0,0,-1).
        @param	up	The object-relative vector that defines "up" for the display object.
        If the object is drawn looking down from the above, the +z axis is its "up"
        vector. Object-relative defines the transformation of the object relative to the
        object space, the object's own frame of reference and coordinate system. Default
        value is (0,-1,0).
        @returns	A modified version of the Matrix3D object specified in the second
        parameter. To transform the display object using the `pointTowards()` method, set
        the Matrix3D property of the display object to the returned Matrix3D object.
    **/
    // static pointTowards(percent  : number, mat : Matrix3D, pos : Vector3D, ?at : Vector3D, ?up : Vector3D) : Matrix3D;
    /**
        Using a projection Matrix3D object, projects a Vector3D object from one space
        coordinate to another. The `projectVector()` method is like the
        `Matrix3D.transformVector()` method except that the `projectVector()` method
        divides the x, y, and z elements of the original Vector3D object by the
        projection depth value. The depth value is the distance from the eye to the
        Vector3D object in view or eye space. The default value for this distance is the
        value of the z element.

        @param	m	A projection Matrix3D object that implements the projection
        transformation. If a display object has a PerspectiveProjection object, you can
        use the `perspectiveProjection.toMatrix()` method to produce a projection Matrix3D
        object that applies to the children of the display object. For more advance
        projections, use the `matrix3D.rawData` property to create a custom projection
        matrix. There is no built-in Matrix3D method for creating a projection Matrix3D
        object.
        @param	v	The Vector3D object that is projected to a new space coordinate.
        @returns	A new Vector3D with a transformed space coordinate.
    **/
    static projectVector(m, v) {
        var n = m.rawData;
        var l_oProj = new Vector3D();
        l_oProj.x = v.x * n[0] + v.y * n[4] + v.z * n[8] + n[12];
        l_oProj.y = v.x * n[1] + v.y * n[5] + v.z * n[9] + n[13];
        l_oProj.z = v.x * n[2] + v.y * n[6] + v.z * n[10] + n[14];
        var w = v.x * n[3] + v.y * n[7] + v.z * n[11] + n[15];
        l_oProj.z /= w;
        l_oProj.x /= w;
        l_oProj.y /= w;
        return l_oProj;
    }
    /**
        Using a projection Matrix3D object, projects a Vector of three-dimensional space
        coordinates (`verts`) to a Vector of two-dimensional space coordinates
        (`projectedVerts`). The projected Vector object should be pre-allocated before it
        is used as a parameter.

        The `projectVectors()` method also sets the t value of the uvt data. You should
        pre-allocate a Vector that can hold the uvts data for each projected Vector set of
        coordinates. Also specify the u and v values of the uvt data. The uvt data is a
        Vector of normalized coordinates used for texture mapping. In UV coordinates,
        (0,0) is the upper left of the bitmap, and (1,1) is the lower right of the bitmap.

        This method can be used in conjunction with the `Graphics.drawTriangles()` method
        and the GraphicsTrianglePath class.

        @param	m	A projection Matrix3D object that implements the projection
        transformation. You can produce a projection Matrix3D object using the
        `Matrix3D.rawData` property.
        @param	verts	A Vector of Floats, where every three Floats represent the x, y,
        and z coordinates of a three-dimensional space, like `Vector3D(x,y,z)`.
        @param	projectedVerts	A vector of Floats, where every two Floats represent a
        projected two-dimensional coordinate, like Point(x,y). You should pre-allocate the
        Vector. The `projectVectors()` method fills the values for each projected point.
        @param	uvts	A vector of Floats, where every three Floats represent the u, v,
        and t elements of the uvt data. The u and v are the texture coordinate for each
        projected point. The t value is the projection depth value, the distance from
        the eye to the Vector3D object in the view or eye space. You should pre-allocate
        the Vector and specify the u and v values. The projectVectors method fills the t
        value for each projected point.
    **/
    static projectVectors(m, verts, projectedVerts, uvts) {
        if (verts.length % 3 != 0)
            return;
        var n = m.rawData;
        var x, y, z, w;
        var x1, y1, z1, w1;
        var i = 0;
        while (i < verts.length) {
            x = verts[i];
            y = verts[i + 1];
            z = verts[i + 2];
            w = 1;
            x1 = x * n[0] + y * n[4] + z * n[8] + w * n[12];
            y1 = x * n[1] + y * n[5] + z * n[9] + w * n[13];
            z1 = x * n[2] + y * n[6] + z * n[10] + w * n[14];
            w1 = x * n[3] + y * n[7] + z * n[11] + w * n[15];
            projectedVerts.push(x1 / w1);
            projectedVerts.push(y1 / w1);
            uvts[i + 2] = 1 / w1;
            i += 3;
        }
    }
}

var openfl$D;
(function (openfl) {
    var media;
    (function (media) {
        /**
            The ID3Info class contains properties that reflect ID3 metadata. You can get
            additional metadata for MP3 files by accessing the `id3` property of the Sound
            class; for example, `mySound.id3.TIME`. For more information, see the entry for
            `Sound.id3` and the ID3 tag definitions at http://www.id3.org.
        **/
        class ID3Info {
            constructor() { }
        }
        media.ID3Info = ID3Info;
    })(media = openfl.media || (openfl.media = {}));
})(openfl$D || (openfl$D = {}));
var ID3Info = openfl$D.media.ID3Info;

/**
    The Sound class lets you work with sound in an application. The Sound class
    lets you create a Sound object, load and play an external MP3 file into
    that object, close the sound stream, and access data about the sound, such
    as information about the number of bytes in the stream and ID3 metadata.
    More detailed control of the sound is performed through the sound source
     -  the SoundChannel or Microphone object for the sound  -  and through the
    properties in the SoundTransform class that control the output of the sound
    to the computer's speakers.

    In Flash Player 10 and later and AIR 1.5 and later, you can also use
    this class to work with sound that is generated dynamically. In this case,
    the Sound object uses the you assign to a `sampleData`
    event handler to poll for sound data. The sound is played as it is
    retrieved from a ByteArray object that you populate with sound data. You
    can use `Sound.extract()` to extract sound data from a Sound
    object, after which you can manipulate it before writing it back to the
    stream for playback.

    To control sounds that are embedded in a SWF file, use the properties in
    the SoundMixer class.

    **Note**: The ActionScript 3.0 Sound API differs from ActionScript
    2.0. In ActionScript 3.0, you cannot take sound objects and arrange them in
    a hierarchy to control their properties.

    When you use this class, consider the following security model:


    * Loading and playing a sound is not allowed if the calling file is in
    a network sandbox and the sound file to be loaded is local.
    * By default, loading and playing a sound is not allowed if the calling
    file is local and tries to load and play a remote sound. A user must grant
    explicit permission to allow this type of access.
    * Certain operations dealing with sound are restricted. The data in a
    loaded sound cannot be accessed by a file in a different domain unless you
    implement a cross-domain policy file. Sound-related APIs that fall under
    this restriction are `Sound.id3`,
    `SoundMixer.computeSpectrum()`,
    `SoundMixer.bufferTime`, and the `SoundTransform`
    class.


    However, in Adobe AIR, content in the `application` security
    sandbox(content installed with the AIR application) are not restricted by
    these security limitations.

    For more information related to security, see the Flash Player Developer
    Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).

    @event complete   Dispatched when data has loaded successfully.
    @event id3        Dispatched by a Sound object when ID3 data is available
                      for an MP3 sound.
    @event ioError    Dispatched when an input/output error occurs that causes
                      a load operation to fail.
    @event open       Dispatched when a load operation starts.
    @event progress   Dispatched when data is received as a load operation
                      progresses.
    @event sampleData Dispatched when the runtime requests new audio data.
**/
class Sound extends EventDispatcher {
    /**
        Creates a new Sound object. If you pass a valid URLRequest object to the
        Sound constructor, the constructor automatically calls the
        `load()` for the Sound object. If you do not pass a
        valid URLRequest object to the Sound constructor, you must call the
        `load()` for the Sound object yourself, or the stream
        will not load.

        Once `load()` is called on a Sound object, you can't later
        load a different sound file into that Sound object. To load a different
        sound file, create a new Sound object.
        In Flash Player 10 and later and AIR 1.5 and later, instead of using
        `load()`, you can use the `sampleData` event handler
        to load sound dynamically into the Sound object.

        @param stream  The URL that points to an external MP3 file.
        @param context An optional SoundLoader context object, which can define
                       the buffer time(the minimum number of milliseconds of MP3
                       data to hold in the Sound object's buffer) and can specify
                       whether the application should check for a cross-domain
                       policy file prior to loading the sound.
    **/
    constructor(stream = null, context = null) {
        super();
        this.bytesLoaded = 0;
        this.bytesTotal = 0;
        this.isBuffering = false;
        this.url = null;
        // __backend = new SoundBackend(this);
        if (stream != null) {
            this.load(stream, context);
        }
    }
    /**
        Closes the stream, causing any download of data to cease. No data may
        be read from the stream after the `close()` method is called.

        @throws IOError The stream could not be closed, or the stream was not
                        open.
    **/
    close() {
        // __backend.close();
    }
    /**
        Extracts raw sound data from a Sound object.
        This method is designed to be used when you are working with
        dynamically generated audio, using a you assign to the
        `sampleData` event for a different Sound object. That is, you can use
        this method to extract sound data from a Sound object. Then you can
        write the data to the byte array that another Sound object is using to
        stream dynamic audio.

        The audio data is placed in the target byte array starting from the
        current position of the byte array. The audio data is always exposed
        as 44100 Hz Stereo. The sample type is a 32-bit floating-point value,
        which can be converted to a Number using `ByteArray.readFloat()`.

        @param target A ByteArray object in which the extracted sound samples
                      are placed.
        @param length The number of sound samples to extract. A sample
                      contains both the left and right channels נthat is,
                      two 32-bit floating-point values.
        @return The number of samples written to the ByteArray specified in
                the `target` parameter.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public extract (target:ByteArray, length:Float, startPosition:Float = -1):Float;
    /**
        Creates a new Sound from a file path synchronously. This means that the
        Sound will be returned immediately (if supported).

        HTML5 and Flash do not support creating Sound synchronously, so these targets
        always return `null`.

        In order to load files from a remote web address, use the `loadFromFile` method,
        which supports asynchronous loading.

        @param	path	A local file path containing a sound
        @returns	A new Sound if successful, or `null` if unsuccessful
    **/
    static fromFile(path) {
        if (path == null)
            return null;
        // return SoundBackend.fromFile(path);
        return null;
    }
    /**
        Initiates loading of an external MP3 file from the specified URL. If you
        provide a valid URLRequest object to the Sound constructor, the
        constructor calls `Sound.load()` for you. You only need to call
        `Sound.load()` yourself if you don't pass a valid URLRequest
        object to the Sound constructor or you pass a `null` value.

        Once `load()` is called on a Sound object, you can't later
        load a different sound file into that Sound object. To load a different
        sound file, create a new Sound object.

        When using this method, consider the following security model:

        * Calling `Sound.load()` is not allowed if the calling file
        is in the local-with-file-system sandbox and the sound is in a network
        sandbox.
        * Access from the local-trusted or local-with-networking sandbox
        requires permission from a website through a URL policy file.
        * You cannot connect to commonly reserved ports. For a complete list
        of blocked ports, see "Restricting Networking APIs" in the _ActionScript
        3.0 Developer's Guide_.
        * You can prevent a SWF file from using this method by setting the
        `allowNetworking` parameter of the `object` and
        `embed` tags in the HTML page that contains the SWF
        content.

         In Flash Player 10 and later, if you use a multipart Content-Type(for
        example "multipart/form-data") that contains an upload(indicated by a
        "filename" parameter in a "content-disposition" header within the POST
        body), the POST operation is subject to the security rules applied to
        uploads:

        * The POST operation must be performed in response to a user-initiated
        action, such as a mouse click or key press.
        * If the POST operation is cross-domain(the POST target is not on the
        same server as the SWF file that is sending the POST request), the target
        server must provide a URL policy file that permits cross-domain
        access.


        Also, for any multipart Content-Type, the syntax must be valid
        (according to the RFC2046 standards). If the syntax appears to be invalid,
        the POST operation is subject to the security rules applied to
        uploads.

        In Adobe AIR, content in the `application` security sandbox
        (content installed with the AIR application) are not restricted by these
        security limitations.

        For more information related to security, see the Flash Player
        Developer Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).

        @param stream  A URL that points to an external MP3 file.
        @param context An optional SoundLoader context object, which can define
                       the buffer time(the minimum number of milliseconds of MP3
                       data to hold in the Sound object's buffer) and can specify
                       whether the application should check for a cross-domain
                       policy file prior to loading the sound.
        @throws IOError       A network error caused the load to fail.
        @throws IOError       The `digest` property of the
                              `stream` object is not `null`.
                              You should only set the `digest` property
                              of a URLRequest object when calling the
                              `URLLoader.load()` method when loading a
                              SWZ file(an Adobe platform component).
        @throws SecurityError Local untrusted files may not communicate with the
                              Internet. You can work around this by reclassifying
                              this file as local-with-networking or trusted.
        @throws SecurityError You cannot connect to commonly reserved ports. For a
                              complete list of blocked ports, see "Restricting
                              Networking APIs" in the _ActionScript 3.0
                              Developer's Guide_.
    **/
    load(stream, context = null) {
        this.url = stream.url;
        if (this.url != null) ;
        else {
            this.dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR));
        }
    }
    /**
        Load MP3 sound data from a ByteArray object into a Sound object. The data will be read from the current
        ByteArray position and will leave the ByteArray position at the end of the specified bytes length once
        finished. If the MP3 sound data contains ID3 data ID3 events will be dispatched during this call.
        This will throw an exception if the ByteArray object does not contain enough data.

        @param	bytes
        @param	bytesLength
    **/
    loadCompressedDataFromByteArray(bytes, bytesLength) {
        if (bytes == null || bytesLength <= 0) {
            this.dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR));
            return;
        }
        // __backend.loadCompressedDataFromByteArray(bytes, bytesLength);
    }
    /**
        Creates a new Sound from a file path or web address asynchronously. The file
        load will occur in the background.

        Progress, completion and error callbacks will be dispatched in the current
        thread using callbacks attached to a returned Future object.

        @param	path	A local file path or web address containing a sound
        @returns	A Future Sound
    **/
    static loadFromFile(path) {
        // return SoundBackend.loadFromFile(path);
        return null;
    }
    /**
        Creates a new Sound from a set of file paths or web addresses asynchronously.
        The audio backend will choose the first compatible file format, and will load the file
        it selects in the background.

        Progress, completion and error callbacks will be dispatched in the current
        thread using callbacks attached to a returned Future object.

        @param	paths	A set of local file paths or web addresses containing sound
        @returns	A Future Sound
    **/
    static loadFromFiles(paths) {
        if (paths == null)
            return Future.withError("");
        // return SoundBackend.loadFromFiles(paths);
        return null;
    }
    /**
        Load PCM 32-bit floating point sound data from a ByteArray object into a Sound object. The data will be read
        from the current ByteArray position and will leave the ByteArray position at the end of the specified sample
        length multiplied by either 1 channel or 2 channels if the stereo flag is set once finished.

        Starting with Flash Player 11.8, the amount of audio data that can be passed to this is limited. For
        SWF versions >= 21, this throws an exception if the amount of audio data passed into this is
        more than 1800 seconds. That is, samples / sampleRate should be less than or equal to 1800. For swf versions <
        21, the runtime fails silently if the amount of audio data passed in is more than 12000 seconds. This is
        provided only for backward compatibility.

        This throws an exception if the ByteArray object does not contain enough data.

        @param	bytes
        @param	samples
        @param	format
        @param	stereo
        @param	sampleRate
    **/
    loadPCMFromByteArray(bytes, samples, format = "float", stereo = true, sampleRate = 44100) {
        if (bytes == null) {
            this.dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR));
            return;
        }
        // __backend.loadPCMFromByteArray(bytes, samples, format, stereo, sampleRate);
    }
    /**
        Generates a new SoundChannel object to play back the sound. This method
        returns a SoundChannel object, which you access to stop the sound and to
        monitor volume.(To control the volume, panning, and balance, access the
        SoundTransform object assigned to the sound channel.)

        @param startTime    The initial position in milliseconds at which playback
                            should start.
        @param loops        Defines the number of times a sound loops back to the
                            `startTime` value before the sound channel
                            stops playback.
        @param sndTransform The initial SoundTransform object assigned to the
                            sound channel.
        @return A SoundChannel object, which you use to control the sound. This
                method returns `null` if you have no sound card or if
                you run out of available sound channels. The maximum number of
                sound channels available at once is 32.
    **/
    play(startTime = 0.0, loops = 0, sndTransform = null) {
        // return __backend.play(startTime, loops, sndTransform);
        return null;
    }
    // Get & Set Methods
    /**
        Provides access to the metadata that is part of an MP3 file.
        MP3 sound files can contain ID3 tags, which provide metadata about the
        file. If an MP3 sound that you load using the `Sound.load()` method
        contains ID3 tags, you can query these properties. Only ID3 tags that
        use the UTF-8 character set are supported.

        Flash Player 9 and later and AIR support ID3 2.0 tags, specifically
        2.3 and 2.4. The following tables list the standard ID3 2.0 tags and
        the type of content the tags represent. The `Sound.id3` property
        provides access to these tags through the format `my_sound.id3.COMM`,
        `my_sound.id3.TIME`, and so on. The first table describes tags that
        can be accessed either through the ID3 2.0 property name or the
        ActionScript property name. The second table describes ID3 tags that
        are supported but do not have predefined properties in ActionScript.

        | ID3 2.0 tag | Corresponding Sound class property |
        | --- | --- |
        | COMM | Sound.id3.comment |
        | TALB | Sound.id3.album |
        | TCON | Sound.id3.genre |
        | TIT2 | Sound.id3.songName |
        | TPE1 | Sound.id3.artist |
        | TRCK | Sound.id3.track |
        | TYER | Sound.id3.year |

        The following table describes ID3 tags that are supported but do not
        have predefined properties in the Sound class. You access them by
        calling `mySound.id3.TFLT`, `mySound.id3.TIME`, and so on. **NOTE:**
        None of these tags are supported in Flash Lite 4.

        | Property | Description |
        | --- | --- |
        | TFLT | File type |
        | TIME | Time |
        | TIT1 | Content group description |
        | TIT2 | Title/song name/content description |
        | TIT3 | Subtitle/description refinement |
        | TKEY | Initial key |
        | TLAN | Languages |
        | TLEN | Length |
        | TMED | Media type |
        | TOAL | Original album/movie/show title |
        | TOFN | Original filename |
        | TOLY | Original lyricists/text writers |
        | TOPE | Original artists/performers |
        | TORY | Original release year |
        | TOWN | File owner/licensee |
        | TPE1 | Lead performers/soloists |
        | TPE2 | Band/orchestra/accompaniment |
        | TPE3 | Conductor/performer refinement |
        | TPE4 | Interpreted, remixed, or otherwise modified by |
        | TPOS | Part of a set |
        | TPUB | Publisher |
        | TRCK | Track number/position in set |
        | TRDA | Recording dates |
        | TRSN | Internet radio station name |
        | TRSO | Internet radio station owner |
        | TSIZ | Size |
        | TSRC | ISRC (international standard recording code) |
        | TSSE | Software/hardware and settings used for encoding |
        | TYER | Year |
        | WXXX | URL link frame |

        When using this property, consider the Flash Player security model:

        * The `id3` property of a Sound object is always permitted for SWF
        files that are in the same security sandbox as the sound file. For
        files in other sandboxes, there are security checks.
        * When you load the sound, using the `load()` method of the Sound
        class, you can specify a `context` parameter, which is a
        SoundLoaderContext object. If you set the `checkPolicyFile` property
        of the SoundLoaderContext object to `true`, Flash Player checks for a
        URL policy file on the server from which the sound is loaded. If a
        policy file exists and permits access from the domain of the loading
        SWF file, then the file is allowed to access the `id3` property of the
        Sound object; otherwise it is not.

        However, in Adobe AIR, content in the `application` security sandbox
        (content installed with the AIR application) are not restricted by
        these security limitations.

        For more information related to security, see the Flash Player
        Developer Center Topic: <a
        href="http://www.adobe.com/go/devnet_security_en"
        scope="external">Security</a>.
    **/
    get id3() {
        // return __backend.getID3();
        return null;
    }
    /**
        The length of the current sound in milliseconds.
    **/
    get length() {
        // return __backend.getLength();
        return 0;
    }
}

/**
    The SoundMixer class contains static properties and methods for global
    sound control in the application. The SoundMixer class controls embedded
    and streaming sounds in the application. it does not control dynamically
    created sounds (that is, sounds generated in response to a Sound object
    dispatching a `sampleData` event).
**/
let SoundMixer = /** @class */ (() => {
    class SoundMixer {
        /**
            Determines whether any sounds are not accessible due to security
            restrictions. For example, a sound loaded from a domain other than
            that of the content calling this method is not accessible if the
            server for the sound has no URL policy file that grants access to the
            domain of that domain. The sound can still be loaded and played, but
            low-level operations, such as getting ID3 metadata for the sound,
            cannot be performed on inaccessible sounds.
            For AIR application content in the application security sandbox,
            calling this method always returns `false`. All sounds, including
            those loaded from other domains, are accessible to content in the
            application security sandbox.
    
            @return The string representation of the boolean.
        **/
        static areSoundsInaccessible() {
            return false;
        }
        /**
            Takes a snapshot of the current sound wave and places it into the
            specified ByteArray object. The values are formatted as normalized
            floating-point values, in the range -1.0 to 1.0. The ByteArray object
            passed to the `outputArray` parameter is overwritten with the new
            values. The size of the ByteArray object created is fixed to 512
            floating-point values, where the first 256 values represent the left
            channel, and the second 256 values represent the right channel.
            **Note:** This method is subject to local file security restrictions
            and restrictions on cross-domain loading. If you are working with
            local files or sounds loaded from a server in a different domain than
            the calling content, you might need to address sandbox restrictions
            through a cross-domain policy file. For more information, see the
            Sound class description. In addition, this method cannot be used to
            extract data from RTMP streams, even when it is called by content that
            reside in the same domain as the RTMP server.
    
            This method is supported over RTMP in Flash Player 9.0.115.0 and later
            and in Adobe AIR. You can control access to streams on Flash Media
            Server in a server-side script. For more information, see the
            `Client.audioSampleAccess` and `Client.videoSampleAccess` properties
            in <a href="http://www.adobe.com/go/documentation" scope="external">_
            Server-Side ActionScript Language Reference for Adobe Flash Media
            Server_</a>.
    
            @param outputArray   A ByteArray object that holds the values
                                 associated with the sound. If any sounds are not
                                 available due to security restrictions
                                 (`areSoundsInaccessible == true`), the
                                 `outputArray` object is left unchanged. If all
                                 sounds are stopped, the `outputArray` object is
                                 filled with zeros.
            @param FFTMode       A Boolean value indicating whether a Fourier
                                 transformation is performed on the sound data
                                 first. Setting this parameter to `true` causes
                                 the method to return a frequency spectrum instead
                                 of the raw sound wave. In the frequency spectrum,
                                 low frequencies are represented on the left and
                                 high frequencies are on the right.
            @param stretchFactor The resolution of the sound samples. If you set
                                 the `stretchFactor` value to 0, data is sampled
                                 at 44.1 KHz; with a value of 1, data is sampled
                                 at 22.05 KHz; with a value of 2, data is sampled
                                 11.025 KHz; and so on.
        **/
        // /** @hidden */ @:dox(hide) public static computeSpectrum (outputArray:ByteArray, FFTMode:Bool = false, stretchFactor:Int = 0):Void;
        /**
            Stops all sounds currently playing.
            >In Flash Professional, this method does not stop the playhead. Sounds
            set to stream will resume playing as the playhead moves over the
            frames in which they are located.
    
            When using this property, consider the following security model:
    
            *  By default, calling the `SoundMixer.stopAll()` method stops only
            sounds in the same security sandbox as the object that is calling the
            method. Any sounds whose playback was not started from the same
            sandbox as the calling object are not stopped.
            * When you load the sound, using the `load()` method of the Sound
            class, you can specify a `context` parameter, which is a
            SoundLoaderContext object. If you set the `checkPolicyFile` property
            of the SoundLoaderContext object to `true`, Flash Player or Adobe AIR
            checks for a cross-domain policy file on the server from which the
            sound is loaded. If the server has a cross-domain policy file, and the
            file permits the domain of the calling content, then the file can stop
            the loaded sound by using the `SoundMixer.stopAll()` method; otherwise
            it cannot.
    
            However, in Adobe AIR, content in the `application` security sandbox
            (content installed with the AIR application) are not restricted by
            these security limitations.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: <a
            href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
    
        **/
        static stopAll() {
            for (let channel of SoundMixer.__soundChannels) {
                channel.stop();
            }
        }
        static __registerSoundChannel(soundChannel) {
            SoundMixer.__soundChannels.push(soundChannel);
        }
        static __unregisterSoundChannel(soundChannel) {
            var index = SoundMixer.__soundChannels.indexOf(soundChannel);
            if (index > -1)
                SoundMixer.__soundChannels.splice(index, 1);
        }
        // Get & Set Methods
        /**
            The SoundTransform object that controls global sound properties. A
            SoundTransform object includes properties for setting volume, panning,
            left speaker assignment, and right speaker assignment. The
            SoundTransform object used in this property provides final sound
            settings that are applied to all sounds after any individual sound
            settings are applied.
        **/
        static get soundTransform() {
            return SoundMixer.__soundTransform;
        }
        static set soundTransform(value) {
            SoundMixer.__soundTransform = value.clone();
            for (let channel of SoundMixer.__soundChannels) {
                channel.__updateTransform();
            }
        }
    }
    SoundMixer.MAX_ACTIVE_CHANNELS = 32;
    SoundMixer.__soundChannels = new Array();
    SoundMixer.__soundTransform = new SoundTransform();
    return SoundMixer;
})();

/**
    The SoundChannel class controls a sound in an application. Every sound is
    assigned to a sound channel, and the application can have multiple sound
    channels that are mixed together. The SoundChannel class contains a
    `stop()` method, properties for monitoring the amplitude
    (volume) of the channel, and a property for assigning a SoundTransform
    object to the channel.

    @event soundComplete Dispatched when a sound has finished playing.
**/
class SoundChannel extends EventDispatcher {
    constructor(sound = null, startTime = 0, loops = 0, soundTransform = null) {
        super();
        this.leftPeak = 1;
        this.rightPeak = 1;
        if (soundTransform != null) {
            this.__soundTransform = soundTransform.clone();
        }
        else {
            this.__soundTransform = new SoundTransform();
        }
        if (sound != null) {
            SoundMixer.__registerSoundChannel(this);
            // __backend = new SoundChannelBackend(this, sound, startTime, loops);
        }
    }
    /**
        Stops the sound playing in the channel.
    **/
    stop() {
        SoundMixer.__unregisterSoundChannel(this);
        // if (__backend == null) return;
        // __backend.stop();
        this.__dispose();
    }
    __dispose() {
        // if (__backend == null) return;
        // __backend.dispose();
        // __backend = null;
    }
    __onComplete() {
        SoundMixer.__unregisterSoundChannel(this);
        this.__dispose();
        this.dispatchEvent(new Event(Event.SOUND_COMPLETE));
    }
    __updateTransform() {
        this.soundTransform = this.soundTransform;
    }
    // Get & Set Methods
    /**
        When the sound is playing, the `position` property indicates in
        milliseconds the current point that is being played in the sound file.
        When the sound is stopped or paused, the `position` property
        indicates the last point that was played in the sound file.

        A common use case is to save the value of the `position`
        property when the sound is stopped. You can resume the sound later by
        restarting it from that saved position.

        If the sound is looped, `position` is reset to 0 at the
        beginning of each loop.
    **/
    get position() {
        // if (__backend == null) return 0;
        // return __backend.getPosition();
        return 0;
    }
    set position(value) {
        // if (__backend == null) return 0;
        // __backend.setPosition(value);
    }
    /**
        The SoundTransform object assigned to the sound channel. A SoundTransform
        object includes properties for setting volume, panning, left speaker
        assignment, and right speaker assignment.
    **/
    get soundTransform() {
        return this.__soundTransform.clone();
    }
    set soundTransform(value) {
        if (value != null) {
            this.__soundTransform.pan = value.pan;
            this.__soundTransform.volume = value.volume;
            // if (__backend != null)
            // {
            // 	__backend.setSoundTransform(value);
            // }
        }
    }
}

var openfl$E;
(function (openfl) {
    var media;
    (function (media) {
        /**
        The SoundLoaderContext class provides security checks for files that load
        sound. SoundLoaderContext objects are passed as an argument to the
        constructor and the `load()` method of the Sound class.
    
        When you use this class, consider the following security model:
    
    
        * Loading and playing a sound is not allowed if the calling file is in
        a network sandbox and the sound file to be loaded is local.
        * By default, loading and playing a sound is not allowed if the calling
        is local and tries to load and play a remote sound. A user must grant
        explicit permission to allow this.
        * Certain operations dealing with sound are restricted. The data in a
        loaded sound cannot be accessed by a file in a different domain unless you
        implement a URL policy file. Sound-related APIs that fall under this
        restriction are the `Sound.id3` property and the
        `SoundMixer.computeSpectrum()`,
        `SoundMixer.bufferTime`, and `SoundTransform()`
        methods.
    
    
        However, in Adobe AIR, content in the `application` security
        sandbox(content installed with the AIR application) are not restricted by
        these security limitations.
    
        For more information related to security, see the Flash Player Developer
        Center Topic: [Security](http://www.adobe.com/go/devnet_security_en).
    **/
        class SoundLoaderContext {
            /**
                Creates a new sound loader context object.
    
                @param bufferTime      The number of seconds to preload a streaming sound
                                       into a buffer before the sound starts to stream.
                @param checkPolicyFile Specifies whether the existence of a URL policy
                                       file should be checked upon loading the object
                                      (`true`) or not.
            **/
            constructor(bufferTime = 1000, checkPolicyFile = false) {
                this.bufferTime = bufferTime;
                this.checkPolicyFile = checkPolicyFile;
            }
        }
        media.SoundLoaderContext = SoundLoaderContext;
    })(media = openfl.media || (openfl.media = {}));
})(openfl$E || (openfl$E = {}));
var SoundLoaderContext = openfl$E.media.SoundLoaderContext;

/**
    The Video class displays live or recorded video in an application without
    embedding the video in your SWF file. This class creates a Video object
    that plays either of the following kinds of video: recorded video files
    stored on a server or locally, or live video captured by the user. A Video
    object is a display object on the application's display list and
    represents the visual space in which the video runs in a user interface.
    When used with Flash Media Server, the Video object allows you to send
    live video captured by a user to the server and then broadcast it from the
    server to other users. Using these features, you can develop media
    applications such as a simple video player, a video player with multipoint
    publishing from one server to another, or a video sharing application for
    a user community.

    Flash Player 9 and later supports publishing and playback of FLV files
    encoded with either the Sorenson Spark or On2 VP6 codec and also supports
    an alpha channel. The On2 VP6 video codec uses less bandwidth than older
    technologies and offers additional deblocking and deringing filters. See
    the openfl.net.NetStream class for more information about video playback
    and supported formats.

    Flash Player 9.0.115.0 and later supports mipmapping to optimize runtime
    rendering quality and performance. For video playback, Flash Player uses
    mipmapping optimization if you set the Video object's `smoothing` property
    to `true`.

    As with other display objects on the display list, you can control various
    properties of Video objects. For example, you can move the Video object
    around on the Stage by using its `x` and `y` properties, you can change
    its size using its `height` and `width` properties, and so on.

    To play a video stream, use `attachCamera()` or `attachNetStream()` to
    attach the video to the Video object. Then, add the Video object to the
    display list using `addChild()`.

    If you are using Flash Professional, you can also place the Video object
    on the Stage rather than adding it with `addChild()`, like this:

    1. If the Library panel isn't visible, select Window > Library to display
    it.
    2. Add an embedded Video object to the library by clicking the Options menu
    on the right side of the Library panel title bar and selecting New Video.
    3. In the Video Properties dialog box, name the embedded Video object for
    use in the library and click OK.
    4. Drag the Video object to the Stage and use the Property Inspector to
    give it a unique instance name, such as `my_video`. (Do not name it
    Video.)

    In AIR applications on the desktop, playing video in fullscreen mode
    disables any power and screen saving features (when allowed by the
    operating system).

    **Note:** The Video class is not a subclass of the InteractiveObject
    class, so it cannot dispatch mouse events. However, you can call the
    `addEventListener()` method on the display object container that contains
    the Video object.
**/
class Video extends DisplayObject {
    /**
        Creates a new Video instance. If no values for the `width` and
        `height` parameters are supplied, the default values are used. You can
        also set the width and height properties of the Video object after the
        initial construction, using `Video.width` and `Video.height`. When a
        new Video object is created, values of zero for width or height are
        not allowed; if you pass zero, the defaults will be applied.
        After creating the Video, call the `DisplayObjectContainer.addChild()`
        or `DisplayObjectContainer.addChildAt()` method to add the Video
        object to a parent DisplayObjectContainer object.

        @param width  The width of the video, in pixels.
        @param height The height of the video, in pixels.
    **/
    constructor(width = 320, height = 240) {
        super();
        this.__type = DisplayObjectType$1.VIDEO;
        this.__width = width;
        this.__height = height;
        this.__renderData.textureTime = -1;
        this.smoothing = false;
        this.deblocking = 0;
    }
    /**
        Specifies a video stream from a camera to be displayed within the
        boundaries of the Video object in the application.
        Use this method to attach live video captured by the user to the Video
        object. You can play the live video locally on the same computer or
        device on which it is being captured, or you can send it to Flash
        Media Server and use the server to stream it to other users.

        **Note:** In an iOS AIR application, camera video cannot be displayed
        when the application uses GPU rendering mode.

        @param camera A Camera object that is capturing video data. To drop
                        the connection to the Video object, pass `null`.
    **/
    // attachCamera(camera : Camera) : void;
    /**
        Specifies a video stream to be displayed within the boundaries of the
        Video object in the application. The video stream is either a video
        file played with `NetStream.play()`, a Camera object, or `null`. If
        you use a video file, it can be stored on the local file system or on
        Flash Media Server. If the value of the `netStream` argument is
        `null`, the video is no longer played in the Video object.
        You do not need to use this method if a video file contains only
        audio; the audio portion of video files is played automatically when
        you call `NetStream.play()`. To control the audio associated with a
        video file, use the `soundTransform` property of the NetStream object
        that plays the video file.

        @param netStream A NetStream object. To drop the connection to the
                            Video object, pass `null`.
    **/
    attachNetStream(netStream) {
        this.__stream = netStream;
        if (this.__stream != null && !this.__stream.__closed) {
            // @:privateAccess __stream.__getVideoElement().play();
            this.__stream.resume();
        }
    }
    /**
        Clears the image currently displayed in the Video object (not the
        video stream). This method is useful for handling the current image.
        For example, you can clear the last image or display standby
        information without hiding the Video object.

    **/
    clear() { }
    __getBounds(rect, matrix) {
        var bounds = Rectangle.__pool.get();
        bounds.setTo(0, 0, this.__width, this.__height);
        bounds.__transform(bounds, matrix);
        rect.__expand(bounds.x, bounds.y, bounds.width, bounds.height);
        Rectangle.__pool.release(bounds);
    }
    __hitTest(x, y, shapeFlag, stack, interactiveOnly, hitObject) {
        if (!hitObject.visible || this.__isMask)
            return false;
        if (this.mask != null && !this.mask.__hitTestMask(x, y))
            return false;
        this.__getRenderTransform();
        var px = this.__renderTransform.__transformInverseX(x, y);
        var py = this.__renderTransform.__transformInverseY(x, y);
        if (px > 0 && py > 0 && px <= this.__width && py <= this.__height) {
            if (stack != null && !interactiveOnly) {
                stack.push(hitObject);
            }
            return true;
        }
        return false;
    }
    __hitTestMask(x, y) {
        var point = Point.__pool.get();
        point.setTo(x, y);
        this.__globalToLocal(point, point);
        var hit = (point.x > 0 && point.y > 0 && point.x <= this.__width && point.y <= this.__height);
        Point.__pool.release(point);
        return hit;
    }
    // Get & Set Methods
    get height() {
        return this.__height * this.scaleY;
    }
    set height(value) {
        if (this.scaleY != 1 || value != this.__height) {
            this.__setTransformDirty();
            this.__setParentRenderDirty();
            this.__dirty = true;
        }
        this.scaleY = 1;
        this.__height = value;
    }
    /**
        An integer specifying the height of the video stream, in pixels. For
        live streams, this value is the same as the `Camera.height` property
        of the Camera object that is capturing the video stream. For recorded
        video files, this value is the height of the video.
        You may want to use this property, for example, to ensure that the
        user is seeing the video at the same size at which it was captured,
        regardless of the actual size of the Video object on the Stage.
    **/
    get videoHeight() {
        if (this.__stream != null) {
            var videoElement = this.__stream.__getVideoElement();
            if (videoElement != null) {
                return videoElement.videoHeight;
            }
        }
        return 0;
    }
    /**
        An integer specifying the width of the video stream, in pixels. For
        live streams, this value is the same as the `Camera.width` property of
        the Camera object that is capturing the video stream. For recorded
        video files, this value is the width of the video.
        You may want to use this property, for example, to ensure that the
        user is seeing the video at the same size at which it was captured,
        regardless of the actual size of the Video object on the Stage.
    **/
    get videoWidth() {
        if (this.__stream != null) {
            var videoElement = this.__stream.__getVideoElement();
            if (videoElement != null) {
                return videoElement.videoWidth;
            }
        }
        return 0;
    }
    get width() {
        return this.__width * this.__scaleX;
    }
    set width(value) {
        if (this.__scaleX != 1 || this.__width != value) {
            this.__setTransformDirty();
            this.__setParentRenderDirty();
            this.__dirty = true;
        }
        this.scaleX = 1;
        this.__width = value;
    }
}

/**
    The FileFilter class is used to indicate what files on the user's system
    are shown in the file-browsing dialog box that is displayed when the
    `FileReference.browse()` method, the `FileReferenceList.browse()` method
    is called or a browse method of a File, FileReference, or
    FileReferenceList object is called. FileFilter instances are passed as a
    value for the optional `typeFilter` parameter to the method. If you use a
    FileFilter instance, extensions and file types that aren't specified in
    the FileFilter instance are filtered out; that is, they are not available
    to the user for selection. If no FileFilter object is passed to the
    method, all files are shown in the dialog box.
    You can use FileFilter instances in one of two ways:

    * A description with file extensions only
    * A description with file extensions and Macintosh file types

    The two formats are not interchangeable within a single call to the browse
    method. You must use one or the other.

    You can pass one or more FileFilter instances to the browse method, as
    shown in the following:

    ```haxe
    var imagesFilter = new FileFilter("Images", "*.jpg;*.gif;*.png");
    var docFilter = new FileFilter("Documents", "*.pdf;*.doc;*.txt");
    var myFileReference = new FileReference();
    myFileReference.browse([imagesFilter, docFilter]);
    ```

    Or in an AIR application:

    ```haxe
    var imagesFilter = new FileFilter("Images", "*.jpg;*.gif;*.png");
    var docFilter = new FileFilter("Documents", "*.pdf;*.doc;*.txt");
    var myFile = new File();
    myFile.browseForOpen("Open", [imagesFilter, docFilter]);
    ```

    The list of extensions in the `FileFilter.extension` property is used to
    filter the files shown in the file browsing dialog. The list is not
    actually displayed in the dialog box; to display the file types for users,
    you must list the file types in the description string as well as in the
    extension list. The description string is displayed in the dialog box in
    Windows and Linux. (It is not used on the Macintosh<sup>஼/sup>.) On the
    Macintosh, if you supply a list of Macintosh file types, that list is used
    to filter the files. If not, the list of file extensions is used.
**/
class FileFilter {
    /**
        Creates a new FileFilter instance.

        @param description The description string that is visible to users
                           when they select files for uploading.
        @param extension   A list of file extensions that indicate which file
                           formats are visible to users when they select files
                           for uploading.
        @param macType     A list of Macintosh file types that indicate which
                           file types are visible to users when they select
                           files for uploading. If no value is passed, this
                           parameter is set to `null`.
    **/
    constructor(description, extension, macType = null) {
        this.description = description;
        this.extension = extension;
        this.macType = macType;
    }
}

/**
    The FileReference class provides a means to upload and download files
    between a user's computer and a server. An operating-system dialog box
    prompts the user to select a file to upload or a location for download.
    Each FileReference object refers to a single file on the user's disk and
    has properties that contain information about the file's size, type, name,
    creation date, modification date, and creator type (Macintosh only).
    **Note:** In Adobe AIR, the File class, which extends the FileReference
    class, provides more capabilities and has less security restrictions than
    the FileReference class.

    FileReference instances are created in the following ways:

    * When you use the `new` operator with the FileReference constructor: `var
    myFileReference = new FileReference();`
    * When you call the `FileReferenceList.browse()` method, which creates an
    array of FileReference objects.

    During an upload operation, all the properties of a FileReference object
    are populated by calls to the `FileReference.browse()` or
    `FileReferenceList.browse()` methods. During a download operation, the
    `name` property is populated when the `select` event is dispatched; all
    other properties are populated when the `complete` event is dispatched.

    The `browse()` method opens an operating-system dialog box that prompts
    the user to select a file for upload. The `FileReference.browse()` method
    lets the user select a single file; the `FileReferenceList.browse()`
    method lets the user select multiple files. After a successful call to the
    `browse()` method, call the `FileReference.upload()` method to upload one
    file at a time. The `FileReference.download()` method prompts the user for
    a location to save the file and initiates downloading from a remote URL.

    The FileReference and FileReferenceList classes do not let you set the
    default file location for the dialog box that the `browse()` or
    `download()` methods generate. The default location shown in the dialog
    box is the most recently browsed folder, if that location can be
    determined, or the desktop. The classes do not allow you to read from or
    write to the transferred file. They do not allow the SWF file that
    initiated the upload or download to access the uploaded or downloaded file
    or the file's location on the user's disk.

    The FileReference and FileReferenceList classes also do not provide
    methods for authentication. With servers that require authentication, you
    can download files with the Flash<sup>஼/sup> Player browser plug-in, but
    uploading (on all players) and downloading (on the stand-alone or external
    player) fails. Listen for FileReference events to determine whether
    operations complete successfully and to handle errors.

    For content running in Flash Player or for content running in Adobe AIR
    outside of the application security sandbox, uploading and downloading
    operations can access files only within its own domain and within any
    domains that a URL policy file specifies. Put a policy file on the file
    server if the content initiating the upload or download doesn't come from
    the same domain as the file server.

    Note that because of new functionality added to the Flash Player, when
    publishing to Flash Player 10, you can have only one of the following
    operations active at one time: `FileReference.browse()`,
    `FileReference.upload()`, `FileReference.download()`,
    `FileReference.load()`, `FileReference.save()`. Otherwise, Flash Player
    throws a runtime error (code 2174). Use `FileReference.cancel()` to stop
    an operation in progress. This restriction applies only to Flash Player
    10. Previous versions of Flash Player are unaffected by this restriction
    on simultaneous multiple operations.

    While calls to the `FileReference.browse()`, `FileReferenceList.browse()`,
    or `FileReference.download()` methods are executing, SWF file playback
    pauses in stand-alone and external versions of Flash Player and in AIR for
    Linux and Mac OS X 10.1 and earlier

    The following sample HTTP `POST` request is sent from Flash Player to a
    server-side script if no parameters are specified:

    ```
    POST /handler.cfm HTTP/1.1
    Accept: text/*
    Content-Type: multipart/form-data;
    boundary=----------Ij5ae0ae0KM7GI3KM7
    User-Agent: Shockwave Flash
    Host: www.example.com
    Content-Length: 421
    Connection: Keep-Alive
    Cache-Control: no-cache

    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="Filename"

    MyFile.jpg
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
    Content-Type: application/octet-stream

    FileDataHere
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="Upload"

    Submit Query
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
    ```

    Flash Player sends the following HTTP `POST` request if the user specifies
    the parameters `"api_sig"`, `"api_key"`, and `"auth_token"`:

    ```
    POST /handler.cfm HTTP/1.1
    Accept: text/*
    Content-Type: multipart/form-data;
    boundary=----------Ij5ae0ae0KM7GI3KM7
    User-Agent: Shockwave Flash
    Host: www.example.com
    Content-Length: 421
    Connection: Keep-Alive
    Cache-Control: no-cache

    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="Filename"

    MyFile.jpg
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="api_sig"

    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="api_key"

    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="auth_token"

    XXXXXXXXXXXXXXXXXXXXXX
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
    Content-Type: application/octet-stream

    FileDataHere
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
    Content-Disposition: form-data; name="Upload"

    Submit Query
    ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
    ```

    @event cancel             Dispatched when a file upload or download is
                              canceled through the file-browsing dialog box by
                              the user. Flash Player does not dispatch this
                              event if the user cancels an upload or download
                              through other means (closing the browser or
                              stopping the current application).
    @event complete           Dispatched when download is complete or when
                              upload generates an HTTP status code of 200. For
                              file download, this event is dispatched when
                              Flash Player or Adobe AIR finishes downloading
                              the entire file to disk. For file upload, this
                              event is dispatched after the Flash Player or
                              Adobe AIR receives an HTTP status code of 200
                              from the server receiving the transmission.
    @event httpResponseStatus Dispatched if a call to the `upload()` or
                              `uploadUnencoded()` method attempts to access
                              data over HTTP and Adobe AIR is able to detect
                              and return the status code for the request.
    @event httpStatus         Dispatched when an upload fails and an HTTP
                              status code is available to describe the
                              failure. The `httpStatus` event is dispatched,
                              followed by an `ioError` event.
                              The `httpStatus` event is dispatched only for
                              upload failures. For content running in Flash
                              Player this event is not applicable for download
                              failures. If a download fails because of an HTTP
                              error, the error is reported as an I/O error.
    @event ioError            Dispatched when the upload or download fails. A
                              file transfer can fail for one of the following
                              reasons:
                              * An input/output error occurs while the player
                              is reading, writing, or transmitting the file.
                              * The SWF file tries to upload a file to a
                              server that requires authentication (such as a
                              user name and password). During upload, Flash
                              Player or Adobe AIR does not provide a means for
                              users to enter passwords. If a SWF file tries to
                              upload a file to a server that requires
                              authentication, the upload fails.
                              * The SWF file tries to download a file from a
                              server that requires authentication, within the
                              stand-alone or external player. During download,
                              the stand-alone and external players do not
                              provide a means for users to enter passwords. If
                              a SWF file in these players tries to download a
                              file from a server that requires authentication,
                              the download fails. File download can succeed
                              only in the ActiveX control, browser plug-in
                              players, and the Adobe AIR runtime.
                              * The value passed to the `url` parameter in the
                              `upload()` method contains an invalid protocol.
                              Valid protocols are HTTP and HTTPS.

                              **Important:** Only applications running in a
                              browser נthat is, using the browser plug-in
                              or ActiveX control נand content running in
                              Adobe AIR can provide a dialog box to prompt the
                              user to enter a user name and password for
                              authentication, and then only for downloads. For
                              uploads using the plug-in or ActiveX control
                              version of Flash Player, or for upload or
                              download using either the stand-alone or the
                              external player, the file transfer fails.
    @event open               Dispatched when an upload or download operation
                              starts.
    @event progress           Dispatched periodically during the file upload
                              or download operation. The `progress` event is
                              dispatched while Flash Player transmits bytes to
                              a server, and it is periodically dispatched
                              during the transmission, even if the
                              transmission is ultimately not successful. To
                              determine if and when the file transmission is
                              actually successful and complete, listen for the
                              `complete` event.
                              In some cases, `progress` events are not
                              received. For example, when the file being
                              transmitted is very small or the upload or
                              download happens very quickly a `progress` event
                              might not be dispatched.

                              File upload progress cannot be determined on
                              Macintosh platforms earlier than OS X 10.3. The
                              `progress` event is called during the upload
                              operation, but the value of the `bytesLoaded`
                              property of the progress event is -1, indicating
                              that the progress cannot be determined.
    @event securityError      Dispatched when a call to the
                              `FileReference.upload()` or
                              `FileReference.download()` method tries to
                              upload a file to a server or get a file from a
                              server that is outside the caller's security
                              sandbox. The value of the text property that
                              describes the specific error that occurred is
                              normally `"securitySandboxError"`. The calling
                              SWF file may have tried to access a SWF file
                              outside its domain and does not have permission
                              to do so. You can try to remedy this error by
                              using a URL policy file.
                              In Adobe AIR, these security restrictions do not
                              apply to content in the application security
                              sandbox.

                              In Adobe AIR, these security restrictions do not
                              apply to content in the application security
                              sandbox.
    @event select             Dispatched when the user selects a file for
                              upload or download from the file-browsing dialog
                              box. (This dialog box opens when you call the
                              `FileReference.browse()`,
                              `FileReferenceList.browse()`, or
                              `FileReference.download()` method.) When the
                              user selects a file and confirms the operation
                              (for example, by clicking OK), the properties of
                              the FileReference object are populated.
                              For content running in Flash Player or outside
                              of the application security sandbox in the Adobe
                              AIR runtime, the `select` event acts slightly
                              differently depending on what method invokes it.
                              When the `select` event is dispatched after a
                              `browse()` call, Flash Player or the AIR
                              application can read all the FileReference
                              object's properties, because the file selected
                              by the user is on the local file system. When
                              the `select` event occurs after a `download()`
                              call, Flash Player or the AIR application can
                              read only the `name` property, because the file
                              hasn't yet been downloaded to the local file
                              system at the moment the `select` event is
                              dispatched. When the file is downloaded and the
                              `complete` event dispatched, Flash Player or the
                              AIR application can read all other properties of
                              the FileReference object.
    @event uploadCompleteData Dispatched after data is received from the
                              server after a successful upload. This event is
                              not dispatched if data is not returned from the
                              server.
**/
class FileReference extends EventDispatcher {
    /**
        Creates a new FileReference object. When populated, a FileReference
        object represents a file on the user's local disk.
    **/
    constructor() {
        super();
        // __backend = new FileReferenceBackend(this);
    }
    /**
        Displays a file-browsing dialog box that lets the user select a file
        to upload. The dialog box is native to the user's operating system.
        The user can select a file on the local computer or from other
        systems, for example, through a UNC path on Windows.
        **Note:** The File class, available in Adobe AIR, includes methods for
        accessing more specific system file selection dialog boxes. These
        methods are `File.browseForDirectory()`, `File.browseForOpen()`,
        `File.browseForOpenMultiple()`, and `File.browseForSave()`.

        When you call this method and the user successfully selects a file,
        the properties of this FileReference object are populated with the
        properties of that file. Each subsequent time that the
        `FileReference.browse()` method is called, the FileReference object's
        properties are reset to the file that the user selects in the dialog
        box. Only one `browse()` or `download()` session can be performed at a
        time (because only one dialog box can be invoked at a time).

        Using the `typeFilter` parameter, you can determine which files the
        dialog box displays.

        In Flash Player 10 and Flash Player 9 Update 5, you can only call this
        method successfully in response to a user event (for example, in an
        event handler for a mouse click or keypress event). Otherwise, calling
        this method results in Flash Player throwing an Error exception.

        Note that because of new functionality added to the Flash Player, when
        publishing to Flash Player 10, you can have only one of the following
        operations active at one time: `FileReference.browse()`,
        `FileReference.upload()`, `FileReference.download()`,
        `FileReference.load()`, `FileReference.save()`. Otherwise, Flash
        Player throws a runtime error (code 2174). Use
        `FileReference.cancel()` to stop an operation in progress. This
        restriction applies only to Flash Player 10. Previous versions of
        Flash Player are unaffected by this restriction on simultaneous
        multiple operations.

        In Adobe AIR, the file-browsing dialog is not always displayed in
        front of windows that are "owned" by another window (windows that have
        a non-null `owner` property). To avoid window ordering issues, hide
        owned windows before calling this method.

        @return Returns `true` if the parameters are valid and the
                file-browsing dialog box opens.
        @throws ArgumentError         If the `typeFilter` array contains
                                      FileFilter objects that are incorrectly
                                      formatted, an exception is thrown. For
                                      information on the correct format for
                                      FileFilter objects, see the <a
                                      href="FileFilter.html">FileFilter</a>
                                      class.
        @throws Error                 If the method is not called in response
                                      to a user action, such as a mouse event
                                      or keypress event.
        @throws IllegalOperationError Thrown in the following situations: 1)
                                      Another FileReference or
                                      FileReferenceList browse session is in
                                      progress; only one file browsing session
                                      may be performed at a time. 2) A setting
                                      in the user's mms.cfg file prohibits
                                      this operation.
        @event cancel Dispatched when the user cancels the file upload Browse
                      window.
        @event select Dispatched when the user successfully selects an item
                      from the Browse file chooser.
    **/
    browse(typeFilter = null) {
        // return __backend.browse(typeFilter);
        return false;
    }
    /**
        Cancels any ongoing upload or download operation on this FileReference
        object. Calling this method does not dispatch the `cancel` event; that
        event is dispatched only when the user cancels the operation by
        dismissing the file upload or download dialog box.

    **/
    cancel() {
        // __backend.cancel();
    }
    /**
        Opens a dialog box that lets the user download a file from a remote
        server. Although Flash Player has no restriction on the size of files
        you can upload or download, the player officially supports uploads or
        downloads of up to 100 MB.
        The `download()` method first opens an operating-system dialog box
        that asks the user to enter a filename and select a location on the
        local computer to save the file. When the user selects a location and
        confirms the download operation (for example, by clicking Save), the
        download from the remote server begins. Listeners receive events to
        indicate the progress, success, or failure of the download. To
        ascertain the status of the dialog box and the download operation
        after calling `download()`, your code must listen for events such as
        `cancel`, `open`, `progress`, and `complete`.

        The `FileReference.upload()` and `FileReference.download()` functions
        are nonblocking. These functions return after they are called, before
        the file transmission is complete. In addition, if the FileReference
        object goes out of scope, any upload or download that is not yet
        completed on that object is canceled upon leaving the scope. Be sure
        that your FileReference object remains in scope for as long as the
        upload or download is expected to continue.

        When the file is downloaded successfully, the properties of the
        FileReference object are populated with the properties of the local
        file. The `complete` event is dispatched if the download is
        successful.

        Only one `browse()` or `download()` session can be performed at a time
        (because only one dialog box can be invoked at a time).

        This method supports downloading of any file type, with either HTTP or
        HTTPS.

        You cannot connect to commonly reserved ports. For a complete list of
        blocked ports, see "Restricting Networking APIs" in the _ActionScript
        3.0 Developer's Guide_.

        **Note**: If your server requires user authentication, only SWF files
        running in a browser נthat is, using the browser plug-in or ActiveX
        control נcan provide a dialog box to prompt the user for a user
        name and password for authentication, and only for downloads. For
        uploads using the plug-in or ActiveX control, or for uploads and
        downloads using the stand-alone or external player, the file transfer
        fails.

        When you use this method , consider the Flash Player security model:

        * Loading operations are not allowed if the calling SWF file is in an
        untrusted local sandbox.
        * The default behavior is to deny access between sandboxes. A website
        can enable access to a resource by adding a URL policy file.
        * You can prevent a SWF file from using this method by setting the
        `allowNetworking` parameter of the the `object` and `embed` tags in
        the HTML page that contains the SWF content.
        * In Flash Player 10 and Flash Player 9 Update 5, you can only call
        this method successfully in response to a user event (for example, in
        an event handler for a mouse click or keypress event). Otherwise,
        calling this method results in Flash Player throwing an Error
        exception.

        However, in Adobe AIR, content in the `application` security sandbox
        (content installed with the AIR application) is not restricted by
        these security limitations.

        For more information related to security, see the Flash Player
        Developer Center Topic: <a
        href="http://www.adobe.com/go/devnet_security_en"
        scope="external">Security</a>.

        When you download a file using this method, it is flagged as
        downloaded on operating systems that flag downloaded files:

        * Windows XP service pack 2 and later, and on Windows Vista
        * Mac OS 10.5 and later

        Some operating systems, such as Linux, do not flag downloaded files.

        Note that because of new functionality added to the Flash Player, when
        publishing to Flash Player 10, you can have only one of the following
        operations active at one time: `FileReference.browse()`,
        `FileReference.upload()`, `FileReference.download()`,
        `FileReference.load()`, `FileReference.save()`. Otherwise, Flash
        Player throws a runtime error (code 2174). Use
        `FileReference.cancel()` to stop an operation in progress. This
        restriction applies only to Flash Player 10. Previous versions of
        Flash Player are unaffected by this restriction on simultaneous
        multiple operations.

        In Adobe AIR, the download dialog is not always displayed in front of
        windows that are "owned" by another window (windows that have a
        non-null `owner` property). To avoid window ordering issues, hide
        owned windows before calling this method.

        @param request         The URLRequest object. The `url` property of
                               the URLRequest object should contain the URL of
                               the file to download to the local computer. If
                               this parameter is `null`, an exception is
                               thrown. The `requestHeaders` property of the
                               URLRequest object is ignored; custom HTTP
                               request headers are not supported in uploads or
                               downloads. To send `POST` or GET parameters to
                               the server, set the value of `URLRequest.data`
                               to your parameters, and set `URLRequest.method`
                               to either `URLRequestMethod.POST` or
                               `URLRequestMethod.GET`.
                               On some browsers, URL strings are limited in
                               length. Lengths greater than 256 characters may
                               fail on some browsers or servers.
        @param defaultFileName The default filename displayed in the dialog
                               box for the file to be downloaded. This string
                               must not contain the following characters: `/ \ : * ? " < > | %`
                               If you omit this parameter, the filename of the
                               remote URL is parsed and used as the default.
        @throws ArgumentError         If `url.data` is of type ByteArray, an
                                      exception is thrown. For use with the
                                      `FileReference.upload()` and
                                      `FileReference.download()` methods,
                                      `url.data` can only be of type
                                      URLVariables or String.
        @throws Error                 If the method is not called in response
                                      to a user action, such as a mouse event
                                      or keypress event.
        @throws IllegalOperationError Thrown in the following situations: 1)
                                      Another browse session is in progress;
                                      only one file browsing session can be
                                      performed at a time. 2) The value passed
                                      to `request` does not contain a valid
                                      path or protocol. 3) The filename to
                                      download contains prohibited characters.
                                      4) A setting in the user's mms.cfg file
                                      prohibits this operation.
        @throws MemoryError           This error can occur for the following
                                      reasons: 1) Flash Player cannot convert
                                      the `URLRequest.data` parameter from
                                      UTF8 to MBCS. This error is applicable
                                      if the URLRequest object passed to the
                                      `FileReference.download()` method is set
                                      to perform a GET operation and if
                                      `System.useCodePage` is set to `true`.
                                      2) Flash Player cannot allocate memory
                                      for the `POST` data. This error is
                                      applicable if the URLRequest object
                                      passed to the `FileReference.download()`
                                      method is set to perform a `POST`
                                      operation.
        @throws SecurityError         Local untrusted content may not
                                      communicate with the Internet. To avoid
                                      this situation, reclassify this SWF file
                                      as local-with-networking or trusted.
                                      This exception is thrown with a message
                                      indicating the filename and the URL that
                                      may not be accessed because of local
                                      file security restrictions.
        @throws SecurityError         You cannot connect to commonly reserved
                                      ports. For a complete list of blocked
                                      ports, see "Restricting Networking APIs"
                                      in the _ActionScript 3.0 Developer's
                                      Guide_.
        @event cancel        Dispatched when the user dismisses the dialog
                             box.
        @event complete      Dispatched when the file download operation
                             successfully completes.
        @event ioError       Dispatched for any of the following reasons:
                             * An input/output error occurs while the file is
                             being read or transmitted.
                             * SWF content running in the stand-alone or
                             external versions of Flash Player tries to
                             download a file from a server that requires
                             authentication. During download, the standalone
                             and external players do not provide a means for
                             users to enter passwords. If a SWF file in these
                             players tries to download a file from a server
                             that requires authentication, the download fails.
                             File download can succeed only in the ActiveX
                             control and browser plug-in players.
        @event open          Dispatched when a download operation starts.
        @event progress      Dispatched periodically during the file download
                             operation.
        @event securityError Dispatched when a download fails because of a
                             security error.
        @event select        Dispatched when the user selects a file for
                             download from the dialog box.
    **/
    download(request, defaultFileName = null) {
        // __backend.download(request, defaultFileName);
    }
    /**
        Starts the load of a local file selected by a user. Although Flash
        Player has no restriction on the size of files you can upload,
        download, load or save, it officially supports sizes of up to 100 MB.
        For content running in Flash Player, you must call the
        `FileReference.browse()` or `FileReferenceList.browse()` method before
        you call the `load()` method. However, content running in AIR in the
        application sandbox can call the `load()` method of a File object
        without first calling the `browse()` method. (The AIR File class
        extends the FileReference class.)
        Listeners receive events to indicate the progress, success, or failure
        of the load. Although you can use the FileReferenceList object to let
        users select multiple files to load, you must load the files one by
        one. To load the files one by one, iterate through the
        `FileReferenceList.fileList` array of FileReference objects.

        Adobe AIR also includes the FileStream class which provides more
        options for reading files.

        The `FileReference.upload()`, `FileReference.download()`,
        `FileReference.load()` and `FileReference.save()` functions are
        nonblocking. These functions return after they are called, before the
        file transmission is complete. In addition, if the FileReference
        object goes out of scope, any transaction that is not yet completed on
        that object is canceled upon leaving the scope. Be sure that your
        FileReference object remains in scope for as long as the upload,
        download, load or save is expected to continue.

        If the file finishes loading successfully, its contents are stored as
        a byte array in the `data` property of the FileReference object.

        The following security considerations apply:

        * Loading operations are not allowed if the calling SWF file is in an
        untrusted local sandbox.
        * The default behavior is to deny access between sandboxes. A website
        can enable access to a resource by adding a cross-domain policy file.
        * You can prevent a file from using this method by setting the
        `allowNetworking` parameter of the the `object` and `embed` tags in
        the HTML page that contains the SWF content.

        However, these considerations do not apply to AIR content in the
        application sandbox.

        Note that when publishing to Flash Player 10 or AIR 1.5, you can have
        only one of the following operations active at one time:
        `FileReference.browse()`, `FileReference.upload()`,
        `FileReference.download()`, `FileReference.load()`,
        `FileReference.save()`. Otherwise, the application throws a runtime
        error (code 2174). Use `FileReference.cancel()` to stop an operation
        in progress. This restriction applies only to Flash Player 10 and AIR
        1.5. Previous versions of Flash Player or AIR are unaffected by this
        restriction on simultaneous multiple operations.

        In Adobe AIR, the file-browsing dialog is not always displayed in
        front of windows that are "owned" by another window (windows that have
        a non-null `owner` property). To avoid window ordering issues, hide
        owned windows before calling this method.

        @throws IllegalOperationError Thrown in the following situations: 1)
                                      Another FileReference or
                                      FileReferenceList browse session is in
                                      progress; only one file browsing session
                                      may be performed at a time. 2) A setting
                                      in the user's mms.cfg file prohibits
                                      this operation.
        @throws MemoryError           This error can occur if the application
                                      cannot allocate memory for the file. The
                                      file may be too large or available
                                      memory may be too low.
        @event complete Dispatched when the file load operation completes
                        successfully.
        @event ioError  Invoked if the load fails because of an input/output
                        error while the application is reading or writing the
                        file.
        @event open     Dispatched when an load operation starts.
        @event progress Dispatched periodically during the file load
                        operation.
    **/
    load() {
        // __backend.load();
    }
    /**
        Opens a dialog box that lets the user save a file to the local
        filesystem. Although Flash Player has no restriction on the size of
        files you can upload, download, load or save, the player officially
        supports sizes of up to 100 MB.
        The `save()` method first opens an operating-system dialog box that
        asks the user to enter a filename and select a location on the local
        computer to save the file. When the user selects a location and
        confirms the save operation (for example, by clicking Save), the save
        process begins. Listeners receive events to indicate the progress,
        success, or failure of the save operation. To ascertain the status of
        the dialog box and the save operation after calling `save()`, your
        code must listen for events such as `cancel`, `open`, `progress`, and
        `complete`.

        Adobe AIR also includes the FileStream class which provides more
        options for saving files locally.

        The `FileReference.upload()`, `FileReference.download()`,
        `FileReference.load()` and `FileReference.save()` functions are
        nonblocking. These functions return after they are called, before the
        file transmission is complete. In addition, if the FileReference
        object goes out of scope, any transaction that is not yet completed on
        that object is canceled upon leaving the scope. Be sure that your
        FileReference object remains in scope for as long as the upload,
        download, load or save is expected to continue.

        When the file is saved successfully, the properties of the
        FileReference object are populated with the properties of the local
        file. The `complete` event is dispatched if the save is successful.

        Only one `browse()` or `save()` session can be performed at a time
        (because only one dialog box can be invoked at a time).

        In Flash Player, you can only call this method successfully in
        response to a user event (for example, in an event handler for a mouse
        click or keypress event). Otherwise, calling this method results in
        Flash Player throwing an Error exception. This limitation does not
        apply to AIR content in the application sandbox.

        In Adobe AIR, the save dialog is not always displayed in front of
        windows that are "owned" by another window (windows that have a
        non-null `owner` property). To avoid window ordering issues, hide
        owned windows before calling this method.

        @param data            The data to be saved. The data can be in one of
                               several formats, and will be treated
                               appropriately:
                               * If the value is `null`, the application
                               throws an ArgumentError exception.
                               * If the value is a String, it is saved as a
                               UTF-8 text file.
                               * If the value is XML, it is written to a text
                               file in XML format, with all formatting
                               preserved.
                               * If the value is a ByteArray object, it is
                               written to a data file verbatim.
                               * If the value is none of the above, the
                               `save()` method calls the `toString()` method
                               of the object to convert the data to a string,
                               and it then saves the data as a text file. If
                               that fails, the application throws an
                               ArgumentError exception.
        @param defaultFileName The default filename displayed in the dialog
                               box for the file to be saved. This string must
                               not contain the following characters: `/ \ : * ? " < > | %`
                               If a File object calls this method, the
                               filename will be that of the file the File
                               object references. (The AIR File class extends
                               the FileReference class.)
        @throws ArgumentError         If `data` is not of type ByteArray, and
                                      it does not have a `toString()` method,
                                      an exception is thrown. If `data` is not
                                      of type XML, and it does not have a
                                      `toXMLString()` method, an exception is
                                      thrown.
        @throws Error                 If the method is not called in response
                                      to a user action, such as a mouse event
                                      or keypress event.
        @throws IllegalOperationError Thrown in the following situations: 1)
                                      Another browse session is in progress;
                                      only one file browsing session can be
                                      performed at a time. 2) The filename to
                                      download contains prohibited characters.
                                      3) A setting in the user's mms.cfg file
                                      prohibits this operation.
        @throws MemoryError           This error can occur if Flash Player
                                      cannot allocate memory for the file. The
                                      file may be too large or available
                                      memory may be too low.
        @event cancel   Dispatched when the user dismisses the dialog box.
        @event complete Dispatched when the file download operation
                        successfully completes.
        @event ioError  Dispatched if an input/output error occurs while the
                        file is being read or transmitted.
        @event open     Dispatched when a download operation starts.
        @event progress Dispatched periodically during the file download
                        operation.
        @event select   Dispatched when the user selects a file for download
                        from the dialog box.
    **/
    save(data, defaultFileName = null) {
        // __backend.save(data, defaultFileName);
    }
    /**
        Starts the upload of the file to a remote server. Although Flash
        Player has no restriction on the size of files you can upload or
        download, the player officially supports uploads or downloads of up to
        100 MB. You must call the `FileReference.browse()` or
        `FileReferenceList.browse()` method before you call this method.
        For the Adobe AIR File class, which extends the FileReference class,
        you can use the `upload()` method to upload any file. For the
        FileReference class (used in Flash Player), the user must first select
        a file.

        Listeners receive events to indicate the progress, success, or failure
        of the upload. Although you can use the FileReferenceList object to
        let users select multiple files for upload, you must upload the files
        one by one; to do so, iterate through the `FileReferenceList.fileList`
        array of FileReference objects.

        The `FileReference.upload()` and `FileReference.download()` functions
        are nonblocking. These functions return after they are called, before
        the file transmission is complete. In addition, if the FileReference
        object goes out of scope, any upload or download that is not yet
        completed on that object is canceled upon leaving the scope. Be sure
        that your FileReference object remains in scope for as long as the
        upload or download is expected to continue.

        The file is uploaded to the URL passed in the `url` parameter. The URL
        must be a server script configured to accept uploads. Flash Player
        uploads files by using the HTTP `POST` method. The server script that
        handles the upload should expect a `POST` request with the following
        elements:

        * `Content-Type` of `multipart/form-data`
        * `Content-Disposition` with a `name` attribute set to `"Filedata"` by
        default and a `filename` attribute set to the name of the original
        file
        * The binary contents of the file

        You cannot connect to commonly reserved ports. For a complete list of
        blocked ports, see "Restricting Networking APIs" in the _ActionScript
        3.0 Developer's Guide_.

        For a sample `POST` request, see the description of the
        `uploadDataFieldName` parameter. You can send `POST` or `GET`
        parameters to the server with the `upload()` method; see the
        description of the `request` parameter.

        If the `testUpload` parameter is `true`, and the file to be uploaded
        is bigger than approximately 10 KB, Flash Player on Windows first
        sends a test upload `POST` operation with zero content before
        uploading the actual file, to verify that the transmission is likely
        to succeed. Flash Player then sends a second `POST` operation that
        contains the actual file content. For files smaller than 10 KB, Flash
        Player performs a single upload `POST` with the actual file content to
        be uploaded. Flash Player on Macintosh does not perform test upload
        `POST` operations.

        **Note**: If your server requires user authentication, only SWF files
        running in a browser נthat is, using the browser plug-in or ActiveX
        control נcan provide a dialog box to prompt the user for a username
        and password for authentication, and only for downloads. For uploads
        using the plug-in or ActiveX control, or for uploads and downloads
        using the stand-alone or external player, the file transfer fails.

        When you use this method , consider the Flash Player security model:

        * Loading operations are not allowed if the calling SWF file is in an
        untrusted local sandbox.
        * The default behavior is to deny access between sandboxes. A website
        can enable access to a resource by adding a URL policy file.
        * You can prevent a SWF file from using this method by setting the
        `allowNetworking` parameter of the the `object` and `embed` tags in
        the HTML page that contains the SWF content.

        However, in Adobe AIR, content in the `application` security sandbox
        (content installed with the AIR application) are not restricted by
        these security limitations.

        For more information related to security, see the Flash Player
        Developer Center Topic: <a
        href="http://www.adobe.com/go/devnet_security_en"
        scope="external">Security</a>.

        Note that because of new functionality added to the Flash Player, when
        publishing to Flash Player 10, you can have only one of the following
        operations active at one time: `FileReference.browse()`,
        `FileReference.upload()`, `FileReference.download()`,
        `FileReference.load()`, `FileReference.save()`. Otherwise, Flash
        Player throws a runtime error (code 2174). Use
        `FileReference.cancel()` to stop an operation in progress. This
        restriction applies only to Flash Player 10. Previous versions of
        Flash Player are unaffected by this restriction on simultaneous
        multiple operations.

        @param request             The URLRequest object; the `url` property
                                   of the URLRequest object should contain the
                                   URL of the server script configured to
                                   handle upload through HTTP `POST` calls. On
                                   some browsers, URL strings are limited in
                                   length. Lengths greater than 256 characters
                                   may fail on some browsers or servers. If
                                   this parameter is `null`, an exception is
                                   thrown. The `requestHeaders` property of
                                   the URLRequest object is ignored; custom
                                   HTTP request headers are not supported in
                                   uploads or downloads.
                                   The URL can be HTTP or, for secure uploads,
                                   HTTPS. To use HTTPS, use an HTTPS url in
                                   the `url` parameter. If you do not specify
                                   a port number in the `url` parameter, port
                                   80 is used for HTTP and port 443 us used
                                   for HTTPS, by default.

                                   To send `POST` or `GET` parameters to the
                                   server, set the `data` property of the
                                   URLRequest object to your parameters, and
                                   set the `method` property to either
                                   `URLRequestMethod.POST` or
                                   `URLRequestMethod.GET`.
        @param uploadDataFieldName The field name that precedes the file data
                                   in the upload `POST` operation. The
                                   `uploadDataFieldName` value must be
                                   non-null and a non-empty String. By
                                   default, the value of `uploadDataFieldName`
                                   is `"Filedata"`, as shown in the following
                                   sample `POST` request: <pre
                                   xml:space="preserve"> Content-Type:
                                   multipart/form-data; boundary=AaB03x
                                   --AaB03x Content-Disposition: form-data;
                                   name="Filedata"; filename="example.jpg"
                                   Content-Type: application/octet-stream ...
                                   contents of example.jpg ... --AaB03x--
                                   </pre>
        @param testUpload          A setting to request a test file upload. If
                                   `testUpload` is `true`, for files larger
                                   than 10 KB, Flash Player attempts a test
                                   file upload `POST` with a Content-Length of
                                   0. The test upload checks whether the
                                   actual file upload will be successful and
                                   that server authentication, if required,
                                   will succeed. A test upload is only
                                   available for Windows players.
        @throws ArgumentError         Thrown in the following situations: 1)
                                      The `uploadDataFieldName` parameter is
                                      an empty string. 2) `url.data` is of
                                      type ByteArray. For use with the
                                      `FileReference.upload()` and
                                      `FileReference.download()` methods,
                                      `url.data` may only be of type
                                      URLVariables or String. 3) In the AIR
                                      runtime (in the application security
                                      sandbox), the method of the URLRequest
                                      is not GET or POST (use
                                      `uploadEncoded()` instead).
        @throws IllegalOperationError Thrown in the following situations: 1)
                                      Another FileReference or
                                      FileReferenceList browse session is in
                                      progress; only one file browsing session
                                      may be performed at a time. 2) The URL
                                      parameter is not a valid path or
                                      protocol. File upload must use HTTP, and
                                      file download must use FTP or HTTP. 3)
                                      The `uploadDataFieldName` parameter is
                                      set to `null`. 4) A setting in the
                                      user's mms.cfg file prohibits this
                                      operation.
        @throws MemoryError           This error can occur for the following
                                      reasons: 1) Flash Player cannot convert
                                      the `URLRequest.data` parameter from
                                      UTF8 to MBCS. This error is applicable
                                      if the URLRequest object passed to
                                      `FileReference.upload()` is set to
                                      perform a GET operation and if
                                      `System.useCodePage` is set to `true`.
                                      2) Flash Player cannot allocate memory
                                      for the `POST` data. This error is
                                      applicable if the URLRequest object
                                      passed to `FileReference.upload()` is
                                      set to perform a `POST` operation.
        @throws SecurityError         Local untrusted SWF files may not
                                      communicate with the Internet. To avoid
                                      this situation, reclassify this SWF file
                                      as local-with-networking or trusted.
                                      This exception is thrown with a message
                                      indicating the name of the local file
                                      and the URL that may not be accessed.
        @throws SecurityError         You cannot connect to commonly reserved
                                      ports. For a complete list of blocked
                                      ports, see "Restricting Networking APIs"
                                      in the _ActionScript 3.0 Developer's
                                      Guide_.
        @event complete           Dispatched when the file upload operation
                                  completes successfully.
        @event httpResponseStatus The upload operation completes successfully
                                  and the server returns a response URL and
                                  response headers.
        @event httpStatus         Dispatched when an upload fails because of
                                  an HTTP error.
        @event ioError            Invoked in any of the following situations:
                                  * The upload fails because of an
                                  input/output error while Flash Player or
                                  Adobe AIR is reading, writing, or
                                  transmitting the file.
                                  * The upload fails because an attempt to
                                  upload a file to a server that requires
                                  authentication (such as a user name and
                                  password). During upload, no mean is
                                  provided for users to enter passwords.
                                  * The upload fails because the `url`
                                  parameter contains an invalid protocol.
                                  `FileReference.upload()` must use HTTP or
                                  HTTPS.
        @event open               Dispatched when an upload operation starts.
        @event progress           Dispatched periodically during the file
                                  upload operation.
        @event securityError      Dispatched when an upload fails because of a
                                  security violation.
        @event uploadCompleteData Dispatched when data has been received from
                                  the server after a successful file upload.
    **/
    upload(request, uploadDataFieldName = "Filedata", testUpload = false) {
        // openfl._internal.Lib.notImplemented();
    }
}

/**
    The FileReferenceList class provides a means to let users select one or
    more files for uploading. A FileReferenceList object represents a group of
    one or more local files on the user's disk as an array of FileReference
    objects. For detailed information and important considerations about
    FileReference objects and the FileReference class, which you use with
    FileReferenceList, see the FileReference class.
    To work with the FileReferenceList class:

    * Instantiate the class: `var myFileRef = new FileReferenceList();`
    * Call the `FileReferenceList.browse()` method, which opens a dialog box
    that lets the user select one or more files for upload:
    `myFileRef.browse();`
    * After the `browse()` method is called successfully, the `fileList`
    property of the FileReferenceList object is populated with an array of
    FileReference objects.
    * Call `FileReference.upload()` on each element in the `fileList` array.

    The FileReferenceList class includes a `browse()` method and a `fileList`
    property for working with multiple files. While a call to
    `FileReferenceList.browse()` is executing, SWF file playback pauses in
    stand-alone and external versions of Flash Player and in AIR for Linux and
    Mac OS X 10.1 and earlier.

    @event cancel Dispatched when the user dismisses the file-browsing dialog
                  box. (This dialog box opens when you call the
                  `FileReferenceList.browse()`, `FileReference.browse()`, or
                  `FileReference.download()` methods.)
    @event select Dispatched when the user selects one or more files to upload
                  from the file-browsing dialog box. (This dialog box opens
                  when you call the `FileReferenceList.browse()`,
                  `FileReference.browse()`, or `FileReference.download()`
                  methods.) When the user selects a file and confirms the
                  operation (for example, by clicking Save), the
                  `FileReferenceList` object is populated with FileReference
                  objects that represent the files that the user selects.
**/
class FileReferenceList extends EventDispatcher {
    /**
        Creates a new FileReferenceList object. A FileReferenceList object
        contains nothing until you call the `browse()` method on it and the
        user selects one or more files. When you call `browse()` on the
        FileReference object, the `fileList` property of the object is
        populated with an array of `FileReference` objects.
    **/
    constructor() {
        super();
        // __backend = new FileReferenceListBackend(this);
    }
    /**
        Displays a file-browsing dialog box that lets the user select one or
        more local files to upload. The dialog box is native to the user's
        operating system.
        In Flash Player 10 and later, you can call this method successfully
        only in response to a user event (for example, in an event handler for
        a mouse click or keypress event). Otherwise, calling this method
        results in Flash Player throwing an Error.

        When you call this method and the user successfully selects files, the
        `fileList` property of this FileReferenceList object is populated with
        an array of FileReference objects, one for each file that the user
        selects. Each subsequent time that the FileReferenceList.browse()
        method is called, the `FileReferenceList.fileList` property is reset
        to the file(s) that the user selects in the dialog box.

        Using the `typeFilter` parameter, you can determine which files the
        dialog box displays.

        Only one `FileReference.browse()`, `FileReference.download()`, or
        `FileReferenceList.browse()` session can be performed at a time on a
        FileReferenceList object (because only one dialog box can be opened at
        a time).

        @return Returns `true` if the parameters are valid and the
                file-browsing dialog box opens.
        @throws ArgumentError         If the `typeFilter` array does not
                                      contain correctly formatted FileFilter
                                      objects, an exception is thrown. For
                                      details on correct filter formatting,
                                      see the FileFilter documentation.
        @throws Error                 If the method is not called in response
                                      to a user action, such as a mouse event
                                      or keypress event.
        @throws IllegalOperationError Thrown for the following reasons: 1)
                                      Another FileReference or
                                      FileReferenceList browse session is in
                                      progress; only one file browsing session
                                      may be performed at a time. 2) A setting
                                      in the user's mms.cfg file prohibits
                                      this operation.
        @event cancel Invoked when the user dismisses the dialog box by
                      clicking Cancel or by closing it.
        @event select Invoked when the user has successfully selected an item
                      for upload from the dialog box.
    **/
    browse(typeFilter = null) {
        // return __backend.browse(typeFilter);
        return false;
    }
    // Get & Set Methods
    /**
        An array of `FileReference` objects.
        When the `FileReferenceList.browse()` method is called and the user
        has selected one or more files from the dialog box that the `browse()`
        method opens, this property is populated with an array of
        FileReference objects, each of which represents the files the user
        selected. You can then use this array to upload each file with the
        `FileReference.upload()`method. You must upload one file at a time.

        The `fileList` property is populated anew each time browse() is called
        on that FileReferenceList object.

        The properties of `FileReference` objects are described in the
        FileReference class documentation.
    **/
    get fileList() {
        return this.__fileList;
    }
}

/**
    The NetConnection class creates a two-way connection between a client and
    a server. The client can be a Flash Player or AIR application. The server
    can be a web server, Flash Media Server, an application server running
    Flash Remoting, or the <a
    href="http://labs.adobe.com/technologies/stratus/" scope="external">Adobe
    Stratus</a> service. Call `NetConnection.connect()` to establish the
    connection. Use the NetStream class to send streams of media and data over
    the connection.
    For security information about loading content and data into Flash Player
    and AIR, see the following:

    * To load content and data into Flash Player from a web server or from a
    local location, see <a href="http://www.adobe.com/go/devnet_security_en"
    scope="external">Flash Player Developer Center: Security</a>.
    * To load content and data into Flash Player and AIR from Flash Media
    Server, see the <a href="http://www.adobe.com/support/flashmediaserver"
    scope="external">Flash Media Server documentation</a>.
    * To load content and data into AIR, see the <a
    href="http://www.adobe.com/devnet/air/" scope="external">Adobe AIR
    Developer Center</a>.

    To write callback methods for this class, extend the class and define the
    callback methods in the subclass, or assign the `client` property to an
    object and define the callback methods on that object.

    @event asyncError    Dispatched when an exception is thrown asynchronously
                         נthat is, from native asynchronous code.
    @event ioError       Dispatched when an input or output error occurs that
                         causes a network operation to fail.
    @event netStatus     Dispatched when a NetConnection object is reporting
                         its status or error condition. The `netStatus` event
                         contains an `info` property, which is an information
                         object that contains specific information about the
                         event, such as whether a connection attempt succeeded
                         or failed.
    @event securityError Dispatched if a call to NetConnection.call() attempts
                         to connect to a server outside the caller's security
                         sandbox.
**/
let NetConnection = /** @class */ (() => {
    class NetConnection extends EventDispatcher {
        /**
            The default object encoding for NetConnection objects. When an object
            is written to or read from binary data, the `defaultObjectEncoding`
            property indicates which Action Message Format (AMF) version is used
            to serialize the data: the ActionScript 3.0 format
            (`ObjectEncoding.AMF3`) or the ActionScript 1.0 and ActionScript 2.0
            format (`ObjectEncoding.AMF0`).
            The default value is `ObjectEncoding.AMF3`. Changing
            `NetConnection.defaultObjectEncoding` does not affect existing
            NetConnection instances; it affects only instances that are created
            subsequently.
    
            To set an object's encoding separately (rather than setting object
            encoding for the entire application), set the `objectEncoding`
            property of the NetConnection object instead.
    
            For more detailed information, see the description of the
            `objectEncoding` property.
        **/
        // /** @hidden */ @:dox(hide) public static defaultObjectEncoding:ObjectEncoding;
        /**
            Indicates the object on which callback methods are invoked. The
            default is this NetConnection instance. If you set the `client`
            property to another object, callback methods will be invoked on that
            object.
    
            @throws TypeError The `client` property must be set to a non-null
                              object.
        **/
        // /** @hidden */ @:dox(hide) public client:Dynamic;
        /**
            Indicates whether the application is connected to a server through a
            persistent RTMP connection (`true`) or not (`false`). When connected
            through HTTP, this property is `false`, except when connected to Flash
            Remoting services on an application server, in which case it is
            `true`.
        **/
        // /** @hidden */ @:dox(hide) public connected (default, null):Bool;
        /**
            The proxy type used to make a successful connection to Flash Media
            Server. Possible values are: `"none"`, `"HTTP"`, `"HTTPS"`, or
            `"CONNECT"`.
            The value is `"none"` if the connection is not tunneled or is a native
            SSL connection.
    
            The value is `"HTTP"` if the connection is tunneled over HTTP.
    
            The value is `"HTTPS"` if the connection is tunneled over HTTPS,
    
            The value is `"CONNECT"` if the connection is tunneled using the
            CONNECT method through a proxy server.
    
            @throws ArgumentError An attempt was made to access this property when
                                  the NetConnection instance was not connected.
        **/
        // /** @hidden */ @:dox(hide) public connectedProxyType (default, null):String;
        /**
            The identifier of the Flash Media Server instance to which this Flash
            Player or Adobe AIR instance is connected. This property is meaningful
            only for RTMFP connections. The value of this property is available
            only after an RTMFP connection is established.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public farID (default, null):String;
        /**
            A value chosen substantially by Flash Media Server, unique to this
            connection. This value appears to the server as its `client.nearNonce`
            value. This value is defined only for RTMFP, RTMPE, and RTMPTE
            connections.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public farNonce (default, null):String;
        /**
            The total number of inbound and outbound peer connections that this
            instance of Flash Player or Adobe AIR allows. The default value is 8.
            This value does not distinguish between publisher and subscriber
            connections. If this value is reduced while peer connections are
            present, the new value affects new incoming connections only. Existing
            connections are not dropped.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public maxPeerConnections:UInt;
        /**
            The identifier of this Flash Player or Adobe AIR instance for this
            NetConnection instance. This property is meaningful only for RTMFP
            connections.
            Every NetConnection instance has a unique `nearID` property. No Flash
            Player or Adobe AIR instance or NetConnection instance has the same
            identifier.
    
            Other Flash Player or Adobe AIR instances use this identifier as the
            `peerID` for new NetStream connections to this client. Subsequently,
            this identifier is the `farID` in any peer NetStream that connects to
            this instance.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public nearID (default, null):String;
        /**
            A value chosen substantially by this Flash Player or Adobe AIR
            instance, unique to this connection. This value appears to the server
            as its `client.farNonce` value. This value is defined only for RTMFP,
            RTMPE, and RTMPTE connections.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public nearNonce (default, null):String;
        /**
            The object encoding for this NetConnection instance.
            When an object is written to or read from binary data, the
            `defaultObjectEncoding` property indicates which Action Message Format
            (AMF) version is used to serialize the data: the ActionScript 3.0
            format (`ObjectEncoding.AMF3`) or the ActionScript 1.0 and
            ActionScript 2.0 format (`ObjectEncoding.AMF0`). Set the
            `objectEncoding` property to set an AMF version for a NetConnection
            instance.
    
            It's important to understand this property if your application needs
            to communicate with servers released prior to Flash Player 9. The
            following three scenarios are possible:
    
            * Connecting to a server that supports AMF3 (for example, Flex Data
            Services 2 or Flash Media Server 3). The default value of
            `defaultObjectEncoding` is `ObjectEncoding.AMF3`. All NetConnection
            instances created in this file use AMF3 serialization, so you don't
            need to set the `objectEncoding` property.
            * Connecting to a server that doesn't support AMF3 (for example, Flash
            Media Server 2). In this scenario, set the static
            `NetConnection.defaultObjectEncoding` property to
            `ObjectEncoding.AMF0`. All NetConnection instances created in this SWF
            file use AMF0 serialization. You don't need to set the
            `objectEncoding` property.
            * Connecting to multiple servers that use different encoding versions.
            Instead of using `defaultObjectEncoding`, set the object encoding on a
            per-connection basis using the `objectEncoding` property for each
            connection. Set it to `ObjectEncoding.AMF0` to connect to servers that
            use AMF0 encoding, such as Flash Media Server 2, and set it to
            `ObjectEncoding.AMF3` to connect to servers that use AMF3 encoding,
            such as Flex Data Services 2.
    
            Once a NetConnection instance is connected, its `objectEncoding`
            property is read-only.
    
            If you use the wrong encoding to connect to a server, the
            NetConnection object dispatches the `netStatus` event. The
            `NetStatusEvent.info` property contains an information object with a
            `code` property value of `NetConnection.Connect.Failed`, and a
            description explaining that the object encoding is incorrect.
    
            @throws ArgumentError  This property was set to a value other than
                                   `ObjectEncoding.AMF0` or `ObjectEncoding.AMF3`.
            @throws ReferenceError An attempt was made to set the value of the
                                   `objectEncoding` property while the
                                   NetConnection instance was connected.
        **/
        // /** @hidden */ @:dox(hide) public objectEncoding:ObjectEncoding;
        /**
            The protocol used to establish the connection. This property is
            relevant when using Flash Media Server. Possible values are as
            follows:
            * `"rtmp"`: Real-Time Messaging Protocol (RTMP)
            * `"rtmpe"`: Encrypted RTMP
            * `"rtmpt"`: HTTP tunneling RTMP
            * `"rtmpte"`: HTTP tunneling encrypted RTMP
            * `"rtmps"`: HTTPS-based RTMP
            * `"rtmfp"`: Real-Time Media Flow Protocol (RTMFP)
    
            @throws ArgumentError An attempt was made to access this property when
                                  the NetConnection instance was not connected.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public protocol (default, null):String;
        /**
            Determines which fallback methods are tried if an initial connection
            attempt to Flash Media Server fails. Set the `proxyType` property
            before calling the `NetConnection.connect()` method.
            Acceptable values are `"none"`, `"HTTP"`, `"CONNECT"`, and
            `"best"`.The default value is `"none"`.
    
            To use native SSL, set the property to `"best"`. If the player cannot
            make a direct connection to the server (over the default port of 443
            or over another port that you specify) and a proxy server is in place,
            the player tries to use the CONNECT method. If that attempt fails, the
            player tunnels over HTTPS.
    
            If the property is set to `"HTTP"` and a direct connection fails, HTTP
            tunneling is used. If the property is set to `"CONNECT"` and a direct
            connection fails, the `CONNECT` method of tunneling is used. If that
            fails, the connection does not fall back to HTTP tunneling.
    
            This property is applicable only when using RTMP, RTMPS, or RTMPT. The
            `CONNECT` method is applicable only to users who are connected to the
            network by a proxy server.
        **/
        // /** @hidden */ @:dox(hide) public proxyType:String;
        /**
            An object that holds all of the peer subscriber NetStream objects that
            are not associated with publishing NetStream objects. Subscriber
            NetStream objects that are associated with publishing NetStream
            objects are in the `NetStream.peerStreams` array.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10) public unconnectedPeerStreams (default, null):Array<Dynamic>;
        /**
            The URI passed to the NetConnection.connect() method. If
            `NetConnection.connect()` hasn't been called or if no URI was passed,
            this property is `undefined`.
        **/
        // /** @hidden */ @:dox(hide) public uri (default, null):String;
        /**
            Indicates whether a secure connection was made using native Transport
            Layer Security (TLS) rather than HTTPS. This property is valid only
            when a NetConnection object is connected.
    
            @throws ArgumentError An attempt was made to access this property when
                                  the NetConnection instance was not connected.
        **/
        // /** @hidden */ @:dox(hide) public usingTLS (default, null):Bool;
        /**
            Creates a NetConnection object. Call the `connect()` method to make a
            connection.
            If an application needs to communicate with servers released prior to
            Flash Player 9, set the NetConnection object's `objectEncoding`
            property.
    
            The following code creates a NetConnection object:
    
            ```haxe
            var nc = new NetConnection();
            ```
        **/
        constructor() {
            super();
        }
        /**
            Adds a context header to the Action Message Format (AMF) packet
            structure. This header is sent with every future AMF packet. If you
            call `NetConnection.addHeader()` using the same name, the new header
            replaces the existing header, and the new header persists for the
            duration of the NetConnection object. You can remove a header by
            calling `NetConnection.addHeader()` with the name of the header to
            remove an undefined object.
    
            @param operation      Identifies the header and the ActionScript
                                  object data associated with it.
            @param mustUnderstand A value of `true` indicates that the server must
                                  understand and process this header before it
                                  handles any of the following headers or
                                  messages.
            @param param          Any ActionScript object.
        **/
        // /** @hidden */ @:dox(hide) public addHeader (operation:String, mustUnderstand:Bool = false, ?param:Object):Void;
        /**
            Calls a command or method on Flash Media Server or on an application
            server running Flash Remoting. Before calling `NetConnection.call()`
            you must call `NetConnection.connect()` to connect to the server. You
            must create a server-side to pass to this method.
            You cannot connect to commonly reserved ports. For a complete list of
            blocked ports, see "Restricting Networking APIs" in the _ActionScript
            3.0 Developer's Guide_.
    
            @param command   A method specified in the form `[objectPath/]method`.
                             For example, the `someObject/doSomething` command
                             tells the remote server to call the
                             `clientObject.someObject.doSomething()` method, with
                             all the optional `... arguments` parameters. If the
                             object path is missing, `clientObject.doSomething()`
                             is invoked on the remote server.
                             With Flash Media Server, `command` is the name of a
                             defined in an application's server-side
                             script. You do not need to use an object path before
                             `command` if the server-side script is placed at the
                             root level of the application directory.
            @param responder An optional object that is used to handle return
                             values from the server. The Responder object can have
                             two defined methods to handle the returned result:
                             `result` and `status`. If an error is returned as the
                             result, `status` is invoked; otherwise, `result` is
                             invoked. The Responder object can process errors
                             related to specific operations, while the
                             NetConnection object responds to errors related to
                             the connection status.
            @event securityError A call attempted to communicate with a server
                                 outside the caller's security sandbox. You can
                                 avoid this problem by using a policy file on the
                                 server.
        **/
        // /** @hidden */ @:dox(hide) public call (command:String, responder:openfl.net.Responder, ?p1:Dynamic, ?p2:Dynamic, ?p3:Dynamic, ?p4:Dynamic, ?p5:Dynamic):Void;
        /**
            Closes the connection that was opened locally or to the server and
            dispatches a `netStatus` event with a `code` property of
            `NetConnection.Connect.Closed`.
            This method disconnects all NetStream objects running over the
            connection. Any queued data that has not been sent is discarded. (To
            terminate local or server streams without closing the connection, use
            `NetStream.close()`.) If you close the connection and then want to
            create a new one, you must create a new NetConnection object and call
            the `connect()` method again.
    
            The `close()` method also disconnects all remote shared objects
            running over this connection. However, you don't need to recreate the
            shared object to reconnect. Instead, you can just call
            `SharedObject.connect()` to reestablish the connection to the shared
            object. Also, any data in the shared object that was queued when you
            issued `NetConnection.close()` is sent after you reestablish a
            connection to the shared object.
    
            With Flash Media Server, the best development practice is to call
            `close()` when the client no longer needs the connection to the
            server. Calling `close()` is the fastest way to clean up unused
            connections. You can configure the server to close idle connections
            automatically as a back-up measure. For more information, see the _<a
            href="http://www.adobe.com/support/documentation"
            scope="external">Flash Media Server Configuration and Administration
            Guide</a>_.
    
        **/
        // /** @hidden */ @:dox(hide) public close ():Void;
        /**
            Creates a two-way connection to an application on Flash Media Server
            or to Flash Remoting, or creates a two-way network endpoint for RTMFP
            peer-to-peer group communication. To report its status or an error
            condition, a call to `NetConnection.connect()` dispatches a
            `netStatus` event.
            Call `NetConnection.connect()` to do the following:
    
            * Pass "null" to play video and mp3 files from a local file system or
            from a web server.
            * Pass an "http" URL to connect to an application server running Flash
            Remoting. Use the NetServices class to call functions on and return
            results from application servers over a NetConnection object. For more
            information, see the <a
            href="http://www.adobe.com/support/documentation"
            scope="external">Flash Remoting documentation</a>.
            * Pass an "rtmp/e/s" URL to connect to a Flash Media Server
            application.
            * Pass an "rtmfp" URL to create a two-way network endpoint for RTMFP
            client-server, peer-to-peer, and IP multicast communication.
            * Pass the string "rtmfp:" to create a serverless two-way network
            endpoint for RTMFP IP multicast communication.
    
            Consider the following security model:
    
            * By default, Flash Player or AIR denies access between sandboxes. A
            website can enable access to a resource by using a URL policy file.
            * Your application can deny access to a resource on the server. In a
            Flash Media Server application, use Server-Side ActionScript code to
            deny access. See the <a
            href="http://www.adobe.com/go/learn_fms_docs_en"
            scope="external">Flash Media Server documentation</a>.
            * You cannot call `NetConnection.connect()` if the calling file is in
            the local-with-file-system sandbox.
            *  You cannot connect to commonly reserved ports. For a complete list
            of blocked ports, see "Restricting Networking APIs" in the
            _ActionScript 3.0 Developer's Guide_.
            * To prevent a SWF file from calling this method, set the
            `allowNetworking` parameter of the the `object` and `embed` tags in
            the HTML page that contains the SWF content.
    
            However, in Adobe AIR, content in the `application` security sandbox
            (content installed with the AIR application) are not restricted by
            these security limitations.
    
            For more information about security, see the Adobe Flash Player
            Developer Center: <a href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
    
            @param command Use one of the following values for the `command`
                           parameter:
                           * To play video and mp3 files from a local file system
                           or from a web server, pass `null`.
                           * To connect to an application server running Flash
                           Remoting, pass a URL that uses the `http` protocol.
                           * (Flash Player 10.1 or AIR 2 or later) To create a
                           serverless network endpoint for RTMFP IP multicast
                           communication, pass the string `"rtmfp:"`. Use this
                           connection type to receive an IP multicast stream from
                           a publisher without using a server. You can also use
                           this connection type to use IP multicast to discover
                           peers on the same local area network (LAN).
                           This connection type has the following limitations:
                           Only peers on the same LAN can discover each other.
                           Using IP multicast, Flash Player can receive streams,
                           it cannot send them.
                           Flash Player and AIR can send and receive streams in a
                           peer-to-peer group, but the peers must be discovered on
                           the same LAN using IP multicast.
                           This technique cannot be used for one-to-one
                           communication.
                           <p/>
                           * To connect to Flash Media Server, pass the URI of the
                           application on the server. Use the following syntax
                           (items in brackets are optional):
                           `protocol:[//host][:port]/appname[/instanceName]`
    
                           Use one of the following protocols: `rtmp`, `rtmpe`,
                           `rtmps`, `rtmpt`, `rtmpte`, or `rtmfp`. If the
                           connection is successful, a `netStatus` event with a
                           `code` property of `NetConnection.Connect.Success` is
                           returned. See the `NetStatusEvent.info` property for a
                           list of all event codes returned in response to calling
                           `connect()`.
    
                           If the file is served from the same host where the
                           server is installed, you can omit the `//host`
                           parameter. If you omit the `/instanceName` parameter,
                           Flash Player or AIR connects to the application's
                           default instance.
    
                           (Flash Player 10.1 or AIR 2 or later)To create
                           peer-to-peer applications, use the `rtmfp` protocol.
            @throws ArgumentError The URI passed to the `command` parameter is
                                  improperly formatted.
            @throws IOError       The connection failed. This can happen if you
                                  call `connect()` from within a `netStatus` event
                                  handler, which is not allowed.
            @throws SecurityError Local-with-filesystem SWF files cannot
                                  communicate with the Internet. You can avoid
                                  this problem by reclassifying the SWF file as
                                  local-with-networking or trusted.
            @throws SecurityError You cannot connect to commonly reserved ports.
                                  For a complete list of blocked ports, see
                                  "Restricting Networking APIs" in the
                                  _ActionScript 3.0 Developer's Guide_.
        **/
        connect(command, ...parameters) {
            if (command != null) {
                throw "Error: Can only connect in \"HTTP streaming\" mode";
            }
            this.dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, true, { code: NetConnection.CONNECT_SUCCESS }));
        }
    }
    NetConnection.CONNECT_SUCCESS = "NetConnection.Connect.Success";
    return NetConnection;
})();

var _end;
/**
    The NetStream class opens a one-way streaming channel over a
    NetConnection.
    Use the NetStream class to do the following:

    * Call `NetStream.play()` to play a media file from a local disk, a web
    server, or Flash Media Server.
    * Call `NetStream.publish()` to publish a video, audio, and data stream to
    Flash Media Server.
    * Call `NetStream.send()` to send data messages to all subscribed clients.
    * Call `NetStream.send()` to add metadata to a live stream.
    * Call `NetStream.appendBytes()` to pass ByteArray data into the
    NetStream.

    **Note:**You cannot play and publish a stream over the same NetStream
    object.

    Adobe AIR and Flash Player 9.0.115.0 and later versions support files
    derived from the standard MPEG-4 container format. These files include
    F4V, MP4, M4A, MOV, MP4V, 3GP, and 3G2 if they contain H.264 video, HEAAC
    v2 encoded audio, or both. H.264 delivers higher quality video at lower
    bit rates when compared to the same encoding profile in Sorenson or On2.
    AAC is a standard audio format defined in the MPEG-4 video standard.
    HE-AAC v2 is an extension of AAC that uses Spectral Band Replication (SBR)
    and Parametric Stereo (PS) techniques to increase coding efficiency at low
    bit rates.

    For information about supported codecs and file formats, see the
    following:

    * <a href="http://www.adobe.com/go/learn_fms_fileformats_en"
    scope="external">Flash Media Server documentation</a>
    * <a href="http://www.adobe.com/go/hardware_scaling_en"
    scope="external">Exploring Flash Player support for high-definition H.264
    video and AAC audio</a>
    * <a href="http://www.adobe.com/go/video_file_format"
    scope="external">FLV/F4V open specification documents</a>

    **Receiving data from a Flash Media Server stream, progressive F4V file,
    or progressive FLV file**

    Flash Media Server, F4V files, and FLV files can send event objects
    containing data at specific data points during streaming or playback. You
    can handle data from a stream or FLV file during playback in two ways:

    *  Associate a client property with an event handler to receive the data
    object. Use the `NetStream.client` property to assign an object to call
    specific data handling functions. The object assigned to the
    `NetStream.client` property can listen for the following data points:
    `onCuePoint()`, `onImageData()`, `onMetaData()`, `onPlayStatus()`,
    `onSeekPoint()`, `onTextData()`, and `onXMPData()`. Write procedures
    within those functions to handle the data object returned from the stream
    during playback. See the `NetStream.client` property for more information.

    *  Associate a client property with a subclass of the NetStream class,
    then write an event handler to receive the data object. NetStream is a
    sealed class, which means that properties or methods cannot be added to a
    NetStream object at runtime. However, you can create a subclass of
    NetStream and define your event handler in the subclass. You can also make
    the subclass dynamic and add the event handler to an instance of the
    subclass.

    Wait to receive a `NetGroup.Neighbor.Connect` event before you use the
    object replication, direct routing, or posting APIs.

    **Note:** To send data through an audio file, like an mp3 file, use the
    Sound class to associate the audio file with a Sound object. Then, use the
    `Sound.id3` property to read metadata from the sound file.

    @event asyncError       Dispatched when an exception is thrown
                            asynchronously נthat is, from native
                            asynchronous code. This event is dispatched when a
                            server calls a method on the client that is not
                            defined.
    @event drmAuthenticate  Dispatched when a NetStream object tries to play a
                            digital rights management (DRM) encrypted content
                            that requires a user credential for authentication
                            before playing.
                            Use the ` setDRMAuthenticationCredentials()`
                            method of the NetStream object to authenticate the
                            user. If user authentication failed, the
                            application retries authentication and dispatches
                            a new DRMAuthenticateEvent event for the NetStream
                            object.
    @event drmError         Dispatched when a NetStream object, trying to play
                            a digital rights management (DRM) encrypted file,
                            encounters a DRM-related error. For example, a
                            DRMErrorEvent object is dispatched when the user
                            authorization fails. This may be because the user
                            has not purchased the rights to view the content
                            or because the content provider does not support
                            the viewing application.
    @event drmStatus        Dispatched when the digital rights management
                            (DRM) encrypted content begins playing (when the
                            user is authenticated and authorized to play the
                            content).
                            DRMStatusEvent object contains information related
                            to the voucher, such as whether the content is
                            available offline or when the voucher expires and
                            users can no longer view the content.
    @event ioError          Dispatched when an input or output error occurs
                            that causes a network operation to fail.
    @event mediaTypeData    Dispatched when playing video content and certain
                            type of messages are processed.
                            A NetDataEvent is dispatched for the following
                            messages:

                            * onCuePoint
                            * onImageData
                            * onMetaData
                            * onPlayStatus (for code NetStream.Play.Complete)
                            * onTextData
                            * onXMPData

                            **Note:** This event is not dispatched by content
                            running in Flash Player in the browser on Android
                            or Blackberry Tablet OS or by content running in
                            AIR on iOS.
    @event netStatus        Dispatched when a NetStream object is reporting
                            its status or error condition. The `netStatus`
                            event contains an `info` property, which is an
                            information object that contains specific
                            information about the event, such as if a
                            connection attempt succeeded or failed.
    @event onCuePoint       Establishes a listener to respond when an embedded
                            cue point is reached while playing a video file.
                            You can use the listener to trigger actions in
                            your code when the video reaches a specific cue
                            point, which lets you synchronize other actions in
                            your application with video playback events. For
                            information about video file formats supported by
                            Flash Media Server, see the <a
                            href="http://www.adobe.com/go/learn_fms_fileformats_en"
                            scope="external">www.adobe.com/go/learn_fms_fileformats_en</a>.

                            `onCuePoint` is actually a property of the
                            `NetStream.client` object. IThe property is listed
                            in the Events section because it responds to a
                            data event, either when streaming media using
                            Flash Media Server or during FLV file playback.
                            For more information, see the NetStream class
                            description. You cannot use the
                            `addEventListener()` method, or any other
                            EventDispatcher methods, to listen for, or process
                            `onCuePoint` as an event. Define a callback
                            function and attach it to one of the following
                            objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. Create a subclass of NetStream and define
                            your event handler in the subclass. You can also
                            make the subclass dynamic and add the event
                            handler to an instance of the subclass.

                            The associated event listener is triggered after a
                            call to the `NetStream.play()` method, but before
                            the video playhead has advanced.

                            You can embed the following types of cue points in
                            a video file:

                            * A navigation cue point specifies a keyframe
                            within the video file and the cue point's `time`
                            property corresponds to that exact keyframe.
                            Navigation cue points are often used as bookmarks
                            or entry points to let users navigate through the
                            video file.
                            * An event cue point specifies a time. The time
                            may or may not correspond to a specific keyframe.
                            An event cue point usually represents a time in
                            the video when something happens that could be
                            used to trigger other application events.

                            The `onCuePoint` event object has the following
                            properties:

                            | Property | Description |
                            | --- | --- |
                            | `name` | The name given to the cue point when it was embedded in the video file. |
                            |`parameters` | An associative array of name and value pair strings specified for this cue point. Any valid string can be used for the parameter name or value. |
                            |`time` | The time in seconds at which the cue point occurred in the video file during playback. |
                            |`type` | The type of cue point that was reached, either navigation or event. |

                            You can define cue points in a video file when you
                            first encode the file, or when you import a video
                            clip in the Flash authoring tool by using the
                            Video Import wizard.

                            The `onMetaData` event also retrieves information
                            about the cue points in a video file. However the
                            `onMetaData` event gets information about all of
                            the cue points before the video begins playing.
                            The `onCuePoint` event receives information about
                            a single cue point at the time specified for that
                            cue point during playback.

                            Generally, to have your code respond to a specific
                            cue point at the time it occurs, use the
                            `onCuePoint` event to trigger some action in your
                            code.

                            You can use the list of cue points provided to the
                            `onMetaData` event to let the user start playing
                            the video at predefined points along the video
                            stream. Pass the value of the cue point's `time`
                            property to the `NetStream.seek()` method to play
                            the video from that cue point.
    @event onDRMContentData Establishes a listener to respond when AIR
                            extracts DRM content metadata embedded in a media
                            file.
                            A DRMContentData object contains the information
                            needed to obtain a voucher required to play a
                            DRM-protected media file. Use the DRMManager class
                            to download the voucher with this information.

                            `onDRMContentData` is a property of the
                            `NetStream.client` object. This property is listed
                            in the Events section because it responds to a
                            data event when preloading embedded data from a
                            local media file. For more information, see the
                            NetStream class description. You cannot use the
                            `addEventListener()` method, or any other
                            EventDispatcher methods, to listen for, or process
                            `onDRMContentData` as an event. Rather, you must
                            define a single callback and attach it
                            directly to one of the following objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. However, you can create a subclass of
                            NetStream and define your event handler in the
                            subclass or make the subclass dynamic and add the
                            event handler to an instance of the
                            subclass.
    @event onImageData      Establishes a listener to respond when Flash
                            Player receives image data as a byte array
                            embedded in a media file that is playing. The
                            image data can produce either JPEG, PNG, or GIF
                            content. Use the
                            `openfl.display.Loader.loadBytes()` method to load
                            the byte array into a display object.
                            `onImageData` is actually a property of the
                            `NetStream.client` object. The property is listed
                            in the Events section because it responds to a
                            data event, either when streaming media using
                            Flash Media Server or during FLV file playback.
                            For more information, see the NetStream class
                            description. You cannot use the
                            `addEventListener()` method, or any other
                            EventDispatcher methods, to listen for, or process
                            `onImageData` as an event. Define a single
                            callback and attach it to one of the
                            following objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. Create a subclass of NetStream and define
                            your event handler in the subclass. You can also
                            make the subclass dynamic and add the event
                            handler to an instance of the subclass.

                            The associated event listener is triggered after a
                            call to the `NetStream.play()` method, but before
                            the video playhead has advanced.

                            The onImageData event object contains the image
                            data as a byte array sent through an AMF0 data
                            channel.
    @event onMetaData       Establishes a listener to respond when Flash
                            Player receives descriptive information embedded
                            in the video being played. For information about
                            video file formats supported by Flash Media
                            Server, see the <a
                            href="http://www.adobe.com/go/learn_fms_fileformats_en"
                            scope="external">www.adobe.com/go/learn_fms_fileformats_en</a>.

                            `onMetaData` is actually a property of the
                            `NetStream.client` object. The property is listed
                            in the Events section because it responds to a
                            data event, either when streaming media using
                            Flash Media Server or during FLV file playback.
                            For more information, see the NetStream class
                            description and the `NetStream.client` property.
                            You cannot use the `addEventListener()` method, or
                            any other EventDispatcher methods, to listen for
                            or process `onMetaData` as an event. Define a
                            single callback and attach it to one of
                            the following objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. You can create a subclass of NetStream
                            and define your event handler in the subclass. You
                            can also make the subclass dynamic and add the
                            event handler to an instance of the
                            subclass.

                            The Flash Video Exporter utility (version 1.1 or
                            later) embeds a video's duration, creation date,
                            data rates, and other information into the video
                            file itself. Different video encoders embed
                            different sets of meta data.

                            The associated event listener is triggered after a
                            call to the `NetStream.play()` method, but before
                            the video playhead has advanced.

                            In many cases, the duration value embedded in
                            stream metadata approximates the actual duration
                            but is not exact. In other words, it does not
                            always match the value of the `NetStream.time`
                            property when the playhead is at the end of the
                            video stream.

                            The event object passed to the onMetaData event
                            handler contains one property for each piece of
                            data.
    @event onPlayStatus     Establishes a listener to respond when a NetStream
                            object has completely played a stream. The
                            associated event object provides information in
                            addition to what's returned by the `netStatus`
                            event. You can use this property to trigger
                            actions in your code when a NetStream object has
                            switched from one stream to another stream in a
                            playlist (as indicated by the information object
                            `NetStream.Play.Switch`) or when a NetStream
                            object has played to the end (as indicated by the
                            information object `NetStream.Play.Complete`).
                            `onPlayStaus` is actually a property of the
                            `NetStream.client` object. The property is listed
                            in the Events section because it responds to a
                            data event, either when streaming media using
                            Flash Media Server or during FLV file playback.
                            For more information, see the NetStream class
                            description. You cannot use the
                            `addEventListener()` method, or any other
                            EventDispatcher methods, to listen for, or process
                            `onPlayStatus` as an event. Define a callback
                            function and attach it to one of the following
                            objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. Create a subclass of NetStream and define
                            your event handler in the subclass. You can also
                            make the subclass dynamic and add the event
                            handler to an instance of the subclass.

                            This event can return an information object with
                            the following properties:

                            | Code property | Level property | Meaning |
                            | --- | --- | --- |
                            | `NetStream.Play.Switch` | `"status"` | The subscriber is switching from one stream to another in a playlist. |
                            | `NetStream.Play.Complete` | `"status"` | Playback has completed. |
                            | `NetStream.Play.TransitionComplete` | `"status"` | The subscriber is switching to a new stream as a result of stream bit-rate switching |
    @event onSeekPoint      Called synchronously from `appendBytes()` when the
                            append bytes parser encounters a point that it
                            believes is a seekable point (for example, a video
                            key frame). Use this event to construct a seek
                            point table. The `byteCount` corresponds to the
                            `byteCount` at the first byte of the parseable
                            message for that seek point, and is reset to zero
                            as described above. To seek, at the event
                            `NetStream.Seek.Notify`, find the bytes that start
                            at a seekable point and call `appendBytes(bytes)`.
                            If the `bytes` argument is a `ByteArray`
                            consisting of bytes starting at the seekable
                            point, the video plays at that seek point.
                            **Note:** Calls to `appendBytes()` from within
                            this callback are ignored.

                            The `onSeekPoint` property is a property of the
                            `NetStream.client` object. The property is listed
                            in the Events section because it responds to data
                            coming into the `appendBytes()` method. For more
                            information, see the NetStream class description
                            and the `NetStream.client` property. You cannot
                            use the `addEventListener()` method, or any other
                            EventDispatcher methods, to listen for or process
                            `onSeekPoint` as an event. To use `onSeekPoint`,
                            define a callback and attach it to one of
                            the following objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. However, you can create a subclass of
                            NetStream and define your event handler in the
                            subclass. You can also make the subclass dynamic
                            and add the event handler to an instance
                            of the subclass.
    @event onTextData       Establishes a listener to respond when Flash
                            Player receives text data embedded in a media file
                            that is playing. The text data is in UTF-8 format
                            and can contain information about formatting based
                            on the 3GP timed text specification.
                            `onTextData` is actually a property of the
                            `NetStream.client` object. The property is listed
                            in the Events section because it responds to a
                            data event, either when streaming media using
                            Flash Media Server or during FLV file playback.
                            For more information, see the NetStream class
                            description. You cannot use the
                            `addEventListener()` method, or any other
                            EventDispatcher methods, to listen for, or process
                            `onTextData` as an event. Define a callback
                            function and attach it to one of the following
                            objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. Create a subclass of NetStream and define
                            your event handler in the subclass. You can also
                            make the subclass dynamic and add the event
                            handler to an instance of the subclass.

                            The associated event listener is triggered after a
                            call to the `NetStream.play()` method, but before
                            the video playhead has advanced.

                            The onTextData event object contains one property
                            for each piece of text data.
    @event onXMPData        Establishes a listener to respond when Flash
                            Player receives information specific to Adobe
                            Extensible Metadata Platform (XMP) embedded in the
                            video being played. For information about video
                            file formats supported by Flash Media Server, see
                            the <a
                            href="http://www.adobe.com/go/learn_fms_fileformats_en"
                            scope="external">www.adobe.com/go/learn_fms_fileformats_en</a>.

                            `onXMPData` is actually a property of the
                            `NetStream.client` object. The property is listed
                            in the Events section because it responds to a
                            data event, either when streaming media using
                            Flash Media Server or during FLV file playback.
                            For more information, see the NetStream class
                            description and the `NetStream.client` property.
                            You cannot use the `addEventListener()` method, or
                            any other EventDispatcher methods, to listen for
                            or process `onMetaData` as an event. Define a
                            callback and attach it to one of the
                            following objects:

                            * The object that the `client` property of a
                            NetStream instance references.
                            * An instance of a NetStream subclass. NetStream
                            is a sealed class, which means that properties or
                            methods cannot be added to a NetStream object at
                            runtime. However, you can create a subclass of
                            NetStream and define your event handler in the
                            subclass. You can also make the subclass dynamic
                            and add the event handler to an instance
                            of the subclass.

                            The associated event listener is triggered after a
                            call to the `NetStream.play()` method, but before
                            the video playhead has advanced.

                            The object passed to the `onXMPData()` event
                            handling has one `data` property, which
                            is a string. The string is generated from a
                            top-level UUID box. (The 128-bit UUID of the top
                            level box is
                            `BE7ACFCB-97A9-42E8-9C71-999491E3AFAC`.) This
                            top-level UUID box contains exactly one XML
                            document represented as a null-terminated UTF-8
                            string.
    @event status           Dispatched when the application attempts to play
                            content encrypted with digital rights management
                            (DRM), by invoking the `NetStream.play()` method.
                            The value of the status code property will be
                            `"DRM.encryptedFLV"`.
**/
class NetStream extends EventDispatcher {
    /**
        Creates a stream that you can use to play media files and send data
        over a NetConnection object.

        @param connection A NetConnection object.
        @param peerID     This optional parameter is available in Flash Player
                          10 and later, for use with RTMFP connections. (If
                          the value of the `NetConnection.protocol` property
                          is not `"rtmfp"`, this parameter is ignored.) Use
                          one of the following values:
                          * To connect to Flash Media Server, specify
                          `NetStream.CONNECT_TO_FMS`.
                          * To publish directly to peers, specify
                          `NetStream.DIRECT_CONNECTIONS`.
                          * To play directly from a specific peer, specify
                          that peer's identity (see `NetConnection.nearID` and
                          `NetStream.farID`).
                          * (Flash Player 10.1 or AIR 2 or later) To publish
                          or play a stream in a peer-to-peer multicast group,
                          specify a `groupspec` string (see the GroupSpecifier
                          class).

                          In most cases, a `groupspec` has the potential to
                          use the network uplink on the local system. In this
                          case, the user is asked for permission to use the
                          computer's network resources. If the user allows
                          this use, a `NetStream.Connect.Success`
                          NetStatusEvent is sent to the NetConnection's event
                          listener. If the user denies permission, a
                          `NetStream.Connect.Rejected` event is sent. When
                          specifying a `groupspec`, until a
                          `NetStream.Connect.Success` event is received, it is
                          an error to use any method of the NetStream object,
                          and an exception is raised.

                          If you include this parameter in your constructor
                          statement but pass a value of `null`, the value is
                          set to `"connectToFMS"`.
        @throws ArgumentError The NetConnection instance is not connected.
    **/
    constructor(connection, peerID = null) {
        super();
        /**
            For RTMFP connections, specifies whether `NetStream.send()` calls are
            sent with full reliability. When TRUE, `NetStream.send()` calls that
            are transmitted over this NetStream are fully reliable. When FALSE,
            `NetStream.send()` calls are not transmitted with full reliability,
            but instead are retransmitted for a limited time and then dropped. You
            can set this value to FALSE to reduce latency at the expense of data
            quality.
            If you try to set this property to FALSE on a network protocol that
            does not support partial reliability, the attempt is ignored and the
            property is set to TRUE.
        **/
        // /** @hidden */ @:dox(hide) @:require(flash10_1) public dataReliable:Bool;
        _end.set(this, void 0);
        this.__connection = connection;
        this.__soundTransform = new SoundTransform();
        // __backend = new NetStreamBackend(this);
    }
    /**
        Passes a ByteArray into a NetStream for playout. Call this method on a
        NetStream in "Data Generation Mode". To put a NetStream into Data
        Generation Mode, call `NetStream.play(null)` on a NetStream created on
        a NetConnection connected to `null`. Calling `appendBytes()` on a
        NetStream that isn't in Data Generation Mode is an error and raises an
        exception.
        The byte parser understands an FLV file with a header. After the
        header is parsed, `appendBytes()` expects all future calls to be
        continuations of the same real or virtual file. Another header is not
        expected unless
        `appendBytesAction(NetStreamAppendBytesAction.RESET_BEGIN)` is called.

        A NetStream object has two buffers: the FIFO from `appendBytes()` to
        the NetStream, and the playout buffer. The FIFO is the partial-FLV-tag
        reassembly buffer and contains no more than one incomplete FLV tag.
        Calls to `NetStream.seek()` flush both buffers. After a call to
        `seek()`, call `appendBytesAction()` to reset the timescale to begin
        at the timestamp of the next appended message.

        Each call to `appendBytes()` adds bytes into the FIFO until an FLV tag
        is complete. When an FLV tag is complete, it moves to the playout
        buffer. A call to `appendBytes()` can write multiple FLV tags. The
        first bytes complete an existing FLV tag (which moves to the playout
        buffer). Complete FLV tags move to the playout buffer. Remaining bytes
        that donӴ form a complete FLV tag go into the FIFO. Bytes in the
        FIFO are either completed by a call to `appendBytes()` or flushed by a
        call to `appendBytesAction()` with the `RESET_SEEK` or `RESET_BEGIN`
        argument.

        **Note:** The byte parser may not be able to completely decode a call
        to `appendBytes()` until a subsequent call to `appendBytes()` is made.

    **/
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public appendBytes (bytes:ByteArray):Void;
    /**
        Indicates a timescale discontinuity, flushes the FIFO, and tells the
        byte parser to expect a file header or the beginning of an FLV tag.
        Calls to `NetStream.seek()` flush the NetStream buffers. The byte
        parser remains in flushing mode until you call `appendBytesAction()`
        and pass the `RESET_BEGIN` or `RESET_SEEK` argument. Capture the
        `"NetStream.Seek.Notify"` event to call `appendBytesAction()` after a
        seek. A new file header can support playlists and seeking without
        calling `NetStream.seek()`.

        You can also call this method to reset the byte counter for the
        `onSeekPoint()`) callback.

    **/
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public appendBytesAction (netStreamAppendBytesAction:String):Void;
    /**
        Attaches a stream to a new NetConnection object. Call this method to
        attach a NetStream to a new NetConnection object after a connection
        has dropped and been reconnected. Flash Player and AIR resume
        streaming from the playback point when the connection was lost.You can
        also use this method to implement load balancing.
        This method requires Flash Media Server version 3.5.3 or later.

        To use this method to implement **stream reconnection**, see the <a
        href="http://www.adobe.com/go/learn_fms_docs_en"
        scope="external">Flash Media Server 3.5.3 documentation</a>.

        To use this method to implement **load balancing**, do the following:

        1.  Attach a connected stream to a NetConnection object on another
        server.
        2. After the stream is successfully attached to the new connection,
        call `NetConnection.close()` on the prior connection to prevent data
        leaks.
        3. Call `NetStream.play2()` and set the value of
        `NetStreamPlayOptions.transition` to RESUME. Set the rest of the
        NetStreamPlayOptions properties to the same values you used when you
        originally called `NetStream.play()` or `NetStream.play2()` to start
        the stream.
    **/
    // /** @hidden */@:dox(hide) @:require(flash10_1) public attach(connection:NetConnection):Void;
    /**
        Attaches an audio stream to a NetStream object from a Microphone
        object passed as the source. This method is available only to the
        publisher of the specified stream.
        Use this method with Flash Media Server to send live audio to the
        server. Call this method before or after you call the `publish()`
        method.

        Set the `Microphone.rate` property to match the rate of the sound
        capture device. Call `setSilenceLevel()` to set the silence level
        threshold. To control the sound properties (volume and panning) of the
        audio stream, use the `Microphone.soundTransform` property.

        ```haxe
        var nc = new NetConnection();
        nc.connect("rtmp://server.domain.com/app");
        var ns = new NetStream(nc);
        var live_mic = Microphone.get();
        live_mic.rate = 8;
        live_mic.setSilenceLevel(20,200);
        var soundTrans = new SoundTransform();
        soundTrans.volume = 6;
        live_mic.soundTransform = soundTrans;
        ns.attachAudio(live_mic);
        ns.publish("mic_stream","live");
        ```

        To hear the audio, call the `NetStream.play()` method and call
        `DisplayObjectContainer.addChild()` to route the audio to an object on
        the display list.

        @param microphone The source of the audio stream to be transmitted.
    **/
    // /** @hidden */ @:dox(hide) public attachAudio (microphone:openfl.media.Microphone):Void;
    /**
        Starts capturing video from a camera, or stops capturing if
        `theCamera` is set to `null`. This method is available only to the
        publisher of the specified stream.
        This method is intended for use with Flash Media Server; for more
        information, see the class description.

        After attaching the video source, you must call `NetStream.publish()`
        to begin transmitting. Subscribers who want to display the video must
        call the `NetStream.play()` and `Video.attachCamera()` methods to
        display the video on the stage.

        You can use `snapshotMilliseconds` to send a single snapshot (by
        providing a value of 0) or a series of snapshots נin effect,
        time-lapse footage נby providing a positive number that adds a
        trailer of the specified number of milliseconds to the video feed. The
        trailer extends the display time of the video message. By repeatedly
        calling `attachCamera()` with a positive value for
        `snapshotMilliseconds`, the sequence of alternating snapshots and
        trailers creates time-lapse footage. For example, you could capture
        one frame per day and append it to a video file. When a subscriber
        plays the file, each frame remains onscreen for the specified number
        of milliseconds and then the next frame is displayed.

        The purpose of the `snapshotMilliseconds` parameter is different from
        the `fps` parameter you can set with `Camera.setMode()`. When you
        specify `snapshotMilliseconds`, you control how much time elapses
        between recorded frames. When you specify `fps` using
        `Camera.setMode()`, you are controlling how much time elapses during
        recording and playback.

        For example, suppose you want to take a snapshot every 5 minutes for a
        total of 100 snapshots. You can do this in two ways:

        * You can issue a `NetStream.attachCamera(myCamera, 500)` command 100
        times, once every 5 minutes. This takes 500 minutes to record, but the
        resulting file will play back in 50 seconds (100 frames with 500
        milliseconds between frames).
        * You can issue a `Camera.setMode()` command with an `fps` value of
        1/300 (one per 300 seconds, or one every 5 minutes), and then issue a
        `NetStream.attachCamera(source)` command, letting the camera capture
        continuously for 500 minutes. The resulting file will play back in 500
        minutes נthe same length of time that it took to record נwith
        each frame being displayed for 5 minutes.

        Both techniques capture the same 500 frames, and both approaches are
        useful; the approach to use depends primarily on your playback
        requirements. For example, in the second case, you could be recording
        audio the entire time. Also, both files would be approximately the
        same size.

        @param theCamera The source of the video transmission. Valid values
                         are a Camera object (which starts capturing video)
                         and `null`. If you pass `null`, the application stops
                         capturing video, and any additional parameters you
                         send are ignored.
    **/
    // /** @hidden */ @:dox(hide) public attachCamera (theCamera:openfl.media.Camera, snapshotMilliseconds:Int = -1):Void;
    /**
        Stops playing all data on the stream, sets the `time` property to 0,
        and makes the stream available for another use. This method also
        deletes the local copy of a video file that was downloaded through
        HTTP. Although the application deletes the local copy of the file that
        it creates, a copy might persist in the cache directory. If you must
        completely prevent caching or local storage of the video file, use
        Flash Media Server.
        When using Flash Media Server, this method is invoked implicitly when
        you call `NetStream.play()` from a publishing stream or
        `NetStream.publish()` from a subscribing stream. Please note that:

        *  If `close()` is called from a publishing stream, the stream stops
        publishing and the publisher can now use the stream for another
        purpose. Subscribers no longer receive anything that was being
        published on the stream, because the stream has stopped publishing.
        *  If `close()` is called from a subscribing stream, the stream stops
        playing for the subscriber, and the subscriber can use the stream for
        another purpose. Other subscribers are not affected.
        *  You can stop a subscribing stream from playing, without closing the
        stream or changing the stream type by using
        `openfl.net.NetStream.play(false)`.

    **/
    close() {
        this.__closed = true;
        // __backend.close();
    }
    /**
        Releases all the resources held by the NetStream object.

        The `dispose()` method is similar to the `close` method. The main difference
        between the two methods is that `dispose()` releases the memory used to display
        the current video frame. If that frame is currently displayed on screen, the
        display will go blank. The `close()` method does not blank the display because it
        does not release this memory.
    **/
    dispose() {
        // __backend.dispose();
    }
    /**
        Invoked when a peer-publishing stream matches a peer-subscribing
        stream. Before the subscriber is connected to the publisher, call this
        method to allow the ActionScript code fine access control for
        peer-to-peer publishing. The following code shows an example of how to
        create a callback for this method:

        ```as3
        var c:Object = new Object;
        c.onPeerConnect = function(subscriber:NetStream):Boolean {
            if (accept) return true;
            else return false;
        };
        m_netStream.client = c;
        ```

        If a peer-publisher does not implement this method, all peers are
        allowed to play any published content.

    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public onPeerConnect (subscriber:NetStream):Bool;
    /**
        Pauses playback of a video stream. Calling this method does nothing if
        the video is already paused. To resume play after pausing a video,
        call `resume()`. To toggle between pause and play (first pausing the
        video, then resuming), call `togglePause()`.
        Starting with Flash Player 9.0.115.0, Flash Player no longer clears
        the buffer when `NetStream.pause()` is called. This behavior is called
        "smart pause". Before Flash Player 9.0.115.0, Flash Player waited for
        the buffer to fill up before resuming playback, which often caused a
        delay.

        **Note:** For backwards compatibility, the `"NetStream.Buffer.Flush"`
        event (see the `NetStatusEvent.info` property) still fires, although
        the server does not flush the buffer.

        For a single pause, the `NetStream.bufferLength` property has a limit
        of either 60 seconds or twice the value of `NetStream.bufferTime`,
        whichever value is higher. For example, if `bufferTime` is 20 seconds,
        Flash Player buffers until `NetStream.bufferLength` is the higher
        value of either 20~~2 (40), or 60, so in this case it buffers until
        `bufferLength` is 60. If `bufferTime` is 40 seconds, Flash Player
        buffers until `bufferLength` is the higher value of 40~~2 (80), or 60,
        so in this case it buffers until `bufferLength` is 80 seconds.

        The `bufferLength` property also has an absolute limit. If any call to
        `pause()` causes `bufferLength` to increase more than 600 seconds or
        the value of `bufferTime` ~~ 2, whichever is higher, Flash Player
        flushes the buffer and resets `bufferLength` to 0. For example, if
        `bufferTime` is 120 seconds, Flash Player flushes the buffer if
        `bufferLength` reaches 600 seconds; if `bufferTime` is 360 seconds,
        Flash Player flushes the buffer if `bufferLength` reaches 720 seconds.

        **Tip**: You can use `NetStream.pause()` in code to buffer data while
        viewers are watching a commercial, for example, and then unpause when
        the main video starts.

    **/
    pause() {
        // __backend.pause();
    }
    /**
        Plays a media file from a local directory or a web server; plays a
        media file or a live stream from Flash Media Server. Dispatches a
        `NetStatusEvent` object to report status and error messages.
        For information about supported codecs and file formats, see the
        following:

        * <a href="http://www.adobe.com/go/learn_fms_fileformats_en"
        scope="external">Flash Media Server documentation</a>
        * <a href="http://www.adobe.com/go/hardware_scaling_en"
        scope="external">Exploring Flash Player support for high-definition
        H.264 video and AAC audio</a>
        * <a href="http://www.adobe.com/go/video_file_format"
        scope="external">FLV/F4V open specification documents</a>

        **Workflow for playing a file or live stream**

        1. Create a NetConnection object and call `NetConnection.connect()`.
        To play a file from a local directory or web server, pass null.

        To play a recorded file or live stream from Flash Media Server, pass
        the URI of a Flash Media Server application.
        2. Call `NetConnection.addEventListener(NetStatusEvent.NET_STATUS,
        netStatusHandler)` to listen for NetStatusEvent events.
        3. On `"NetConnection.Connect.Success"`, create a NetStream object and
        pass the NetConnection object to the constructor.
        4. Create a Video object and call `Video.attachNetStream()` and pass
        the NetStream object.
        5. Call `NetStream.play()`.
        To play a live stream, pass the stream name passed to the
        `NetStream.publish()` method.

        To play a recorded file, pass the file name.
        6. Call `addChild()` and pass the Video object to display the video.

        **Note:**To see sample code, scroll to the example at the bottom of
        this page.

        **Enable Data Generation Mode**

        Call `play(null)` to enable "Data Generation Mode". In this mode, call
        the `appendBytes()` method to deliver data to the NetStream. Use Data
        Generation Mode to stream content over HTTP from the Adobe HTTP
        Dynamic Streaming Origin Module on an Apache HTTP Server. HTTP Dynamic
        Streaming lets clients seek quickly to any point in a file. The Open
        Source Media Framework (OSMF) supports HTTP Dynamic Streaming for vod
        and live streams. For examples of how to use NetStream Data Generation
        Mode, download the <a href="http://www.opensourcemediaframework.com"
        scope="external">OSMF</a> source. For more information about HTTP
        Dynamic Streaming, see <a
        href="http://www.adobe.com/go/learn_fms_http_en" scope="external">HTTP
        Dynamic Streaming</a>.

        When you use this method without Flash Media Server, there are
        security considerations. A file in the local-trusted or
        local-with-networking sandbox can load and play a video file from the
        remote sandbox, but cannot access the remote file's data without
        explicit permission in the form of a URL policy file. Also, you can
        prevent a SWF file running in Flash Player from using this method by
        setting the `allowNetworking` parameter of the the `object` and
        `embed` tags in the HTML page that contains the SWF content. For more
        information related to security, see the Flash Player Developer Center
        Topic: <a href="http://www.adobe.com/go/devnet_security_en"
        scope="external">Security</a>.

        @throws ArgumentError At least one parameter must be specified.
        @throws Error         The NetStream Object is invalid. This may be due
                              to a failed NetConnection.
        @throws SecurityError Local untrusted SWF files cannot communicate
                              with the Internet. You can work around this
                              restriction by reclassifying this SWF file as
                              local-with-networking or trusted.
        @event status Dispatched when attempting to play content encrypted
                      with digital rights management (DRM). The value of the
                      `code` property is `"DRM.encryptedFLV"`.
    **/
    play(url, ...parameters) {
        // __backend.play(url, p1, p2, p3, p4, p5);
    }
    /**
        Switches seamlessly between files with multiple bit rates and allows a
        NetStream to resume when a connection is dropped and reconnected.
        This method is an enhanced version of `NetStream.play()`. Like the
        `play()` method, the `play2()` method begins playback of a media file
        or queues up media files to create a playlist. When used with Flash
        Media Server, it can also request that the server switch to a
        different media file. The transition occurs seamlessly in the client
        application. The following features use `play2()` stream switching:

        **Dynamic streaming**

        Dynamic streaming (supported in Flash Media Server 3.5 and later) lets
        you serve a stream encoded at multiple bit rates. As a viewer's
        network conditions change, they receive the bitrate that provides the
        best viewing experience. Use the `NetStreamInfo` class to monitor
        network conditions and switch streams based on the data. You can also
        switch streams for clients with different capabilities. For more
        information, see <a
        href="http://www.adobe.com/go/learn_fms_dynstream_en"
        scope="external">"Dynamic streaming"</a> in the "Adobe Flash Media
        Server Developer Guide".

        Adobe built a custom ActionScript class called DynamicStream that
        extends the NetStream class. You can use the DynamicStream class to
        implement dynamic streaming in an application instead of writing your
        own code to detect network conditions. Even if you choose to write
        your own dynamic streaming code, use the DynamicStream class as a
        reference implementation. Download the class and the class
        documentation at the <a href="http://www.adobe.com/go/fms_tools"
        scope="external">Flash Media Server tools and downloads</a> page.

        **Stream reconnecting**

        Stream reconnecting (supported in Flash Media Server 3.5.3 and later)
        lets users to experience media uninterrupted even when they lose their
        connection. The media uses the buffer to play while your ActionScript
        logic reconnects to Flash Media Server. After reconnection, call
        `NetStream.attach()` to use the same NetStream object with the new
        NetConnection. Use the `NetStream.attach()`,
        `NetStreamPlayTransitions.RESUME`, and
        `NetStreamPlayTrasitions.APPEND_AND_WAIT` APIs to reconnect a stream.
        For more information, see the <a
        href="http://www.adobe.com/go/learn_fms_docs_en"
        scope="external">Flash Media Server 3.5.3 documentation</a>.

    **/
    // /** @hidden */ @:dox(hide) @:require(flash10) public play2 (param:openfl.net.NetStreamPlayOptions):Void;
    /**
        Sends streaming audio, video, and data messages from a client to Flash
        Media Server, optionally recording the stream during transmission.
        This method dispatches a NetStatusEvent object with information about
        the stream. Before you call `NetStream.publish()`, capture the
        `"NetConnection.Connect.Success"` event to verify that the application
        has successfully connected to Flash Media Server.
        While publishing, you can record files in FLV or F4V format. If you
        record a file in F4V format, use a flattener tool to edit or play the
        file in another application. To download the tool, see <a
        href="http://www.adobe.com/go/fms_tools"
        scope="external">www.adobe.com/go/fms_tools</a>.

        **Note:**Do not use this method to play a stream. To play a stream,
        call the `NetStream.play()` method.

        Workflow for publishing a stream

        1. Create a NetConnection object and call `NetConnection.connect()`.
        2. Call `NetConnection.addEventListener()` to listen for NetStatusEvent
        events.
        3. On the `"NetConnection.Connect.Success"` event, create a NetStream
        object and pass the NetConnection object to the constructor.
        4. To capture audio and video, call the `NetStream.attachAudio()`method
        and the `NetStream.attachCamera()` method.
        5. To publish a stream, call the `NetStream.publish()` method. You can
        record the data as you publish it so that users can play it back
        later.

        **Note:** A NetStream can either publish a stream or play a stream, it
        cannot do both. To publish a stream and view the playback from the
        server, create two NetStream objects. You can send multiple NetStream
        objects over one NetConnection object.

        When Flash Media Server records a stream it creates a file. By
        default, the server creates a directory with the application instance
        name passed to `NetConnection.connect()` and stores the file in the
        directory. For example, the following code connects to the default
        instance of the "lectureseries" application and records a stream
        called "lecture". The file "lecture.flv" is recorded in the
        applications/lectureseries/streams/_definst_ directory:

        ```as3
        var nc:NetConnection = new NetConnection();
        nc.connect("rtmp://fms.example.com/lectureseries");
        nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);

        function netStatusHandler(event:NetStatusEvent):void{
            if (event.info.code == "NetConnection.Connect.Success"){
                var ns:NetStream = new NetStream(nc);
                ns.publish("lecture", "record");
            }
        }
        ```

        The following example connects to the "monday" instance of the same
        application. The file "lecture.flv" is recorded in the directory
        /applications/lectureseries/streams/monday:

        ```as3
        var nc:NetConnection = new NetConnection();
        nc.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
        nc.connect("rtmp://fms.example.com/lectureseries/monday");

        function netStatusHandler(event:NetStatusEvent):void{
            if (event.info.code == "NetConnection.Connect.Success"){
                var ns:NetStream = new NetStream(nc);
                ns.publish("lecture", "record");
            }
        }
        ```

        @param name A string that identifies the stream. Clients that
                    subscribe to this stream pass this name when they call
                    `NetStream.play()`. Don't follow the stream name with a
                    "/". For example, don't use the stream name `"bolero/"`.
                    You can record files in the formats described in the
                    following table (you cannot use `publish()` for MP3 format
                    files). The syntax differs depending on the file format.

                    | File format | Syntax | Example |
                    | --- | --- | --- |
                    | FLV | Specify the stream name as a string without a filename extension. | `ns.publish("myflvstream");` |
                    | MPEG-4-based files (such as F4V or MP4) | Specify the stream name as a string with the prefix `mp4:` with or without the filename extension. Flash Player doesn't encode using H.264, but Flash Media Server can record any codec in the F4V container. Flash Media Live Encoder can encode using H.264. | `ns.publish("mp4:myvideo.f4v")` `ns.publish("mp4:myvideo");` |
                    | RAW | Specify the stream name as a string with the prefix `raw:` | `ns.publish("raw:myvideo");` |
        @param type A string that specifies how to publish the stream. Valid
                    values are "`record`", "`append`", "`appendWithGap`", and
                    "`live`". The default value is "`live`".
                    * If you pass "`record`", the server publishes and records
                    live data, saving the recorded data to a new file with a
                    name matching the value passed to the `name` parameter. If
                    the file exists, it is overwritten.
                    * If you pass "`append`", the server publishes and records
                    live data, appending the recorded data to a file with a
                    name that matches the value passed to the `name`
                    parameter. If no file matching the `name` parameter is
                    found, it is created.
                    * If you pass "`appendWithGap`", additional information
                    about time coordination is passed to help the server
                    determine the correct transition point when dynamic
                    streaming.
                    * If you omit this parameter or pass "`live`", the server
                    publishes live data without recording it. If a file with a
                    name that matches the value passed to the `name` parameter
                    exists, it is deleted.
    **/
    // /** @hidden */ @:dox(hide) public publish (?name:String, ?type:String):Void;
    /**
        Specifies whether incoming audio plays on the stream. This method is
        available only to clients subscribed to the specified stream. It is
        not available to the publisher of the stream. Call this method before
        or after you call the `NetStream.play()` method. For example, attach
        this method to a button to allow users to mute and unmute the audio.
        Use this method only on unicast streams that are played back from
        Flash Media Server. This method doesn't work on RTMFP multicast
        streams or when using the `NetStream.appendBytes()` method.

        @param flag Specifies whether incoming audio plays on the stream
                    (`true`) or not (`false`). The default value is `true`. If
                    the specified stream contains only audio data,
                    `NetStream.time` stops incrementing when you pass `false`.
    **/
    // /** @hidden */ @:dox(hide) public receiveAudio (flag:Bool):Void;
    /**
        Specifies whether incoming video plays on the stream. This method is
        available only to clients subscribed to the specified stream. It is
        not available to the publisher of the stream. Call this method before
        or after you call the `NetStream.play()` method. For example, attach
        this method to a button to allow users to show and hide the video. Use
        this method only on unicast streams that are played back from Flash
        Media Server. This method doesn't work on RTMFP multicast streams or
        when using `the NetStream.appendBytes()` method.

        @param flag Specifies whether incoming video plays on this stream
                    (`true`) or not (`false`). The default value is `true`. If
                    the specified stream contains only video data,
                    `NetStream.time` stops incrementing when you pass `false`.
    **/
    // /** @hidden */ @:dox(hide) public receiveVideo (flag:Bool):Void;
    /**
        Specifies the frame rate for incoming video. This method is available
        only to clients subscribed to the specified stream. It is not
        available to the publisher of the stream. Call this method before or
        after you call the `NetStream.play()` method. For example, call this
        method to allow users to set the video frame rate. To determine the
        current frame rate, use `NetStream.currentFPS`. To stop receiving
        video, pass `0`.
        When you pass a value to the FPS parameter to limit the frame rate of
        the video, Flash Media Server attempts to reduce the frame rate while
        preserving the integrity of the video. Between every two keyframes,
        the server sends the minimum number of frames needed to satisfy the
        desired rate. Please note that I-frames (or intermediate frames) must
        be sent contiguously, otherwise the video is corrupted. Therefore, the
        desired number of frames is sent immediately and contiguously
        following a keyframe. Since the frames are not evenly distributed, the
        motion appears smooth in segments punctuated by stalls.

        Use this method only on unicast streams that are played back from
        Flash Media Server. This method doesn't work on RTMFP multicast
        streams or when using the `NetStream.appendBytes()` method.

        @param FPS Specifies the frame rate per second at which the incoming
                   video plays.
    **/
    // /** @hidden */ @:dox(hide) public receiveVideoFPS (FPS:Float):Void;
    /**
        Deletes all locally cached digital rights management (DRM) voucher
        data.
        The application must re-download any required vouchers from the media
        rights server for the user to be able to access protected content.
        Calling this is equivalent to calling the
        `resetDRMVouchers()` of the DRMManager object.

        @throws IOError The voucher data cannot be deleted.
    **/
    // /** @hidden */ @:dox(hide) public static resetDRMVouchers ():Void;
    /**
        Resumes playback of a video stream that is paused. If the video is
        already playing, calling this method does nothing.

    **/
    resume() {
        // __backend.resume();
    }
    /**
        Seeks the keyframe (also called an I-frame in the video industry)
        closest to the specified location. The keyframe is placed at an
        offset, in seconds, from the beginning of the stream.
        Video streams are usually encoded with two types of frames, keyframes
        (or I-frames) and P-frames. A keyframe contains an entire image, while
        a P-frame is an interim frame that provides additional video
        information between keyframes. A video stream typically has a keyframe
        every 10-50 frames.

        Flash Media Server has several types of seek behavior: enhanced
        seeking and smart seeking.

        **Enhanced seeking**

        Enhanced seeking is enabled by default. To disable enhanced seeking,
        on Flash Media Server set the `EnhancedSeek` element in the
        `Application.xml` configuration file to `false`.

        If enhanced seeking is enabled, the server generates a new keyframe at
        `offset` based on the previous keyframe and any intervening P-frames.
        However, generating keyframes creates a high processing load on the
        server and distortion might occur in the generated keyframe. If the
        video codec is On2, the keyframe before the seek point and any
        P-frames between the keyframe and the seek point are sent to the
        client.

        If enhanced seeking is disabled, the server starts streaming from the
        nearest keyframe. For example, suppose a video has keyframes at 0
        seconds and 10 seconds. A seek to 4 seconds causes playback to start
        at 4 seconds using the keyframe at 0 seconds. The video stays frozen
        until it reaches the next keyframe at 10 seconds. To get a better
        seeking experience, you need to reduce the keyframe interval. In
        normal seek mode, you cannot start the video at a point between the
        keyframes.

        **Smart seeking**

        To enable smart seeking, set `NetStream.inBufferSeek` to `true`.

        Smart seeking allows Flash Player to seek within an existing back
        buffer and forward buffer. When smart seeking is disabled, each time
        `seek()` is called Flash Player flushes the buffer and requests data
        from the server. For more information, see `NetStream.inBufferSeek`.

        **Seeking in Data Generation Mode**

        When you call `seek()` on a NetStream in Data Generation Mode, all
        bytes passed to `appendBytes()` are discarded (not placed in the
        buffer, accumulated in the partial message FIFO, or parsed for seek
        points) until you call
        `appendBytesAction(NetStreamAppendBytesAction.RESET_BEGIN)` or
        `appendBytesAction(NetStreamAppendBytesAction.RESET_SEEK)` to reset
        the parser. For information about Data Generation Mode, see
        `NetStream.play()`.

        @param offset The approximate time value, in seconds, to move to in a
                      video file. With Flash Media Server, if `<EnhancedSeek>`
                      is set to `true` in the Application.xml configuration
                      file (which it is by default), the server generates a
                      keyframe at `offset`.
                      * To return to the beginning of the stream, pass 0 for
                      `offset`.
                      * To seek forward from the beginning of the stream, pass
                      the number of seconds to advance. For example, to
                      position the playhead at 15 seconds from the beginning
                      (or the keyframe before 15 seconds), use
                      `myStream.seek(15)`.
                      * To seek relative to the current position, pass
                      `NetStream.time + n` or `NetStream.time - n` to seek `n`
                      seconds forward or backward, respectively, from the
                      current position. For example, to rewind 20 seconds from
                      the current position, use `NetStream.seek(NetStream.time
                      - 20).`
    **/
    seek(time) {
        // __backend.seek(time);
    }
    /**
        Sends a message on a published stream to all subscribing clients. This
        method is available only to the publisher of the specified stream.
        This method is available for use with Flash Media Server only. To
        process and respond to this message, create a handler on the
        `NetStream` object, for example, `ns.HandlerName`.
        Flash Player or AIR does not serialize methods or their data, object
        prototype variables, or non-enumerable variables. For display objects,
        Flash Player or AIR serializes the path but none of the data.

        You can call the `send()` method to add data keyframes to a live
        stream published to Flash Media Server. A data keyframe is a message a
        publisher adds to a live stream. Data keyframes are typically used to
        add metadata to a live stream before data is captured for the stream
        from camera and microphone. A publisher can add a data keyframe at any
        time while the live stream is being published. The data keyframe is
        saved in the server's memory as long as the publisher is connected to
        the server.

        Clients who are subscribed to the live stream before a data keyframe
        is added receive the keyframe as soon as it is added. Clients who
        subscribe to the live stream after the data keyframe is added receive
        the keyframe when they subscribe.

        To add a keyframe of metadata to a live stream sent to Flash Media
        Server, use `@setDataFrame` as the handler name, followed by two
        additional arguments, for example:

        ```as3
        var ns:NetStream = new NetStream(nc);
        ns.send("@setDataFrame", "onMetaData", metaData);
        ```

        The `@setDataFrame` argument refers to a special handler built in to
        Flash Media Server. The `onMetaData` argument is the name of a
        callback in your client application that listens for the
        `onMetaData` event and retrieves the metadata. The third item,
        `metaData`, is an instance of `Object` or `Array` with properties that
        define the metadata values.

        Use `@clearDataFrame` to clear a keyframe of metadata that has already
        been set in the stream:

        ```as3
        ns.send("@clearDataFrame", "onMetaData");
        ```

        @param handlerName The message to send; also the name of the
                           ActionScript handler to receive the message. The
                           handler name can be only one level deep (that is,
                           it can't be of the form parent/child) and is
                           relative to the stream object. Do not use a
                           reserved term for a handler name. For example,
                           using "`close`" as a handler name causes the method
                           to fail. With Flash Media Server, use
                           `@setDataFrame` to add a keyframe of metadata to a
                           live stream or `@clearDataFrame` to remove a
                           keyframe.
    **/
    // /** @hidden */ @:dox(hide) public send (handlerName:String, ?p1:Dynamic, ?p2:Dynamic, ?p3:Dynamic, ?p4:Dynamic, ?p5:Dynamic):Void;
    /**
        Steps forward or back the specified number of frames, relative to the
        currently displayed frame. Specify a positive number to step forward
        and a negative number to step in reverse. Call this method to create
        accurate fast forward or rewind functionality.
        This method is available only when data is streaming from Flash Media
        Server 3.5.3 or higher and when `NetStream.inBufferSeek` is `true`.
        Also, the target frame must be in the buffer. For example, if the
        currently displayed frame is frame number 120 and you specify a value
        of 1000, the method fails if frame number 1120 is not in the buffer.

        This method is intended to be used with the `pause()` or
        `togglePause()` methods. If you step 10 frames forward or backward
        during playback without pausing, you may not notice the steps or
        they'll look like a glitch. Also, when you call `pause()` or
        `togglePause` the audio is suppressed.

        If the call to `NetStream.step()` is successful, a NetStatusEvent is
        sent with "NetStream.Step.Notify" as the value of the info object's
        `code` property.

    **/
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public step (frames:Int):Void;
    /**
        Pauses or resumes playback of a stream. The first time you call this
        method, it pauses play; the next time, it resumes play. You could use
        this method to let users pause or resume playback by pressing a single
        button.

    **/
    togglePause() {
        // __backend.togglePause();
    }
    __getVideoElement() {
        // return __backend.video;
        return null;
    }
    // Get & Set Methods
    /**
        Controls sound in this NetStream object. For more information, see the
        SoundTransform class.
    **/
    get soundTransform() {
        return this.__soundTransform.clone();
    }
    set soundTransform(value) {
        if (value != null) {
            this.__soundTransform.pan = value.pan;
            this.__soundTransform.volume = value.volume;
            // this.__backend.setSoundTransform(value);
        }
    }
    get speed() {
        // return __backend.getSpeed();
        return 0;
    }
    set speed(value) {
        // __backend.setSpeed(value);
    }
}
_end = new WeakMap();

/**
    The SharedObjectFlushStatus class provides values for the code returned
    from a call to the `SharedObject.flush()` method.
**/
var SharedObjectFlushStatus;
(function (SharedObjectFlushStatus) {
    /**
        Indicates that the flush completed successfully.
    **/
    SharedObjectFlushStatus["FLUSHED"] = "flushed";
    /**
        Indicates that the user is being prompted to increase disk space for the
        shared object before the flush can occur.
    **/
    SharedObjectFlushStatus["PENDING"] = "pending";
})(SharedObjectFlushStatus || (SharedObjectFlushStatus = {}));
var SharedObjectFlushStatus$1 = SharedObjectFlushStatus;

/**
    The SharedObject class is used to read and store limited amounts of data on
    a user's computer or on a server. Shared objects offer real-time data
    sharing between multiple client SWF files and objects that are persistent
    on the local computer or remote server. Local shared objects are similar to
    browser cookies and remote shared objects are similar to real-time data
    transfer devices. To use remote shared objects, you need Adobe Flash Media
    Server.

    Use shared objects to do the following:


    * **Maintain local persistence**. This is the simplest way to use a
    shared object, and does not require Flash Media Server. For example, you
    can call `SharedObject.getLocal()` to create a shared object in
    an application, such as a calculator with memory. When the user closes the
    calculator, Flash Player saves the last value in a shared object on the
    user's computer. The next time the calculator is run, it contains the
    values it had previously. Alternatively, if you set the shared object's
    properties to `null` before the calculator application is
    closed, the next time the application runs, it opens without any values.
    Another example of maintaining local persistence is tracking user
    preferences or other data for a complex website, such as a record of which
    articles a user read on a news site. Tracking this information allows you
    to display articles that have already been read differently from new,
    unread articles. Storing this information on the user's computer reduces
    server load.
    * **Store and share data on Flash Media Server**. A shared object
    can store data on the server for other clients to retrieve. For example,
    call `SharedObject.getRemote()` to create a remote shared
    object, such as a phone list, that is persistent on the server. Whenever a
    client makes changes to the shared object, the revised data is available to
    all clients currently connected to the object or who later connect to it.
    If the object is also persistent locally, and a client changes data while
    not connected to the server, the data is copied to the remote shared object
    the next time the client connects to the object.
    * **Share data in real time**. A shared object can share data among
    multiple clients in real time. For example, you can open a remote shared
    object that stores a list of users connected to a chat room that is visible
    to all clients connected to the object. When a user enters or leaves the
    chat room, the object is updated and all clients that are connected to the
    object see the revised list of chat room users.


     To create a local shared object, call
    `SharedObject.getLocal()`. To create a remote shared object,
    call `SharedObject.getRemote()`.

     When an application closes, shared objects are _flushed_, or
    written to a disk. You can also call the `flush()` method to
    explicitly write data to a disk.

    **Local disk space considerations.** Local shared objects have some
    limitations that are important to consider as you design your application.
    Sometimes SWF files may not be allowed to write local shared objects, and
    sometimes the data stored in local shared objects can be deleted without
    your knowledge. Flash Player users can manage the disk space that is
    available to individual domains or to all domains. When users decrease the
    amount of disk space available, some local shared objects may be deleted.
    Flash Player users also have privacy controls that can prevent third-party
    domains(domains other than the domain in the current browser address bar)
    from reading or writing local shared objects.

    **Note**: SWF files that are stored and run on a local computer, not
    from a remote server, can always write third-party shared objects to disk.
    For more information about third-party shared objects, see the
    [Global Storage Settings panel](http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager03.html)
    in Flash Player Help.

    It's a good idea to check for failures related to the amount of disk
    space and to user privacy controls. Perform these checks when you call
    `getLocal()` and `flush()`:

    * `SharedObject.getLocal()`  -  Flash Player throws an
    exception when a call to this method fails, such as when the user has
    disabled third-party shared objects and the domain of your SWF file does
    not match the domain in the browser address bar.
    * `SharedObject.flush()`  -  Flash Player throws an
    exception when a call to this method fails. It returns
    `SharedObjectFlushStatus.FLUSHED` when it succeeds. It returns
    `SharedObjectFlushStatus.PENDING` when additional storage space
    is needed. Flash Player prompts the user to allow an increase in storage
    space for locally saved information. Thereafter, the `netStatus`
    event is dispatched with an information object indicating whether the flush
    failed or succeeded.



    If your SWF file attempts to create or modify local shared objects, make
    sure that your SWF file is at least 215 pixels wide and at least 138 pixels
    high(the minimum dimensions for displaying the dialog box that prompts
    users to increase their local shared object storage limit). If your SWF
    file is smaller than these dimensions and an increase in the storage limit
    is required, `SharedObject.flush()` fails, returning
    `SharedObjectFlushedStatus.PENDING` and dispatching the
    `netStatus` event.

    **Remote shared objects.** With Flash Media Server, you can create
    and use remote shared objects, that are shared in real-time by all clients
    connected to your application. When one client changes a property of a
    remote shared object, the property is changed for all connected clients.
    You can use remote shared objects to synchronize clients, for example,
    users in a multi-player game.

     Each remote shared object has a `data` property which is an
    Object with properties that store data. Call `setProperty()` to
    change an property of the data object. The server updates the properties,
    dispatches a `sync` event, and sends the properties back to the
    connected clients.

     You can choose to make remote shared objects persistent on the client,
    the server, or both. By default, Flash Player saves locally persistent
    remote shared objects up to 100K in size. When you try to save a larger
    object, Flash Player displays the Local Storage dialog box, which lets the
    user allow or deny local storage for the shared object. Make sure your
    Stage size is at least 215 by 138 pixels; this is the minimum size Flash
    requires to display the dialog box.

     If the user selects Allow, the server saves the shared object and
    dispatches a `netStatus` event with a `code` property
    of `SharedObject.Flush.Success`. If the user select Deny, the
    server does not save the shared object and dispatches a
    `netStatus` event with a `code` property of
    `SharedObject.Flush.Failed`.

    @event asyncError Dispatched when an exception is thrown asynchronously  -
                      that is, from native asynchronous code.
    @event netStatus  Dispatched when a SharedObject instance is reporting its
                      status or error condition. The `netStatus`
                      event contains an `info` property, which is an
                      information object that contains specific information
                      about the event, such as whether a connection attempt
                      succeeded or whether the shared object was successfully
                      written to the local disk.
    @event sync       Dispatched when a remote shared object has been updated
                      by the server.
**/
let SharedObject = /** @class */ (() => {
    class SharedObject extends EventDispatcher {
        constructor() {
            super();
            this.client = this;
            this.objectEncoding = SharedObject.defaultObjectEncoding;
            // __backend = new SharedObjectBackend(this);
        }
        /**
            For local shared objects, purges all of the data and deletes the shared
            object from the disk. The reference to the shared object is still active,
            but its data properties are deleted.
    
             For remote shared objects used with Flash Media Server,
            `clear()` disconnects the object and purges all of the data. If
            the shared object is locally persistent, this method also deletes the
            shared object from the disk. The reference to the shared object is still
            active, but its data properties are deleted.
    
        **/
        clear() {
            this.data = {};
            // __backend.clear();
        }
        /**
            Closes the connection between a remote shared object and the server.
            If a remote shared object is locally persistent, the user can make
            changes to the local copy of the object after this method is called.
            Any changes made to the local object are sent to the server the next
            time the user connects to the remote shared object.
    
        **/
        close() { }
        /**
            Connects to a remote shared object on a server through a specified
            NetConnection object. Use this method after calling `getRemote()`.
            When a connection is successful, the `sync` event is dispatched.
            Before attempting to work with a remote shared object, first check for
            any errors using a `try..catch..finally` statement. Then, listen for
            and handle the `sync` event before you make changes to the shared
            object. Any changes made locally — before the `sync` event is
            dispatched — might be lost.
    
            Call the `connect()` method to connect to a remote shared object, for
            example:
    
            ```as3
            var myRemoteSO:SharedObject = SharedObject.getRemote("mo", myNC.uri, false);
            myRemoteSO.connect(myNC);
            ```
    
            @param myConnection A NetConnection object that uses the Real-Time
                                Messaging Protocol (RTMP), such as a NetConnection
                                object used to communicate with Flash Media
                                Server.
            @param params       A string defining a message to pass to the remote
                                shared object on the server. Cannot be used with
                                Flash Media Server.
            @throws Error Flash Player could not connect to the specified remote
                          shared object. Verify that the NetConnection instance is
                          valid and connected and that the remote shared object
                          was successfully created on the server.
        **/
        connect(myConnection, params = null) {
            // openfl._internal.Lib.notImplemented();
        }
        // /** @hidden */ @:dox(hide) public static deleteAll (url:String):Int;
        /**
            Immediately writes a locally persistent shared object to a local file. If
            you don't use this method, Flash Player writes the shared object to a file
            when the shared object session ends  -  that is, when the SWF file is
            closed, when the shared object is garbage-collected because it no longer
            has any references to it, or when you call
            `SharedObject.clear()` or `SharedObject.close()`.
    
            If this method returns `SharedObjectFlushStatus.PENDING`,
            Flash Player displays a dialog box asking the user to increase the amount
            of disk space available to objects from this domain. To allow space for
            the shared object to grow when it is saved in the future, which avoids
            return values of `PENDING`, pass a value for
            `minDiskSpace`. When Flash Player tries to write the file, it
            looks for the number of bytes passed to `minDiskSpace`, instead
            of looking for enough space to save the shared object at its current size.
    
    
            For example, if you expect a shared object to grow to a maximum size of
            500 bytes, even though it might start out much smaller, pass 500 for
            `minDiskSpace`. If Flash asks the user to allot disk space for
            the shared object, it asks for 500 bytes. After the user allots the
            requested amount of space, Flash won't have to ask for more space on
            future attempts to flush the object(as long as its size doesn't exceed
            500 bytes).
    
            After the user responds to the dialog box, this method is called again.
            A `netStatus` event is dispatched with a `code`
            property of `SharedObject.Flush.Success` or
            `SharedObject.Flush.Failed`.
    
            @param minDiskSpace The minimum disk space, in bytes, that must be
                                allotted for this object.
            @return Either of the following values:
    
                     * `SharedObjectFlushStatus.PENDING`: The user has
                    permitted local information storage for objects from this domain,
                    but the amount of space allotted is not sufficient to store the
                    object. Flash Player prompts the user to allow more space. To
                    allow space for the shared object to grow when it is saved, thus
                    avoiding a `SharedObjectFlushStatus.PENDING` return
                    value, pass a value for `minDiskSpace`.
                     * `SharedObjectFlushStatus.FLUSHED`: The shared
                    object has been successfully written to a file on the local
                    disk.
    
            @throws Error Flash Player cannot write the shared object to disk. This
                          error might occur if the user has permanently disallowed
                          local information storage for objects from this domain.
    
                          **Note:** Local content can always write shared
                          objects from third-party domains(domains other than the
                          domain in the current browser address bar) to disk, even if
                          writing of third-party shared objects to disk is
                          disallowed.
        **/
        flush(minDiskSpace = 0) {
            if (Object.getOwnPropertyNames(this.data).length == 0) {
                return SharedObjectFlushStatus$1.FLUSHED;
            }
            // return __backend.flush(minDiskSpace);
            return null;
        }
        // /** @hidden */ @:dox(hide) public static getDiskUsage (url:String):Int;
        /**
            Returns a reference to a locally persistent shared object that is only
            available to the current client. If the shared object does not already
            exist, this method creates one. If any values passed to
            `getLocal()` are invalid or if the call fails, Flash Player
            throws an exception.
    
            The following code shows how you assign the returned shared object
            reference to a variable:
    
            `var so:SharedObject =
            SharedObject.getLocal("savedData");`
    
            **Note:** If the user has chosen to never allow local storage for
            this domain, the object is not saved locally, even if a value for
            `localPath` is specified. The exception to this rule is local
            content. Local content can always write shared objects from third-party
            domains(domains other than the domain in the current browser address bar)
            to disk, even if writing of third-party shared objects to disk is
            disallowed.
    
            To avoid name conflicts, Flash looks at the location of the SWF file
            creating the shared object. For example, if a SWF file at
            www.myCompany.com/apps/stockwatcher.swf creates a shared object named
            `portfolio`, that shared object does not conflict with another
            object named `portfolio` that was created by a SWF file at
            www.yourCompany.com/photoshoot.swf because the SWF files originate from
            different directories.
    
            Although the `localPath` parameter is optional, you should
            give some thought to its use, especially if other SWF files need to access
            the shared object. If the data in the shared object is specific to one SWF
            file that will not be moved to another location, then use of the default
            value makes sense. If other SWF files need access to the shared object, or
            if the SWF file that creates the shared object will later be moved, then
            the value of this parameter affects how accessible the shared object will
            be. For example, if you create a shared object with `localPath`
            set to the default value of the full path to the SWF file, no other SWF
            file can access that shared object. If you later move the original SWF
            file to another location, not even that SWF file can access the data
            already stored in the shared object.
    
            To avoid inadvertently restricting access to a shared object, use the
            `localpath` parameter. The most permissive approach is to set
            `localPath` to `/`(slash), which makes the shared
            object available to all SWF files in the domain, but increases the
            likelihood of name conflicts with other shared objects in the domain. A
            more restrictive approach is to append `localPath` with folder
            names that are in the full path to the SWF file. For example, for a
            `portfolio` shared object created by the SWF file at
            www.myCompany.com/apps/stockwatcher.swf, you could set the
            `localPath` parameter to `/`, `/apps`, or
            `/apps/stockwatcher.swf`. You must determine which approach
            provides optimal flexibility for your application.
    
            When using this method, consider the following security model:
    
            * You cannot access shared objects across sandbox boundaries.
            * Users can restrict shared object access by using the Flash Player
            Settings dialog box or the Settings Manager. By default, an application
            can create shared objects of up 100 KB of data per domain. Administrators
            and users can also place restrictions on the ability to write to the file
            system.
    
            Suppose you publish SWF file content to be played back as local files
            (either locally installed SWF files or EXE files), and you need to access
            a specific shared object from more than one local SWF file. In this
            situation, be aware that for local files, two different locations might be
            used to store shared objects. The domain that is used depends on the
            security permissions granted to the local file that created the shared
            object. Local files can have three different levels of permissions:
    
             1. Access to the local filesystem only.
             2. Access to the network only.
             3. Access to both the network and the local filesystem.
    
            Local files with access to the local filesystem(level 1 or 3) store
            their shared objects in one location. Local files without access to the
            local filesystem(level 2) store their shared objects in another
            location.
    
            You can prevent a SWF file from using this method by setting the
            `allowNetworking` parameter of the the `object` and
            `embed` tags in the HTML page that contains the SWF
            content.
    
            For more information, see the Flash Player Developer Center Topic:
            [Security](http://www.adobe.com/go/devnet_security_en).
    
            @param name      The name of the object. The name can include forward
                             slashes(`/`); for example,
                             `work/addresses` is a legal name. Spaces are
                             not allowed in a shared object name, nor are the
                             following characters: `~ % & \
                             ; : " ' , < > ? #`
            @param localPath The full or partial path to the SWF file that created the
                             shared object, and that determines where the shared
                             object will be stored locally. If you do not specify this
                             parameter, the full path is used.
            @param secure    Determines whether access to this shared object is
                             restricted to SWF files that are delivered over an HTTPS
                             connection. If your SWF file is delivered over HTTPS,
                             this parameter's value has the following effects:
    
                              * If this parameter is set to `true`,
                             Flash Player creates a new secure shared object or gets a
                             reference to an existing secure shared object. This
                             secure shared object can be read from or written to only
                             by SWF files delivered over HTTPS that call
                             `SharedObject.getLocal()` with the
                             `secure` parameter set to
                             `true`.
                              * If this parameter is set to `false`,
                             Flash Player creates a new shared object or gets a
                             reference to an existing shared object that can be read
                             from or written to by SWF files delivered over non-HTTPS
                             connections.
    
    
                             If your SWF file is delivered over a non-HTTPS
                             connection and you try to set this parameter to
                             `true`, the creation of a new shared object
                            (or the access of a previously created secure shared
                             object) fails and `null` is returned.
                             Regardless of the value of this parameter, the created
                             shared objects count toward the total amount of disk
                             space allowed for a domain.
    
                             The following diagram shows the use of the
                             `secure` parameter:
            @return A reference to a shared object that is persistent locally and is
                    available only to the current client. If Flash Player can't create
                    or find the shared object(for example, if `localPath`
                    was specified but no such directory exists), this method throws an
                    exception.
            @throws Error Flash Player cannot create the shared object for whatever
                          reason. This error might occur is if persistent shared
                          object creation and storage by third-party Flash content is
                          prohibited(does not apply to local content). Users can
                          prohibit third-party persistent shared objects on the Global
                          Storage Settings panel of the Settings Manager, located at
                          [http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html](http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html).
        **/
        static getLocal(name, localPath = null, secure = false /* note: unsupported**/) {
            var illegalValues = [" ", "~", "%", "&", "\\", ";", ":", "\"", "'", ",", "<", ">", "?", "#"];
            var allowed = true;
            if (name == null || name == "") {
                allowed = false;
            }
            else {
                for (let value of illegalValues) {
                    if (name.indexOf(value) > -1) {
                        allowed = false;
                        break;
                    }
                }
            }
            if (!allowed) {
                throw new Error$1("Error #2134: Cannot create SharedObject.");
            }
            if (SharedObject.__sharedObjects == null) {
                SharedObject.__sharedObjects = new Map();
            }
            var id = localPath + "/" + name;
            if (!SharedObject.__sharedObjects.has(id)) {
                var sharedObject = new SharedObject();
                // sharedObject.__backend.getLocal(name, localPath, secure);
                if (sharedObject.data == null) {
                    sharedObject.data = {};
                }
                SharedObject.__sharedObjects.set(id, sharedObject);
                return sharedObject;
            }
            else {
                return SharedObject.__sharedObjects.get(id);
            }
        }
        /**
            Returns a reference to a shared object on Flash Media Server that
            multiple clients can access. If the remote shared object does not
            already exist, this method creates one.
            To create a remote shared object, call `getRemote()` the call
            `connect()` to connect the remote shared object to the server, as in
            the following:
    
            ```as3
            var nc:NetConnection = new NetConnection();
            nc.connect("rtmp://somedomain.com/applicationName");
            var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
            myRemoteSO.connect(nc);
            ```
    
            To confirm that the local and remote copies of the shared object are
            synchronized, listen for and handle the `sync` event. All clients that
            want to share this object must pass the same values for the `name` and
            `remotePath` parameters.
    
            To create a shared object that is available only to the current
            client, use `SharedObject.getLocal()`.
    
            @param name        The name of the remote shared object. The name can
                               include forward slashes (/); for example,
                               work/addresses is a legal name. Spaces are not
                               allowed in a shared object name, nor are the
                               following characters: `~ % & \ ; :  " ' , > ? ? #`
            @param remotePath  The URI of the server on which the shared object
                               will be stored. This URI must be identical to the
                               URI of the NetConnection object passed to the
                               `connect()` method.
            @param persistence Specifies whether the attributes of the shared
                               object's data property are persistent locally,
                               remotely, or both. This parameter can also specify
                               where the shared object will be stored locally.
                               Acceptable values are as follows:
                               * A value of `false` specifies that the shared
                               object is not persistent on the client or server.
                               * A value of `true` specifies that the shared
                               object is persistent only on the server.
                               * A full or partial local path to the shared object
                               indicates that the shared object is persistent on
                               the client and the server. On the client, it is
                               stored in the specified path; on the server, it is
                               stored in a subdirectory within the application
                               directory.
    
                               **Note:** If the user has chosen to never allow
                               local storage for this domain, the object will not
                               be saved locally, even if a local path is specified
                               for persistence. For more information, see the
                               class description.
            @param secure      Determines whether access to this shared object is
                               restricted to SWF files that are delivered over an
                               HTTPS connection. For more information, see the
                               description of the `secure` parameter in the
                               `getLocal` method entry.
            @return A reference to an object that can be shared across multiple
                    clients.
            @throws Error Flash Player can't create or find the shared object.
                          This might occur if nonexistent paths were specified for
                          the `remotePath` and `persistence` parameters.
        **/
        static getRemote(name, remotePath = null, persistence = false, secure = false) {
            // openfl._internal.Lib.notImplemented();
            return null;
        }
        /**
            Broadcasts a message to all clients connected to a remote shared
            object, including the client that sent the message. To process and
            respond to the message, create a callback attached to the
            shared object.
    
        **/
        send(args) {
            // openfl._internal.Lib.notImplemented();
        }
        /**
            Indicates to the server that the value of a property in the shared
            object has changed. This method marks properties as _dirty_, which
            means changed.
            Call the `SharedObject.setProperty()` to create properties for a
            shared object.
    
            The `SharedObject.setProperty()` method implements `setDirty()`. In
            most cases, such as when the value of a property is a primitive type
            like String or Number, you can call `setProperty()` instead of calling
            `setDirty()`. However, when the value of a property is an object that
            contains its own properties, call `setDirty()` to indicate when a
            value within the object has changed.
    
            @param propertyName The name of the property that has changed.
        **/
        setDirty(propertyName) { }
        /**
            Updates the value of a property in a shared object and indicates to
            the server that the value of the property has changed. The
            `setProperty()` method explicitly marks properties as changed, or
            dirty.
            For more information about remote shared objects see the <a
            href="http://www.adobe.com/go/learn_fms_docs_en"> Flash Media Server
            documentation</a>.
    
            **Note:** The `SharedObject.setProperty()` method implements the
            `setDirty()` method. In most cases, such as when the value of a
            property is a primitive type like String or Number, you would use
            `setProperty()` instead of `setDirty`. However, when the value of a
            property is an object that contains its own properties, use
            `setDirty()` to indicate when a value within the object has changed.
            In general, it is a good idea to call `setProperty()` rather than
            `setDirty()`, because `setProperty()` updates a property value only
            when that value has changed, whereas `setDirty()` forces
            synchronization on all subscribed clients.
    
            @param propertyName The name of the property in the shared object.
            @param value        The value of the property (an ActionScript
                                object), or `null` to delete the property.
        **/
        setProperty(propertyName, value = null) {
            if (this.data != null) {
                this.data[propertyName] = value;
            }
        }
        // Getters & Setters
        /**
            The current size of the shared object, in bytes.
    
            Flash calculates the size of a shared object by stepping through all of
            its data properties; the more data properties the object has, the longer
            it takes to estimate its size. Estimating object size can take significant
            processing time, so you may want to avoid using this method unless you
            have a specific need for it.
        **/
        get size() {
            // return __backend.getSize();
            return 0;
        }
    }
    /**
        The default object encoding (AMF version) for all local shared objects created in
        the SWF file. When local shared objects are written to disk, the
        `SharedObject.defaultObjectEncoding` property indicates which Action Message
        Format version should be used: the ActionScript 3.0 format (AMF3) or the
        ActionScript 1.0 or 2.0 format (AMF0).

        For more information about object encoding, including the difference between
        encoding in local and remote shared objects, see the description of the
        `objectEncoding` property.

        The default value of `SharedObject.defaultObjectEncoding` is set to use the
        ActionScript 3.0 format, AMF3. If you need to write local shared objects that
        ActionScript 2.0 or 1.0 SWF files can read, set
        `SharedObject.defaultObjectEncoding` to use the ActionScript 1.0 or ActionScript
        2.0 format, `openfl.net.ObjectEncoding.AMF0`, at the beginning of your script,
        before you create any local shared objects. All local shared objects created
        thereafter will use AMF0 encoding and can interact with older content. You cannot
        change the `objectEncoding` value of existing local shared objects by setting
        `SharedObject.defaultObjectEncoding` after the local shared objects have been
        created.

        To set the object encoding on a per-object basis, rather than for all shared
        objects created by the SWF file, set the objectEncoding property of the local
        shared object instead.
    **/
    SharedObject.defaultObjectEncoding = ObjectEncoding$1.DEFAULT;
    return SharedObject;
})();

// import haxe.Serializer;
/**
    The Socket class enables code to establish Transport Control Protocol
    (TCP) socket connections for sending and receiving binary data.
    The Socket class is useful for working with servers that use binary
    protocols.

    To use the methods of the Socket class, first use the constructor, `new
    Socket`, to create a Socket object.

    A socket transmits and receives data asynchronously.

    On some operating systems, flush() is called automatically between
    execution frames, but on other operating systems, such as Windows, the
    data is never sent unless you call `flush()` explicitly. To ensure your
    application behaves reliably across all operating systems, it is a good
    practice to call the `flush()` method after writing each message (or
    related group of data) to the socket.

    In Adobe AIR, Socket objects are also created when a listening
    ServerSocket receives a connection from an external process. The Socket
    representing the connection is dispatched in a ServerSocketConnectEvent.
    Your application is responsible for maintaining a reference to this Socket
    object. If you don't, the Socket object is eligible for garbage collection
    and may be destroyed by the runtime without warning.

    SWF content running in the local-with-filesystem security sandbox cannot
    use sockets.

    _Socket policy files_ on the target host specify the hosts from which SWF
    files can make socket connections, and the ports to which those
    connections can be made. The security requirements with regard to socket
    policy files have become more stringent in the last several releases of
    Flash Player. In all versions of Flash Player, Adobe recommends the use of
    a socket policy file; in some circumstances, a socket policy file is
    required. Therefore, if you are using Socket objects, make sure that the
    target host provides a socket policy file if necessary.

    The following list summarizes the requirements for socket policy files in
    different versions of Flash Player:

    *  In Flash Player 9.0.124.0 and later, a socket policy file is required
    for any socket connection. That is, a socket policy file on the target
    host is required no matter what port you are connecting to, and is
    required even if you are connecting to a port on the same host that is
    serving the SWF file.
    *  In Flash Player versions 9.0.115.0 and earlier, if you want to connect
    to a port number below 1024, or if you want to connect to a host other
    than the one serving the SWF file, a socket policy file on the target host
    is required.
    *  In Flash Player 9.0.115.0, even if a socket policy file isn't required,
    a warning is displayed when using the Flash Debug Player if the target
    host doesn't serve a socket policy file.
    * In AIR, a socket policy file is not required for content running in the
    application security sandbox. Socket policy files are required for any
    socket connection established by content running outside the AIR
    application security sandbox.

    For more information related to security, see the Flash Player Developer
    Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
    scope="external">Security</a>

    @event close         Dispatched when the server closes the socket
                         connection.
                         The `close` event is dispatched only when the server
                         closes the connection; it is not dispatched when you
                         call the `Socket.close()` method.
    @event connect       Dispatched when a network connection has been
                         established.
    @event ioError       Dispatched when an input/output error occurs that
                         causes a send or load operation to fail.
    @event securityError Dispatched if a call to `Socket.connect()` attempts
                         to connect to a server prohibited by the caller's
                         security sandbox or to a port lower than 1024 and no
                         socket policy file exists to permit such a
                         connection.
                         **Note:** In an AIR application, content running in
                         the application security sandbox is permitted to
                         connect to any server and port number without a
                         socket policy file.
    @event socketData    Dispatched when a socket has received data.
                         The data received by the socket remains in the socket
                         until it is read. You do not have to read all the
                         available data during the handler for this event.

                         Events of type `socketData` do not use the
                         `ProgressEvent.bytesTotal` property.
**/
class Socket extends EventDispatcher {
    /**
        Creates a new Socket object. If no parameters are specified, an
        initially disconnected socket is created. If parameters are specified,
        a connection is attempted to the specified host and port.
        **Note:** It is strongly advised to use the constructor form **without
        parameters**, then add any event listeners, then call the `connect`
        method with `host` and `port` parameters. This sequence guarantees
        that all event listeners will work properly.

        @param host A fully qualified DNS domain name or an IP address. IPv4
                    addresses are specified in dot-decimal notation, such as
                    _192.0.2.0_. In Flash Player 9.0.115.0 and AIR 1.0 and
                    later, you can specify IPv6 addresses using
                    hexadecimal-colon notation, such as
                    _2001:db8:ccc3:ffff:0:444d:555e:666f_. You can also
                    specify `null` to connect to the host server on which the
                    SWF file resides. If the SWF file issuing this call is
                    running in a web browser, `host` must be in the domain
                    from which the SWF file originated.
        @param port The TCP port number on the target host used to establish a
                    connection. In Flash Player 9.0.124.0 and later, the
                    target host must serve a socket policy file specifying
                    that socket connections are permitted from the host
                    serving the SWF file to the specified port. In earlier
                    versions of Flash Player, a socket policy file is required
                    only if you want to connect to a port number below 1024,
                    or if you want to connect to a host other than the one
                    serving the SWF file.
        @throws SecurityError This error occurs in SWF content for the
                              following reasons:
                              * Local-with-filesystem files cannot communicate
                              with the Internet. You can work around this
                              problem by reclassifying this SWF file as
                              local-with-networking or trusted. This
                              limitation is not set for AIR application
                              content in the application security sandbox.
                              * You cannot specify a socket port higher than
                              65535.
        @event connect       Dispatched when a network connection has been
                             established.
        @event ioError       Dispatched when an input/output error occurs that
                             causes the connection to fail.
        @event securityError Dispatched if a call to `Socket.connect()`
                             attempts to connect either to a server that
                             doesn't serve a socket policy file, or to a
                             server whose policy file doesn't grant the
                             calling host access to the specified port. For
                             more information on policy files, see "Website
                             controls (policy files)" in the _ActionScript 3.0
                             Developer's Guide_ and the Flash Player Developer
                             Center Topic: <a
                             href="http://www.adobe.com/go/devnet_security_en"
                             scope="external">Security</a>.
    **/
    constructor(host = null, port = 0) {
        super();
        // __backend = new SocketBackend(this);
        this.endian = Endian$1.BIG_ENDIAN;
        this.timeout = 20000;
        if (port > 0 && port < 65535) {
            this.connect(host, port);
        }
    }
    /**
        Closes the socket. You cannot read or write any data after the
        `close()` method has been called.
        The `close` event is dispatched only when the server closes the
        connection; it is not dispatched when you call the `close()` method.

        You can reuse the Socket object by calling the `connect()` method on
        it again.

        @throws IOError The socket could not be closed, or the socket was not
                        open.
    **/
    close() {
        this.__checkValid();
        // __backend.close();
    }
    /**
        Connects the socket to the specified host and port.
        If the connection fails immediately, either an event is dispatched or
        an exception is thrown: an error event is dispatched if a host was
        specified, and an exception is thrown if no host was specified.
        Otherwise, the status of the connection is reported by an event. If
        the socket is already connected, the existing connection is closed
        first.

        @param host The name or IP address of the host to connect to. If no
                    host is specified, the host that is contacted is the host
                    where the calling file resides. If you do not specify a
                    host, use an event listener to determine whether the
                    connection was successful.
        @param port The port number to connect to.
        @throws IOError       No host was specified and the connection failed.
        @throws SecurityError This error occurs in SWF content for the
                              following reasons:
                              * Local untrusted SWF files may not communicate
                              with the Internet. You can work around this
                              limitation by reclassifying the file as
                              local-with-networking or as trusted.
                              * You cannot specify a socket port higher than
                              65535.
                              * In the HTML page that contains the SWF
                              content, the `allowNetworking` parameter of the
                              `object` and `embed` tags is set to `"none"`.
        @event connect       Dispatched when a network connection has been
                             established.
        @event ioError       Dispatched if a host is specified and an
                             input/output error occurs that causes the
                             connection to fail.
        @event securityError Dispatched if a call to `Socket.connect()`
                             attempts to connect either to a server that
                             doesn't serve a socket policy file, or to a
                             server whose policy file doesn't grant the
                             calling host access to the specified port. For
                             more information on policy files, see "Website
                             controls (policy files)" in the _ActionScript 3.0
                             Developer's Guide_ and the Flash Player Developer
                             Center Topic: <a
                             href="http://www.adobe.com/go/devnet_security_en"
                             scope="external">Security</a>.
    **/
    connect(host = null, port = 0) {
        if (port < 0 || port > 65535) {
            throw new SecurityError("Invalid socket port number specified.");
        }
        // __backend.connect(host, port);
    }
    /**
        Flushes any accumulated data in the socket's output buffer.
        On some operating systems, flush() is called automatically between
        execution frames, but on other operating systems, such as Windows, the
        data is never sent unless you call `flush()` explicitly. To ensure
        your application behaves reliably across all operating systems, it is
        a good practice to call the `flush()` method after writing each
        message (or related group of data) to the socket.

        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    flush() {
        this.__checkValid();
        // __backend.flush();
    }
    /**
        Reads a Boolean value from the socket. After reading a single byte,
        the method returns `true` if the byte is nonzero, and `false`
        otherwise.

        @return A value of `true` if the byte read is nonzero, otherwise
                `false`.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readBoolean() {
        this.__checkValid();
        return false;
        // return __backend.readBoolean();
    }
    /**
        Reads a signed byte from the socket.

        @return A value from -128 to 127.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readByte() {
        this.__checkValid();
        return 0;
        // return __backend.readByte();
    }
    /**
        Reads the number of data bytes specified by the length parameter from
        the socket. The bytes are read into the specified byte array, starting
        at the position indicated by `offset`.

        @param bytes  The ByteArray object to read data into.
        @param offset The offset at which data reading should begin in the
                      byte array.
        @param length The number of bytes to read. The default value of 0
                      causes all available data to be read.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readBytes(bytes, offset = 0, length = 0) {
        this.__checkValid();
        // __backend.readBytes(bytes, offset, length);
    }
    /**
        Reads an IEEE 754 double-precision floating-point number from the
        socket.

        @return An IEEE 754 double-precision floating-point number.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readDouble() {
        this.__checkValid();
        return 0;
        // return __backend.readDouble();
    }
    /**
        Reads an IEEE 754 single-precision floating-point number from the
        socket.

        @return An IEEE 754 single-precision floating-point number.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readFloat() {
        this.__checkValid();
        return 0;
        // return __backend.readFloat();
    }
    /**
        Reads a signed 32-bit integer from the socket.

        @return A value from -2147483648 to 2147483647.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readInt() {
        this.__checkValid();
        return 0;
        // return __backend.readInt();
    }
    /**
        Reads a multibyte string from the byte stream, using the specified
        character set.

        @param length  The number of bytes from the byte stream to read.
        @param charSet The string denoting the character set to use to
                       interpret the bytes. Possible character set strings
                       include `"shift_jis"`, `"CN-GB"`, and `"iso-8859-1"`.
                       For a complete list, see <a
                       href="../../charset-codes.html">Supported Character
                       Sets</a>.
                       **Note:** If the value for the `charSet` parameter is
                       not recognized by the current system, then the
                       application uses the system's default code page as the
                       character set. For example, a value for the `charSet`
                       parameter, as in `myTest.readMultiByte(22,
                       "iso-8859-01")` that uses `01` instead of `1` might
                       work on your development machine, but not on another
                       machine. On the other machine, the application will use
                       the system's default code page.
        @return A UTF-8 encoded string.
        @throws EOFError There is insufficient data available to read.
    **/
    readMultiByte(length, charSet) {
        this.__checkValid();
        return null;
        // return __backend.readMultiByte(length, charSet);
    }
    /**
        Reads an object from the socket, encoded in AMF serialized format.

        @return The deserialized object
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readObject() {
        // if (objectEncoding == HXSF)
        // {
        // 	return Unserializer.run(readUTF());
        // }
        // else
        // {
        // TODO: Add support for AMF if haxelib "format" is included
        return null;
        // }
    }
    /**
        Reads a signed 16-bit integer from the socket.

        @return A value from -32768 to 32767.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readShort() {
        this.__checkValid();
        return 0;
        // return __backend.readShort();
    }
    /**
        Reads an unsigned byte from the socket.

        @return A value from 0 to 255.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readUnsignedByte() {
        this.__checkValid();
        return 0;
        // return __backend.readUnsignedByte();
    }
    /**
        Reads an unsigned 32-bit integer from the socket.

        @return A value from 0 to 4294967295.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readUnsignedInt() {
        this.__checkValid();
        return 0;
        // return __backend.readUnsignedInt();
    }
    /**
        Reads an unsigned 16-bit integer from the socket.

        @return A value from 0 to 65535.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readUnsignedShort() {
        this.__checkValid();
        return 0;
        // return __backend.readUnsignedShort();
    }
    /**
        Reads a UTF-8 string from the socket. The string is assumed to be
        prefixed with an unsigned short integer that indicates the length in
        bytes.

        @return A UTF-8 string.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readUTF() {
        this.__checkValid();
        return null;
        // return __backend.readUTF();
    }
    /**
        Reads the number of UTF-8 data bytes specified by the `length`
        parameter from the socket, and returns a string.

        @param length The number of bytes to read.
        @return A UTF-8 string.
        @throws EOFError There is insufficient data available to read.
        @throws IOError  An I/O error occurred on the socket, or the socket is
                         not open.
    **/
    readUTFBytes(length) {
        this.__checkValid();
        return null;
        // return __backend.readUTFBytes(length);
    }
    /**
        Writes a Boolean value to the socket. This method writes a single
        byte, with either a value of 1 (`true`) or 0 (`false`).

        @param value The value to write to the socket: 1 (`true`) or 0
                     (`false`).
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeBoolean(value) {
        this.__checkValid();
        // __backend.writeBoolean(value);
    }
    /**
        Writes a byte to the socket.

        @param value The value to write to the socket. The low 8 bits of the
                     value are used; the high 24 bits are ignored.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeByte(value) {
        this.__checkValid();
        // __backend.writeByte(value);
    }
    /**
        Writes a sequence of bytes from the specified byte array. The write
        operation starts at the position specified by `offset`.
        If you omit the `length` parameter the default length of 0 causes the
        method to write the entire buffer starting at `offset`.

        If you also omit the `offset` parameter, the entire buffer is written.

        @param bytes  The ByteArray object to write data from.
        @param offset The zero-based offset into the `bytes` ByteArray object
                      at which data writing should begin.
        @param length The number of bytes to write. The default value of 0
                      causes the entire buffer to be written, starting at the
                      value specified by the `offset` parameter.
        @throws IOError    An I/O error occurred on the socket, or the socket
                           is not open.
        @throws RangeError If `offset` is greater than the length of the
                           ByteArray specified in `bytes` or if the amount of
                           data specified to be written by `offset` plus
                           `length` exceeds the data available.
    **/
    writeBytes(bytes, offset = 0, length = 0) {
        this.__checkValid();
        // __backend.writeBytes(bytes, offset, length);
    }
    /**
        Writes an IEEE 754 double-precision floating-point number to the
        socket.

        @param value The value to write to the socket.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeDouble(value) {
        this.__checkValid();
        // __backend.writeDouble(value);
    }
    /**
        Writes an IEEE 754 single-precision floating-point number to the
        socket.

        @param value The value to write to the socket.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeFloat(value) {
        this.__checkValid();
        // __backend.writeFloat(value);
    }
    /**
        Writes a 32-bit signed integer to the socket.

        @param value The value to write to the socket.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeInt(value) {
        this.__checkValid();
        // __backend.writeInt(value);
    }
    /**
        Writes a multibyte string from the byte stream, using the specified
        character set.

        @param value   The string value to be written.
        @param charSet The string denoting the character set to use to
                       interpret the bytes. Possible character set strings
                       include `"shift_jis"`, `"CN-GB"`, and `"iso-8859-1"`.
                       For a complete list, see <a
                       href="../../charset-codes.html">Supported Character
                       Sets</a>.
    **/
    writeMultiByte(value, charSet) {
        this.__checkValid();
        // __backend.writeUTFBytes(value);
    }
    /**
        Write an object to the socket in AMF serialized format.

        @param object The object to be serialized.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeObject(object) {
        this.__checkValid();
        // if (objectEncoding == HXSF)
        // {
        // 	__backend.writeUTF(Serializer.run(object));
        // }
        // else
        // {
        // TODO: Add support for AMF if haxelib "format" is included
        // }
    }
    /**
        Writes a 16-bit integer to the socket. The bytes written are as
        follows:

        ```
        (v >> 8) & 0xff v & 0xff
        ```

        The low 16 bits of the parameter are used; the high 16 bits are
        ignored.

        @param value The value to write to the socket.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeShort(value) {
        this.__checkValid();
        // __backend.writeShort(value);
    }
    /**
        Writes a 32-bit unsigned integer to the socket.

        @param value The value to write to the socket.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeUnsignedInt(value) {
        this.__checkValid();
        // __backend.writeUnsignedInt(value);
    }
    /**
        Writes the following data to the socket: a 16-bit unsigned integer,
        which indicates the length of the specified UTF-8 string in bytes,
        followed by the string itself.
        Before writing the string, the method calculates the number of bytes
        that are needed to represent all characters of the string.

        @param value The string to write to the socket.
        @throws IOError    An I/O error occurred on the socket, or the socket
                           is not open.
        @throws RangeError The length is larger than 65535.
    **/
    writeUTF(value) {
        this.__checkValid();
        // __backend.writeUTF(value);
    }
    /**
        Writes a UTF-8 string to the socket.

        @param value The string to write to the socket.
        @throws IOError An I/O error occurred on the socket, or the socket is
                        not open.
    **/
    writeUTFBytes(value) {
        this.__checkValid();
        // __backend.writeUTFBytes(value);
    }
    __checkValid() {
        if (!this.__connected) {
            throw new IOError("Operation attempted on invalid socket.");
        }
    }
    // Get & Set Methods
    /**
        The number of bytes of data available for reading in the input buffer.

        Your code must access `bytesAvailable` to ensure that sufficient data
        is available before trying to read it with one of the `read` methods.
    **/
    get bytesAvailable() {
        // TODO
        // return __backend.getBytesAvailable();
        return 0;
    }
    /**
        Indicates the number of bytes remaining in the write buffer.

        Use this property in combination with with the OutputProgressEvent. An
        OutputProgressEvent is thrown whenever data is written from the write buffer to
        the network. In the event handler, you can check bytesPending to see how much data
        is still left in the buffer waiting to be written. When bytesPending returns 0, it
        means that all the data has been transferred from the write buffer to the network,
        and it is safe to do things like remove event handlers, null out socket
        references, start the next upload in a queue, etc.
    **/
    get bytesPending() {
        // TODO
        // return __backend.getBytesPending();
        return 0;
    }
    /**
        Indicates whether this Socket object is currently connected. A call to
        this property returns a value of `true` if the socket is currently
        connected, or `false` otherwise.
    **/
    get connected() {
        return this.__connected;
    }
    /**
        Indicates the byte order for the data. Possible values are constants
        from the openfl.utils.Endian class, `Endian.BIG_ENDIAN` or
        `Endian.LITTLE_ENDIAN`.

        @default Endian.BIG_ENDIAN
    **/
    get endian() {
        // TODO
        return Endian$1.LITTLE_ENDIAN;
        // return __backend.getEndian();
    }
    set endian(value) {
        // __backend.setEndian(value);
        // return value;
    }
}

/**
    A URLRequestHeader object encapsulates a single HTTP request header and
    consists of a name/value pair. URLRequestHeader objects are used in the
    `requestHeaders` property of the URLRequest class.

    In Adobe<sup>®</sup> AIR<sup>®</sup>, content in the application
    security sandbox(such as content installed with the AIR application) can
    use any request headers, without error. However, for content running in
    Adobe AIR that is in a different security sandbox, or for content running
    in Flash<sup>®</sup> Player, using following request headers cause a
    runtime error to be thrown, and the restricted terms are not case-sensitive
    (for example, `Get`, `get`, and `GET` are
    each not allowed):

    In Flash Player and in Adobe AIR content outside of the application
    security sandbox, the following request headers cannot be used, and the
    restricted terms are not case-sensitive(for example, `Get`,
    `get`, and `GET` are all not allowed). Also,
    hyphenated terms apply if an underscore character is used(for example,
    both `Content-Length` and `Content_Length` are not
    allowed):

    `Accept-Charset`, `Accept-Encoding`,
    `Accept-Ranges`, `Age`, `Allow`,
    `Allowed`, `Authorization`, `Charge-To`,
    `Connect`, `Connection`, `Content-Length`,
    `Content-Location`, `Content-Range`,
    `Cookie`, `Date`, `Delete`,
    `ETag`, `Expect`, `Get`,
    `Head`, `Host`, `If-Modified-Since`,
    `Keep-Alive`, `Last-Modified`, `Location`,
    `Max-Forwards`, `Options`, `Origin`,
    `Post`, `Proxy-Authenticate`,
    `Proxy-Authorization`, `Proxy-Connection`,
    `Public`, `Put`, `Range`,
    `Referer`, `Request-Range`, `Retry-After`,
    `Server`, `TE`, `Trace`,
    `Trailer`, `Transfer-Encoding`, `Upgrade`,
    `URI`, `User-Agent`, `Vary`,
    `Via`, `Warning`, `WWW-Authenticate`,
    `x-flash-version`.

    URLRequestHeader objects are restricted in length. If the cumulative
    length of a URLRequestHeader object(the length of the `name`
    property plus the `value` property) or an array of
    URLRequestHeader objects used in the `URLRequest.requestHeaders`
    property exceeds the acceptable length, an exception is thrown.

    Content running in Adobe AIR sets the `ACCEPT` header to the
    following, unless you specify a setting for the `ACCEPT` header
    in the `requestHeaders` property of the URLRequest class:

    ```
    text/xml, application/xml, application/xhtml+xml, text/html;q=0.9, text/plain;q=0.8, image/png, application/x-shockwave-flash, video/mp4;q=0.9, flv-application/octet-stream;q=0.8, video/x-flv;q=0.7, audio/mp4, * /*;q=0.5
    ```

    Not all methods that accept URLRequest parameters support the
    `requestHeaders` property, consult the documentation for the
    method you are calling. For example, the
    `FileReference.upload()` and
    `FileReference.download()` methods do not support the
    `URLRequest.requestHeaders` property.

    Due to browser limitations, custom HTTP request headers are only
    supported for `POST` requests, not for `GET`
    requests.
**/
class URLRequestHeader {
    /**
        Creates a new URLRequestHeader object that encapsulates a single HTTP
        request header. URLRequestHeader objects are used in the
        `requestHeaders` property of the URLRequest class.

        @param name  An HTTP request header name(such as
                     `Content-Type` or `SOAPAction`).
        @param value The value associated with the `name` property
                    (such as `text/plain`).
    **/
    constructor(name = "", value = "") {
        this.name = name;
        this.value = value;
    }
}

/**
    The URLStream class provides low-level access to downloading URLs. Data is
    made available to application code immediately as it is downloaded,
    instead of waiting until the entire file is complete as with URLLoader.
    The URLStream class also lets you close a stream before it finishes
    downloading. The contents of the downloaded file are made available as raw
    binary data.
    The read operations in URLStream are nonblocking. This means that you must
    use the `bytesAvailable` property to determine whether sufficient data is
    available before reading it. An `EOFError` exception is thrown if
    insufficient data is available.

    All binary data is encoded by default in big-endian format, with the most
    significant byte first.

    The security rules that apply to URL downloading with the URLStream class
    are identical to the rules applied to URLLoader objects. Policy files may
    be downloaded as needed. Local file security rules are enforced, and
    security warnings are raised as needed.

    @event complete           Dispatched when data has loaded successfully.
    @event httpResponseStatus Dispatched if a call to the `URLStream.load()`
                                method attempts to access data over HTTP and
                                Adobe AIR is able to detect and return the
                                status code for the request.
                                If a URLStream object registers for an
                                `httpStatusEvent` event, error responses are
                                delivered as though they are content. So instead
                                of dispatching an `ioError` event, the URLStream
                                dispatches `progress` and `complete` events as
                                the error data is loaded into the URLStream.
    @event httpStatus         Dispatched if a call to `URLStream.load()`
                                attempts to access data over HTTP, and Flash
                                Player or Adobe AIR is able to detect and return
                                the status code for the request. (Some browser
                                environments may not be able to provide this
                                information.) Note that the `httpStatus` (if
                                any) will be sent before (and in addition to)
                                any `complete` or `error` event.
    @event ioError            Dispatched when an input/output error occurs
                                that causes a load operation to fail.
    @event open               Dispatched when a load operation starts.
    @event progress           Dispatched when data is received as the download
                                operation progresses. Data that has been
                                received can be read immediately using the
                                methods of the URLStream class.
    @event securityError      Dispatched if a call to `URLStream.load()`
                                attempts to load data from a server outside the
                                security sandbox.
**/
class URLStream extends EventDispatcher {
    constructor() {
        super();
        this.__loader = new URLLoader();
        this.__loader.dataFormat = URLLoaderDataFormat$1.BINARY;
    }
    /**
        Immediately closes the stream and cancels the download operation. No
        data can be read from the stream after the `close()` method is called.

        @throws IOError The stream could not be closed, or the stream was not
                        open.
    **/
    close() {
        this.__removeEventListeners();
        this.__data = null;
    }
    /**
        Begins downloading the URL specified in the `request` parameter.
        **Note**: If a file being loaded contains non-ASCII characters (as
        found in many non-English languages), it is recommended that you save
        the file with UTF-8 or UTF-16 encoding, as opposed to a non-Unicode
        format like ASCII.

        If the loading operation fails immediately, an IOError or
        SecurityError (including the local file security error) exception is
        thrown describing the failure. Otherwise, an `open` event is
        dispatched if the URL download starts downloading successfully, or an
        error event is dispatched if an error occurs.

        By default, the calling SWF file and the URL you load must be in
        exactly the same domain. For example, a SWF file at www.adobe.com can
        load data only from sources that are also at www.adobe.com. To load
        data from a different domain, place a URL policy file on the server
        hosting the data.

        In Flash Player, you cannot connect to commonly reserved ports. For a
        complete list of blocked ports, see "Restricting Networking APIs" in
        the _ActionScript 3.0 Developer's Guide_.

        In Flash Player, you can prevent a SWF file from using this method by
        setting the `allowNetworking` parameter of the the `object` and
        `embed` tags in the HTML page that contains the SWF content.

        In Flash Player 10 and later, and in AIR 1.5 and later, if you use a
        multipart Content-Type (for example "multipart/form-data") that
        contains an upload (indicated by a "filename" parameter in a
        "content-disposition" header within the POST body), the POST operation
        is subject to the security rules applied to uploads:

        * The POST operation must be performed in response to a user-initiated
        action, such as a mouse click or key press.
        * If the POST operation is cross-domain (the POST target is not on the
        same server as the SWF file that is sending the POST request), the
        target server must provide a URL policy file that permits cross-domain
        access.

        Also, for any multipart Content-Type, the syntax must be valid
        (according to the RFC2046 standards). If the syntax appears to be
        invalid, the POST operation is subject to the security rules applied
        to uploads.

        These rules also apply to AIR content in non-application sandboxes.
        However, in Adobe AIR, content in the application sandbox (content
        installed with the AIR application) are not restricted by these
        security limitations.

        For more information related to security, see The Flash Player
        Developer Center Topic: <a
        href="http://www.adobe.com/go/devnet_security_en"
        scope="external">Security</a>.

        In AIR, a URLRequest object can register for the `httpResponse` status
        event. Unlike the `httpStatus` event, the `httpResponseStatus` event
        is delivered before any response data. Also, the `httpResponseStatus`
        event includes values for the `responseHeaders` and `responseURL`
        properties (which are undefined for an `httpStatus` event. Note that
        the `httpResponseStatus` event (if any) will be sent before (and in
        addition to) any `complete` or `error` event.

        If there _is_ an `httpResponseStatus` event listener, the body of the
        response message is _always_ sent; and HTTP status code responses
        always results in a `complete` event. This is true in spite of whether
        the HTTP response status code indicates a success or an error.

        In AIR, if there is _no_ `httpResponseStatus` event listener, the
        behavior differs based on the SWF version:

        * For SWF 9 content, the body of the HTTP response message is sent
        _only if_ the HTTP response status code indicates success. Otherwise
        (if there is an error), no body is sent and the URLRequest object
        dispatches an IOError event.
        * For SWF 10 content, the body of the HTTP response message is
        _always_ sent. If there is an error, the URLRequest object dispatches
        an IOError event.

        @param request A URLRequest object specifying the URL to download. If
                       the value of this parameter or the `URLRequest.url`
                       property of the URLRequest object passed are `null`,
                       the application throws a null pointer error.
        @throws ArgumentError `URLRequest.requestHeader` objects may not
                              contain certain prohibited HTTP request headers.
                              For more information, see the URLRequestHeader
                              class description.
        @throws MemoryError   This error can occur for the following reasons:
                              1. Flash Player or Adobe AIR cannot convert the
                              `URLRequest.data` parameter from UTF8 to MBCS.
                              This error is applicable if the URLRequest
                              object passed to `load()` is set to perform a
                              `GET` operation and if `System.useCodePage` is
                              set to `true`.
                              2. Flash Player or Adobe AIR cannot allocate
                              memory for the `POST` data. This error is
                              applicable if the URLRequest object passed to
                              load is set to perform a `POST` operation.
        @throws SecurityError Local untrusted SWF files may not communicate
                              with the Internet. This may be worked around by
                              reclassifying this SWF file as
                              local-with-networking or trusted.
        @throws SecurityError You are trying to connect to a commonly reserved
                              port. For a complete list of blocked ports, see
                              "Restricting Networking APIs" in the
                              _ActionScript 3.0 Developer's Guide_.
        @event complete           Dispatched after data has loaded
                                  successfully. If there is a
                                  `httpResponseStatus` event listener, the
                                  URLRequest object also dispatches a
                                  `complete` event whether the HTTP response
                                  status code indicates a success _or_ an
                                  error.
        @event httpResponseStatus Dispatched if a call to the `load()` method
                                  attempts to access data over HTTP and Adobe
                                  AIR is able to detect and return the status
                                  code for the request.
        @event httpStatus         If access is by HTTP and the current
                                  environment supports obtaining status codes,
                                  you may receive these events in addition to
                                  any `complete` or `error` event.
        @event ioError            The load operation could not be completed.
        @event open               Dispatched when a load operation starts.
        @event securityError      A load operation attempted to retrieve data
                                  from a server outside the caller's security
                                  sandbox. This may be worked around using a
                                  policy file on the server.
    **/
    load(request) {
        this.__removeEventListeners();
        this.__addEventListeners();
        this.__loader.load(request);
    }
    /**
        Reads a Boolean value from the stream. A single byte is read, and
        `true` is returned if the byte is nonzero, `false` otherwise.

        @return `True` is returned if the byte is nonzero, `false` otherwise.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readBoolean() {
        return this.__data.readBoolean();
    }
    /**
        Reads a signed byte from the stream.
        The returned value is in the range -128...127.

        @return Value in the range -128...127.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readByte() {
        return this.__data.readByte();
    }
    /**
        Reads `length` bytes of data from the stream. The bytes are read into
        the ByteArray object specified by `bytes`, starting `offset` bytes
        into the ByteArray object.

        @param bytes  The ByteArray object to read data into.
        @param offset The offset into `bytes` at which data read should begin.
                      Defaults to 0.
        @param length The number of bytes to read. The default value of 0 will
                      cause all available data to be read.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readBytes(bytes, offset = 0, length = 0) {
        this.__data.readBytes(bytes, offset, length);
    }
    /**
        Reads an IEEE 754 double-precision floating-point number from the
        stream.

        @return An IEEE 754 double-precision floating-point number from the
                stream.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readDouble() {
        return this.__data.readDouble();
    }
    /**
        Reads an IEEE 754 single-precision floating-point number from the
        stream.

        @return An IEEE 754 single-precision floating-point number from the
                stream.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readFloat() {
        return this.__data.readFloat();
    }
    /**
        Reads a signed 32-bit integer from the stream.
        The returned value is in the range -2147483648...2147483647.

        @return Value in the range -2147483648...2147483647.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readInt() {
        return this.__data.readInt();
    }
    /**
        Reads a multibyte string of specified length from the byte stream
        using the specified character set.

        @param length  The number of bytes from the byte stream to read.
        @param charSet The string denoting the character set to use to
                       interpret the bytes. Possible character set strings
                       include `"shift_jis"`, `"CN-GB"`, `"iso-8859-1"`, and
                       others. For a complete list, see <a
                       href="../../charset-codes.html">Supported Character
                       Sets</a>.
                       **Note:** If the value for the `charSet` parameter is
                       not recognized by the current system, the application
                       uses the system's default code page as the character
                       set. For example, a value for the `charSet` parameter,
                       as in `myTest.readMultiByte(22, "iso-8859-01")` that
                       uses `01` instead of `1` might work on your development
                       machine, but not on another machine. On the other
                       machine, the application will use the system's default
                       code page.
        @return UTF-8 encoded string.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
    **/
    readMultiByte(length, charSet) {
        return this.__data.readMultiByte(length, charSet);
    }
    /**
        Reads an object from the socket, encoded in Action Message Format
        (AMF).

        @return The deserialized object.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readObject() {
        return this.__data.readObject();
    }
    /**
        Reads a signed 16-bit integer from the stream.
        The returned value is in the range -32768...32767.

        @return Value in the range -32768...32767.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readShort() {
        return this.__data.readShort();
    }
    /**
        Reads an unsigned byte from the stream.
        The returned value is in the range 0...255.

        @return Value in the range 0...255.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readUnsignedByte() {
        return this.__data.readUnsignedByte();
    }
    /**
        Reads an unsigned 32-bit integer from the stream.
        The returned value is in the range 0...4294967295.

        @return Value in the range 0...4294967295.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readUnsignedInt() {
        return this.__data.readUnsignedInt();
    }
    /**
        Reads an unsigned 16-bit integer from the stream.
        The returned value is in the range 0...65535.

        @return Value in the range 0...65535.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readUnsignedShort() {
        return this.__data.readUnsignedShort();
    }
    /**
        Reads a UTF-8 string from the stream. The string is assumed to be
        prefixed with an unsigned short indicating the length in bytes.

        @return A UTF-8 string.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readUTF() {
        return this.__data.readUTF();
    }
    /**
        Reads a sequence of `length` UTF-8 bytes from the stream, and returns
        a string.

        @param length A sequence of UTF-8 bytes.
        @return A UTF-8 string produced by the byte representation of
                characters of specified length.
        @throws EOFError There is insufficient data available to read. If a
                         local SWF file triggers a security warning, Flash
                         Player prevents the URLStream data from being
                         available to ActionScript. When this happens, the
                         `bytesAvailable` property returns 0 even if data has
                         been received, and any of the read methods throws an
                         EOFError exception.
        @throws IOError  An I/O error occurred on the stream, or the stream is
                         not open.
    **/
    readUTFBytes(length) {
        return this.__data.readUTFBytes(length);
    }
    // @:require(flash11_4) public stop ():Void;
    __addEventListeners() {
        this.__loader.addEventListener(Event.COMPLETE, this.loader_onComplete);
        this.__loader.addEventListener(IOErrorEvent.IO_ERROR, this.loader_onIOError);
        this.__loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.loader_onSecurityError);
        this.__loader.addEventListener(ProgressEvent.PROGRESS, this.loader_onProgressEvent);
    }
    __removeEventListeners() {
        this.__loader.removeEventListener(Event.COMPLETE, this.loader_onComplete);
        this.__loader.removeEventListener(IOErrorEvent.IO_ERROR, this.loader_onIOError);
        this.__loader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.loader_onSecurityError);
        this.__loader.removeEventListener(ProgressEvent.PROGRESS, this.loader_onProgressEvent);
    }
    // Event Handlers
    loader_onComplete(event) {
        this.__removeEventListeners();
        this.__data = this.__loader.data;
        this.__data.objectEncoding = this.__objectEncoding;
        this.dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, this.__loader.bytesLoaded, this.__loader.bytesTotal));
        this.dispatchEvent(new Event(Event.COMPLETE));
    }
    loader_onIOError(event) {
        this.__removeEventListeners();
        this.dispatchEvent(event);
    }
    loader_onSecurityError(event) {
        this.__removeEventListeners();
        this.dispatchEvent(event);
    }
    loader_onProgressEvent(event) {
        this.__data = this.__loader.data;
        this.dispatchEvent(event);
    }
    // Get & Set Methods
    /**
        Returns the number of bytes of data available for reading in the input
        buffer. Your code must call the `bytesAvailable` property to ensure
        that sufficient data is available before you try to read it with one
        of the `read` methods.
    **/
    get bytesAvailable() {
        if (this.__data != null) {
            return this.__data.length - this.__data.position;
        }
        return 0;
    }
    /**
        Indicates whether this URLStream object is currently connected. A call
        to this property returns a value of `true` if the URLStream object is
        connected, or `false` otherwise.
    **/
    get connected() {
        return false;
    }
    /**
        Indicates the byte order for the data. Possible values are
        `Endian.BIG_ENDIAN` or `Endian.LITTLE_ENDIAN`.

        @default Endian.BIG_ENDIAN
    **/
    get endian() {
        return this.__data.endian;
    }
    set endian(value) {
        this.__data.endian = value;
    }
    /**
        Controls the version of Action Message Format (AMF) used when writing
        or reading an object.
    **/
    get objectEncoding() {
        return this.__objectEncoding;
    }
    set objectEncoding(value) {
        if (this.__data != null) {
            this.__data.objectEncoding = value;
        }
        this.__objectEncoding = value;
    }
}

/**
    The URLVariables class allows you to transfer variables between an
    application and a server. Use URLVariables objects with methods of the
    URLLoader class, with the `data` property of the URLRequest
    class, and with openfl.net namespace functions.
**/
class URLVariables extends Object {
    /**
        Creates a new URLVariables object. You pass URLVariables objects to the
        `data` property of URLRequest objects.

        If you call the URLVariables constructor with a string, the
        `decode()` method is automatically called to convert the string
        to properties of the URLVariables object.

        @param source A URL-encoded string containing name/value pairs.
    **/
    constructor(source = null) {
        super();
        if (source != null) {
            this.decode(source);
        }
    }
    /**
        Converts the variable string to properties of the specified URLVariables
        object.

        This method is used internally by the URLVariables events. Most users
        do not need to call this method directly.

        @param source A URL-encoded query string containing name/value pairs.
        @throws Error The source parameter must be a URL-encoded query string
                      containing name/value pairs.
    **/
    decode(source) {
        var fields = Object.getOwnPropertyNames(this);
        for (let f of fields) {
            delete this[f];
        }
        var fields = source.split(";").join("&").split("&");
        for (let f of fields) {
            var eq = f.indexOf("=");
            if (eq > 0) {
                this[decodeURIComponent(f.substr(0, eq))] = decodeURIComponent(f.substr(eq + 1));
            }
            else if (eq != 0) {
                this[decodeURIComponent(f)] = "";
            }
        }
    }
    /**
        Returns a string containing all enumerable variables, in the MIME content
        encoding _application/x-www-form-urlencoded_.

        @return A URL-encoded string containing name/value pairs.
    **/
    toString() {
        var result = new Array();
        var fields = Object.getOwnPropertyNames(this);
        for (let f of fields) {
            var value = this[f];
            if (f.indexOf("[]") > -1 && value instanceof Array) {
                var arrayValue = value.map((v) => encodeURIComponent(v)).join(`&amp;${f}=`);
                result.push(`${encodeURIComponent(f)}=${arrayValue}`);
            }
            else {
                result.push(`${encodeURIComponent(f)}=${encodeURIComponent(value)}`);
            }
        }
        return result.join("&");
    }
}

/**
    The XMLSocket class implements client sockets that let the Flash Player or
    AIR application communicate with a server computer identified by an IP
    address or domain name. The XMLSocket class is useful for client-server
    applications that require low latency, such as real-time chat systems. A
    traditional HTTP-based chat solution frequently polls the server and
    downloads new messages using an HTTP request. In contrast, an XMLSocket
    chat solution maintains an open connection to the server, which lets the
    server immediately send incoming messages without a request from the
    client. To use the XMLSocket class, the server computer must run a daemon
    that understands the protocol used by the XMLSocket class. The protocol is
    described in the following list:
    * XML messages are sent over a full-duplex TCP/IP stream socket
    connection.
    * Each XML message is a complete XML document, terminated by a zero (0)
    byte.
    * An unlimited number of XML messages can be sent and received over a
    single XMLSocket connection.

    Setting up a server to communicate with the XMLSocket object can be
    challenging. If your application does not require real-time interactivity,
    use the URLLoader class instead of the XMLSocket class.

    To use the methods of the XMLSocket class, first use the constructor, `new
    XMLSocket`, to create an XMLSocket object.

    SWF files in the local-with-filesystem sandbox may not use sockets.

    _Socket policy files_ on the target host specify the hosts from which SWF
    files can make socket connections, and the ports to which those
    connections can be made. The security requirements with regard to socket
    policy files have become more stringent in the last several releases of
    Flash Player. In all versions of Flash Player, Adobe recommends the use of
    a socket policy file; in some circumstances, a socket policy file is
    required. Therefore, if you are using XMLSocket objects, make sure that
    the target host provides a socket policy file if necessary.

    The following list summarizes the requirements for socket policy files in
    different versions of Flash Player:

    *  In Flash Player 9.0.124.0 and later, a socket policy file is required
    for any XMLSocket connection. That is, a socket policy file on the target
    host is required no matter what port you are connecting to, and is
    required even if you are connecting to a port on the same host that is
    serving the SWF file.
    *  In Flash Player versions 9.0.115.0 and earlier, if you want to connect
    to a port number below 1024, or if you want to connect to a host other
    than the one serving the SWF file, a socket policy file on the target host
    is required.
    *  In Flash Player 9.0.115.0, even if a socket policy file isn't required,
    a warning is displayed when using the Flash Debug Player if the target
    host doesn't serve a socket policy file.

    However, in Adobe AIR, content in the `application` security sandbox
    (content installed with the AIR application) are not restricted by these
    security limitations.

    For more information related to security, see the Flash Player Developer
    Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
    scope="external">Security</a>.

    @event close         Dispatched when the server closes the socket
                         connection. The `close` event is dispatched only when
                         the server closes the connection; it is not
                         dispatched when you call the `XMLSocket.close()`
                         method.
    @event connect       Dispatched after a successful call to the
                         `XMLSocket.connect()` method.
    @event data          Dispatched after raw data is sent or received.
    @event ioError       Dispatched when an input/output error occurs that
                         causes a send or receive operation to fail.
    @event securityError Dispatched if a call to the `XMLSocket.connect()`
                         method attempts to connect either to a server outside
                         the caller's security sandbox or to a port lower than
                         1024.
**/
class XMLSocket extends EventDispatcher {
    /**
        Creates a new XMLSocket object. If no parameters are specified, an
        initially disconnected socket is created. If parameters are specified,
        a connection is attempted to the specified host and port.
        **Note:** It is strongly advised to use the constructor form **without
        parameters**, then add any event listeners, then call the `connect`
        method with `host` and `port` parameters. This sequence guarantees
        that all event listeners will work properly.

        @param host A fully qualified DNS domain name or an IP address in the
                    form _.222.333.444_. In Flash Player 9.0.115.0 and AIR 1.0
                    and later, you can specify IPv6 addresses, such as
                    rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. You can also
                    specify `null` to connect to the host server on which the
                    SWF file resides. If the SWF file issuing this call is
                    running in a web browser, `host` must be in the same
                    domain as the SWF file.
        @param port The TCP port number on the target host used to establish a
                    connection. In Flash Player 9.0.124.0 and later, the
                    target host must serve a socket policy file specifying
                    that socket connections are permitted from the host
                    serving the SWF file to the specified port. In earlier
                    versions of Flash Player, a socket policy file is required
                    only if you want to connect to a port number below 1024,
                    or if you want to connect to a host other than the one
                    serving the SWF file.
    **/
    constructor(host = null, port = 80) {
        super();
        if (host != null) {
            this.connect(host, port);
        }
    }
    /**
        Closes the connection specified by the XMLSocket object. The `close`
        event is dispatched only when the server closes the connection; it is
        not dispatched when you call the `close()` method.

    **/
    close() {
        this.__socket.removeEventListener(Event.CLOSE, this.__onClose);
        this.__socket.removeEventListener(Event.CONNECT, this.__onConnect);
        this.__socket.removeEventListener(IOErrorEvent.IO_ERROR, this.__onError);
        this.__socket.removeEventListener(ProgressEvent.SOCKET_DATA, this.__onSocketData);
        this.__socket.close();
    }
    /**
        Establishes a connection to the specified Internet host using the
        specified TCP port.
        If you specify `null` for the `host` parameter, the host contacted is
        the one where the file calling `XMLSocket.connect()` resides. For
        example, if the calling file was downloaded from www.adobe.com,
        specifying `null` for the host parameter means you are connecting to
        www.adobe.com.

        You can prevent a file from using this method by setting the
        `allowNetworking` parameter of the the `object` and `embed` tags in
        the HTML page that contains the SWF content.

        For more information, see the Flash Player Developer Center Topic: <a
        href="http://www.adobe.com/go/devnet_security_en"
        scope="external">Security</a>.

        @param host A fully qualified DNS domain name or an IP address in the
                    form _111.222.333.444_. You can also specify `null` to
                    connect to the host server on which the SWF file resides.
                    If the calling file is a SWF file running in a web
                    browser, `host` must be in the same domain as the file.
        @param port The TCP port number on the target host used to establish a
                    connection. In Flash Player 9.0.124.0 and later, the
                    target host must serve a socket policy file specifying
                    that socket connections are permitted from the host
                    serving the SWF file to the specified port. In earlier
                    versions of Flash Player, a socket policy file is required
                    only if you want to connect to a port number below 1024,
                    or if you want to connect to a host other than the one
                    serving the SWF file.
        @throws SecurityError Local untrusted files may not communicate with
                              the Internet. Work around this limitation by
                              reclassifying the file as local-with-networking
                              or trusted.
        @throws SecurityError You may not specify a socket port higher than
                              65535.
        @event connect       Dispatched when network connection has been
                             established.
        @event data          Dispatched when raw data has been received.
        @event securityError A connect operation attempted to connect to a
                             host outside the caller's security sandbox, or to
                             a port that requires a socket policy file. Work
                             around either problem by using a socket policy
                             file on the target host.
    **/
    connect(host, port) {
        this.__connected = false;
        this.__socket = new Socket();
        this.__socket.addEventListener(Event.CLOSE, this.__onClose);
        this.__socket.addEventListener(Event.CONNECT, this.__onConnect);
        this.__socket.addEventListener(IOErrorEvent.IO_ERROR, this.__onError);
        this.__socket.addEventListener(ProgressEvent.SOCKET_DATA, this.__onSocketData);
        this.__socket.connect(host, port);
    }
    /**
        Converts the XML object or data specified in the `object` parameter to
        a string and transmits it to the server, followed by a zero (0) byte.
        If `object` is an XML object, the string is the XML textual
        representation of the XML object. The send operation is asynchronous;
        it returns immediately, but the data may be transmitted at a later
        time. The `XMLSocket.send()` method does not return a value indicating
        whether the data was successfully transmitted.
        If you do not connect the XMLSocket object to the server using
        `XMLSocket.connect()`), the `XMLSocket.send()` operation fails.

        @param object An XML object or other data to transmit to the server.
        @throws IOError The XMLSocket object is not connected to the server.
    **/
    send(object) {
        this.__socket.writeUTFBytes(String(object));
        this.__socket.writeByte(0);
        this.__socket.flush();
    }
    // Event Handlers
    __onClose(_) {
        this.__connected = false;
        this.dispatchEvent(new Event(Event.CLOSE));
    }
    __onConnect(_) {
        this.__connected = true;
        this.dispatchEvent(new Event(Event.CONNECT));
    }
    __onError(_) {
        this.dispatchEvent(new Event(IOErrorEvent.IO_ERROR));
    }
    __onSocketData(_) {
        this.dispatchEvent(new DataEvent(DataEvent.DATA, false, false, this.__socket.readUTFBytes(this.__socket.bytesAvailable)));
    }
    // Get & Set Methods
    /**
        Indicates whether this XMLSocket object is currently connected. You
        can also check whether the connection succeeded by registering for the
        `connect` event and `ioError` event.
    **/
    get connected() {
        return this.__connected;
    }
}

var navigateToURL = openfl.net.navigateToURL;

var sendToURL = openfl.net.sendToURL;

/**
    The Telemetry class lets an application profile ActionScript code and register handlers
    for commands
**/
let Telemetry = /** @class */ (() => {
    class Telemetry {
        /**
            Register a that can be called by issuing a command over a socket
    
            Returns `true` if the registration is successful. If registration fails, there is
            already a handler registered for the command used (or the command name starts with
            '.', which is reserved for player internal use) Already registered handlers may be
            unregistered using `unregisterCommandHandler` before registering another handler.
    
            The handler function's return value is sent as the result of the command
            (`tlm-response.result`). The handler can throw Error, if it wants to send
            an error response. In this case, `Error.message` and `Error.id` are sent as
            `tlm-response.tlm-error.message` and `tlm-response.tlm-error.code`, respectively.
            (`tlm-response.result` and `tlm-response.tlm-error.data` are sent as `null`)
    
            @param	commandName	String specifying a unique name (The command over the socket
            should specify this string as the method name). The guideline is to follow reverse
            DNS notation, which helps to avoid namespace collisions. Additionally, and names
            starting with . are reserved for native use.
            @param	handler	Function to be called when a command is received by Telemetry over
            the socket with the method name, as specified in `functionId` argument. The handler
            should accept only one argument of type Array (as defined by `tlm-method.params` in
            Telemetry Protocol), which has to be sent by Telemetry server along with method
            name.
            @returns
        **/
        static registerCommandHandler(commandName, handler) {
            return false;
        }
        /**
            Requests a custom metric from Telemetry. The metric name and object are sent as
            per the Telemetry protocol format.
    
            The guideline for custom metric namespaces is to follow reverse DNS notation,
            which helps to avoid namespace collisions.
    
            @param	metric	Metric name
            @param	value	Any primitive value/object containing the metric details
            @throws	ArgumentError	If metric uses reserved namespaces like flash native
            namespace (for example, if the metric name starts with '.')
        **/
        static sendMetric(metric, value) { }
        /**
            Requests a custom span metric from Telemetry
    
            Use `Telemetry.spanMarker` to get a marker at the start of to be profiled
            and call `Telemetry.sendSpanMetric` at the end of with the marker.
            Telemetry sends the name, starting marker, and duration of the plus the
            optional value as per the Telemetry protocol.
    
            The guideline for custom metric namespaces is to follow reverse DNS notation, which
            helps to avoid namespace collisions.
    
            Span metrics for durations less than a specified threshold, which could be
            controlled from the Telemetry Server using Telemetry Protocol, would be ignored by
            Telemetry (will not be sent to Telemetry Server).
    
            @param	metric	Metric name
            @param	startSpanMarker	Start marker.
            @param	value	Optional parameter. Any primitive value/object to be sent along with
            name, marker and duration
            @throws	ArgumentError	If metric uses reserved namespaces like flash native
            namespace (i.e. if metric name starts with '.')
        **/
        static sendSpanMetric(metric, startSpanMarker, value = null) { }
        /**
            @param	commandName
            @returns
        **/
        static unregisterCommandHandler(commandName) {
            return false;
        }
        static __advanceFrame() {
        }
        static __endTiming(name) {
        }
        static __initialize() {
        }
        static __rewindStack(stack) {
        }
        static __startTiming(name) {
        }
        static __unwindStack() {
            return "";
        }
        // Get & Set Methods
        /**
            Indicates whether Telemetry is connected to a server
        **/
        static get connected() {
            return false;
        }
    }
    /**
        Returns a marker for use with `Telemetry.sendSpanMetric`
    **/
    Telemetry.spanMarker = 0.0;
    return Telemetry;
})();

/**
    The Accelerometer class dispatches events based on activity detected by the
    device's motion sensor. This data represents the device's location or
    movement along a 3-dimensional axis. When the device moves, the sensor
    detects this movement and returns acceleration data. The Accelerometer
    class provides methods to query whether or not accelerometer is supported,
    and also to set the rate at which acceleration events are dispatched.

    **Note:** Use the `Accelerometer.isSupported` property to
    test the runtime environment for the ability to use this feature. While the
    Accelerometer class and its members are accessible to the Runtime Versions
    listed for each API entry, the current environment for the runtime
    determines the availability of this feature. For example, you can compile
    code using the Accelerometer class properties for Flash Player 10.1, but
    you need to use the `Accelerometer.isSupported` property to test
    for the availability of the Accelerometer feature in the current deployment
    environment for the Flash Player runtime. If
    `Accelerometer.isSupported` is `true` at runtime,
    then Accelerometer support currently exists.

    _AIR profile support:_ This feature is supported only on mobile
    devices. It is not supported on desktop or AIR for TV devices. See
    [AIR Profile Support](http://help.adobe.com/en_US/air/build/WS144092a96ffef7cc16ddeea2126bb46b82f-8000.html)
    for more information regarding API support across
    multiple profiles.

    @event status Dispatched when an accelerometer changes its status.

                  **Note:** On some devices, the accelerometer is always
                  available. On such devices, an Accelerometer object never
                  dispatches a `status` event.
    @event update The `update` event is dispatched in response to
                  updates from the accelerometer sensor. The event is
                  dispatched in the following circumstances:



                   * When a new listener is attached through
                  `addEventListener()`, this event is delivered once
                  to all the registered listeners for providing the current
                  value of the accelerometer.
                   * Whenever accelerometer updates are obtained from the
                  platform at device determined intervals.
                   * Whenever the application misses a change in the
                  accelerometer(for example, the runtime is resuming after
                  being idle).
**/
let Accelerometer = /** @class */ (() => {
    class Accelerometer extends EventDispatcher {
        /**
            Creates a new Accelerometer instance.
        **/
        constructor() {
            super();
            Accelerometer.initialize();
            this.__interval = 0;
            this.__muted = false;
            this.__timerID = 0;
            this.setRequestedUpdateInterval(Accelerometer.defaultInterval);
        }
        addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false) {
            super.addEventListener(type, listener, useCapture, priority, useWeakReference);
            this.update();
        }
        static initialize() {
            if (!Accelerometer.initialized) {
                // AccelerometerBackend.initialize();
                Accelerometer.initialized = true;
            }
        }
        /**
            The `setRequestedUpdateInterval` method is used to set the
            desired time interval for updates. The time interval is measured in
            milliseconds. The update interval is only used as a hint to conserve the
            battery power. The actual time between acceleration updates may be greater
            or lesser than this value. Any change in the update interval affects all
            registered listeners. You can use the Accelerometer class without calling
            the `setRequestedUpdateInterval()` method. In this case, the
            application receives updates based on the device's default interval.
    
            @param interval The requested update interval. If `interval` is
                            set to 0, then the minimum supported update interval is
                            used.
            @throws ArgumentError The specified `interval` is less than
                                  zero.
        **/
        setRequestedUpdateInterval(interval) {
            this.__interval = interval;
            if (this.__interval < 0) {
                throw new ArgumentError();
            }
            else if (this.__interval == 0) {
                this.__interval = Accelerometer.defaultInterval;
            }
            if (this.__timerID != 0) {
                clearInterval(this.__timerID);
                this.__timerID = 0;
            }
            if (Accelerometer.supported && !this.muted) {
                this.__timerID = window.setInterval(this.update, this.__interval);
            }
        }
        update() {
            var event = new AccelerometerEvent(AccelerometerEvent.UPDATE);
            event.timestamp = Lib$1.getTimer();
            event.accelerationX = Accelerometer.currentX;
            event.accelerationY = Accelerometer.currentY;
            event.accelerationZ = Accelerometer.currentZ;
            this.dispatchEvent(event);
        }
        // Getters & Setters
        /**
            The `isSupported` property is set to `true` if the
            accelerometer sensor is available on the device, otherwise it is set to
            `false`.
        **/
        static get isSupported() {
            Accelerometer.initialize();
            return Accelerometer.supported;
        }
        /**
            Specifies whether the user has denied access to the accelerometer
            (`true`) or allowed access(`false`). When this
            value changes, a `status` event is dispatched.
        **/
        get muted() {
            return this.__muted;
        }
        set muted(value) {
            this.__muted = value;
            this.setRequestedUpdateInterval(this.__interval);
        }
    }
    Accelerometer.currentX = 0.0;
    Accelerometer.currentY = 1.0;
    Accelerometer.currentZ = 0.0;
    Accelerometer.defaultInterval = 34;
    Accelerometer.initialized = false;
    Accelerometer.supported = false;
    return Accelerometer;
})();

/**
        The TouchscreenType class is an enumeration class that provides values for
        the different types of touch screens.
        Use the values defined by the TouchscreenType class with the
        `Capabilities.touchscreenType` property.
    **/
var TouchscreenType;
(function (TouchscreenType) {
    /**
        A touchscreen designed to respond to finger touches.
    **/
    TouchscreenType["FINGER"] = "finger";
    /**
        The computer or device does not have a supported touchscreen.
    **/
    TouchscreenType["NONE"] = "none";
    /**
        A touchscreen designed for use with a stylus.
    **/
    TouchscreenType["STYLUS"] = "stylus";
})(TouchscreenType || (TouchscreenType = {}));
var TouchscreenType$1 = TouchscreenType;

/**
    The Capabilities class provides properties that describe the system and
    runtime that are hosting the application. For example, a mobile phone's
    screen might be 100 square pixels, black and white, whereas a PC screen
    might be 1000 square pixels, color. By using the Capabilities class to
    determine what capabilities the client has, you can provide appropriate
    content to as many users as possible. When you know the device's
    capabilities, you can tell the server to send the appropriate SWF files or
    tell the SWF file to alter its presentation.
    However, some capabilities of Adobe AIR are not listed as properties in
    the Capabilities class. They are properties of other classes:

    | Property | Description |
    | --- | --- |
    | `NativeApplication.supportsDockIcon` | Whether the operating system supports application doc icons. |
    | `NativeApplication.supportsMenu` | Whether the operating system supports a global application menu bar. |
    | `NativeApplication.supportsSystemTrayIcon` | Whether the operating system supports system tray icons. |
    | `NativeWindow.supportsMenu` | Whether the operating system supports window menus. |
    | `NativeWindow.supportsTransparency` | Whether the operating system supports transparent windows. |

    Do _not_ use `Capabilities.os` or `Capabilities.manufacturer` to determine
    a capability based on the operating system. Basing a capability on the
    operating system is a bad idea, since it can lead to problems if an
    application does not consider all potential target operating systems.
    Instead, use the property corresponding to the capability for which you
    are testing.

    You can send capabilities information, which is stored in the
    `Capabilities.serverString` property as a URL-encoded string, using the
    `GET` or `POST` HTTP method. The following example shows a server string
    for a computer that has MP3 support and 1600 x 1200 pixel resolution and
    that is running Windows XP with an input method editor (IME) installed:
    <pre
    xml:space="preserve">A=t&SA=t&SV=t&EV=t&MP3=t&AE=t&VE=t&ACC=f&PR=t&SP=t&
    SB=f&DEB=t&V=WIN%209%2C0%2C0%2C0&M=Adobe%20Windows&
    R=1600x1200&DP=72&COL=color&AR=1.0&OS=Windows%20XP&
    L=en&PT=External&AVD=f&LFD=f&WD=f&IME=t</pre>
    The following table lists the properties of the Capabilities class and
    corresponding server strings: <adobetable><tgroup
    <row><entry align="left">Capabilities class
    property</entry><entry align="left">Server
    string |
        |`avHardwareDisable` | `AVD` |
        |`hasAccessibility` | `ACC` |
        |`hasAudio` | `A` |
        |`hasAudioEncoder` | `AE` |
        |`hasEmbeddedVideo` | `EV` |
        |`hasIME` | `IME` |
        |`hasMP3` | `MP3` |
        |`hasPrinting` | `PR` |
        |`hasScreenBroadcast` | `SB` |
        |`hasScreenPlayback` | `SP` |
        |`hasStreamingAudio` | `SA` |
        |`hasStreamingVideo` | `SV` |
        |`hasTLS` | `TLS` |
        |`hasVideoEncoder` | `VE` |
        |`isDebugger` | `DEB` |
        |`language` | `L` |
        |`localFileReadDisable` | `LFD` |
        |`manufacturer` | `M` |
        |`maxLevelIDC` | `ML` |
        |`os` | `OS` |
        |`pixelAspectRatio` | `AR` |
        |`playerType` | `PT` |
        |`screenColor` | `COL` |
        |`screenDPI` | `DP` |
        |`screenResolutionX` | `R` |
        |`screenResolutionY` | `R` |
        |`version` | `V` |


    There is also a `WD` server string that specifies whether windowless mode
    is disabled. Windowless mode can be disabled in Flash Player due to
    incompatibility with the web browser or to a user setting in the mms.cfg
    file. There is no corresponding Capabilities property.

    All properties of the Capabilities class are read-only.
**/
let Capabilities = /** @class */ (() => {
    class Capabilities {
        /**
            Specifies whether the system supports multichannel audio of a specific type. The
            class flash.media.AudioDecoder enumerates the possible types.
    
            _AIR profile support:_ Multichannel audio is supported only on AIR for TV devices.
            On all other devices, this method always returns `false`. See AIR Profile Support
            for more information regarding API support across multiple profiles.
    
            **Note:** When using one of the DTS audio codecs, scenarios exist in which
            `hasMultiChannelAudio()` returns `true` but the DTS audio is not played. For
            example, consider a Blu-ray player with an S/PDIF output, connected to an old
            amplifier. The old amplifier does not support DTS, but S/PDIF has no protocol to
            notify the Blu-ray player. If the Blu-ray player sends the DTS stream to the old
            amplifier, the user hears nothing. Therefore, as a best practice when using DTS,
            provide a user interface so that the user can indicate if no sound is playing.
            Then, your application can revert to a different codec.
    
            The following table shows the server string for each multichannel audio type:
    
            | Multichannel audio type | Server string |
            | --- | --- |
            | AudioDecoder.DOLBY_DIGITAL | DD |
            | AudioDecoder.DOLBY_DIGITAL_PLUS | DDP |
            | AudioDecoder.DTS | DTS |
            | AudioDecoder.DTS_EXPRESS | DTE |
            | AudioDecoder.DTS_HD_HIGH_RESOLUTION_AUDIO | DTH |
            | AudioDecoder.DTS_HD_MASTER_AUDIO | DTM |
    
            @param	type	A String value representing a multichannel audio type. The valid
            values are the constants defined in flash.media.AudioDecoder.
            @returns	The Boolean value `true` if the system supports the multichannel audio
            type passed in the `type` parameter. Otherwise, the return value is `false`.
    
        **/
        static hasMultiChannelAudio(type) {
            return false;
        }
        // Getters & Setters
        /**
            Specifies whether access to the user's camera and microphone has been
            administratively prohibited(`true`) or allowed
            (`false`). The server string is `AVD`.
    
            For content in Adobe AIR™, this property applies only to content in
            security sandboxes other than the application security sandbox. Content in
            the application security sandbox can always access the user's camera and
            microphone.
        **/
        static get avHardwareDisable() {
            return Capabilities.__avHardwareDisable;
        }
        /**
            Specifies the current CPU architecture. The `cpuArchitecture`
            property can return the following strings: "`PowerPC`",
            "`x86`", "`SPARC`", and "`ARM`". The
            server string is `ARCH`.
        **/
        static get cpuArchitecture() {
            // TODO: Check architecture
            return "x86";
        }
        /**
            Specifies whether the system supports(`true`) or does not
            support(`false`) communication with accessibility aids. The
            server string is `ACC`.
        **/
        static get hasAccessibility() {
            return Capabilities.__hasAccessibility;
        }
        /**
            Specifies whether the system has audio capabilities. This property is
            always `true`. The server string is `A`.
        **/
        static get hasAudio() {
            return Capabilities.__hasAudio;
        }
        /**
            Specifies whether the system can(`true`) or cannot
            (`false`) encode an audio stream, such as that coming from a
            microphone. The server string is `AE`.
        **/
        static get hasAudioEncoder() {
            return Capabilities.__hasAudioEncoder;
        }
        /**
            Specifies whether the system supports(`true`) or does not
            support(`false`) embedded video. The server string is
            `EV`.
        **/
        static get hasEmbeddedVideo() {
            return Capabilities.__hasEmbeddedVideo;
        }
        /**
            Specifies whether the system does(`true`) or does not
            (`false`) have an input method editor(IME) installed. The
            server string is `IME`.
        **/
        static get hasIME() {
            return Capabilities.__hasIME;
        }
        /**
            Specifies whether the system does(`true`) or does not
            (`false`) have an MP3 decoder. The server string is
            `MP3`.
        **/
        static get hasMP3() {
            return Capabilities.__hasMP3;
        }
        /**
            Specifies whether the system does(`true`) or does not
            (`false`) support printing. The server string is
            `PR`.
        **/
        static get hasPrinting() {
            return Capabilities.__hasPrinting;
        }
        /**
            Specifies whether the system does(`true`) or does not
            (`false`) support the development of screen broadcast
            applications to be run through Flash Media Server. The server string is
            `SB`.
        **/
        static get hasScreenBroadcast() {
            return Capabilities.__hasScreenBroadcast;
        }
        /**
            Specifies whether the system does(`true`) or does not
            (`false`) support the playback of screen broadcast applications
            that are being run through Flash Media Server. The server string is
            `SP`.
        **/
        static get hasScreenPlayback() {
            return Capabilities.__hasScreenPlayback;
        }
        /**
            Specifies whether the system can(`true`) or cannot
            (`false`) play streaming audio. The server string is
            `SA`.
        **/
        static get hasStreamingAudio() {
            return Capabilities.__hasStreamingAudio;
        }
        /**
            Specifies whether the system can(`true`) or cannot
            (`false`) play streaming video. The server string is
            `SV`.
        **/
        static get hasStreamingVideo() {
            return Capabilities.__hasStreamingVideo;
        }
        /**
            Specifies whether the system supports native SSL sockets through
            NetConnection(`true`) or does not(`false`). The
            server string is `TLS`.
        **/
        static get hasTLS() {
            return Capabilities.__hasTLS;
        }
        /**
            Specifies whether the system can(`true`) or cannot
            (`false`) encode a video stream, such as that coming from a web
            camera. The server string is `VE`.
        **/
        static get hasVideoEncoder() {
            return Capabilities.__hasVideoEncoder;
        }
        /**
            Specifies whether the system is a special debugging version
            (`true`) or an officially released version
            (`false`). The server string is `DEB`. This property
            is set to `true` when running in the debug version of Flash
            Player or the AIR Debug Launcher(ADL).
        **/
        static get isDebugger() {
            return Capabilities.__isDebugger;
        }
        /**
            Specifies whether the Flash runtime is embedded in a PDF file that is open
            in Acrobat 9.0 or higher(`true`) or not(`false`).
        **/
        static get isEmbeddedInAcrobat() {
            return Capabilities.__isEmbeddedInAcrobat;
        }
        /**
            Specifies the language code of the system on which the content is
            running. The language is specified as a lowercase two-letter language
            code from ISO 639-1. For Chinese, an additional uppercase two-letter
            country code from ISO 3166 distinguishes between Simplified and
            Traditional Chinese. The languages codes are based on the English
            names of the language: for example, `hu` specifies Hungarian.
            On English systems, this property returns only the language code
            (`en`), not the country code. On Microsoft Windows systems, this
            property returns the user interface (UI) language, which refers to the
            language used for all menus, dialog boxes, error messages, and help
            files. The following table lists the possible values:
    
            | Language | Value |
            | --- | --- |
            | Czech | `cs` |
            | Danish | `da` |
            | Dutch | `nl` |
            | English | `en` |
            | Finnish | `fi` |
            | French | `fr` |
            | German | `de` |
            | Hungarian | `hu` |
            | Italian | `it` |
            | Japanese | `ja` |
            | Korean | `ko` |
            | Norwegian | `no` |
            | Other/unknown | `xu` |
            | Polish | `pl` |
            | Portuguese | `pt` |
            | Russian | `ru` |
            | Simplified Chinese | `zh-CN` |
            | Spanish | `es` |
            | Swedish | `sv` |
            | Traditional Chinese | `zh-TW` |
            | Turkish | `tr` |
    
            _Note:_ The value of `Capabilities.language` property is limited to
            the possible values on this list. Because of this limitation, Adobe
            AIR applications should use the first element in the
            `Capabilities.languages` array to determine the primary user interface
            language for the system.
    
            The server string is `L`.
        **/
        static get language() {
            // return CapabilitiesBackend.getLanguage();
            return null;
        }
        /**
            Specifies whether read access to the user's hard disk has been
            administratively prohibited(`true`) or allowed
            (`false`). For content in Adobe AIR, this property applies only
            to content in security sandboxes other than the application security
            sandbox.(Content in the application security sandbox can always read from
            the file system.) If this property is `true`, Flash Player
            cannot read files(including the first file that Flash Player launches
            with) from the user's hard disk. If this property is `true`,
            AIR content outside of the application security sandbox cannot read files
            from the user's hard disk. For example, attempts to read a file on the
            user's hard disk using load methods will fail if this property is set to
            `true`.
    
            Reading runtime shared libraries is also blocked if this property is
            set to `true`, but reading local shared objects is allowed
            without regard to the value of this property.
    
            The server string is `LFD`.
        **/
        static get localFileReadDisable() {
            return Capabilities.__localFileReadDisable;
        }
        /**
            Specifies the manufacturer of the running version of Flash Player or the
            AIR runtime, in the format `"Adobe`
            `_OSName_"`. The value for `_OSName_`
            could be `"Windows"`, `"Macintosh"`,
            `"Linux"`, or another operating system name. The server string
            is `M`.
    
            Do _not_ use `Capabilities.manufacturer` to determine a
            capability based on the operating system if a more specific capability
            property exists. Basing a capability on the operating system is a bad
            idea, since it can lead to problems if an application does not consider
            all potential target operating systems. Instead, use the property
            corresponding to the capability for which you are testing. For more
            information, see the Capabilities class description.
        **/
        static get manufacturer() {
            // return CapabilitiesBackend.getManufacturer();
            return null;
        }
        /**
            Retrieves the highest H.264 Level IDC that the client hardware supports.
            Media run at this level are guaranteed to run; however, media run at the
            highest level might not run with the highest quality. This property is
            useful for servers trying to target a client's capabilities. Using this
            property, a server can determine the level of video to send to the client.
    
    
            The server string is `ML`.
        **/
        static get maxLevelIDC() {
            return Capabilities.__maxLevelIDC;
        }
        /**
            Specifies the current operating system. The `os` property can return
            the following strings:
    
            |Operating system | Value |
            | --- | --- |
            | Windows 7 | `"Windows 7"` |
            | Windows Vista | `"Windows Vista"` |
            | Windows Server 2008 R2 | `"Windows Server 2008 R2"` |
            | Windows Server 2008 | `"Windows Server 2008"` |
            | Windows Home Server | `"Windows Home Server"` |
            | Windows Server 2003 R2 | `"Windows Server 2003 R2"` |
            | Windows Server 2003 | `"Windows Server 2003"` |
            | Windows XP 64 | `"Windows Server XP 64"` |
            | Windows XP | `"Windows XP"` |
            | Windows 98 | `"Windows 98"` |
            | Windows 95 | `"Windows 95"` |
            | Windows NT | `"Windows NT"` |
            | Windows 2000 | `"Windows 2000"` |
            | Windows ME | `"Windows ME"` |
            | Windows CE | `"Windows CE"` |
            | Windows SmartPhone | `"Windows SmartPhone"` |
            | Windows PocketPC | `"Windows PocketPC"` |
            | Windows CEPC | `"Windows CEPC"` |
            | Windows Mobile | `"Windows Mobile"` |
            | Mac OS | `"Mac OS X.Y.Z"` (where X.Y.Z is the version number, for example: `"Mac OS 10.5.2"`) |
            | Linux | `"Linux"` (Flash Player attaches the Linux version, such as `"Linux 2.6.15-1.2054_FC5smp"` |
            | iPhone OS 4.1 | `"iPhone3,1"` |
    
            The server string is `OS`.
    
            Do _not_ use `Capabilities.os` to determine a capability based on the
            operating system if a more specific capability property exists. Basing
            a capability on the operating system is a bad idea, since it can lead
            to problems if an application does not consider all potential target
            operating systems. Instead, use the property corresponding to the
            capability for which you are testing. For more information, see the
            Capabilities class description.
        **/
        static get os() {
            // return CapabilitiesBackend.getOS();
            return null;
        }
        /**
            Specifies the pixel aspect ratio of the screen. The server string is
            `AR`.
        **/
        static get pixelAspectRatio() {
            return 1;
        }
        /**
            Specifies the type of runtime environment. This property can have one of
            the following values:
    
            * `"ActiveX"` for the Flash Player ActiveX control used by
            Microsoft Internet Explorer
            * `"Desktop"` for the Adobe AIR runtime(except for SWF
            content loaded by an HTML page, which has
            `Capabilities.playerType` set to `"PlugIn"`)
            * `"External"` for the external Flash Player<ph
            outputclass="flashonly"> or in test mode
            * `"PlugIn"` for the Flash Player browser plug-in(and for
            SWF content loaded by an HTML page in an AIR application)
            * `"StandAlone"` for the stand-alone Flash Player
    
            The server string is `PT`.
        **/
        static get playerType() {
            return Capabilities.__playerType;
        }
        /**
            Specifies the screen color. This property can have the value
            `"color"`, `"gray"`(for grayscale), or
            `"bw"`(for black and white). The server string is
            `COL`.
        **/
        static get screenColor() {
            return Capabilities.__screenColor;
        }
        /**
            Specifies the dots-per-inch(dpi) resolution of the screen, in pixels. The
            server string is `DP`.
        **/
        static get screenDPI() {
            // return CapabilitiesBackend.getScreenDPI();
            return 0;
        }
        /**
            Specifies the maximum horizontal resolution of the screen. The server
            string is `R`(which returns both the width and height of the
            screen). This property does not update with a user's screen resolution and
            instead only indicates the resolution at the time Flash Player or an Adobe
            AIR application started. Also, the value only specifies the primary
            screen.
        **/
        static get screenResolutionX() {
            // return CapabilitiesBackend.getScreenResolutionX();
            return 0;
        }
        /**
            Specifies the maximum vertical resolution of the screen. The server string
            is `R`(which returns both the width and height of the screen).
            This property does not update with a user's screen resolution and instead
            only indicates the resolution at the time Flash Player or an Adobe AIR
            application started. Also, the value only specifies the primary screen.
        **/
        static get screenResolutionY() {
            // return CapabilitiesBackend.getScreenResolutionY();
            return 0;
        }
        /**
            A URL-encoded string that specifies values for each Capabilities property.
    
    
            The following example shows a URL-encoded string:
            `A=t&SA=t&SV=t&EV=t&MP3=t&AE=t&VE=t&ACC=f&PR=t&SP=t&
            SB=f&DEB=t&V=WIN%208%2C5%2C0%2C208&M=Adobe%20Windows&
            R=1600x1200&DP=72&COL=color&AR=1.0&OS=Windows%20XP&
            L=en&PT=External&AVD=f&LFD=f&WD=f`
        **/
        static get serverString() {
            return Capabilities.__serverString;
        }
        /**
            Specifies whether the system supports running 32-bit processes. The server
            string is `PR32`.
        **/
        static get supports32BitProcesses() {
            return Capabilities.__supports32BitProcesses;
        }
        /**
            Specifies whether the system supports running 64-bit processes. The server
            string is `PR64`.
        **/
        static get supports64BitProcesses() {
            return Capabilities.__supports64BitProcesses;
        }
        /**
            Specifies the type of touchscreen supported, if any. Values are defined in
            the openfl.system.TouchscreenType class.
        **/
        static get touchscreenType() {
            return Capabilities.__touchscreenType;
        }
        /**
            Specifies the Flash Player or Adobe<sup>®</sup> AIR<sup>®</sup> platform
            and version information. The format of the version number is: _platform
            majorVersion,minorVersion,buildNumber,internalBuildNumber_. Possible
            values for _platform_ are `"WIN"`, ` `"MAC"`,
            `"LNX"`, and `"AND"`. Here are some examples of
            version information: `WIN 9,0,0,0 // Flash
            Player 9 for Windows MAC 7,0,25,0 // Flash Player 7 for Macintosh LNX
            9,0,115,0 // Flash Player 9 for Linux AND 10,2,150,0 // Flash Player 10
            for Android`
    
            Do _not_ use `Capabilities.version` to determine a
            capability based on the operating system if a more specific capability
            property exists. Basing a capability on the operating system is a bad
            idea, since it can lead to problems if an application does not consider
            all potential target operating systems. Instead, use the property
            corresponding to the capability for which you are testing. For more
            information, see the Capabilities class description.
    
            The server string is `V`.
        **/
        static get version() {
            var value = "WEB";
            // TODO:
            // if (Compiler.getDefine("openfl") != null)
            // {
            // 	value += " " + StringTools.replace(Compiler.getDefine("openfl"), ".", ",") + ",0";
            // }
            return value;
        }
    }
    Capabilities.__avHardwareDisable = true;
    Capabilities.__hasAccessibility = false;
    Capabilities.__hasAudio = true;
    Capabilities.__hasAudioEncoder = false;
    Capabilities.__hasEmbeddedVideo = false;
    Capabilities.__hasIME = false;
    Capabilities.__hasMP3 = false;
    Capabilities.__hasPrinting = true;
    Capabilities.__hasScreenBroadcast = false;
    Capabilities.__hasScreenPlayback = false;
    Capabilities.__hasStreamingAudio = false;
    Capabilities.__hasStreamingVideo = false;
    Capabilities.__hasTLS = true;
    Capabilities.__hasVideoEncoder = true;
    Capabilities.__isDebugger = false;
    Capabilities.__isEmbeddedInAcrobat = false;
    Capabilities.__localFileReadDisable = true;
    Capabilities.__maxLevelIDC = 0;
    Capabilities.__playerType = "PlugIn";
    Capabilities.__screenColor = "color";
    Capabilities.__serverString = "";
    Capabilities.__supports32BitProcesses = false;
    Capabilities.__supports64BitProcesses = false;
    Capabilities.__touchscreenType = TouchscreenType$1.FINGER;
    return Capabilities;
})();

/**
    The LoaderContext class provides options for loading SWF files and other
    media by using the Loader class. The LoaderContext class is used as the
    `context` parameter in the `load()` and `loadBytes()` methods of the
    Loader class.
    When loading SWF files with the `Loader.load()` method, you have two
    decisions to make : numbero which security domain the loaded SWF file should
    be placed, and into which application domain within that security domain?
    For more details on these choices, see the `applicationDomain` and
    `securityDomain` properties.

    When loading a SWF file with the `Loader.loadBytes()` method, you have the
    same application domain choice to make as for `Loader.load()`, but it's
    not necessary to specify a security domain, because `Loader.loadBytes()`
    always places its loaded SWF file into the security domain of the loading
    SWF file.

    When loading images (JPEG, GIF, or PNG) instead of SWF files, there is no
    need to specify a SecurityDomain or an application domain, because those
    concepts are meaningful only for SWF files. Instead, you have only one
    decision to make: do you need programmatic access to the pixels of the
    loaded image? If so, see the `checkPolicyFile` property. If you want to
    apply deblocking when loading an image, use the JPEGLoaderContext class
    instead of the LoaderContext class.
**/
class LoaderContext {
    /**
        Creates a new LoaderContext object, with the specified settings. For
        complete details on these settings, see the descriptions of the
        properties of this class.

        @param checkPolicyFile   Specifies whether a check should be made for
                                 the existence of a URL policy file before
                                 loading the object.
        @param applicationDomain Specifies the ApplicationDomain object to use
                                 for a Loader object.
        @param securityDomain    Specifies the SecurityDomain object to use
                                 for a Loader object.
                                 _Note:_ Content in the air application
                                 security sandbox cannot load content from
                                 other sandboxes into its SecurityDomain.
    **/
    constructor(checkPolicyFile = false, applicationDomain = null, securityDomain = null) {
        this.checkPolicyFile = checkPolicyFile;
        this.securityDomain = securityDomain;
        this.applicationDomain = applicationDomain;
        this.allowCodeImport = true;
        this.allowLoadBytesCodeExecution = true;
    }
}

/**
    The Security class lets you specify how content in different domains can
    communicate with each other.
**/
let Security = /** @class */ (() => {
    class Security {
        /**
            Lets SWF files in the identified domains access objects and variables
            in the SWF file that contains the `allowDomain()` call.
            _Note:_ Calling this method from code in the AIR application sandbox
            throws a SecurityError exception. Content outside of the application
            security domain cannot directly cross-script content in the
            application sandbox. However, content outside of the application
            sandbox can communicate with content in the application security
            sandbox using a sandbox bridge.
    
            If two SWF files are served from the same domain נfor example,
            http://mysite.com/swfA.swf and http://mysite.com/swfB.swf נthen
            swfA.swf can examine and modify variables, objects, properties,
            methods, and so on in swfB.swf, and swfB.swf can do the same for
            swfA.swf. This is called _cross-movie scripting_ or _cross-scripting_.
    
            If two SWF files are served from different domains נfor example,
            http://siteA.com/swfA.swf and http://siteB.com/siteB.swf נthen, by
            default, Flash Player does not allow swfA.swf to script swfB.swf, nor
            swfB.swf to script swfA.swf. A SWF file gives permission to SWF files
            from other domains by calling `Security.allowDomain()`. This is called
            _cross-domain scripting_. By calling
            `Security.allowDomain("siteA.com")`, siteB.swf gives siteA.swf
            permission to script it.
    
            In any cross-domain situation, it is important to be clear about the
            two parties involved. For the purposes of this discussion, the side
            performing the cross-scripting is called the _accessing party_
            (usually the accessing SWF), and the other side is called _the party
            being accessed_ (usually the SWF file being accessed). When siteA.swf
            scripts siteB.swf, siteA.swf is the accessing party, and siteB.swf is
            the party being accessed.
    
            ![Cross-domain diagram](/images/crossScript_load.jpg)
    
            Cross-domain permissions that are established with `allowDomain()` are
            asymmetrical. In the previous example, siteA.swf can script siteB.swf,
            but siteB.swf cannot script siteA.swf, because siteA.swf has not
            called `allowDomain()` to give SWF files at siteB.com permission to
            script it. You can set up symmetrical permissions by having both SWF
            files call `allowDomain()`.
    
            In addition to protecting SWF files from cross-domain scripting
            originated by other SWF files, Flash Player protects SWF files from
            cross-domain scripting originated by HTML files. HTML-to-SWF scripting
            can occur with older browser functions such as `SetVariable` or
            callbacks established through `ExternalInterface.addCallback()`. When
            HTML-to-SWF scripting crosses domains, the SWF file being accessed
            must call `allowDomain()`, just as when the accessing party is a SWF
            file, or the operation will fail.
    
            Specifying an IP address as a parameter to `allowDomain()` does not
            permit access by all parties that originate at the specified IP
            address. Instead, it permits access only by a party that contains the
            specified IP address it its URL, rather than a domain name that maps
            to that IP address.
    
            **Version-specific differences**
    
            Flash Player's cross-domain security rules have evolved from version
            to version. The following table summarizes the differences.
    
            | Latest SWF version involved in cross-scripting | `allowDomain()` needed? | `allowInsecureDomain()` needed? | Which SWF file must call `allowDomain()` or `allowInsecureDomain()`? | What can be specified in `allowDomain()` or `allowInsecureDomain()`? |
            | --- | --- | --- | --- | --- |
            | 5 or earlier | No | No | N/A | N/A |
            | 6 | Yes, if superdomains don't match | No | The SWF file being accessed, or any SWF file with the same superdomain as the SWF file being accessed | <ul><li>Text-based domain (mysite.com)</li><li>IP address (192.168.1.1)</li></ul> |
            | 7 | Yes, if domains don't match exactly | Yes, if performing HTTP-to-HTTPS access (even if domains match exactly) | The SWF file being accessed, or any SWF file with exactly the same domain as the SWF file being accessed | <ul><li>Text-based domain (mysite.com)</li><li>IP address (192.168.1.1)</li></ul> |
            | 8 or later | Yes, if domains don't match exactly | Yes, if performing HTTP-to-HTTPS access (even if domains match exactly) | SWF file being accessed | <ul><li>Text-based domain (mysite.com)</li><li>IP address (192.168.1.1)</li><li>Wildcard (*)</li></ul> |
    
            The versions that control the behavior of Flash Player are _SWF
            versions_ (the published version of a SWF file), not the version of
            Flash Player itself. For example, when Flash Player 8 is playing a SWF
            file published for version 7, it applies behavior that is consistent
            with version 7. This practice ensures that player upgrades do not
            change the behavior of `Security.allowDomain()` in deployed SWF files.
    
            The version column in the previous table shows the latest SWF version
            involved in a cross-scripting operation. Flash Player determines its
            behavior according to either the accessing SWF file's version or the
            version of the SWF file that is being accessed, whichever is later.
    
            The following paragraphs provide more detail about Flash Player
            security changes involving `Security.allowDomain()`.
    
            **Version 5**. There are no cross-domain scripting restrictions.
    
            **Version 6**. Cross-domain scripting security is introduced. By
            default, Flash Player forbids cross-domain scripting;
            `Security.allowDomain()` can permit it. To determine whether two files
            are in the same domain, Flash Player uses each file's superdomain,
            which is the exact host name from the file's URL, minus the first
            segment, down to a minimum of two segments. For example, the
            superdomain of www.mysite.com is mysite.com. SWF files from
            www.mysite.com and store.mysite.com to script each other without a
            call to `Security.allowDomain()`.
    
            **Version 7**. Superdomain matching is changed to exact domain
            matching. Two files are permitted to script each other only if the
            host names in their URLs are identical; otherwise, a call to
            `Security.allowDomain()` is required. By default, files loaded from
            non-HTTPS URLs are no longer permitted to script files loaded from
            HTTPS URLs, even if the files are loaded from exactly the same domain.
            This restriction helps protect HTTPS files, because a non-HTTPS file
            is vulnerable to modification during download, and a maliciously
            modified non-HTTPS file could corrupt an HTTPS file, which is
            otherwise immune to such tampering. `Security.allowInsecureDomain()`
            is introduced to allow HTTPS SWF files that are being accessed to
            voluntarily disable this restriction, but the use of
            `Security.allowInsecureDomain()` is discouraged.
    
            **Version 8**. There are two major areas of change:
    
            * Calling `Security.allowDomain()` now permits cross-scripting
            operations only if the SWF file being accessed is the SWF file that
            called `Security.allowDomain()`. In other words, a SWF file that calls
            `Security.allowDomain()` now permits access only to itself. In
            previous versions, calling `Security.allowDomain()` permitted
            cross-scripting operations where the SWF file being accessed could be
            any SWF file in the same domain as the SWF file that called
            `Security.allowDomain()`. Calling `Security.allowDomain()` previously
            opened up the entire domain of the calling SWF file.
            * Support has been added for wildcard values with
            `Security.allowDomain("*")` and `Security.allowInsecureDomain("*")`.
            The wildcard (*) value permits cross-scripting operations where the
            accessing file is any file at all, loaded from anywhere. Think of the
            wildcard as a global permission. Wildcard permissions are required to
            enable certain kinds of operations under the local file security
            rules. Specifically, for a local SWF file with network-access
            permissions to script a SWF file on the Internet, the Internet SWF
            file being accessed must call `Security.allowDomain("*")`, reflecting
            that the origin of a local SWF file is unknown. (If the Internet SWF
            file is loaded from an HTTPS URL, the Internet SWF file must instead
            call `Security.allowInsecureDomain("*")`.)
    
            Occasionally, you may encounter the following situation: You load a
            child SWF file from a different domain and want to allow the child SWF
            file to script the parent SWF file, but you don't know the final
            domain of the child SWF file. This can happen, for example, when you
            use load-balancing redirects or third-party servers.
    
            In this situation, you can use the `url` property of the URLRequest
            object that you pass to `Loader.load()`. For example, if you load a
            child SWF file into a parent SWF, you can access the
            `contentLoaderInfo` property of the Loader object for the parent SWF:
    
            ```as3
            Security.allowDomain(loader.contentLoaderInfo.url)
            ```
    
            Make sure that you wait until the child SWF file begins loading to get
            the correct value of the `url` property. To determine when the child
            SWF has begun loading, use the `progress` event.
    
            The opposite situation can also occur; that is, you might create a
            child SWF file that wants to allow its parent to script it, but
            doesn't know what the domain of its parent will be. In this situation,
            you can access the `loaderInfo` property of the display object that is
            the SWF's root object. In the child SWF, call ` Security.allowDomain(
            this.root.loaderInfo.loaderURL)`. You don't have to wait for the
            parent SWF file to load; the parent will already be loaded by the time
            the child loads.
    
            If you are publishing for Flash Player 8 or later, you can also handle
            these situations by calling `Security.allowDomain("*")`. However,
            this can sometimes be a dangerous shortcut, because it allows the
            calling SWF file to be accessed by any other SWF file from any domain.
            It is usually safer to use the `_url` property.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: <a
            href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
    
            @throws SecurityError Calling this method from code in the AIR
                                  application security sandbox throws a
                                  SecurityError exception. Content outside of the
                                  application security sandbox cannot cross-script
                                  content in the application security sandbox.
        **/
        static allowDomain(...parameters) { }
        /**
            Lets SWF files and HTML files in the identified domains access objects
            and variables in the calling SWF file, which is hosted by means of the
            HTTPS protocol.
            Flash Player provides `allowInsecureDomain()` to maximize flexibility,
            but calling this method is not recommended. Serving a file over HTTPS
            provides several protections for you and your users, and calling
            `allowInsecureDomain` weakens one of those protections.
    
            _Note:_ Calling this method from code in the AIR application sandbox
            throws a SecurityError exception. Content outside of the application
            security domain cannot directly cross-script content in the
            application sandbox. However, content outside of the application
            sandbox can communicate with content in the application security
            sandbox using a sandbox bridge.
    
            This method works in the same way as `Security.allowDomain()`, but it
            also permits operations in which the accessing party is loaded with a
            non-HTTPS protocol, and the party being accessed is loaded with HTTPS.
            In Flash Player 7 and later, non-HTTPS files are not allowed to script
            HTTPS files. The `allowInsecureDomain()` method lifts this restriction
            when the HTTPS SWF file being accessed uses it.
    
            Use `allowInsecureDomain()` only to enable scripting from non-HTTPS
            files to HTTPS files. Use it to enable scripting when the accessing
            non-HTTPS file and the HTTPS file being accessed are served from the
            same domain, for example, if a SWF file at http://mysite.com wants to
            script a SWF file at https://mysite.com. Do not use this method to
            enable scripting between non-HTTPS files, between HTTPS files, or from
            HTTPS files to non-HTTPS files. For those situations, use
            `allowDomain()` instead.
            The following scenario illustrates how `allowInsecureDomain()` can
            compromise security, if it is not used with careful consideration.
            Note that the following information is only one possible scenario,
            designed to help you understand `allowInsecureDomain()` through a
            real-world example of cross-scripting. It does not cover all issues
            with security architecture and should be used for background
            information only. The Flash Player Developer Center contains extensive
            information on Flash Player and security. For more information, see
            the Flash Player Developer Center Topic <a
            href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
    
            Suppose you are building an e-commerce site that consists of two
            components: a catalog, which does not need to be secure, because it
            contains only public information; and a shopping cart/checkout
            component, which must be secure to protect users' financial and
            personal information. Suppose you are considering serving the catalog
            from http://mysite.com/catalog.swf and the cart from
            https://mysite.com/cart.swf. One requirement for your site is that a
            third party should not be able to steal your users' credit card
            numbers by taking advantage of a weakness in your security
            architecture.
    
            Suppose that a middle-party attacker intervenes between your server
            and your users, attempting to steal the credit card numbers that your
            users enter into your shopping cart application. A middle party might,
            for example, be an unscrupulous ISP used by some of your users, or a
            malicious administrator at a user's workplace נanyone who has the
            ability to view or alter network packets transmitted over the public
            Internet between your users and your servers. This situation is not
            uncommon.
    
            If cart.swf uses HTTPS to transmit credit card information to your
            servers, then the middle-party attacker can't directly steal this
            information from network packets, because the HTTPS transmission is
            encrypted. However, the attacker can use a different technique:
            altering the contents of one of your SWF files as it is delivered to
            the user, replacing your SWF file with an altered version that
            transmits the user's information to a different server, owned by the
            attacker.
    
            The HTTPS protocol, among other things, prevents this "modification"
            attack from working, because, in addition to being encrypted, HTTPS
            transmissions are tamper-resistant. If a middle-party attacker alters
            a packet, the receiving side detects the alteration and discards the
            packet. So the attacker in this situation can't alter cart.swf,
            because it is delivered over HTTPS.
    
            However, suppose that you want to allow buttons in catalog.swf, served
            over HTTP, to add items to the shopping cart in cart.swf, served over
            HTTPS. To accomplish this, cart.swf calls `allowInsecureDomain()`,
            which allows catalog.swf to script cart.swf. This action has an
            unintended consequence: Now the attacker can alter catalog.swf as it
            is initially being downloaded by the user, because catalog.swf is
            delivered with HTTP and is not tamper-resistant. The attacker's
            altered catalog.swf can now script cart.swf, because cart.swf contains
            a call to `allowInsecureDomain()`. The altered catalog.swf file can
            use ActionScript to access the variables in cart.swf, thus reading the
            user's credit card information and other sensitive data. The altered
            catalog.swf can then send this data to an attacker's server.
    
            Obviously, this implementation is not desired, but you still want to
            allow cross-scripting between the two SWF files on your site. Here are
            two possible ways to redesign this hypothetical e-commerce site to
            avoid `allowInsecureDomain()`:
    
            * Serve all SWF files in the application over HTTPS. This is by far
            the simplest and most reliable solution. In the scenario described,
            you would serve both catalog.swf and cart.swf over HTTPS. You might
            experience slightly higher bandwidth consumption and server CPU load
            when switching a file such as catalog.swf from HTTP to HTTPS, and your
            users might experience slightly longer application load times. You
            need to experiment with real servers to determine the severity of
            these effects; usually they are no worse than 10-20% each, and
            sometimes they are not present at all. You can usually improve results
            by using HTTPS-accelerating hardware or software on your servers. A
            major benefit of serving all cooperating SWF files over HTTPS is that
            you can use an HTTPS URL as the main URL in the user's browser without
            generating any mixed-content warnings from the browser. Also, the
            browser's padlock icon becomes visible, providing your users with a
            common and trusted indicator of security.
            * Use HTTPS-to-HTTP scripting, rather than HTTP-to-HTTPS scripting. In
            the scenario described, you could store the contents of the user's
            shopping cart in catalog.swf, and have cart.swf manage only the
            checkout process. At checkout time, cart.swf could retrieve the cart
            contents from ActionScript variables in catalog.swf. The restriction
            on HTTP-to-HTTPS scripting is asymmetrical; although an HTTP-delivered
            catalog.swf file cannot safely be allowed to script an HTTPS-delivered
            cart.swf file, an HTTPS cart.swf file can script the HTTP catalog.swf
            file. This approach is more delicate than the all-HTTPS approach; you
            must be careful not to trust any SWF file delivered over HTTP, because
            of its vulnerability to tampering. For example, when cart.swf
            retrieves the ActionScript variable that describes the cart contents,
            the ActionScript code in cart.swf cannot trust that the value of this
            variable is in the format that you expect. You must verify that the
            cart contents do not contain invalid data that might lead cart.swf to
            take an undesired action. You must also accept the risk that a middle
            party, by altering catalog.swf, could supply valid but inaccurate data
            to cart.swf; for example, by placing items in the user's cart. The
            usual checkout process mitigates this risk somewhat by displaying the
            cart contents and total cost for final approval by the user, but the
            risk remains present.
    
            Web browsers have enforced separation between HTTPS and non-HTTPS
            files for years, and the scenario described illustrates one good
            reason for this restriction. Flash Player gives you the ability to
            work around this security restriction when you absolutely must, but be
            sure to consider the consequences carefully before doing so.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: <a
            href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
    
            @throws SecurityError Calling this method from code in the AIR
                                  application security sandbox causes a
                                  SecurityError exception to be thrown. Content
                                  outside of the application security sandbox
                                  cannot cross-script content in the application
                                  security sandbox.
        **/
        static allowInsecureDomain(...parameters) { }
        // /** @hidden */ @:dox(hide) @:require(flash10_1) public static duplicateSandboxBridgeInputArguments (toplevel:Dynamic, args:Array<Dynamic>):Array<Dynamic>;
        // /** @hidden */ @:dox(hide) @:require(flash10_1) public static duplicateSandboxBridgeOutputArgument (toplevel:Dynamic, arg:Dynamic):Dynamic;
        /**
            Looks for a policy file at the location specified by the `url`
            parameter. Adobe AIR and Flash Player use policy files to determine
            whether to permit applications to load data from servers other than
            their own. Note that even though the method name is `
            loadPolicyFile()`, the file isn't actually loaded until a network
            request that requires a policy file is made.
            With `Security.loadPolicyFile()`, Flash Player or AIR can load policy
            files from arbitrary locations, as shown in the following example:
    
            ```as3
            Security.loadPolicyFile("http://www.example.com/sub/dir/pf.xml");
            ```
    
            This causes Flash Player or AIR to attempt to retrieve a policy file
            from the specified URL. Any permissions granted by the policy file at
            that location will apply to all content at the same level or lower in
            the virtual directory hierarchy of the server.
    
            For example, following the previous code, these lines do not throw an
            exception:
    
            ```haxe
            import openfl.net.*;
    
            var request = new URLRequest("http://www.example.com/sub/dir/vars.txt");
            var loader = new URLLoader();
            loader.load(request);
    
            var loader2 = new URLLoader();
            var request2 = new URLRequest("http://www.example.com/sub/dir/deep/vars2.txt");
            loader2.load(request2);
            ```
    
            However, the following code does throw a security exception:
    
            ```haxe
            import openfl.net.*;
    
            var request3 = new URLRequest("http://www.example.com/elsewhere/vars3.txt");
            var loader3 = new URLLoader();
            loader3.load(request3);
            ```
    
            You can use `loadPolicyFile()` to load any number of policy files.
            When considering a request that requires a policy file, Flash Player
            or AIR always waits for the completion of any policy file downloads
            before denying a request. As a final fallback, if no policy file
            specified with `loadPolicyFile()` authorizes a request, Flash Player
            or AIR consults the original default locations.
    
            When checking for a master policy file, Flash Player waits three
            seconds for a server response. If a response isn't received, Flash
            Player assumes that no master policy file exists. However, there is no
            default timeout value for calls to `loadPolicyFile()`; Flash Player
            assumes that the file being called exists, and waits as long as
            necessary to load it. Therefore, if you want to make sure that a
            master policy file is loaded, use `loadPolicyFile()` to call it
            explicitly.
    
            You cannot connect to commonly reserved ports. For a complete list of
            blocked ports, see "Restricting Networking APIs" in the _ActionScript
            3.0 Developer's Guide_.
    
            Using the `xmlsocket` protocol along with a specific port number lets
            you retrieve policy files directly from an XMLSocket server, as shown
            in the following example. Socket connections are not subject to the
            reserved port restriction described above.
    
            ```haxe
            Security.loadPolicyFile("xmlsocket://foo.com:414");
            ```
    
            This causes Flash Player or AIR to attempt to retrieve a policy file
            from the specified host and port. Upon establishing a connection with
            the specified port, Flash Player or AIR transmits
            `<policy-file-request />`, terminated by a `null` byte. The server
            must send a null byte to terminate a policy file, and may thereafter
            close the connection; if the server does not close the connection,
            Flash Player or AIR does so upon receiving the terminating `null`
            byte.
    
            You can prevent a SWF file from using this method by setting the
            `allowNetworking` parameter of the `object` and `embed` tags in the
            HTML page that contains the SWF content.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: <a
            href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
    
            @param url The URL location of the policy file to be loaded.
        **/
        static loadPolicyFile(url) {
            // res = haxe.Http.requestUrl( url );
        }
        /**
            Displays the Security Settings panel in Flash Player. This method does
            not apply to content in Adobe AIR; calling it in an AIR application
            has no effect.
    
            @param panel A value from the SecurityPanel class that specifies which
                         Security Settings panel you want to display. If you omit
                         this parameter, `SecurityPanel.DEFAULT` is used.
        **/
        // /** @hidden */ @:dox(hide) public static showSettings (panel:openfl.system.SecurityPanel = null):Void;
        // Get & Set Methods
        /**
            Indicates the type of security sandbox in which the calling file is
            operating.
            `Security.sandboxType` has one of the following values:
    
            * `remote` (`Security.REMOTE`)הhis file is from an Internet URL and
            operates under domain-based sandbox rules.
            * `localWithFile` (`Security.LOCAL_WITH_FILE`)הhis file is a local
            file, has not been trusted by the user, and it is not a SWF file that
            was published with a networking designation. The file may read from
            local data sources but may not communicate with the Internet.
            * `localWithNetwork` (`Security.LOCAL_WITH_NETWORK`)הhis SWF file
            is a local file, has not been trusted by the user, and was published
            with a networking designation. The SWF file can communicate with the
            Internet but cannot read from local data sources.
            * `localTrusted` (`Security.LOCAL_TRUSTED`)הhis file is a local
            file and has been trusted by the user, using either the Flash Player
            Settings Manager or a FlashPlayerTrust configuration file. The file
            can read from local data sources and communicate with the Internet.
            * `application` (`Security.APPLICATION`)הhis file is running in an
            AIR application, and it was installed with the namespace (AIR file) for
            that application. By default, files in the AIR application sandbox can
            cross-script any file from any domain (although files outside the AIR
            application sandbox may not be permitted to cross-script the AIR
            file). By default, files in the AIR application sandbox can load
            content and data from any domain.
    
            For more information related to security, see the Flash Player
            Developer Center Topic: <a
            href="http://www.adobe.com/go/devnet_security_en"
            scope="external">Security</a>.
        **/
        static get sandboxType() {
            return Security.__sandboxType;
        }
    }
    /**
        The file is running in an AIR application, and it was installed with
        the namespace (the AIR file) for that application. This content is
        included in the AIR application resource directory (where the
        application content is installed).
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public static APPLICATION:String;
    /**
        The file is a local file and has been trusted by the user, using
        either the Flash Player Settings Manager or a FlashPlayerTrust
        configuration file. The file can read from local data sources and
        communicate with the Internet.
    **/
    Security.LOCAL_TRUSTED = "localTrusted";
    /**
        The file is a local file, has not been trusted by the user, and it is
        not a SWF file that was published with a networking designation. In
        Adobe AIR, the local file is _not_ in the application resource
        directory; such files are put in the application security sandbox. The
        file may read from local data sources but may not communicate with the
        Internet.
    **/
    Security.LOCAL_WITH_FILE = "localWithFile";
    /**
        The file is a local file, has not been trusted by the user, and it is
        a SWF file that was published with a networking designation. The file
        can communicate with the Internet but cannot read from local data
        sources.
    **/
    Security.LOCAL_WITH_NETWORK = "localWithNetwork";
    /**
        The file is from an Internet URL and operates under domain-based
        sandbox rules.
    **/
    Security.REMOTE = "remote";
    return Security;
})();

/**
    The SecurityDomain class represents the current security "sandbox," also
    known as a security domain. By passing an instance of this class to
    `Loader.load()`, you can request that loaded media be placed in a
    particular sandbox.
**/
let SecurityDomain = /** @class */ (() => {
    class SecurityDomain {
        // /** @hidden */ @:dox(hide) @:require(flash11_3) public domainID (default, null):String;
        constructor() { }
        // Get & Set Methods
        /**
            Gets the current security domain.
        **/
        static get currentDomain() {
            return SecurityDomain.__currentDomain;
        }
    }
    SecurityDomain.__currentDomain = new SecurityDomain();
    return SecurityDomain;
})();

/**
        The System class contains properties related to local settings and
        operations. Among these are settings for camers and microphones, operations
        with shared objects and the use of the Clipboard.

        Additional properties and methods are in other classes within the
        openfl.system package: the Capabilities class, the IME class, and the
        Security class.

        This class contains only static methods and properties. You cannot
        create new instances of the System class.
    **/
let System = /** @class */ (() => {
    class System {
        /**
            Makes the specified XML object immediately available for garbage
            collection. This method will remove parent and child connections
            between all the nodes for the specified XML node.
    
            @hidden
            @param node XML reference that should be made available for garbage
                        collection.
        **/
        static disposeXML(node) { }
        /**
            Closes Flash Player.
    
            _For the standalone Flash Player debugger version only._
    
            AIR applications should call the `NativeApplication.exit()`
            method to exit the application.
    
            @param code A value to pass to the operating system. Typically, if the
                        process exits normally, the value is 0.
        **/
        static exit(code) {
            // SystemBackend.exit(code);
        }
        /**
            Forces the garbage collection process.
    
            _For the Flash Player debugger version and AIR applications only._
            In an AIR application, the `System.gc()` method is only enabled
            in content running in the AIR Debug Launcher(ADL) or, in an installed
            applcation, in content in the application security sandbox.
    
        **/
        static gc() {
            // SystemBackend.gc();
        }
        /**
            Pauses Flash Player or the AIR Debug Launcher(ADL). After calling this
            method, nothing in the application continues except the delivery of Socket
            events.
    
            _For the Flash Player debugger version or the AIR Debug Launcher
            (ADL) only._
    
        **/
        static pause() {
            // openfl._internal.Lib.notImplemented();
        }
        // /** @hidden */ @:dox(hide) @:require(flash11) public static pauseForGCIfCollectionImminent (imminence:Float = 0.75):Void;
        /**
            Resumes the application after calling `System.pause()`.
    
            _For the Flash Player debugger version or the AIR Debug Launcher
            (ADL) only._
    
        **/
        static resume() {
            // openfl._internal.Lib.notImplemented();
        }
        /**
            Replaces the contents of the Clipboard with a specified text string. This
            method works from any security context when called as a result of a user
            event(such as a keyboard or input device event handler).
    
            This method is provided for SWF content running in Flash Player 9. It
            allows only adding String content to the Clipboard.
    
            Flash Player 10 content and content in the application security sandbox
            in an AIR application can call the `Clipboard.setData()`
            method.
    
            @param string A plain-text string of characters to put on the system
                          Clipboard, replacing its current contents(if any).
        **/
        static setClipboard(string) {
            Clipboard.generalClipboard.setData(ClipboardFormats$1.TEXT_FORMAT, string);
        }
        // Getters & Setters
        /**
            The amount of memory(in bytes) currently in use that has been directly
            allocated by Flash Player or AIR.
    
            This property does not return _all_ memory used by an Adobe AIR
            application or by the application(such as a browser) containing Flash
            Player content. The browser or operating system may consume other memory.
            The `System.privateMemory` property reflects _all_ memory
            used by an application.
    
            If the amount of memory allocated is greater than the maximum value for
            a uint object(`uint.MAX_VALUE`, or 4,294,967,295), then this
            property is set to 0. The `System.totalMemoryNumber` property
            allows larger values.
        **/
        static get totalMemory() {
            return 0;
            // return SystemBackend.getTotalMemory();
        }
        /**
            Undocumented property
            @hidden
        **/
        static get vmVersion() {
            return "1.0.0";
        }
    }
    /**
        The amount of memory (in bytes) that is allocated to
        Adobe<sup>஼/sup> Flash<sup>஼/sup> Player or Adobe<sup>஼/sup>
        AIR<sup>஼/sup> and that is not in use. This unused portion of
        allocated memory (`System.totalMemory`) fluctuates as garbage
        collection takes place. Use this property to monitor garbage
        collection.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public static freeMemory (default, null):Float;
    /**
        The currently installed system IME. To register for imeComposition
        events, call `addEventListener()` on this instance.
    **/
    // /** @hidden */ @:dox(hide) public static ime (default, null):openfl.system.IME;
    /**
        The entire amount of memory (in bytes) used by an application. This is
        the amount of resident private memory for the entire process.
        AIR developers should use this property to determine the entire memory
        consumption of an application.

        For Flash Player, this includes the memory used by the container
        application, such as the web browser.
    **/
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public static privateMemory (default, null):Float;
    // /** @hidden */ @:dox(hide) @:require(flash11) public static processCPUUsage (default, null):Float;
    // /** @hidden */ @:dox(hide) @:require(flash10_1) public static totalMemoryNumber (default, null):Float;
    /**
        A Boolean value that determines which code page to use to interpret
        external text files. When the property is set to `false`,
        external text files are interpretted as Unicode.(These files must be
        encoded as Unicode when you save them.) When the property is set to
        `true`, external text files are interpretted using the
        traditional code page of the operating system running the application. The
        default value of `useCodePage` is `false`.

        Text that you load as an external file(using
        `Loader.load()`, the URLLoader class or URLStream) must have
        been saved as Unicode in order for the application to recognize it as
        Unicode. To encode external files as Unicode, save the files in an
        application that supports Unicode, such as Notepad on Windows.

        If you load external text files that are not Unicode-encoded, set
        `useCodePage` to `true`. Add the following as the
        first line of code of the file that is loading the data(for Flash
        Professional, add it to the first frame):
        `System.useCodePage = true;`

        When this code is present, the application interprets external text
        using the traditional code page of the operating system. For example, this
        is generally CP1252 for an English Windows operating system and Shift-JIS
        for a Japanese operating system.

        If you set `useCodePage` to `true`, Flash Player
        6 and later treat text as Flash Player 5 does.(Flash Player 5 treated all
        text as if it were in the traditional code page of the operating system
        running the player.)

        If you set `useCodePage` to `true`, remember that
        the traditional code page of the operating system running the application
        must include the characters used in your external text file in order to
        display your text. For example, if you load an external text file that
        contains Chinese characters, those characters cannot display on a system
        that uses the CP1252 code page because that code page does not include
        Chinese characters.

        To ensure that users on all platforms can view external text files used
        in your application, you should encode all external text files as Unicode
        and leave `useCodePage` set to `false`. This way,
        the application(Flash Player 6 and later, or AIR) interprets the text as
        Unicode.
    **/
    System.useCodePage = false;
    return System;
})();

/**
        The AntiAliasType class provides values for anti-aliasing in the
        openfl.text.TextField class.
    **/
var AntiAliasType;
(function (AntiAliasType) {
    /**
        Sets anti-aliasing to advanced anti-aliasing. Advanced anti-aliasing
        allows font faces to be rendered at very high quality at small sizes. It
        is best used with applications that have a lot of small text. Advanced
        anti-aliasing is not recommended for very large fonts(larger than 48
        points). This constant is used for the `antiAliasType` property
        in the TextField class. Use the syntax
        `AntiAliasType.ADVANCED`.
    **/
    AntiAliasType["ADVANCED"] = "advanced";
    /**
        Sets anti-aliasing to the anti-aliasing that is used in Flash Player 7 and
        earlier. This setting is recommended for applications that do not have a
        lot of text. This constant is used for the `antiAliasType`
        property in the TextField class. Use the syntax
        `AntiAliasType.NORMAL`.
    **/
    AntiAliasType["NORMAL"] = "normal";
})(AntiAliasType || (AntiAliasType = {}));
var AntiAliasType$1 = AntiAliasType;

/**
        The FontStyle class provides values for the TextRenderer class.
    **/
var FontStyle;
(function (FontStyle) {
    /**
        Defines the bold style of a font for the `fontStyle` parameter
        in the `setAdvancedAntiAliasingTable()` method. Use the syntax
        `FontStyle.BOLD`.
    **/
    FontStyle["BOLD"] = "bold";
    /**
        Defines the italic style of a font for the `fontStyle`
        parameter in the `setAdvancedAntiAliasingTable()` method. Use
        the syntax `FontStyle.ITALIC`.
    **/
    FontStyle["BOLD_ITALIC"] = "boldItalic";
    /**
        Defines the italic style of a font for the `fontStyle`
        parameter in the `setAdvancedAntiAliasingTable()` method. Use
        the syntax `FontStyle.ITALIC`.
    **/
    FontStyle["ITALIC"] = "italic";
    /**
        Defines the plain style of a font for the `fontStyle` parameter
        in the `setAdvancedAntiAliasingTable()` method. Use the syntax
        `FontStyle.REGULAR`.
    **/
    FontStyle["REGULAR"] = "regular";
})(FontStyle || (FontStyle = {}));
var FontStyle$1 = FontStyle;

/**
        The FontType class contains the enumerated constants
        `"embedded"` and `"device"` for the
        `fontType` property of the Font class.
    **/
var FontType;
(function (FontType) {
    /**
        Indicates that this is a device font. The SWF file renders fonts with
        those installed on the system.

        Using device fonts results in a smaller movie size, because font data
        is not included in the file. Device fonts are often a good choice for
        displaying text at small point sizes, because anti-aliased text can be
        blurry at small sizes. Device fonts are also a good choice for large
        blocks of text, such as scrolling text.

        Text fields that use device fonts may not be displayed the same across
        different systems and platforms, because they are rendered with fonts
        installed on the system. For the same reason, device fonts are not
        anti-aliased and may appear jagged at large point sizes.
    **/
    FontType["DEVICE"] = "device";
    /**
        Indicates that this is an embedded font. Font outlines are embedded in the
        published SWF file.

        Text fields that use embedded fonts are always displayed in the chosen
        font, whether or not that font is installed on the playback system. Also,
        text fields that use embedded fonts are always anti-aliased(smoothed).
        You can select the amount of anti-aliasing you want by using the
        `TextField.antiAliasType property`.

        One drawback to embedded fonts is that they increase the size of the
        SWF file.

        Fonts of type `EMBEDDED` can only be used by TextField. If
        flash.text.engine classes are directed to use such a font they will fall
        back to device fonts.
    **/
    FontType["EMBEDDED"] = "embedded";
    /**
        Indicates that this is an embedded CFF font. Font outlines and a subset of
        OpenType tables are embedded in the published SWF file.

        Text that uses embedded CFF fonts is always displayed in the chosen font, whether
        or not that font is installed on the playback system. Also, text that uses
        embedded CFF fonts is always anti-aliased (smoothed) by Flash Player. You can
        select the rendering mode and hinting for an embedded CFF font using the
        `flash.text.engine.FontDescription.renderingMode` and
        `flash.text.engine.FontDescription.cffHinting` properties.

        One drawback to embedded CFF fonts is that they increase the size of the SWF file.
        However, embedded CFF fonts are typically 20% to 30% smaller than regular
        embedded fonts.

        Fonts of type EMBEDDED_CFF can only be used by the `flash.text.engine` classes. A
        TextField directed to use such a font will fail to render.
    **/
    FontType["EMBEDDED_CFF"] = "embeddedCFF";
})(FontType || (FontType = {}));
var FontType$1 = FontType;

/**
    The GameInput class is the entry point into the GameInput API. You can use this API to
    manage the communications between an application and game input devices (for example:
    joysticks, gamepads, and wands).

    The main purpose of this class is to provide access to the supported input devices that
    are connected to your application platform. This static class enumerates the connected
    input devices in a list. You access a device from the list using the
    `getDeviceAt(index:Int)` method.

    The `numDevices` property provides the number of input devices currently connected to
    your platform. Use this value to determine the upper bound of the list of devices.

    Use an instance of this class to listen for events that notify you about the addition
    and removal of input devices. To listen these events, do the following:

    1. Create an instance of the GameInput class.
    2. Add event listeners for the `GameInputEvent.DEVICE_ADDED` and
    `GameInputEvent.DEVICE_REMOVED` events. (Events can only be registered on an instance
    of the class.)

    This class also features the `isSupported` flag, which indicates whether the GameInput
    API is supported on your platform.

    For more information, see the Adobe Air Developer Center article: Game controllers on
    Adobe AIR.

    For Android, this feature supports a minimum Android OS version of 4.1 and requires the
    minimum SWF version 20 and namespace 3.7. For iOS, this feature supports a minimum iOS
    version of 9.0 and requires the minimum SWF version 34 and namespace 23.0.

    **How to Detect One Game Input Device From Among Identical Devices**

    A common requirement for two-or-more player games is detecting one device from among
    identical devices. For example, applications sometimes must determine which device
    represents "Player 1", "Player 2", ..., "Player N".

    Solution:

    1. Add event listeners to every control on all undetected input devices. These event
    listeners listen for `Event.CHANGE` events, which are dispatched whenever a control
    value changes.
    2. The first time any control is activated (for example a button press or trigger pull)
    the application labels that device.
    3. Remove all of the event listeners from the remaining undetected input devices.
    4. Repeat steps 1-3 as required to identify the rest of the undetected input devices.
**/
let GameInput = /** @class */ (() => {
    class GameInput extends EventDispatcher {
        constructor() {
            super();
            GameInput.__instances.push(this);
        }
        addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false) {
            super.addEventListener(type, listener, useCapture, priority, useWeakReference);
            if (type == GameInputEvent.DEVICE_ADDED) {
                for (let device of GameInput.__deviceList) {
                    this.dispatchEvent(new GameInputEvent(GameInputEvent.DEVICE_ADDED, true, false, device));
                }
            }
        }
        /**
            Gets the input device at the specified index location in the list of connected
            input devices.
    
            The order of devices in the index may change whenever a device is added or removed.
            You can check the name and id properties on a GameInputDevice object to match a
            specific input device.
    
            @param	index	The index position in the list of input devices.
            @returns	The specified GameInputDevice.
            @throws	RangeError	When the provided index is less than zero or greater than
            (`numDevices` - 1).
        **/
        static getDeviceAt(index) {
            if (index >= 0 && index < GameInput.__deviceList.length) {
                return GameInput.__deviceList[index];
            }
            return null;
        }
        static __addInputDevice(device) {
            GameInput.__deviceList.push(device);
            for (let instance of GameInput.__instances) {
                instance.dispatchEvent(new GameInputEvent(GameInputEvent.DEVICE_ADDED, true, false, device));
            }
        }
        static __removeInputDevice(device) {
            let index = GameInput.__deviceList.indexOf(device);
            if (index > -1)
                GameInput.__deviceList.splice(index, 1);
            for (let instance of GameInput.__instances) {
                instance.dispatchEvent(new GameInputEvent(GameInputEvent.DEVICE_REMOVED, true, false, device));
            }
        }
        // Get & Set Methods
        /**
            Provides the number of connected input devices. When a device is connected, the
            `GameInputEvent.DEVICE_ADDED` event is fired.
        **/
        static get numDevices() {
            return GameInput.__deviceList.length;
        }
    }
    /**
        Indicates whether the current platform supports the GameInput API.
    **/
    GameInput.isSupported = true;
    GameInput.__deviceList = new Array();
    GameInput.__instances = [];
    return GameInput;
})();

class GameInputControl extends EventDispatcher {
    constructor(device, id, minValue, maxValue, value = 0) {
        super();
        this.device = device;
        this.id = id;
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.value = value;
    }
}

let GameInputDevice = /** @class */ (() => {
    class GameInputDevice {
        constructor(id, name) {
            this.__axis = new Map();
            this.__button = new Map();
            this.__controls = new Array();
            this.id = id;
            this.name = name;
            var control;
            for (let i = 0; i < 6; i++) {
                control = new GameInputControl(this, "AXIS_" + i, -1, 1);
                this.__axis.set(i, control);
                this.__controls.push(control);
            }
            for (let i = 0; i < 15; i++) {
                control = new GameInputControl(this, "BUTTON_" + i, 0, 1);
                this.__button.set(i, control);
                this.__controls.push(control);
            }
        }
        /**
            Writes cached sample values to the ByteArray.
            @param	data
            @param	append
            @return
        **/
        getCachedSamples(data, append = false) {
            return 0;
        }
        /**
            Retrieves a specific control from a device.
            @param	i
            @return
        **/
        getControlAt(i) {
            if (i >= 0 && i < this.__controls.length) {
                return this.__controls[i];
            }
            return null;
        }
        /**
            Requests this device to start keeping a cache of sampled values.
            @param	numSamples
            @param	controls
        **/
        startCachingSamples(numSamples, controls) { }
        /**
            Stops sample caching.
        **/
        stopCachingSamples() { }
        // Get & Set Methods
        /**
            Returns the number of controls on this device.
        **/
        get numControls() {
            return this.__controls.length;
        }
    }
    /**
        Specifies the maximum size for the buffer used to cache sampled control values.
        If `startCachingSamples` returns samples that require more memory than you specify,
        it throws a memory error.
    **/
    GameInputDevice.MAX_BUFFER_SIZE = 32000;
    return GameInputDevice;
})();

/**
        The MultitouchInputMode class provides values for the
        `inputMode` property in the openfl.ui.Multitouch class. These
        values set the type of touch events the Flash runtime dispatches when the
        user interacts with a touch-enabled device.
    **/
var MultitouchInputMode;
(function (MultitouchInputMode) {
    /**
        Specifies that TransformGestureEvent, PressAndTapGestureEvent, and
        GestureEvent events are dispatched for the related user interaction
        supported by the current environment, and other touch events(such as a
        simple tap) are interpreted as mouse events.
    **/
    MultitouchInputMode["GESTURE"] = "gesture";
    /**
        Specifies that all user contact with a touch-enabled device is interpreted as a
        type of mouse event.
    **/
    MultitouchInputMode["NONE"] = "none";
    /**
        Specifies that all user contact with a touch-enabled device is interpreted
        as a type of mouse event.
    **/
    MultitouchInputMode["TOUCH_POINT"] = "touchPoint";
})(MultitouchInputMode || (MultitouchInputMode = {}));
var MultitouchInputMode$1 = MultitouchInputMode;

/**
    The Multitouch class manages and provides information about the current
    environment's support for handling contact from user input devices,
    including contact that has two or more touch points(such as a user's
    fingers on a touch screen). When a user interacts with a device such as a
    mobile phone or tablet with a touch screen, the user typically touches the
    screen with his or her fingers or a pointing device. While there is a broad
    range of pointing devices, such as a mouse or a stylus, many of these
    devices only have a single point of contact with an application. For
    pointing devices with a single point of contact, user interaction events
    can be handled as a mouse event, or using a basic set of touch events
    (called "touch point" events). However, for pointing devices that have
    several points of contact and perform complex movement, such as the human
    hand, Flash runtimes support an additional set of event handling API called
    gesture events. The API for handling user interaction with these gesture
    events includes the following classes:



    * openfl.events.TouchEvent
    * openfl.events.GestureEvent
    * openfl.events.GesturePhase
    * openfl.events.TransformGestureEvent
    * openfl.events.PressAndTapGestureEvent



    Use the listed classes to write code that handles touch events. Use the
    Multitouch class to determine the current environment's support for touch
    interaction, and to manage the support of touch interaction if the current
    environment supports touch input.

    You cannot create a Multitouch object directly from ActionScript code.
    If you call `new Multitouch()`, an exception is thrown.

    **Note:** The Multitouch feature is not supported for SWF files
    embedded in HTML running on Mac OS.
**/
let Multitouch = /** @class */ (() => {
    class Multitouch {
        // Getters & Setters
        /**
            Indicates whether the current environment supports basic touch input, such
            as a single finger tap. Touch events are listed in the TouchEvent class.
        **/
        static get supportsTouchEvents() {
            if ("ontouchstart" in document.documentElement) {
                return true;
            }
            return false;
        }
    }
    /**
        Identifies the multi-touch mode for touch and gesture event handling. Use
        this property to manage whether or not events are dispatched as touch
        events with multiple points of contact and specific events for different
        gestures(such as rotation and pan), or only a single point of contact
        (such as tap), or none at all(contact is handled as a mouse event). To
        set this property, use values from the openfl.ui.MultitouchInputMode class.

        @default gesture
    **/
    Multitouch.inputMode = MultitouchInputMode$1.TOUCH_POINT;
    // /** @hidden */ @:dox(hide) public static mapTouchToMouse:Bool;
    /**
        The maximum number of concurrent touch points supported by the current
        environment.
    **/
    Multitouch.maxTouchPoints = 2;
    /**
        A Vector array(a typed array of string values) of multi-touch contact
        types supported in the current environment. The array of strings can be
        used as event types to register event listeners. Possible values are
        constants from the GestureEvent, PressAndTapGestureEvent, and
        TransformGestureEvent classes(such as `GESTURE_PAN`).

        If the Flash runtime is in an environment that does not support any
        multi-touch gestures, the value is `null`.

        **Note:** For Mac OS 10.5.3 and later,
        `Multitouch.supportedGestures` returns non-null values
        (possibly indicating incorrectly that gesture events are supported) even
        if the current hardware does not support gesture input.

        Use this property to test for multi-touch gesture support. Then, use
        event handlers for the available multi-touch gestures. For those gestures
        that are not supported in the current evironment, you'll need to create
        alternative event handling.
    **/
    Multitouch.supportedGestures = null;
    /**
        Indicates whether the current environment supports gesture input, such as
        rotating two fingers around a touch screen. Gesture events are listed in
        the TransformGestureEvent, PressAndTapGestureEvent, and GestureEvent
        classes.

        **Note:** For Mac OS 10.5.3 and later, this value is always
        `true`. `Multitouch.supportsGestureEvent` returns
        `true` even if the hardware does not support gesture
        events.
    **/
    Multitouch.supportsGestureEvents = false;
    return Multitouch;
})();

class AssetLibrary {
    constructor() {
    }
    static fromBundle(bundle) {
        return null;
    }
    static fromBytes(bytes, rootPath = null) {
        return null;
    }
    static fromFile(path, rootPath = null) {
        return null;
    }
    static fromManifest(manifest) {
        return null;
    }
    getMovieClip(id) {
        return null;
    }
    static loadFromBytes(bytes, rootPath = null) {
        return Future.withValue(null);
    }
    static loadFromFile(path, rootPath = null) {
        return Future.withValue(null);
    }
    static loadFromManifest(manifest) {
        return Future.withValue(null);
    }
    loadMovieClip(id) {
        return Future.withValue(this.getMovieClip(id));
    }
}

/**
    The AssetType enum lists the core set of available
    asset types from the OpenFL command-line tools.
**/
var AssetType;
(function (AssetType) {
    /**
        Binary assets (data that is not readable as text)
    **/
    AssetType["BINARY"] = "BINARY";
    /**
        Font assets, such as *.ttf or *.otf files
    **/
    AssetType["FONT"] = "FONT";
    /**
        Image assets, such as *.png or *.jpg files
    **/
    AssetType["IMAGE"] = "IMAGE";
    /**
        MovieClip assets, such as from a *.swf file
    **/
    AssetType["MOVIE_CLIP"] = "MOVIE_CLIP";
    /**
        Audio assets, such as *.ogg or *.wav files

        In previous versions of OpenFL, `AssetType.MUSIC` was recommended
        for long background music, but in current versions, both
        `AssetType.MUSIC` and `AssetType.SOUND` behave similarly.

        A future version may implement optimizations specific to each audio type
        again.
    **/
    AssetType["MUSIC"] = "MUSIC";
    /**
        Audio assets, such as *.ogg or *.wav files

        In previous versions of OpenFL, `AssetType.SOUND` was recommended
        for short or repetitively used sounds, but in current versions, both
        `AssetType.MUSIC` and `AssetType.SOUND` behave similarly.

        A future version may implement optimizations specific to each audio type
        again.
    **/
    AssetType["SOUND"] = "SOUND";
    /**
        Used internally in the tools

        @hidden
    **/
    AssetType["TEMPLATE"] = "TEMPLATE";
    /**
        Text assets
    **/
    AssetType["TEXT"] = "TEXT";
})(AssetType || (AssetType = {}));
var AssetType$1 = AssetType;

class AssetManifest {
    constructor() {
    }
    addBitmapData(path, id = null) {
        this.assets.push({
            path: path,
            id: (id != null ? id : path),
            type: AssetType$1.IMAGE,
            preload: true
        });
    }
    addBytes(path, id = null) {
        this.assets.push({
            path: path,
            id: (id != null ? id : path),
            type: AssetType$1.BINARY,
            preload: true
        });
    }
    addFont(name, id = null) {
        this.assets.push({
            path: name,
            id: (id != null ? id : name),
            type: AssetType$1.FONT,
            preload: true
        });
    }
    addSound(paths, id = null) {
        this.assets.push({
            pathGroup: paths,
            id: (id != null ? id : paths[0]),
            type: AssetType$1.SOUND,
            preload: true
        });
    }
    addText(path, id = null) {
        this.assets.push({
            path: path,
            id: (id != null ? id : path),
            type: AssetType$1.TEXT,
            preload: true
        });
    }
    static fromBytes(bytes, rootPath = null) {
        return null;
    }
    static fromFile(path, rootPath = null) {
        return null;
    }
    static loadFromBytes(bytes, rootPath = null) {
        return null;
    }
    static loadFromFile(path, rootPath = null) {
        return null;
    }
    static parse(data, rootPath = null) {
        return null;
    }
}

/**
    The Timer class is the interface to timers, which let you run code on a
    specified time sequence. Use the `start()` method to start a
    timer. Add an event listener for the `timer` event to set up
    code to be run on the timer interval.

    You can create Timer objects to run once or repeat at specified
    intervals to execute code on a schedule. Depending on the SWF file's
    framerate or the runtime environment(available memory and other factors),
    the runtime may dispatch events at slightly offset intervals. For example,
    if a SWF file is set to play at 10 frames per second(fps), which is 100
    millisecond intervals, but your timer is set to fire an event at 80
    milliseconds, the event will be dispatched close to the 100 millisecond
    interval. Memory-intensive scripts may also offset the events.

    @event timer         Dispatched whenever a Timer object reaches an interval
                         specified according to the `Timer.delay`
                         property.
    @event timerComplete Dispatched whenever it has completed the number of
                         requests set by `Timer.repeatCount`.
**/
class Timer extends EventDispatcher {
    /**
        Constructs a new Timer object with the specified `delay` and
        `repeatCount` states.

        The timer does not start automatically; you must call the
        `start()` method to start it.

        @param delay       The delay between timer events, in milliseconds. A
                           `delay` lower than 20 milliseconds is not
                           recommended. Timer frequency is limited to 60 frames
                           per second, meaning a delay lower than 16.6
                           milliseconds causes runtime problems.
        @param repeatCount Specifies the number of repetitions. If zero, the timer
                           repeats infinitely. If nonzero, the timer runs the
                           specified number of times and then stops.
        @throws Error if the delay specified is negative or not a finite number
    **/
    constructor(delay, repeatCount = 0) {
        if (Number.isNaN(delay) || delay < 0) {
            throw new Error$1("The delay specified is negative or not a finite number");
        }
        super();
        this.__delay = delay;
        this.__repeatCount = repeatCount;
        this.__running = false;
        this.__currentCount = 0;
        this.__timerID = 0;
    }
    /**
        Stops the timer, if it is running, and sets the `currentCount`
        property back to 0, like the reset button of a stopwatch. Then, when
        `start()` is called, the timer instance runs for the specified
        number of repetitions, as set by the `repeatCount` value.

    **/
    reset() {
        if (this.__running) {
            stop();
        }
        this.__currentCount = 0;
    }
    /**
        Starts the timer, if it is not already running.

    **/
    start() {
        if (!this.__running) {
            this.__running = true;
            this.__timerID = window.setInterval(this.timer_onTimer, this.__delay);
        }
    }
    /**
        Stops the timer. When `start()` is called after
        `stop()`, the timer instance runs for the _remaining_
        number of repetitions, as set by the `repeatCount` property.

    **/
    stop() {
        this.__running = false;
        if (this.__timerID != 0) {
            window.clearInterval(this.__timerID);
            this.__timerID = 0;
        }
    }
    // Getters & Setters
    /**
        The total number of times the timer has fired since it started at zero. If
        the timer has been reset, only the fires since the reset are counted.
    **/
    get currentCount() {
        return this.__currentCount;
    }
    /**
        The delay, in milliseconds, between timer events. If you set the delay
        interval while the timer is running, the timer will restart at the same
        `repeatCount` iteration.

        **Note:** A `delay` lower than 20 milliseconds is not
        recommended. Timer frequency is limited to 60 frames per second, meaning a
        delay lower than 16.6 milliseconds causes runtime problems.

        @throws Error Throws an exception if the delay specified is negative or
                      not a finite number.
    **/
    get delay() {
        return this.__delay;
    }
    set delay(value) {
        this.__delay = value;
        if (this.__running) {
            this.stop();
            this.start();
        }
    }
    /**
        The total number of times the timer is set to run. If the repeat count is
        set to 0, the timer continues forever or until the `stop()`
        method is invoked or the program stops. If the repeat count is nonzero,
        the timer runs the specified number of times. If `repeatCount`
        is set to a total that is the same or less then `currentCount`
        the timer stops and will not fire again.
    **/
    get repeatCount() {
        return this.__repeatCount;
    }
    set repeatCount(v) {
        if (this.__running && v != 0 && v <= this.__currentCount) {
            this.stop();
        }
        this.__repeatCount = v;
    }
    /**
        The timer's current state; `true` if the timer is running,
        otherwise `false`.
    **/
    get running() {
        return this.__running;
    }
    // Event Handlers
    timer_onTimer() {
        this.__currentCount++;
        if (this.__repeatCount > 0 && this.__currentCount >= this.__repeatCount) {
            stop();
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER));
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER_COMPLETE));
        }
        else {
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER));
        }
    }
}

var getTimer = openfl.utils.getTimer;

/**
    Adobe Flash Player supports an accelerated method of reading and
    writing to the `ByteArray` object, known as "domain memory"

    The Memory API provides access to domain memory using `Memory.select`
    on an existing `ByteArray` on the Flash target, and falls back to
    standard access on other targets.
**/
class Memory {
    /**
        Get a byte from the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @return	An 8-bit integer value
    **/
    static getByte(position) {
        return Memory.__byteArray[position];
    }
    /**
        Get a double from the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @return	A 64-bit floating point value
    **/
    static getDouble(position) {
        return Memory._setPositionTemporarily(position, () => {
            return Memory.__byteArray.readDouble();
        });
    }
    /**
        Get a float from the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @return	A 32-bit floating-point value
    **/
    static getFloat(position) {
        return Memory._setPositionTemporarily(position, () => {
            return Memory.__byteArray.readFloat();
        });
    }
    /**
        Get an int from the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @return A 32-bit integer value
    **/
    static getI32(position) {
        return Memory._setPositionTemporarily(position, () => {
            return Memory.__byteArray.readInt();
        });
    }
    /**
        Return an unsigned int from the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @return An unsigned 16-bit integer value
    **/
    static getUI16(position) {
        return Memory._setPositionTemporarily(position, () => {
            return Memory.__byteArray.readUnsignedShort();
        });
    }
    /**
        Selects the `ByteArray` to use for subsequent domain memory access
        @param	byteArray	A `ByteArray` object to use for memory
    **/
    static select(byteArray) {
        Memory.__byteArray = byteArray;
        Memory.__length = (byteArray != null) ? byteArray.length : 0;
    }
    /**
        Set a byte at the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @param	v	An 8-bit byte value
    **/
    static setByte(position, v) {
        Memory.__byteArray[position] = v;
    }
    /**
        Set a double at the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @param	v	A 64-bit floating-point value
    **/
    static setDouble(position, v) {
        Memory._setPositionTemporarily(position, () => {
            Memory.__byteArray.writeDouble(v);
        });
    }
    /**
        Set a float at the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @param	v	A 32-bit floating-point value
    **/
    static setFloat(position, v) {
        Memory._setPositionTemporarily(position, () => {
            Memory.__byteArray.writeFloat(v);
        });
    }
    /**
        Set an int at the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @param	v	A 16-bit integer value
    **/
    static setI16(position, v) {
        Memory._setPositionTemporarily(position, () => {
            Memory.__byteArray.writeShort(v);
        });
    }
    /**
        Set a long int at the specified memory address
        @param	position	An existing address in the selected `ByteArray` memory
        @param	v	A 32-bit integer value
    **/
    static setI32(position, v) {
        Memory._setPositionTemporarily(position, () => {
            Memory.__byteArray.writeInt(v);
        });
    }
    static _setPositionTemporarily(position, action) {
        var oldPosition = Memory.__byteArray.position;
        Memory.__byteArray.position = position;
        var value = action();
        Memory.__byteArray.position = oldPosition;
        return value;
    }
}

export { AGALMiniAssembler, Accelerometer, AccelerometerEvent, ActivityEvent, AntiAliasType$1 as AntiAliasType, ApplicationDomain, ArgumentError, AssetCache, AssetLibrary, AssetManifest, AssetType$1 as AssetType, Assets, AsyncErrorEvent, Bitmap, BitmapData, BitmapDataChannel, BitmapFilter, BitmapFilterQuality$1 as BitmapFilterQuality, BitmapFilterShader, BitmapFilterType$1 as BitmapFilterType, BlendMode, BlurFilter, ByteArray, Capabilities, CapsStyle, Clipboard, ClipboardFormats$1 as ClipboardFormats, ClipboardTransferMode$1 as ClipboardTransferMode, ColorMatrixFilter, ColorTransform, CompressionAlgorithm$1 as CompressionAlgorithm, Context3D, Context3DBlendFactor, Context3DBufferUsage, Context3DClearMask, Context3DCompareMode, Context3DMipFilter, Context3DProfile, Context3DProgramType, Context3DRenderMode, Context3DStencilAction, Context3DTextureFilter, Context3DTextureFormat, Context3DTriangleFace, Context3DVertexBufferFormat, Context3DWrapMode, ConvolutionFilter, CubeTexture, DOMElement, DataEvent, DisplayObject, DisplayObjectContainer, DisplayObjectRenderer, DisplayObjectShader, DropShadowFilter, EOFError, Endian$1 as Endian, Error$1 as Error, ErrorEvent, Event, EventDispatcher, EventPhase$1 as EventPhase, ExternalInterface, FPS, FileFilter, FileReference, FileReferenceList, FocusEvent, Font, FontStyle$1 as FontStyle, FontType$1 as FontType, FrameLabel, FullScreenEvent, Future, GameInput, GameInputControl, GameInputDevice, GameInputEvent, GlowFilter, GradientType, Graphics, GraphicsBitmapFill, GraphicsEndFill, GraphicsGradientFill, GraphicsPath, GraphicsPathCommand, GraphicsPathWinding, GraphicsQuadPath, GraphicsShader, GraphicsShaderFill, GraphicsSolidFill, GraphicsStroke, GraphicsTrianglePath, GridFitType$1 as GridFitType, HTTPStatusEvent, ID3Info, IOError, IOErrorEvent, IllegalOperationError, IndexBuffer3D, JPEGEncoderOptions, JointStyle, KeyLocation$1 as KeyLocation, Keyboard, KeyboardEvent, Lib$1 as Lib, LineScaleMode, Loader, LoaderContext, LoaderInfo, Matrix, Matrix3D, Memory, Mouse, MouseCursor$1 as MouseCursor, MouseEvent, MovieClip, Multitouch, MultitouchInputMode$1 as MultitouchInputMode, NetConnection, NetStatusEvent, NetStream, ObjectEncoding$1 as ObjectEncoding, Orientation3D, PNGEncoderOptions, PerspectiveProjection, PixelSnapping, Point, Program3D, ProgressEvent, RangeError, Rectangle, RectangleTexture, RenderEvent, SampleDataEvent, Security, SecurityDomain, SecurityError, SecurityErrorEvent, Shader, ShaderData, ShaderFilter, ShaderInput, ShaderJob, ShaderParameter, ShaderParameterType, ShaderPrecision, Shape, SharedObject, SharedObjectFlushStatus$1 as SharedObjectFlushStatus, SimpleButton, Socket, Sound, SoundChannel, SoundLoaderContext, SoundMixer, SoundTransform, SpreadMethod, Sprite, Stage, Stage3D, StageAlign, StageDisplayState, StageQuality, StageScaleMode, System, Telemetry, TextEvent, TextField, TextFieldAutoSize$1 as TextFieldAutoSize, TextFieldType$1 as TextFieldType, TextFormat, TextFormatAlign$1 as TextFormatAlign, TextLineMetrics, Texture, TextureBase, Tile, TileContainer, Tilemap, Tileset, Timer, TimerEvent, TouchEvent, TouchscreenType$1 as TouchscreenType, Transform, TriangleCulling, TypeError$1 as TypeError, URLLoader, URLLoaderDataFormat$1 as URLLoaderDataFormat, URLRequest, URLRequestDefaults, URLRequestHeader, URLRequestMethod$1 as URLRequestMethod, URLStream, URLVariables, UncaughtErrorEvent, UncaughtErrorEvents, Utils3D, Vector, Vector3D, VertexBuffer3D, Video, VideoTexture, VideoTextureEvent, XMLSocket, getTimer, navigateToURL, sendToURL };
//# sourceMappingURL=unsorted.es.js.map
